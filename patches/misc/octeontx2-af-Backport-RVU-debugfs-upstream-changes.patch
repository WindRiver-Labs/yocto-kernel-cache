From d728d265ef1261263d3e74582802f3209273bb5a Mon Sep 17 00:00:00 2001
From: Rakesh Babu <rsaladi2@marvell.com>
Date: Tue, 16 Mar 2021 22:43:08 +0530
Subject: [PATCH 06/13] octeontx2-af: Backport RVU debugfs upstream changes.

commit 2b2848fb66b5d3485566a1688030bb003c87f72c from
git@git.assembla.com:cavium/WindRiver.linux.git

Local git repo and upstream branches are not inline w.r.t. code
placement. Changes are made in local repo such that it is in sync
with upstream repo.

Change-Id: I53dd816231f8ffad69fa96a395be6f6f939b1bff
Signed-off-by: Rakesh Babu <rsaladi2@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/47860
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Integrated-by: Abhishek Paliwal <paliwal.abhishek@windriver.com>
---
 .../marvell/octeontx2/af/rvu_debugfs.c        | 684 +++++++++---------
 1 file changed, 342 insertions(+), 342 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_debugfs.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_debugfs.c
index c1c0e49e32d0..08450c0f5b12 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_debugfs.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_debugfs.c
@@ -917,135 +917,6 @@ static int rvu_dbg_nix_ndc_tx_hits_miss_display(struct seq_file *filp,
 
 RVU_DEBUG_SEQ_FOPS(nix_ndc_tx_hits_miss, nix_ndc_tx_hits_miss_display, NULL);
 
-#define PRINT_CGX_CUML_NIXRX_STATUS(idx, name)				\
-	({								\
-		u64 cnt;						\
-		err = rvu_cgx_nix_cuml_stats(rvu, cgxd, lmac_id, (idx),	\
-					     NIX_STATS_RX, &(cnt));	\
-		if (!err)						\
-			seq_printf(s, "%s: %llu\n", name, cnt);		\
-		cnt;							\
-	})
-
-#define PRINT_CGX_CUML_NIXTX_STATUS(idx, name)			\
-	({								\
-		u64 cnt;						\
-		err = rvu_cgx_nix_cuml_stats(rvu, cgxd, lmac_id, (idx),	\
-					  NIX_STATS_TX, &(cnt));	\
-		if (!err)						\
-			seq_printf(s, "%s: %llu\n", name, cnt);		\
-		cnt;							\
-	})
-
-static int cgx_print_stats(struct seq_file *s, int lmac_id)
-{
-	struct cgx_link_user_info linfo;
-	void *cgxd = s->private;
-	u64 ucast, mcast, bcast;
-	int stat = 0, err = 0;
-	u64 tx_stat, rx_stat;
-	struct rvu *rvu;
-
-	rvu = pci_get_drvdata(pci_get_device(PCI_VENDOR_ID_CAVIUM,
-					     PCI_DEVID_OCTEONTX2_RVU_AF, NULL));
-	if (!rvu)
-		return -ENODEV;
-
-	/* Link status */
-	seq_puts(s, "\n=======Link Status======\n\n");
-	err = cgx_get_link_info(cgxd, lmac_id, &linfo);
-	if (err)
-		seq_puts(s, "Failed to read link status\n");
-	seq_printf(s, "\nLink is %s %d Mbps\n\n",
-		   linfo.link_up ? "UP" : "DOWN", linfo.speed);
-
-	/* Rx stats */
-	seq_puts(s, "\n=======NIX RX_STATS(CGX port level)======\n\n");
-	ucast = PRINT_CGX_CUML_NIXRX_STATUS(RX_UCAST, "rx_ucast_frames");
-	if (err)
-		return err;
-	mcast = PRINT_CGX_CUML_NIXRX_STATUS(RX_MCAST, "rx_mcast_frames");
-	if (err)
-		return err;
-	bcast = PRINT_CGX_CUML_NIXRX_STATUS(RX_BCAST, "rx_bcast_frames");
-	if (err)
-		return err;
-	seq_printf(s, "rx_frames: %llu\n", ucast + mcast + bcast);
-	PRINT_CGX_CUML_NIXRX_STATUS(RX_OCTS, "rx_bytes");
-	if (err)
-		return err;
-	PRINT_CGX_CUML_NIXRX_STATUS(RX_DROP, "rx_drops");
-	if (err)
-		return err;
-	PRINT_CGX_CUML_NIXRX_STATUS(RX_ERR, "rx_errors");
-	if (err)
-		return err;
-
-	/* Tx stats */
-	seq_puts(s, "\n=======NIX TX_STATS(CGX port level)======\n\n");
-	ucast = PRINT_CGX_CUML_NIXTX_STATUS(TX_UCAST, "tx_ucast_frames");
-	if (err)
-		return err;
-	mcast = PRINT_CGX_CUML_NIXTX_STATUS(TX_MCAST, "tx_mcast_frames");
-	if (err)
-		return err;
-	bcast = PRINT_CGX_CUML_NIXTX_STATUS(TX_BCAST, "tx_bcast_frames");
-	if (err)
-		return err;
-	seq_printf(s, "tx_frames: %llu\n", ucast + mcast + bcast);
-	PRINT_CGX_CUML_NIXTX_STATUS(TX_OCTS, "tx_bytes");
-	if (err)
-		return err;
-	PRINT_CGX_CUML_NIXTX_STATUS(TX_DROP, "tx_drops");
-	if (err)
-		return err;
-
-	/* Rx stats */
-	seq_puts(s, "\n=======CGX RX_STATS======\n\n");
-	while (stat < CGX_RX_STATS_COUNT) {
-		err = cgx_get_rx_stats(cgxd, lmac_id, stat, &rx_stat);
-		if (err)
-			return err;
-		seq_printf(s, "%s: %llu\n", cgx_rx_stats_fields[stat], rx_stat);
-		stat++;
-	}
-
-	/* Tx stats */
-	stat = 0;
-	seq_puts(s, "\n=======CGX TX_STATS======\n\n");
-	while (stat < CGX_TX_STATS_COUNT) {
-		err = cgx_get_tx_stats(cgxd, lmac_id, stat, &tx_stat);
-		if (err)
-			return err;
-		seq_printf(s, "%s: %llu\n", cgx_tx_stats_fields[stat], tx_stat);
-		stat++;
-	}
-
-	return err;
-}
-
-static int rvu_dbg_cgx_stat_display(struct seq_file *filp, void *unused)
-{
-	struct dentry *current_dir;
-	int err, lmac_id;
-	char *buf;
-
-	current_dir = filp->file->f_path.dentry->d_parent;
-	buf = strrchr(current_dir->d_name.name, 'c');
-	if (!buf)
-		return -EINVAL;
-
-	err = kstrtoint(buf + 1, 10, &lmac_id);
-	if (!err) {
-		err = cgx_print_stats(filp, lmac_id);
-		if (err)
-			return err;
-	}
-	return err;
-}
-
-RVU_DEBUG_SEQ_FOPS(cgx_stat, cgx_stat_display, NULL);
-
 /* Dumps given nix_sq's context */
 static void print_nix_sq_ctx(struct seq_file *m, struct nix_aq_enq_rsp *rsp)
 {
@@ -1450,90 +1321,365 @@ static int rvu_dbg_nix_cq_ctx_display(struct seq_file *filp, void *unused)
 
 RVU_DEBUG_SEQ_FOPS(nix_cq_ctx, nix_cq_ctx_display, nix_cq_ctx_write);
 
-/* NPC debugfs APIs */
-static inline void rvu_print_npc_mcam_info(struct seq_file *s,
-					   u16 pcifunc, int blkaddr)
+static void print_nix_qctx_qsize(struct seq_file *filp, int qsize,
+				 unsigned long *bmap, char *qtype)
 {
-	struct rvu *rvu = s->private;
-	int entry_acnt, entry_ecnt;
-	int cntr_acnt, cntr_ecnt;
+	char *buf;
 
-	/* Skip PF0 */
-	if (!pcifunc)
-		return;
-	rvu_npc_get_mcam_entry_alloc_info(rvu, pcifunc, blkaddr,
-					  &entry_acnt, &entry_ecnt);
-	rvu_npc_get_mcam_counter_alloc_info(rvu, pcifunc, blkaddr,
-					    &cntr_acnt, &cntr_ecnt);
-	if (!entry_acnt && !cntr_acnt)
+	buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	if (!buf)
 		return;
 
-	if (!(pcifunc & RVU_PFVF_FUNC_MASK))
-		seq_printf(s, "\n\t\t Device \t\t: PF%d\n",
-			   rvu_get_pf(pcifunc));
+	bitmap_print_to_pagebuf(false, buf, bmap, qsize);
+	seq_printf(filp, "%s context count : %d\n", qtype, qsize);
+	seq_printf(filp, "%s context ena/dis bitmap : %s\n",
+		   qtype, buf);
+	kfree(buf);
+}
+
+static void print_nix_qsize(struct seq_file *filp, struct rvu_pfvf *pfvf)
+{
+	if (!pfvf->cq_ctx)
+		seq_puts(filp, "cq context is not initialized\n");
 	else
-		seq_printf(s, "\n\t\t Device \t\t: PF%d VF%d\n",
-			   rvu_get_pf(pcifunc),
-			   (pcifunc & RVU_PFVF_FUNC_MASK) - 1);
+		print_nix_qctx_qsize(filp, pfvf->cq_ctx->qsize, pfvf->cq_bmap,
+				     "cq");
 
-	if (entry_acnt) {
-		seq_printf(s, "\t\t Entries allocated \t: %d\n", entry_acnt);
-		seq_printf(s, "\t\t Entries enabled \t: %d\n", entry_ecnt);
-	}
-	if (cntr_acnt) {
-		seq_printf(s, "\t\t Counters allocated \t: %d\n", cntr_acnt);
-		seq_printf(s, "\t\t Counters enabled \t: %d\n", cntr_ecnt);
-	}
+	if (!pfvf->rq_ctx)
+		seq_puts(filp, "rq context is not initialized\n");
+	else
+		print_nix_qctx_qsize(filp, pfvf->rq_ctx->qsize, pfvf->rq_bmap,
+				     "rq");
+
+	if (!pfvf->sq_ctx)
+		seq_puts(filp, "sq context is not initialized\n");
+	else
+		print_nix_qctx_qsize(filp, pfvf->sq_ctx->qsize, pfvf->sq_bmap,
+				     "sq");
 }
 
-static int rvu_dbg_npc_mcam_info_display(struct seq_file *filp, void *unsued)
+static ssize_t rvu_dbg_nix_qsize_write(struct file *filp,
+				       const char __user *buffer,
+				       size_t count, loff_t *ppos)
 {
-	struct rvu *rvu = filp->private;
-	int pf, vf, numvfs, blkaddr;
-	struct npc_mcam *mcam;
-	u16 pcifunc, counters;
-	u64 cfg;
+	return rvu_dbg_qsize_write(filp, buffer, count, ppos,
+				   BLKTYPE_NIX);
+}
 
-	blkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);
-	if (blkaddr < 0)
-		return -ENODEV;
+static int rvu_dbg_nix_qsize_display(struct seq_file *filp, void *unused)
+{
+	return rvu_dbg_qsize_display(filp, unused, BLKTYPE_NIX);
+}
 
-	mcam = &rvu->hw->mcam;
-	counters = rvu->hw->npc_counters;
+RVU_DEBUG_SEQ_FOPS(nix_qsize, nix_qsize_display, nix_qsize_write);
 
-	seq_puts(filp, "\nNPC MCAM info:\n");
-	/* MCAM keywidth on receive and transmit sides */
-	cfg = rvu_read64(rvu, blkaddr, NPC_AF_INTFX_KEX_CFG(NIX_INTF_RX));
-	cfg = (cfg >> 32) & 0x07;
-	seq_printf(filp, "\t\t RX keywidth \t: %s\n", (cfg == NPC_MCAM_KEY_X1) ?
-		   "112bits" : ((cfg == NPC_MCAM_KEY_X2) ?
-		   "224bits" : "448bits"));
-	cfg = rvu_read64(rvu, blkaddr, NPC_AF_INTFX_KEX_CFG(NIX_INTF_TX));
-	cfg = (cfg >> 32) & 0x07;
-	seq_printf(filp, "\t\t TX keywidth \t: %s\n", (cfg == NPC_MCAM_KEY_X1) ?
-		   "112bits" : ((cfg == NPC_MCAM_KEY_X2) ?
-		   "224bits" : "448bits"));
+static ssize_t rvu_dbg_nix_tx_stall_hwissue_display(struct file *filp,
+						    char __user *buffer,
+						    size_t count, loff_t *ppos)
+{
+	return rvu_nix_get_tx_stall_counters(filp->private_data, buffer, ppos);
+}
 
-	mutex_lock(&mcam->lock);
-	/* MCAM entries */
-	seq_printf(filp, "\n\t\t MCAM entries \t: %d\n", mcam->total_entries);
-	seq_printf(filp, "\t\t Reserved \t: %d\n",
-		   mcam->total_entries - mcam->bmap_entries);
-	seq_printf(filp, "\t\t Available \t: %d\n", mcam->bmap_fcnt);
+RVU_DEBUG_FOPS(nix_tx_stall_hwissue, nix_tx_stall_hwissue_display, NULL);
 
-	/* MCAM counters */
-	seq_printf(filp, "\n\t\t MCAM counters \t: %d\n", counters);
-	seq_printf(filp, "\t\t Reserved \t: %d\n",
-		   counters - mcam->counters.max);
-	seq_printf(filp, "\t\t Available \t: %d\n",
-		   rvu_rsrc_free_count(&mcam->counters));
+static void rvu_dbg_nix_init(struct rvu *rvu, int blkaddr)
+{
+	struct nix_hw *nix_hw;
 
-	if (mcam->bmap_entries == mcam->bmap_fcnt) {
-		mutex_unlock(&mcam->lock);
-		return 0;
+	if (!is_block_implemented(rvu->hw, blkaddr))
+		return;
+
+	if (blkaddr == BLKADDR_NIX0) {
+		rvu->rvu_dbg.nix = debugfs_create_dir("nix", rvu->rvu_dbg.root);
+		nix_hw = &rvu->hw->nix[0];
+	} else {
+		rvu->rvu_dbg.nix = debugfs_create_dir("nix1",
+						      rvu->rvu_dbg.root);
+		nix_hw = &rvu->hw->nix[1];
 	}
 
-	seq_puts(filp, "\n\t\t Current allocation\n");
+	debugfs_create_file("sq_ctx", 0600, rvu->rvu_dbg.nix, nix_hw,
+			    &rvu_dbg_nix_sq_ctx_fops);
+	debugfs_create_file("rq_ctx", 0600, rvu->rvu_dbg.nix, nix_hw,
+			    &rvu_dbg_nix_rq_ctx_fops);
+	debugfs_create_file("cq_ctx", 0600, rvu->rvu_dbg.nix, nix_hw,
+			    &rvu_dbg_nix_cq_ctx_fops);
+	debugfs_create_file("ndc_tx_cache", 0600, rvu->rvu_dbg.nix, nix_hw,
+			    &rvu_dbg_nix_ndc_tx_cache_fops);
+	debugfs_create_file("ndc_rx_cache", 0600, rvu->rvu_dbg.nix, nix_hw,
+			    &rvu_dbg_nix_ndc_rx_cache_fops);
+	debugfs_create_file("ndc_tx_hits_miss", 0600, rvu->rvu_dbg.nix, nix_hw,
+			    &rvu_dbg_nix_ndc_tx_hits_miss_fops);
+	debugfs_create_file("ndc_rx_hits_miss", 0600, rvu->rvu_dbg.nix, nix_hw,
+			    &rvu_dbg_nix_ndc_rx_hits_miss_fops);
+	debugfs_create_file("qsize", 0600, rvu->rvu_dbg.nix, rvu,
+			    &rvu_dbg_nix_qsize_fops);
+	if (is_rvu_96xx_A0(rvu)) {
+		debugfs_create_file("tx_stall_hwissue", 0600,
+				    rvu->rvu_dbg.nix, nix_hw,
+				    &rvu_dbg_nix_tx_stall_hwissue_fops);
+	}
+}
+
+static void rvu_dbg_npa_init(struct rvu *rvu)
+{
+	rvu->rvu_dbg.npa = debugfs_create_dir("npa", rvu->rvu_dbg.root);
+
+	debugfs_create_file("qsize", 0600, rvu->rvu_dbg.npa, rvu,
+			    &rvu_dbg_npa_qsize_fops);
+	debugfs_create_file("aura_ctx", 0600, rvu->rvu_dbg.npa, rvu,
+			    &rvu_dbg_npa_aura_ctx_fops);
+	debugfs_create_file("pool_ctx", 0600, rvu->rvu_dbg.npa, rvu,
+			    &rvu_dbg_npa_pool_ctx_fops);
+	debugfs_create_file("ndc_cache", 0600, rvu->rvu_dbg.npa, rvu,
+			    &rvu_dbg_npa_ndc_cache_fops);
+	debugfs_create_file("ndc_hits_miss", 0600, rvu->rvu_dbg.npa, rvu,
+			    &rvu_dbg_npa_ndc_hits_miss_fops);
+}
+
+#define PRINT_CGX_CUML_NIXRX_STATUS(idx, name)				\
+	({								\
+		u64 cnt;						\
+		err = rvu_cgx_nix_cuml_stats(rvu, cgxd, lmac_id, (idx),	\
+					     NIX_STATS_RX, &(cnt));	\
+		if (!err)						\
+			seq_printf(s, "%s: %llu\n", name, cnt);		\
+		cnt;							\
+	})
+
+#define PRINT_CGX_CUML_NIXTX_STATUS(idx, name)			\
+	({								\
+		u64 cnt;						\
+		err = rvu_cgx_nix_cuml_stats(rvu, cgxd, lmac_id, (idx),	\
+					  NIX_STATS_TX, &(cnt));	\
+		if (!err)						\
+			seq_printf(s, "%s: %llu\n", name, cnt);		\
+		cnt;							\
+	})
+
+static int cgx_print_stats(struct seq_file *s, int lmac_id)
+{
+	struct cgx_link_user_info linfo;
+	void *cgxd = s->private;
+	u64 ucast, mcast, bcast;
+	int stat = 0, err = 0;
+	u64 tx_stat, rx_stat;
+	struct rvu *rvu;
+
+	rvu = pci_get_drvdata(pci_get_device(PCI_VENDOR_ID_CAVIUM,
+					     PCI_DEVID_OCTEONTX2_RVU_AF, NULL));
+	if (!rvu)
+		return -ENODEV;
+
+	/* Link status */
+	seq_puts(s, "\n=======Link Status======\n\n");
+	err = cgx_get_link_info(cgxd, lmac_id, &linfo);
+	if (err)
+		seq_puts(s, "Failed to read link status\n");
+	seq_printf(s, "\nLink is %s %d Mbps\n\n",
+		   linfo.link_up ? "UP" : "DOWN", linfo.speed);
+
+	/* Rx stats */
+	seq_puts(s, "\n=======NIX RX_STATS(CGX port level)======\n\n");
+	ucast = PRINT_CGX_CUML_NIXRX_STATUS(RX_UCAST, "rx_ucast_frames");
+	if (err)
+		return err;
+	mcast = PRINT_CGX_CUML_NIXRX_STATUS(RX_MCAST, "rx_mcast_frames");
+	if (err)
+		return err;
+	bcast = PRINT_CGX_CUML_NIXRX_STATUS(RX_BCAST, "rx_bcast_frames");
+	if (err)
+		return err;
+	seq_printf(s, "rx_frames: %llu\n", ucast + mcast + bcast);
+	PRINT_CGX_CUML_NIXRX_STATUS(RX_OCTS, "rx_bytes");
+	if (err)
+		return err;
+	PRINT_CGX_CUML_NIXRX_STATUS(RX_DROP, "rx_drops");
+	if (err)
+		return err;
+	PRINT_CGX_CUML_NIXRX_STATUS(RX_ERR, "rx_errors");
+	if (err)
+		return err;
+
+	/* Tx stats */
+	seq_puts(s, "\n=======NIX TX_STATS(CGX port level)======\n\n");
+	ucast = PRINT_CGX_CUML_NIXTX_STATUS(TX_UCAST, "tx_ucast_frames");
+	if (err)
+		return err;
+	mcast = PRINT_CGX_CUML_NIXTX_STATUS(TX_MCAST, "tx_mcast_frames");
+	if (err)
+		return err;
+	bcast = PRINT_CGX_CUML_NIXTX_STATUS(TX_BCAST, "tx_bcast_frames");
+	if (err)
+		return err;
+	seq_printf(s, "tx_frames: %llu\n", ucast + mcast + bcast);
+	PRINT_CGX_CUML_NIXTX_STATUS(TX_OCTS, "tx_bytes");
+	if (err)
+		return err;
+	PRINT_CGX_CUML_NIXTX_STATUS(TX_DROP, "tx_drops");
+	if (err)
+		return err;
+
+	/* Rx stats */
+	seq_puts(s, "\n=======CGX RX_STATS======\n\n");
+	while (stat < CGX_RX_STATS_COUNT) {
+		err = cgx_get_rx_stats(cgxd, lmac_id, stat, &rx_stat);
+		if (err)
+			return err;
+		seq_printf(s, "%s: %llu\n", cgx_rx_stats_fields[stat], rx_stat);
+		stat++;
+	}
+
+	/* Tx stats */
+	stat = 0;
+	seq_puts(s, "\n=======CGX TX_STATS======\n\n");
+	while (stat < CGX_TX_STATS_COUNT) {
+		err = cgx_get_tx_stats(cgxd, lmac_id, stat, &tx_stat);
+		if (err)
+			return err;
+		seq_printf(s, "%s: %llu\n", cgx_tx_stats_fields[stat], tx_stat);
+		stat++;
+	}
+
+	return err;
+}
+
+static int rvu_dbg_cgx_stat_display(struct seq_file *filp, void *unused)
+{
+	struct dentry *current_dir;
+	int err, lmac_id;
+	char *buf;
+
+	current_dir = filp->file->f_path.dentry->d_parent;
+	buf = strrchr(current_dir->d_name.name, 'c');
+	if (!buf)
+		return -EINVAL;
+
+	err = kstrtoint(buf + 1, 10, &lmac_id);
+	if (!err) {
+		err = cgx_print_stats(filp, lmac_id);
+		if (err)
+			return err;
+	}
+	return err;
+}
+
+RVU_DEBUG_SEQ_FOPS(cgx_stat, cgx_stat_display, NULL);
+
+static void rvu_dbg_cgx_init(struct rvu *rvu)
+{
+	int i, lmac_id;
+	char dname[20];
+	void *cgx;
+
+	rvu->rvu_dbg.cgx_root = debugfs_create_dir("cgx", rvu->rvu_dbg.root);
+	if (!cgx_get_cgxcnt_max())
+		return;
+
+	for (i = 0; i < cgx_get_cgxcnt_max(); i++) {
+		cgx = rvu_cgx_pdata(i, rvu);
+		if (!cgx)
+			continue;
+		/* cgx debugfs dir */
+		sprintf(dname, "cgx%d", i);
+		rvu->rvu_dbg.cgx = debugfs_create_dir(dname,
+						      rvu->rvu_dbg.cgx_root);
+		for (lmac_id = 0; lmac_id < cgx_get_lmac_cnt(cgx); lmac_id++) {
+			/* lmac debugfs dir */
+			sprintf(dname, "lmac%d", lmac_id);
+			rvu->rvu_dbg.lmac =
+				debugfs_create_dir(dname, rvu->rvu_dbg.cgx);
+
+			debugfs_create_file("stats", 0600, rvu->rvu_dbg.lmac,
+					    cgx, &rvu_dbg_cgx_stat_fops);
+		}
+	}
+}
+
+/* NPC debugfs APIs */
+static inline void rvu_print_npc_mcam_info(struct seq_file *s,
+					   u16 pcifunc, int blkaddr)
+{
+	struct rvu *rvu = s->private;
+	int entry_acnt, entry_ecnt;
+	int cntr_acnt, cntr_ecnt;
+
+	/* Skip PF0 */
+	if (!pcifunc)
+		return;
+	rvu_npc_get_mcam_entry_alloc_info(rvu, pcifunc, blkaddr,
+					  &entry_acnt, &entry_ecnt);
+	rvu_npc_get_mcam_counter_alloc_info(rvu, pcifunc, blkaddr,
+					    &cntr_acnt, &cntr_ecnt);
+	if (!entry_acnt && !cntr_acnt)
+		return;
+
+	if (!(pcifunc & RVU_PFVF_FUNC_MASK))
+		seq_printf(s, "\n\t\t Device \t\t: PF%d\n",
+			   rvu_get_pf(pcifunc));
+	else
+		seq_printf(s, "\n\t\t Device \t\t: PF%d VF%d\n",
+			   rvu_get_pf(pcifunc),
+			   (pcifunc & RVU_PFVF_FUNC_MASK) - 1);
+
+	if (entry_acnt) {
+		seq_printf(s, "\t\t Entries allocated \t: %d\n", entry_acnt);
+		seq_printf(s, "\t\t Entries enabled \t: %d\n", entry_ecnt);
+	}
+	if (cntr_acnt) {
+		seq_printf(s, "\t\t Counters allocated \t: %d\n", cntr_acnt);
+		seq_printf(s, "\t\t Counters enabled \t: %d\n", cntr_ecnt);
+	}
+}
+
+static int rvu_dbg_npc_mcam_info_display(struct seq_file *filp, void *unsued)
+{
+	struct rvu *rvu = filp->private;
+	int pf, vf, numvfs, blkaddr;
+	struct npc_mcam *mcam;
+	u16 pcifunc, counters;
+	u64 cfg;
+
+	blkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);
+	if (blkaddr < 0)
+		return -ENODEV;
+
+	mcam = &rvu->hw->mcam;
+	counters = rvu->hw->npc_counters;
+
+	seq_puts(filp, "\nNPC MCAM info:\n");
+	/* MCAM keywidth on receive and transmit sides */
+	cfg = rvu_read64(rvu, blkaddr, NPC_AF_INTFX_KEX_CFG(NIX_INTF_RX));
+	cfg = (cfg >> 32) & 0x07;
+	seq_printf(filp, "\t\t RX keywidth \t: %s\n", (cfg == NPC_MCAM_KEY_X1) ?
+		   "112bits" : ((cfg == NPC_MCAM_KEY_X2) ?
+		   "224bits" : "448bits"));
+	cfg = rvu_read64(rvu, blkaddr, NPC_AF_INTFX_KEX_CFG(NIX_INTF_TX));
+	cfg = (cfg >> 32) & 0x07;
+	seq_printf(filp, "\t\t TX keywidth \t: %s\n", (cfg == NPC_MCAM_KEY_X1) ?
+		   "112bits" : ((cfg == NPC_MCAM_KEY_X2) ?
+		   "224bits" : "448bits"));
+
+	mutex_lock(&mcam->lock);
+	/* MCAM entries */
+	seq_printf(filp, "\n\t\t MCAM entries \t: %d\n", mcam->total_entries);
+	seq_printf(filp, "\t\t Reserved \t: %d\n",
+		   mcam->total_entries - mcam->bmap_entries);
+	seq_printf(filp, "\t\t Available \t: %d\n", mcam->bmap_fcnt);
+
+	/* MCAM counters */
+	seq_printf(filp, "\n\t\t MCAM counters \t: %d\n", counters);
+	seq_printf(filp, "\t\t Reserved \t: %d\n",
+		   counters - mcam->counters.max);
+	seq_printf(filp, "\t\t Available \t: %d\n",
+		   rvu_rsrc_free_count(&mcam->counters));
+
+	if (mcam->bmap_entries == mcam->bmap_fcnt) {
+		mutex_unlock(&mcam->lock);
+		return 0;
+	}
+
+	seq_puts(filp, "\n\t\t Current allocation\n");
 	seq_puts(filp, "\t\t====================\n");
 	for (pf = 0; pf < rvu->hw->total_pfs; pf++) {
 		pcifunc = (pf << RVU_PFVF_PF_SHIFT);
@@ -1782,152 +1928,6 @@ static void rvu_dbg_npc_init(struct rvu *rvu)
 			    &rvu_dbg_npc_rx_miss_act_fops);
 }
 
-static void print_nix_qctx_qsize(struct seq_file *filp, int qsize,
-				 unsigned long *bmap, char *qtype)
-{
-	char *buf;
-
-	buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
-	if (!buf)
-		return;
-
-	bitmap_print_to_pagebuf(false, buf, bmap, qsize);
-	seq_printf(filp, "%s context count : %d\n", qtype, qsize);
-	seq_printf(filp, "%s context ena/dis bitmap : %s\n",
-		   qtype, buf);
-	kfree(buf);
-}
-
-static void print_nix_qsize(struct seq_file *filp, struct rvu_pfvf *pfvf)
-{
-	if (!pfvf->cq_ctx)
-		seq_puts(filp, "cq context is not initialized\n");
-	else
-		print_nix_qctx_qsize(filp, pfvf->cq_ctx->qsize, pfvf->cq_bmap,
-				     "cq");
-
-	if (!pfvf->rq_ctx)
-		seq_puts(filp, "rq context is not initialized\n");
-	else
-		print_nix_qctx_qsize(filp, pfvf->rq_ctx->qsize, pfvf->rq_bmap,
-				     "rq");
-
-	if (!pfvf->sq_ctx)
-		seq_puts(filp, "sq context is not initialized\n");
-	else
-		print_nix_qctx_qsize(filp, pfvf->sq_ctx->qsize, pfvf->sq_bmap,
-				     "sq");
-}
-
-static ssize_t rvu_dbg_nix_qsize_write(struct file *filp,
-				       const char __user *buffer,
-				       size_t count, loff_t *ppos)
-{
-	return rvu_dbg_qsize_write(filp, buffer, count, ppos,
-				   BLKTYPE_NIX);
-}
-
-static int rvu_dbg_nix_qsize_display(struct seq_file *filp, void *unused)
-{
-	return rvu_dbg_qsize_display(filp, unused, BLKTYPE_NIX);
-}
-
-RVU_DEBUG_SEQ_FOPS(nix_qsize, nix_qsize_display, nix_qsize_write);
-
-static ssize_t rvu_dbg_nix_tx_stall_hwissue_display(struct file *filp,
-						    char __user *buffer,
-						    size_t count, loff_t *ppos)
-{
-	return rvu_nix_get_tx_stall_counters(filp->private_data, buffer, ppos);
-}
-
-RVU_DEBUG_FOPS(nix_tx_stall_hwissue, nix_tx_stall_hwissue_display, NULL);
-
-static void rvu_dbg_nix_init(struct rvu *rvu, int blkaddr)
-{
-	struct nix_hw *nix_hw;
-
-	if (!is_block_implemented(rvu->hw, blkaddr))
-		return;
-
-	if (blkaddr == BLKADDR_NIX0) {
-		rvu->rvu_dbg.nix = debugfs_create_dir("nix", rvu->rvu_dbg.root);
-		nix_hw = &rvu->hw->nix[0];
-	} else {
-		rvu->rvu_dbg.nix = debugfs_create_dir("nix1",
-						      rvu->rvu_dbg.root);
-		nix_hw = &rvu->hw->nix[1];
-	}
-
-	debugfs_create_file("sq_ctx", 0600, rvu->rvu_dbg.nix, nix_hw,
-			    &rvu_dbg_nix_sq_ctx_fops);
-	debugfs_create_file("rq_ctx", 0600, rvu->rvu_dbg.nix, nix_hw,
-			    &rvu_dbg_nix_rq_ctx_fops);
-	debugfs_create_file("cq_ctx", 0600, rvu->rvu_dbg.nix, nix_hw,
-			    &rvu_dbg_nix_cq_ctx_fops);
-	debugfs_create_file("ndc_tx_cache", 0600, rvu->rvu_dbg.nix, nix_hw,
-			    &rvu_dbg_nix_ndc_tx_cache_fops);
-	debugfs_create_file("ndc_rx_cache", 0600, rvu->rvu_dbg.nix, nix_hw,
-			    &rvu_dbg_nix_ndc_rx_cache_fops);
-	debugfs_create_file("ndc_tx_hits_miss", 0600, rvu->rvu_dbg.nix, nix_hw,
-			    &rvu_dbg_nix_ndc_tx_hits_miss_fops);
-	debugfs_create_file("ndc_rx_hits_miss", 0600, rvu->rvu_dbg.nix, nix_hw,
-			    &rvu_dbg_nix_ndc_rx_hits_miss_fops);
-	debugfs_create_file("qsize", 0600, rvu->rvu_dbg.nix, rvu,
-			    &rvu_dbg_nix_qsize_fops);
-	if (is_rvu_96xx_A0(rvu)) {
-		debugfs_create_file("tx_stall_hwissue", 0600,
-				    rvu->rvu_dbg.nix, nix_hw,
-				    &rvu_dbg_nix_tx_stall_hwissue_fops);
-	}
-}
-
-static void rvu_dbg_cgx_init(struct rvu *rvu)
-{
-	int i, lmac_id;
-	char dname[20];
-	void *cgx;
-
-	rvu->rvu_dbg.cgx_root = debugfs_create_dir("cgx", rvu->rvu_dbg.root);
-	if (!cgx_get_cgxcnt_max())
-		return;
-
-	for (i = 0; i < cgx_get_cgxcnt_max(); i++) {
-		cgx = rvu_cgx_pdata(i, rvu);
-		if (!cgx)
-			continue;
-		/* cgx debugfs dir */
-		sprintf(dname, "cgx%d", i);
-		rvu->rvu_dbg.cgx = debugfs_create_dir(dname,
-						      rvu->rvu_dbg.cgx_root);
-		for (lmac_id = 0; lmac_id < cgx_get_lmac_cnt(cgx); lmac_id++) {
-			/* lmac debugfs dir */
-			sprintf(dname, "lmac%d", lmac_id);
-			rvu->rvu_dbg.lmac =
-				debugfs_create_dir(dname, rvu->rvu_dbg.cgx);
-
-			debugfs_create_file("stats", 0600, rvu->rvu_dbg.lmac,
-					    cgx, &rvu_dbg_cgx_stat_fops);
-		}
-	}
-}
-
-static void rvu_dbg_npa_init(struct rvu *rvu)
-{
-	rvu->rvu_dbg.npa = debugfs_create_dir("npa", rvu->rvu_dbg.root);
-
-	debugfs_create_file("qsize", 0600, rvu->rvu_dbg.npa, rvu,
-			    &rvu_dbg_npa_qsize_fops);
-	debugfs_create_file("aura_ctx", 0600, rvu->rvu_dbg.npa, rvu,
-			    &rvu_dbg_npa_aura_ctx_fops);
-	debugfs_create_file("pool_ctx", 0600, rvu->rvu_dbg.npa, rvu,
-			    &rvu_dbg_npa_pool_ctx_fops);
-	debugfs_create_file("ndc_cache", 0600, rvu->rvu_dbg.npa, rvu,
-			    &rvu_dbg_npa_ndc_cache_fops);
-	debugfs_create_file("ndc_hits_miss", 0600, rvu->rvu_dbg.npa, rvu,
-			    &rvu_dbg_npa_ndc_hits_miss_fops);
-}
-
 static int parse_sso_cmd_buffer(char *cmd_buf, size_t *count,
 				const char __user *buffer, int *ssolf,
 				bool *all)
-- 
2.17.0

