From f591e8ae0d01c663de499ec1e903c3c5a157dbf8 Mon Sep 17 00:00:00 2001
From: Harman Kalra <hkalra@marvell.com>
Date: Thu, 1 Jul 2021 19:27:50 +0530
Subject: [PATCH 05/13] soc: marvell: hw_access: get cgx info

commit 8b7159793cdd77398fd7eef840e9a8835ae74f23 from
git@git.assembla.com:cavium/WindRiver.linux.git

Implementing a new ioctl to get pci func to cgx mapping, also
returning nix index to which respective CGX is attached.

Increasing the register map range to read CSRs of 5 CGXs in case
of 98xx

Change-Id: I18c7afdbf2a1cc711d3809758433a9f14a85d9e7
Signed-off-by: Harman Kalra <hkalra@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/55870
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Sunil Kovvuri Goutham <sgoutham@marvell.com>
Integrated-by: Abhishek Paliwal <paliwal.abhishek@windriver.com>
---
 drivers/soc/marvell/hw-access/hw_rw_access.c | 53 +++++++++++++++++++-
 1 file changed, 51 insertions(+), 2 deletions(-)

diff --git a/drivers/soc/marvell/hw-access/hw_rw_access.c b/drivers/soc/marvell/hw-access/hw_rw_access.c
index 10dcb1e84372..38bdfbe5ea89 100644
--- a/drivers/soc/marvell/hw-access/hw_rw_access.c
+++ b/drivers/soc/marvell/hw-access/hw_rw_access.c
@@ -33,12 +33,12 @@
 #define REG_PHYS_BASEADDR		0x802000000000
 /* Last physical address - First phsycial address + 1 will be the
  * length of IO remapped block
- * 0x87E0E24FFFFF - 0x802000000000 + 1 = 0x7C0E2500000
+ * 0x87E0E48FFFFF - 0x802000000000 + 1 = 0x7C0E4800000
  * Last phsyical address is the highest end physical address of all HW devices.
  * First physical address is the smallest start physical address of all HW
  * devices.
  */
-#define REG_SPACE_MAPSIZE		0x7C0E2500000
+#define REG_SPACE_MAPSIZE		0x7C0E4800000
 
 struct hw_reg_cfg {
 	u64	regaddr; /* Register physical address within a hw device */
@@ -53,11 +53,19 @@ struct hw_ctx_cfg {
 	u8	op;
 };
 
+struct hw_cgx_info {
+	u8	pf;
+	u8	cgx_id;
+	u8	lmac_id;
+	u8	nix_idx;
+};
+
 #define HW_ACCESS_TYPE			120
 
 #define HW_ACCESS_CSR_READ_IOCTL	_IO(HW_ACCESS_TYPE, 1)
 #define HW_ACCESS_CSR_WRITE_IOCTL	_IO(HW_ACCESS_TYPE, 2)
 #define HW_ACCESS_CTX_READ_IOCTL	_IO(HW_ACCESS_TYPE, 3)
+#define HW_ACCESS_CGX_INFO_IOCTL	_IO(HW_ACCESS_TYPE, 4)
 
 struct hw_priv_data {
 	void __iomem *reg_base;
@@ -193,6 +201,44 @@ hw_access_ctx_read(struct rvu *rvu, unsigned long arg)
 	return 0;
 }
 
+static int
+hw_access_cgx_info(struct rvu *rvu, unsigned long arg)
+{
+	struct hw_cgx_info cgx_info;
+	struct rvu_pfvf *pfvf;
+	u8 cgx_id, lmac_id, pf;
+	u16 pcifunc;
+
+	if (copy_from_user(&cgx_info, (void __user *)arg,
+			   sizeof(struct hw_cgx_info))) {
+		pr_err("Reading PF value failed: copy from user\n");
+		return -EFAULT;
+	}
+
+	pf = cgx_info.pf;
+	if (!(pf >= PF_CGXMAP_BASE && pf <= rvu->cgx_mapped_pfs)) {
+		pr_err("Invalid PF value %d\n", pf);
+		return -EFAULT;
+	}
+
+	pcifunc = pf << 10;
+	pfvf = &rvu->pf[pf];
+	rvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_id,
+			    &lmac_id);
+	cgx_info.cgx_id = cgx_id;
+	cgx_info.lmac_id = lmac_id;
+	cgx_info.nix_idx = (pfvf->nix_blkaddr == BLKADDR_NIX0) ? 0 : 1;
+
+	if (copy_to_user((void __user *)(unsigned long)arg,
+			 &cgx_info,
+			 sizeof(struct hw_cgx_info))) {
+		pr_err("Fault in copy to user\n");
+
+		return -EFAULT;
+	}
+	return 0;
+}
+
 static long hw_access_ioctl(struct file *filp, unsigned int cmd,
 			   unsigned long arg)
 {
@@ -210,6 +256,9 @@ static long hw_access_ioctl(struct file *filp, unsigned int cmd,
 	case HW_ACCESS_CTX_READ_IOCTL:
 		return hw_access_ctx_read(rvu, arg);
 
+	case HW_ACCESS_CGX_INFO_IOCTL:
+		return hw_access_cgx_info(rvu, arg);
+
 	default:
 		pr_info("Invalid IOCTL: %d\n", cmd);
 
-- 
2.31.1

