From a3f4efeeab295bef9039c1be7506fab5363f7504 Mon Sep 17 00:00:00 2001
From: Ovidiu Panait <ovidiu.panait@windriver.com>
Date: Mon, 7 Jun 2021 11:01:34 +0000
Subject: [PATCH 3/3] Revert "bpf: allocate 0x06 to new eBPF instruction class
 JMP32"

This reverts commit a4d20e91398a9fef9c527c6e685c4d940aea5451.

Revert this patchset as it introduced the following test_verifier kernel oops:
$ ./test_verifier
 #0/u add+sub+mul OK
 #0/p add+sub+mul OK
 #1/u DIV32 by 0, zero check 1 OK
BPF interpreter: unknown opcode 56
------------[ cut here ]------------
kernel BUG at kernel/bpf/core.c:1395!
invalid opcode: 0000 [#1] PREEMPT SMP PTI
CPU: 0 PID: 306 Comm: test_verifier Not tainted 4.18.45-yocto-standard #1
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014
RIP: 0010:___bpf_prog_run+0xf32/0xf40
Code: 57 f9 ff ff 0f b6 43 01 83 e0 0f 49 8d 54 c5 00 48 8b 02 48 0f c8 48 89 02 e9 3d f9 ff ff 48 c7 c7 48 09 8e b0 e8 d1 92 f6 ff <0f> 0b 66 66 2e 0f 1f 84 00 00 00 00 00 90 0f 1f 44 00 00 55 48 89
RSP: 0018:ffffab6640b03cf8 EFLAGS: 00010246
RAX: 0000000000000022 RBX: ffffab66406e1050 RCX: 0000000000000000
RDX: 0000000000000000 RSI: ffffffffb08e266e RDI: 00000000ffffffff
RBP: ffffab6640b03d18 R08: 00000000000001f1 R09: 0000000000000007
R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000
R13: ffffab6640b03d48 R14: ffffffffb061d040 R15: ffff88e379173700
FS:  00007fe1ddff8100(0000) GS:ffff88e37fc00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 000055bd0b28fff8 CR3: 0000000134130006 CR4: 0000000000160ef0
Call Trace:
 __bpf_prog_run32+0x42/0x60
 ? fd_install+0x25/0x30
 ? ktime_get+0x3c/0xa0
 ? preempt_count_add+0x5e/0xd0
 bpf_test_run+0x9c/0x110
 bpf_prog_test_run_skb+0x17a/0x2a0
 __se_sys_bpf+0xdbb/0x1540
 __x64_sys_bpf+0x1a/0x20
 do_syscall_64+0x4d/0x110
 entry_SYSCALL_64_after_hwframe+0x44/0xa9
RIP: 0033:0x7fe1de103389
...

Signed-off-by: Ovidiu Panait <ovidiu.panait@windriver.com>
---
 Documentation/networking/filter.txt | 15 +++++++--------
 include/uapi/linux/bpf.h            |  1 -
 tools/include/uapi/linux/bpf.h      |  1 -
 3 files changed, 7 insertions(+), 10 deletions(-)

diff --git a/Documentation/networking/filter.txt b/Documentation/networking/filter.txt
index a6caadf24372..e6b4ebb2b243 100644
--- a/Documentation/networking/filter.txt
+++ b/Documentation/networking/filter.txt
@@ -863,7 +863,7 @@ Three LSB bits store instruction class which is one of:
   BPF_STX   0x03          BPF_STX   0x03
   BPF_ALU   0x04          BPF_ALU   0x04
   BPF_JMP   0x05          BPF_JMP   0x05
-  BPF_RET   0x06          BPF_JMP32 0x06
+  BPF_RET   0x06          [ class 6 unused, for future if needed ]
   BPF_MISC  0x07          BPF_ALU64 0x07
 
 When BPF_CLASS(code) == BPF_ALU or BPF_JMP, 4th bit encodes source operand ...
@@ -900,9 +900,9 @@ If BPF_CLASS(code) == BPF_ALU or BPF_ALU64 [ in eBPF ], BPF_OP(code) is one of:
   BPF_ARSH  0xc0  /* eBPF only: sign extending shift right */
   BPF_END   0xd0  /* eBPF only: endianness conversion */
 
-If BPF_CLASS(code) == BPF_JMP or BPF_JMP32 [ in eBPF ], BPF_OP(code) is one of:
+If BPF_CLASS(code) == BPF_JMP, BPF_OP(code) is one of:
 
-  BPF_JA    0x00  /* BPF_JMP only */
+  BPF_JA    0x00
   BPF_JEQ   0x10
   BPF_JGT   0x20
   BPF_JGE   0x30
@@ -910,8 +910,8 @@ If BPF_CLASS(code) == BPF_JMP or BPF_JMP32 [ in eBPF ], BPF_OP(code) is one of:
   BPF_JNE   0x50  /* eBPF only: jump != */
   BPF_JSGT  0x60  /* eBPF only: signed '>' */
   BPF_JSGE  0x70  /* eBPF only: signed '>=' */
-  BPF_CALL  0x80  /* eBPF BPF_JMP only: function call */
-  BPF_EXIT  0x90  /* eBPF BPF_JMP only: function return */
+  BPF_CALL  0x80  /* eBPF only: function call */
+  BPF_EXIT  0x90  /* eBPF only: function return */
   BPF_JLT   0xa0  /* eBPF only: unsigned '<' */
   BPF_JLE   0xb0  /* eBPF only: unsigned '<=' */
   BPF_JSLT  0xc0  /* eBPF only: signed '<' */
@@ -934,9 +934,8 @@ Classic BPF wastes the whole BPF_RET class to represent a single 'ret'
 operation. Classic BPF_RET | BPF_K means copy imm32 into return register
 and perform function exit. eBPF is modeled to match CPU, so BPF_JMP | BPF_EXIT
 in eBPF means function exit only. The eBPF program needs to store return
-value into register R0 before doing a BPF_EXIT. Class 6 in eBPF is used as
-BPF_JMP32 to mean exactly the same operations as BPF_JMP, but with 32-bit wide
-operands for the comparisons instead.
+value into register R0 before doing a BPF_EXIT. Class 6 in eBPF is currently
+unused and reserved for future use.
 
 For load and store instructions the 8-bit 'code' field is divided as:
 
diff --git a/include/uapi/linux/bpf.h b/include/uapi/linux/bpf.h
index 6d2da9e75e9a..b7db3261c62d 100644
--- a/include/uapi/linux/bpf.h
+++ b/include/uapi/linux/bpf.h
@@ -14,7 +14,6 @@
 /* Extended instruction set based on top of classic BPF */
 
 /* instruction classes */
-#define BPF_JMP32	0x06	/* jmp mode in word width */
 #define BPF_ALU64	0x07	/* alu mode in double word width */
 
 /* ld/ldx fields */
diff --git a/tools/include/uapi/linux/bpf.h b/tools/include/uapi/linux/bpf.h
index 6d2da9e75e9a..b7db3261c62d 100644
--- a/tools/include/uapi/linux/bpf.h
+++ b/tools/include/uapi/linux/bpf.h
@@ -14,7 +14,6 @@
 /* Extended instruction set based on top of classic BPF */
 
 /* instruction classes */
-#define BPF_JMP32	0x06	/* jmp mode in word width */
 #define BPF_ALU64	0x07	/* alu mode in double word width */
 
 /* ld/ldx fields */
-- 
2.31.1

