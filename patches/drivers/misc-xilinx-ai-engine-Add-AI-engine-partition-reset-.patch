From 3f6bc8ff36d3b991b82dac53b99fb0ba74a63e92 Mon Sep 17 00:00:00 2001
From: Wendy Liang <wendy.liang@xilinx.com>
Date: Tue, 15 Sep 2020 15:14:17 -0700
Subject: [PATCH 1593/1852] misc: xilinx-ai-engine: Add AI engine partition
 reset function

commit 9a12d773fae493b091046c387c393b15063d56b6 from
https://github.com/Xilinx/linux-xlnx.git

Add AI engine partition reset function to reset AI engine without
releasing AI engine partition.

The AI engine reset function will do the following:
* check if any memory or register is mapped. Don't reset if there is
  any memory or register mapped.
* gate columns
* reset columns
* reset shims
* gate columns

After the reset function is called, post_reinit() function is expected
to be called after when the user considers the AI engine partition is
re-initialization is done.

The post_init() function will rescan the tiles to check which tiles are
gated or not.

Signed-off-by: Wendy Liang <wendy.liang@xilinx.com>
Reviewed-by: Hyun Kwon <hyun.kwon@xilinx.com>
State: pending
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 .../xilinx-ai-engine/ai-engine-internal.h     |  5 ++
 drivers/misc/xilinx-ai-engine/ai-engine-mem.c | 23 +++++
 .../misc/xilinx-ai-engine/ai-engine-part.c    | 16 ++++
 .../misc/xilinx-ai-engine/ai-engine-reset.c   | 87 +++++++++++++++++++
 4 files changed, 131 insertions(+)

diff --git a/drivers/misc/xilinx-ai-engine/ai-engine-internal.h b/drivers/misc/xilinx-ai-engine/ai-engine-internal.h
index 4236c6bdbb83..ddc748425151 100644
--- a/drivers/misc/xilinx-ai-engine/ai-engine-internal.h
+++ b/drivers/misc/xilinx-ai-engine/ai-engine-internal.h
@@ -546,4 +546,9 @@ int aie_device_init(struct aie_device *adev);
 void aie_array_backtrack(struct work_struct *work);
 irqreturn_t aie_interrupt(int irq, void *data);
 
+bool aie_part_has_mem_mmapped(struct aie_partition *apart);
+bool aie_part_has_regs_mmapped(struct aie_partition *apart);
+
+int aie_part_reset(struct aie_partition *apart);
+int aie_part_post_reinit(struct aie_partition *apart);
 #endif /* AIE_INTERNAL_H */
diff --git a/drivers/misc/xilinx-ai-engine/ai-engine-mem.c b/drivers/misc/xilinx-ai-engine/ai-engine-mem.c
index 302112cc3060..20f96c97a4b8 100644
--- a/drivers/misc/xilinx-ai-engine/ai-engine-mem.c
+++ b/drivers/misc/xilinx-ai-engine/ai-engine-mem.c
@@ -272,3 +272,26 @@ int aie_mem_get_info(struct aie_partition *apart, unsigned long arg)
 	kfree(mems);
 	return ret;
 }
+
+/**
+ * aie_part_has_mem_mmapped() - check if memories in the partition are mapped
+ * @apart: AI engine partition
+ * @return: return true if there are memories mmaped, false otherwise.
+ *
+ * This function checks if there are memories in the partition mmapped in the
+ * partition.
+ */
+bool aie_part_has_mem_mmapped(struct aie_partition *apart)
+{
+	unsigned int num_mems, i;
+
+	num_mems = apart->adev->ops->get_mem_info(&apart->range, NULL);
+	if (!num_mems)
+		return false;
+
+	for (i = 0; i < num_mems; i++) {
+		if (apart->pmems[i].dbuf)
+			return true;
+	}
+	return false;
+}
diff --git a/drivers/misc/xilinx-ai-engine/ai-engine-part.c b/drivers/misc/xilinx-ai-engine/ai-engine-part.c
index 23f963f04830..39c6173c687d 100644
--- a/drivers/misc/xilinx-ai-engine/ai-engine-part.c
+++ b/drivers/misc/xilinx-ai-engine/ai-engine-part.c
@@ -764,3 +764,19 @@ void aie_part_remove(struct aie_partition *apart)
 	device_del(&apart->dev);
 	put_device(&apart->dev);
 }
+
+/**
+ * aie_part_has_regs_mmapped() - check if registers in the partition are mapped.
+ * @apart: AI engine partition
+ * @return: return true if there are registers mmaped, false otherwise.
+ *
+ * This function checks if there are registerss in the partition mmapped in the
+ * partition.
+ */
+bool aie_part_has_regs_mmapped(struct aie_partition *apart)
+{
+	struct address_space *mapping;
+
+	mapping = apart->filep->f_inode->i_mapping;
+	return mapping_mapped(mapping);
+}
diff --git a/drivers/misc/xilinx-ai-engine/ai-engine-reset.c b/drivers/misc/xilinx-ai-engine/ai-engine-reset.c
index d35cd8d17d95..f419d2661fb5 100644
--- a/drivers/misc/xilinx-ai-engine/ai-engine-reset.c
+++ b/drivers/misc/xilinx-ai-engine/ai-engine-reset.c
@@ -157,3 +157,90 @@ int aie_part_clean(struct aie_partition *apart)
 
 	return 0;
 }
+
+/**
+ * aie_part_reset() - reset AI engine partition
+ * @apart: AI engine partition
+ * @return: 0 for success and negative value for failure
+ *
+ * This function will:
+ * - gate all the columns
+ * - reset AI engine partition columns
+ * - reset AI engine shims
+ * - gate all the tiles in a partition.
+ *
+ * This function will not validate the partition, the caller will need to
+ * provide a valid AI engine partition.
+ */
+int aie_part_reset(struct aie_partition *apart)
+{
+	struct aie_device *adev = apart->adev;
+	int ret;
+
+	ret = mutex_lock_interruptible(&apart->mlock);
+	if (ret)
+		return ret;
+
+	/*
+	 * Check if any AI engine memories or registers in the
+	 * partition have been mapped. If yes, don't reset.
+	 */
+	if (aie_part_has_mem_mmapped(apart) ||
+	    aie_part_has_regs_mmapped(apart)) {
+		dev_err(&apart->dev,
+			"failed to reset, there are mmapped memories or registers.\n");
+		mutex_unlock(&apart->mlock);
+		return -EBUSY;
+	}
+
+	/* Clear tiles in use bitmap and clock state bitmap */
+	aie_resource_clear(&apart->tiles_inuse, 0, apart->tiles_inuse.total);
+	aie_resource_clear(&apart->cores_clk_state, 0,
+			   apart->cores_clk_state.total);
+
+	aie_part_set_cols_clkbuf(apart, false);
+	aie_part_set_cols_reset(apart, true);
+
+	ret = apart->adev->ops->reset_shim(adev, &apart->range);
+	if (ret < 0) {
+		return ret;
+		mutex_unlock(&apart->mlock);
+	}
+
+	aie_part_set_cols_clkbuf(apart, false);
+
+	mutex_unlock(&apart->mlock);
+	return 0;
+}
+
+/**
+ * aie_part_post_reinit() - AI engine partition has been re-initialized
+ * @apart: AI engine partition
+ * @return: 0 for success and negative value for failure
+ *
+ * This function will:
+ * - scan which tiles are gated
+ * - update memories and registers mapping
+ *
+ * This function will scan which tiles are gated, and update the memories and
+ * registers setting. This function is called after the AI engine partition is
+ * reconfigured with PDI outside the AI engine driver.
+ */
+int aie_part_post_reinit(struct aie_partition *apart)
+{
+	int ret;
+
+	ret = mutex_lock_interruptible(&apart->mlock);
+	if (ret)
+		return ret;
+
+	ret = aie_part_scan_clk_state(apart);
+	mutex_unlock(&apart->mlock);
+	if (ret) {
+		dev_err(&apart->dev,
+			"failed to scan clock states after reset is done.\n");
+		return ret;
+	}
+
+	return 0;
+}
-- 
2.31.1

