From 7f386acaa63d11fba3171c537c23538f185e0ec1 Mon Sep 17 00:00:00 2001
From: Devarsh Thakkar <devarsht@xilinx.com>
Date: Tue, 27 Feb 2018 15:34:55 -0800
Subject: [PATCH 0296/1852] v4l: xilinx: dma: Fix v4l2 enumeration callback for
 multiplanar

commit 20701a47d2791ea2e804c7b283e7e5353b074795 from
https://github.com/Xilinx/linux-xlnx.git

This fixes issues with v4l2 enumeration callback with multiplanar
formats due to which supported multiplanar formats were not getting
enumerated when using VIDEO_ENUM_FMT ioctl.

The intention of existing implementation for multiplanar formats was
to save in array and return the subset of all the v4l2 formats
supported by attached dma device and the supported media bus format
and also cache the supported media bus format so that for future calls
if same media bus format is called then the v4l2 pixel formats can be
directly returned from the entries saved in the array.

This is acheived now with below changes :
a. Use V4L2 subdev helper functions to query supported media bus
  format code.
b. Cache the media bus format also for the condition when it is empty
  along with whenever new media bus format is detected.
c. Fix NULL pointer deference error by dynamically allocating
  memory for poss_v4l2_fmts.

Signed-off-by: Devarsh Thakkar <devarsht@xilinx.com>
Signed-off-by: Satish Kumar Nagireddy <satishna@xilinx.com>
Reviewed-by: Hyun Kwon <hyun.kwon@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
State: pending
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 drivers/media/platform/xilinx/xilinx-dma.c | 68 ++++++++++++++++++++--
 drivers/media/platform/xilinx/xilinx-dma.h |  6 ++
 2 files changed, 69 insertions(+), 5 deletions(-)

diff --git a/drivers/media/platform/xilinx/xilinx-dma.c b/drivers/media/platform/xilinx/xilinx-dma.c
index 3570e6f0e9a3..f37158bd1d47 100644
--- a/drivers/media/platform/xilinx/xilinx-dma.c
+++ b/drivers/media/platform/xilinx/xilinx-dma.c
@@ -639,15 +639,73 @@ xvip_dma_enum_format(struct file *file, void *fh, struct v4l2_fmtdesc *f)
 {
 	struct v4l2_fh *vfh = file->private_data;
 	struct xvip_dma *dma = to_xvip_dma(vfh->vdev);
+	struct v4l2_subdev *subdev;
+	struct v4l2_subdev_format v4l_fmt;
+	int err, ret;
+	const struct xvip_video_format *fmt;
+
+	if (V4L2_TYPE_IS_MULTIPLANAR(dma->format.type)) {
+		/* establish media pad format */
+		subdev = xvip_dma_remote_subdev(&dma->pad, &v4l_fmt.pad);
+		if (!subdev)
+			return -EPIPE;
+
+		v4l_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+		ret = v4l2_subdev_call(subdev, pad, get_fmt, NULL, &v4l_fmt);
+		if (ret < 0)
+			return ret == -ENOIOCTLCMD ? -EINVAL : ret;
+
+		/* has media pad value changed? */
+		if (v4l_fmt.format.code != dma->remote_subdev_med_bus ||
+		    !dma->remote_subdev_med_bus) {
+			u32 i, fmt_cnt, *fmts;
+			/* re-generate legal list of fourcc codes */
+			dma->poss_v4l2_fmt_cnt = 0;
+			dma->remote_subdev_med_bus = v4l_fmt.format.code;
+			err = xilinx_xdma_get_v4l2_vid_fmts(dma->dma, &fmt_cnt,
+							    &fmts);
+			if (err)
+				return err;
+			if (!dma->poss_v4l2_fmts) {
+				dma->poss_v4l2_fmts =
+					devm_kzalloc(&dma->video.dev,
+						     sizeof(u32) * fmt_cnt,
+						     GFP_KERNEL);
+				if (!dma->poss_v4l2_fmts)
+					return -ENOMEM;
+			}
+			for (i = 0; i < fmt_cnt; i++) {
+				fmt = xvip_get_format_by_fourcc(fmts[i]);
+				if (IS_ERR(fmt))
+					return PTR_ERR(fmt);
+
+				if (fmt->code != dma->remote_subdev_med_bus)
+					continue;
+
+				dma->poss_v4l2_fmts[dma->poss_v4l2_fmt_cnt++] =
+									fmts[i];
+			}
+		}
+
+		/* Return err if index is greater than count of legal values */
+		if (f->index >= dma->poss_v4l2_fmt_cnt)
+			return -EINVAL;
 
+		/* Else return pix format in table */
+		fmt = xvip_get_format_by_fourcc(dma->poss_v4l2_fmts[f->index]);
+		if (IS_ERR(fmt))
+			return PTR_ERR(fmt);
+
+		f->pixelformat = fmt->fourcc;
+
+		return 0;
+	}
+
+	/* Single plane formats */
 	if (f->index > 0)
 		return -EINVAL;
 
-	if (V4L2_TYPE_IS_MULTIPLANAR(dma->format.type))
-		f->pixelformat = dma->format.fmt.pix_mp.pixelformat;
-	else
-		f->pixelformat = dma->format.fmt.pix.pixelformat;
-
+	f->pixelformat = dma->format.fmt.pix.pixelformat;
 	return 0;
 }
 
diff --git a/drivers/media/platform/xilinx/xilinx-dma.h b/drivers/media/platform/xilinx/xilinx-dma.h
index dfdf3cd67fa6..8c7f21eea645 100644
--- a/drivers/media/platform/xilinx/xilinx-dma.h
+++ b/drivers/media/platform/xilinx/xilinx-dma.h
@@ -55,12 +55,15 @@ static inline struct xvip_pipeline *to_xvip_pipeline(struct media_entity *e)
  * @list: list entry in a composite device dmas list
  * @video: V4L2 video device associated with the DMA channel
  * @pad: media pad for the video device entity
+ * @remote_subdev_med_bus: media bus format of sub-device
  * @xdev: composite device the DMA channel belongs to
  * @pipe: pipeline belonging to the DMA channel
  * @port: composite device DT node port number for the DMA channel
  * @lock: protects the @format, @fmtinfo and @queue fields
  * @format: active V4L2 pixel format
  * @fmtinfo: format information corresponding to the active @format
+ * @poss_v4l2_fmts: All possible v4l formats supported
+ * @poss_v4l2_fmt_cnt: number of supported v4l formats
  * @queue: vb2 buffers queue
  * @sequence: V4L2 buffers sequence number
  * @queued_bufs: list of queued buffers
@@ -74,6 +77,7 @@ struct xvip_dma {
 	struct list_head list;
 	struct video_device video;
 	struct media_pad pad;
+	u32 remote_subdev_med_bus;
 
 	struct xvip_composite_device *xdev;
 	struct xvip_pipeline pipe;
@@ -82,6 +86,8 @@ struct xvip_dma {
 	struct mutex lock;
 	struct v4l2_format format;
 	const struct xvip_video_format *fmtinfo;
+	u32 *poss_v4l2_fmts;
+	u32 poss_v4l2_fmt_cnt;
 
 	struct vb2_queue queue;
 	unsigned int sequence;
-- 
2.31.1

