From 0855c0ad747d3558a4777f8db6dba8fcab1f9252 Mon Sep 17 00:00:00 2001
From: Hariprasad Kelam <hkelam@marvell.com>
Date: Tue, 26 Jan 2021 14:15:13 +0530
Subject: [PATCH 1217/1921] octeontx2-af: clean up rpm driver

Rename common structures and move strcuture declarations
to proper files.

Change-Id: I9fc94d200e97acc77617018e5563a01e08d62190
Signed-off-by: Hariprasad Kelam <hkelam@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/44373
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Tested-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 .../net/ethernet/marvell/octeontx2/af/cgx.c   | 89 +++++++------------
 .../net/ethernet/marvell/octeontx2/af/cgx.h   | 61 +------------
 .../marvell/octeontx2/af/lmac_common.h        | 64 ++++++++++++-
 .../net/ethernet/marvell/octeontx2/af/rpm.c   | 56 +++++++++---
 .../ethernet/marvell/octeontx2/af/rvu_cgx.c   | 21 ++---
 .../marvell/octeontx2/af/rvu_debugfs.c        | 13 +--
 .../ethernet/marvell/octeontx2/af/rvu_nix.c   |  5 +-
 7 files changed, 160 insertions(+), 149 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/af/cgx.c b/drivers/net/ethernet/marvell/octeontx2/af/cgx.c
index 54e07f80386c..c8d6161d2957 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/cgx.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/cgx.c
@@ -29,52 +29,6 @@
 
 #define CGX_RX_STAT_GLOBAL_INDEX	9
 
-static struct cgx_mac_ops	otx2_mac_ops    = {
-	.name		=       "cgx",
-	.csr_offset	=       0,
-	.lmac_offset    =       18,
-	.int_register	=       CGXX_CMRX_INT,
-	.int_set_reg	=       CGXX_CMRX_INT_ENA_W1S,
-	.irq_offset	=       9,
-	.int_ena_bit    =       FW_CGX_INT,
-	.lmac_fwi	=	CGX_LMAC_FWI,
-	.non_contiguous_serdes_lane = false,
-	.rx_stats_cnt   =       9,
-	.tx_stats_cnt   =       18,
-	.get_nr_lmacs	=	cgx_get_nr_lmacs,
-	.get_lmac_type  =       cgx_get_lmac_type,
-	.mac_lmac_intl_lbk =    cgx_lmac_internal_loopback,
-	.mac_get_rx_stats  =	cgx_get_rx_stats,
-	.mac_get_tx_stats  =	cgx_get_tx_stats,
-	.mac_enadis_rx_pause_fwding =	cgx_lmac_enadis_rx_pause_fwding,
-	.mac_get_pause_frm_status =	cgx_lmac_get_pause_frm_status,
-	.mac_enadis_pause_frm =		cgx_lmac_enadis_pause_frm,
-	.mac_pause_frm_config =		cgx_lmac_pause_frm_config,
-};
-
-static struct cgx_mac_ops	cn10k_mac_ops   = {
-	.name		=       "rpm",
-	.csr_offset     =       0x4e00,
-	.lmac_offset    =       20,
-	.int_register	=       RPMX_CMRX_SW_INT,
-	.int_set_reg    =       RPMX_CMRX_SW_INT_ENA_W1S,
-	.irq_offset     =       1,
-	.int_ena_bit    =       BIT_ULL(0),
-	.lmac_fwi	=	RPM_LMAC_FWI,
-	.non_contiguous_serdes_lane = true,
-	.rx_stats_cnt   =       43,
-	.tx_stats_cnt   =       34,
-	.get_nr_lmacs	=	rpm_get_nr_lmacs,
-	.get_lmac_type  =       rpm_get_lmac_type,
-	.mac_lmac_intl_lbk =    rpm_lmac_internal_loopback,
-	.mac_get_rx_stats  =	rpm_get_rx_stats,
-	.mac_get_tx_stats  =	rpm_get_tx_stats,
-	.mac_enadis_rx_pause_fwding =	rpm_lmac_enadis_rx_pause_fwding,
-	.mac_get_pause_frm_status =	rpm_lmac_get_pause_frm_status,
-	.mac_enadis_pause_frm =		rpm_lmac_enadis_pause_frm,
-	.mac_pause_frm_config =		rpm_lmac_pause_frm_config,
-};
-
 static LIST_HEAD(cgx_list);
 
 /* Convert firmware speed encoding to user format(Mbps) */
@@ -123,7 +77,7 @@ static int get_sequence_id_of_lmac(struct cgx *cgx, int lmac_id)
 	return id;
 }
 
-struct cgx_mac_ops *cgx_get_mac_ops(void *cgxd)
+struct mac_ops *get_mac_ops(void *cgxd)
 {
 	if (!cgxd)
 		return cgxd;
@@ -258,7 +212,7 @@ int cgx_lmac_addr_set(u8 cgx_id, u8 lmac_id, u8 *mac_addr)
 {
 	struct cgx *cgx_dev = cgx_get_pdata(cgx_id);
 	struct lmac *lmac = lmac_pdata(lmac_id, cgx_dev);
-	struct cgx_mac_ops *mac_ops;
+	struct mac_ops *mac_ops;
 	int index, id;
 	u64 cfg;
 
@@ -289,7 +243,7 @@ int cgx_lmac_addr_add(u8 cgx_id, u8 lmac_id, u8 *mac_addr)
 {
 	struct cgx *cgx_dev = cgx_get_pdata(cgx_id);
 	struct lmac *lmac = lmac_pdata(lmac_id, cgx_dev);
-	struct cgx_mac_ops *mac_ops;
+	struct mac_ops *mac_ops;
 	int index, idx;
 	u64 cfg = 0;
 	int id;
@@ -325,7 +279,7 @@ int cgx_lmac_addr_reset(u8 cgx_id, u8 lmac_id)
 {
 	struct cgx *cgx_dev = cgx_get_pdata(cgx_id);
 	struct lmac *lmac = lmac_pdata(lmac_id, cgx_dev);
-	struct cgx_mac_ops *mac_ops;
+	struct mac_ops *mac_ops;
 	u8 index = 0;
 	u64 cfg;
 
@@ -355,7 +309,7 @@ int cgx_lmac_addr_del(u8 cgx_id, u8 lmac_id, u8 index)
 {
 	struct cgx *cgx_dev = cgx_get_pdata(cgx_id);
 	struct lmac *lmac = lmac_pdata(lmac_id, cgx_dev);
-	struct cgx_mac_ops *mac_ops;
+	struct mac_ops *mac_ops;
 	int id;
 
 	if (!lmac)
@@ -398,7 +352,7 @@ u64 cgx_lmac_addr_get(u8 cgx_id, u8 lmac_id)
 {
 	struct cgx *cgx_dev = cgx_get_pdata(cgx_id);
 	struct lmac *lmac = lmac_pdata(lmac_id, cgx_dev);
-	struct cgx_mac_ops *mac_ops;
+	struct mac_ops *mac_ops;
 	int index;
 	u64 cfg;
 	int id;
@@ -479,7 +433,7 @@ void cgx_lmac_promisc_config(int cgx_id, int lmac_id, bool enable)
 	struct cgx *cgx = cgx_get_pdata(cgx_id);
 	struct lmac *lmac = lmac_pdata(lmac_id, cgx);
 	u16 max_dmac = lmac->mac_to_index_bmap.max;
-	struct cgx_mac_ops *mac_ops;
+	struct mac_ops *mac_ops;
 	int index, i;
 	u64 cfg = 0;
 	int id;
@@ -1593,7 +1547,7 @@ static void cgx_lmac_get_fifolen(struct cgx *cgx)
 static int cgx_configure_interrupt(struct cgx *cgx, struct lmac *lmac,
 				   int cnt, bool req_free)
 {
-	struct cgx_mac_ops     *mac_ops = cgx->mac_ops;
+	struct mac_ops     *mac_ops = cgx->mac_ops;
 	u64 offset, ena_bit;
 	unsigned int irq;
 	int err;
@@ -1745,6 +1699,29 @@ static void cgx_populate_features(struct cgx *cgx)
 				    RVU_LMAC_FEAT_PTP | RVU_LMAC_FEAT_DMACF);
 }
 
+struct mac_ops		cgx_mac_ops    = {
+	.name		=       "cgx",
+	.csr_offset	=       0,
+	.lmac_offset    =       18,
+	.int_register	=       CGXX_CMRX_INT,
+	.int_set_reg	=       CGXX_CMRX_INT_ENA_W1S,
+	.irq_offset	=       9,
+	.int_ena_bit    =       FW_CGX_INT,
+	.lmac_fwi	=	CGX_LMAC_FWI,
+	.non_contiguous_serdes_lane = false,
+	.rx_stats_cnt   =       9,
+	.tx_stats_cnt   =       18,
+	.get_nr_lmacs	=	cgx_get_nr_lmacs,
+	.get_lmac_type  =       cgx_get_lmac_type,
+	.mac_lmac_intl_lbk =    cgx_lmac_internal_loopback,
+	.mac_get_rx_stats  =	cgx_get_rx_stats,
+	.mac_get_tx_stats  =	cgx_get_tx_stats,
+	.mac_enadis_rx_pause_fwding =	cgx_lmac_enadis_rx_pause_fwding,
+	.mac_get_pause_frm_status =	cgx_lmac_get_pause_frm_status,
+	.mac_enadis_pause_frm =		cgx_lmac_enadis_pause_frm,
+	.mac_pause_frm_config =		cgx_lmac_pause_frm_config,
+};
+
 static int cgx_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 {
 	struct device *dev = &pdev->dev;
@@ -1760,9 +1737,9 @@ static int cgx_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 
 	/* Use mac_ops to get MAC specific features */
 	if (pdev->device == PCI_DEVID_CN10K_RPM)
-		cgx->mac_ops = &cn10k_mac_ops;
+		cgx->mac_ops = rpm_get_mac_ops();
 	else
-		cgx->mac_ops = &otx2_mac_ops;
+		cgx->mac_ops = &cgx_mac_ops;
 
 	err = pci_enable_device(pdev);
 	if (err) {
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/cgx.h b/drivers/net/ethernet/marvell/octeontx2/af/cgx.h
index 61f72849dceb..8213a6415112 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/cgx.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/cgx.h
@@ -133,65 +133,6 @@ struct cgx_event_cb {
 	void *data;
 };
 
-/* CGX & RPM has different feature set
- * update the structure fields with different one
- */
-struct cgx_mac_ops {
-	char		       *name;
-	/* Features like  DMAC FILTER csrs differs by fixed
-	 * bar offset for example
-	 * CGX DMAC_CTL0  0x1f8
-	 * RPM DMAC_CTL0  0x4ff8
-	 */
-	u64			csr_offset;
-	/* lmac offset is different is RPM */
-	u8			lmac_offset;
-	/* For ATF to send events to kernel, there is no dedicated interrupt
-	 * defined hence CGX uses OVERFLOW bit in CMR_INT. RPM block supports
-	 * SW_INT so that ATF triggers this interrupt after processing of
-	 * requested command
-	 */
-	u64			int_register;
-	u64			int_set_reg;
-	u8			irq_offset;
-	u8			int_ena_bit;
-	u8			lmac_fwi;
-	u32			fifo_len;
-	bool			non_contiguous_serdes_lane;
-	/* RPM & CGX differs in number of Receive/transmit stats */
-	u8			rx_stats_cnt;
-	u8			tx_stats_cnt;
-
-	/* Incase of RPM get number of lmacs from RPMX_CMR_RX_LMACS[LMAC_EXIST]
-	 * number of setbits in lmac_exist tells number of lmacs
-	 */
-	int			(*get_nr_lmacs)(void *cgx);
-	u8                      (*get_lmac_type)(void *cgx, int lmac_id);
-	int                     (*mac_lmac_intl_lbk)(void *cgx, int lmac_id,
-						     bool enable);
-	/* Register Stats related functions */
-	int			(*mac_get_rx_stats)(void *cgx, int lmac_id,
-						    int idx, u64 *rx_stat);
-	int			(*mac_get_tx_stats)(void *cgx, int lmac_id,
-						    int idx, u64 *tx_stat);
-	/* Enable LMAC Pause Frame Configuration */
-	void			(*mac_enadis_rx_pause_fwding)(void *cgxd,
-							      int lmac_id,
-							      bool enable);
-	int			(*mac_get_pause_frm_status)(void *cgxd,
-							    int lmac_id,
-							    u8 *tx_pause,
-							    u8 *rx_pause);
-	int			(*mac_enadis_pause_frm)(void *cgxd,
-							int lmac_id,
-							u8 tx_pause,
-							u8 rx_pause);
-	void			(*mac_pause_frm_config)(void  *cgxd,
-							int lmac_id,
-							bool enable);
-
-};
-
 extern struct pci_driver cgx_driver;
 
 int cgx_get_cgxcnt_max(void);
@@ -239,7 +180,7 @@ bool is_higig2_enabled(void *cgxd, int lmac_id);
 int cgx_get_pkind(void *cgxd, u8 lmac_id, int *pkind);
 u8 cgx_lmac_get_p2x(int cgx_id, int lmac_id);
 u64 cgx_features_get(void *cgxd);
-struct cgx_mac_ops *cgx_get_mac_ops(void *cgxd);
+struct mac_ops *get_mac_ops(void *cgxd);
 int cgx_get_nr_lmacs(void *cgxd);
 void cgx_lmac_write(int cgx_id, int lmac_id, u64 offset, u64 val);
 u64 cgx_lmac_read(int cgx_id, int lmac_id, u64 offset);
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/lmac_common.h b/drivers/net/ethernet/marvell/octeontx2/af/lmac_common.h
index 06146e7b2723..c9166b3ad12b 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/lmac_common.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/lmac_common.h
@@ -34,6 +34,65 @@ struct lmac {
 	char *name;
 };
 
+/* CGX & RPM has different feature set
+ * update the structure fields with different one
+ */
+struct mac_ops {
+	char		       *name;
+	/* Features like  DMAC FILTER csrs differs by fixed
+	 * bar offset for example
+	 * CGX DMAC_CTL0  0x1f8
+	 * RPM DMAC_CTL0  0x4ff8
+	 */
+	u64			csr_offset;
+	/* For ATF to send events to kernel, there is no dedicated interrupt
+	 * defined hence CGX uses OVERFLOW bit in CMR_INT. RPM block supports
+	 * SW_INT so that ATF triggers this interrupt after processing of
+	 * requested command
+	 */
+	u64			int_register;
+	u64			int_set_reg;
+	/* lmac offset is different is RPM */
+	u8			lmac_offset;
+	u8			irq_offset;
+	u8			int_ena_bit;
+	u8			lmac_fwi;
+	u32			fifo_len;
+	bool			non_contiguous_serdes_lane;
+	/* RPM & CGX differs in number of Receive/transmit stats */
+	u8			rx_stats_cnt;
+	u8			tx_stats_cnt;
+
+	/* Incase of RPM get number of lmacs from RPMX_CMR_RX_LMACS[LMAC_EXIST]
+	 * number of setbits in lmac_exist tells number of lmacs
+	 */
+	int			(*get_nr_lmacs)(void *cgx);
+	u8                      (*get_lmac_type)(void *cgx, int lmac_id);
+	int                     (*mac_lmac_intl_lbk)(void *cgx, int lmac_id,
+						     bool enable);
+	/* Register Stats related functions */
+	int			(*mac_get_rx_stats)(void *cgx, int lmac_id,
+						    int idx, u64 *rx_stat);
+	int			(*mac_get_tx_stats)(void *cgx, int lmac_id,
+						    int idx, u64 *tx_stat);
+	/* Enable LMAC Pause Frame Configuration */
+	void			(*mac_enadis_rx_pause_fwding)(void *cgxd,
+							      int lmac_id,
+							      bool enable);
+	int			(*mac_get_pause_frm_status)(void *cgxd,
+							    int lmac_id,
+							    u8 *tx_pause,
+							    u8 *rx_pause);
+	int			(*mac_enadis_pause_frm)(void *cgxd,
+							int lmac_id,
+							u8 tx_pause,
+							u8 rx_pause);
+	void			(*mac_pause_frm_config)(void  *cgxd,
+							int lmac_id,
+							bool enable);
+
+};
+
 struct cgx {
 	void __iomem            *reg_base;
 	struct pci_dev          *pdev;
@@ -44,7 +103,7 @@ struct cgx {
 	struct                  workqueue_struct *cgx_cmd_workq;
 	struct list_head        cgx_list;
 	u64                     hw_features;
-	struct cgx_mac_ops     *mac_ops;
+	struct mac_ops     *mac_ops;
 	/* Lock to serialize read/write of global csrs like
 	 * RPMX_MTI_STAT_DATA_HI_CDC etc
 	 */
@@ -52,6 +111,8 @@ struct cgx {
 	unsigned long		lmac_bmap; /* bitmap of enabled lmacs */
 };
 
+typedef struct cgx rpm_t;
+
 /* Function Declarations */
 void cgx_write(struct cgx *cgx, u64 lmac, u64 offset, u64 val);
 u64 cgx_read(struct cgx *cgx, u64 lmac, u64 offset);
@@ -59,3 +120,4 @@ struct lmac *lmac_pdata(u8 lmac_id, struct cgx *cgx);
 int cgx_fwi_cmd_send(u64 req, u64 *resp, struct lmac *lmac);
 int cgx_fwi_cmd_generic(u64 req, u64 *resp, struct cgx *cgx, int lmac_id);
 bool is_lmac_valid(struct cgx *cgx, int lmac_id);
+struct mac_ops *rpm_get_mac_ops(void);
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rpm.c b/drivers/net/ethernet/marvell/octeontx2/af/rpm.c
index a1720514006b..0ddb9b527d74 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rpm.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rpm.c
@@ -8,26 +8,54 @@
 #include "cgx.h"
 #include "lmac_common.h"
 
-static void rpm_write(struct cgx *rpm, u64 lmac, u64 offset, u64 val)
+static struct mac_ops		rpm_mac_ops   = {
+	.name		=       "rpm",
+	.csr_offset     =       0x4e00,
+	.lmac_offset    =       20,
+	.int_register	=       RPMX_CMRX_SW_INT,
+	.int_set_reg    =       RPMX_CMRX_SW_INT_ENA_W1S,
+	.irq_offset     =       1,
+	.int_ena_bit    =       BIT_ULL(0),
+	.lmac_fwi	=	RPM_LMAC_FWI,
+	.non_contiguous_serdes_lane = true,
+	.rx_stats_cnt   =       43,
+	.tx_stats_cnt   =       34,
+	.get_nr_lmacs	=	rpm_get_nr_lmacs,
+	.get_lmac_type  =       rpm_get_lmac_type,
+	.mac_lmac_intl_lbk =    rpm_lmac_internal_loopback,
+	.mac_get_rx_stats  =	rpm_get_rx_stats,
+	.mac_get_tx_stats  =	rpm_get_tx_stats,
+	.mac_enadis_rx_pause_fwding =	rpm_lmac_enadis_rx_pause_fwding,
+	.mac_get_pause_frm_status =	rpm_lmac_get_pause_frm_status,
+	.mac_enadis_pause_frm =		rpm_lmac_enadis_pause_frm,
+	.mac_pause_frm_config =		rpm_lmac_pause_frm_config,
+};
+
+struct mac_ops *rpm_get_mac_ops(void)
+{
+	return &rpm_mac_ops;
+}
+
+static void rpm_write(rpm_t *rpm, u64 lmac, u64 offset, u64 val)
 {
 	cgx_write(rpm, lmac, offset, val);
 }
 
-static u64 rpm_read(struct cgx *rpm, u64 lmac, u64 offset)
+static u64 rpm_read(rpm_t *rpm, u64 lmac, u64 offset)
 {
 	return	cgx_read(rpm, lmac, offset);
 }
 
 int rpm_get_nr_lmacs(void *rpmd)
 {
-	struct cgx *rpm = rpmd;
+	rpm_t *rpm = rpmd;
 
 	return hweight8(rpm_read(rpm, 0, CGXX_CMRX_RX_LMACS) & 0xFULL);
 }
 
 u8 rpm_get_lmac_type(void *rpmd, int lmac_id)
 {
-	struct cgx *rpm = rpmd;
+	rpm_t *rpm = rpmd;
 	u64 req = 0, resp;
 	int err;
 
@@ -40,7 +68,7 @@ u8 rpm_get_lmac_type(void *rpmd, int lmac_id)
 
 int rpm_lmac_internal_loopback(void *rpmd, int lmac_id, bool enable)
 {
-	struct cgx *rpm = rpmd;
+	rpm_t *rpm = rpmd;
 	u8 lmac_type;
 	u64 cfg;
 
@@ -69,7 +97,7 @@ int rpm_lmac_internal_loopback(void *rpmd, int lmac_id, bool enable)
 
 int rpm_get_rx_stats(void *rpmd, int lmac_id, int idx, u64 *rx_stat)
 {
-	struct cgx *rpm = rpmd;
+	rpm_t *rpm = rpmd;
 	u64 val_lo, val_hi;
 
 	if (!is_lmac_valid(rpm, lmac_id))
@@ -97,7 +125,7 @@ int rpm_get_rx_stats(void *rpmd, int lmac_id, int idx, u64 *rx_stat)
 
 int rpm_get_tx_stats(void *rpmd, int lmac_id, int idx, u64 *tx_stat)
 {
-	struct cgx *rpm = rpmd;
+	rpm_t *rpm = rpmd;
 	u64 val_lo, val_hi;
 
 	if (!is_lmac_valid(rpm, lmac_id))
@@ -120,7 +148,7 @@ int rpm_get_tx_stats(void *rpmd, int lmac_id, int idx, u64 *tx_stat)
 
 void rpm_lmac_enadis_rx_pause_fwding(void *rpmd, int lmac_id, bool enable)
 {
-	struct cgx *rpm = rpmd;
+	rpm_t *rpm = rpmd;
 	u64 cfg;
 
 	if (!rpm)
@@ -137,10 +165,10 @@ void rpm_lmac_enadis_rx_pause_fwding(void *rpmd, int lmac_id, bool enable)
 	}
 }
 
-int rpm_lmac_get_pause_frm_status(void *cgxd, int lmac_id,
+int rpm_lmac_get_pause_frm_status(void *rpmd, int lmac_id,
 				  u8 *tx_pause, u8 *rx_pause)
 {
-	struct cgx *rpm = cgxd;
+	rpm_t *rpm = rpmd;
 	u64 cfg;
 
 	if (!is_lmac_valid(rpm, lmac_id))
@@ -157,7 +185,7 @@ int rpm_lmac_get_pause_frm_status(void *cgxd, int lmac_id,
 static int rpm_lmac_enadis_8023_pause_frm(void *rpmd, int lmac_id, u8 tx_pause,
 					  u8 rx_pause)
 {
-	struct cgx *rpm = rpmd;
+	rpm_t *rpm = rpmd;
 	u64 cfg;
 
 	cfg = rpm_read(rpm, lmac_id, RPMX_MTI_MAC100X_COMMAND_CONFIG);
@@ -186,7 +214,7 @@ static int rpm_lmac_enadis_8023_pause_frm(void *rpmd, int lmac_id, u8 tx_pause,
 int rpm_lmac_enadis_pause_frm(void *rpmd, int lmac_id,
 			      u8 tx_pause, u8 rx_pause)
 {
-	struct cgx *rpm = rpmd;
+	rpm_t *rpm = rpmd;
 
 	if (!is_lmac_valid(rpm, lmac_id))
 		return -ENODEV;
@@ -197,7 +225,7 @@ int rpm_lmac_enadis_pause_frm(void *rpmd, int lmac_id,
 
 void rpm_lmac_pause_frm_config(void *rpmd, int lmac_id, bool enable)
 {
-	struct cgx *rpm = rpmd;
+	rpm_t *rpm = rpmd;
 	u64 cfg;
 
 	if (enable) {
@@ -228,7 +256,7 @@ void rpm_lmac_pause_frm_config(void *rpmd, int lmac_id, bool enable)
 		rpm_write(rpm, lmac_id, RPMX_MTI_MAC100X_CL01_PAUSE_QUANTA,
 			  cfg | RPM_DEFAULT_PAUSE_TIME);
 		/* Set pause interval as the hardware default is too short */
-		cfg = cgx_read(rpm, lmac_id,
+		cfg = rpm_read(rpm, lmac_id,
 			       RPMX_MTI_MAC100X_CL01_QUANTA_THRESH);
 		cfg &= ~0xFFFFULL;
 		rpm_write(rpm, lmac_id, RPMX_MTI_MAC100X_CL01_QUANTA_THRESH,
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_cgx.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_cgx.c
index a01032be602b..94b0e40a211f 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_cgx.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_cgx.c
@@ -14,6 +14,7 @@
 
 #include "rvu.h"
 #include "cgx.h"
+#include "lmac_common.h"
 #include "rvu_reg.h"
 #include "rvu_trace.h"
 
@@ -403,7 +404,7 @@ inline bool is_cgx_config_permitted(struct rvu *rvu, u16 pcifunc)
 
 void rvu_cgx_enadis_rx_bp(struct rvu *rvu, int pf, bool enable)
 {
-	struct cgx_mac_ops *mac_ops;
+	struct mac_ops *mac_ops;
 	u8 cgx_id, lmac_id;
 	void *cgxd;
 
@@ -413,7 +414,7 @@ void rvu_cgx_enadis_rx_bp(struct rvu *rvu, int pf, bool enable)
 	rvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_id, &lmac_id);
 	cgxd = rvu_cgx_pdata(cgx_id, rvu);
 
-	mac_ops = cgx_get_mac_ops(cgxd);
+	mac_ops = get_mac_ops(cgxd);
 	/* Set / clear CTL_BCK to control pause frame forwarding to NIX */
 	if (enable)
 		mac_ops->mac_enadis_rx_pause_fwding(cgxd, lmac_id, true);
@@ -509,7 +510,7 @@ static int rvu_lmac_get_stats(struct rvu *rvu, struct msg_req *req,
 			      void *rsp)
 {
 	int pf = rvu_get_pf(req->hdr.pcifunc);
-	struct cgx_mac_ops *mac_ops;
+	struct mac_ops *mac_ops;
 	int stat = 0, err = 0;
 	u64 tx_stat, rx_stat;
 	u8 cgx_idx, lmac;
@@ -520,7 +521,7 @@ static int rvu_lmac_get_stats(struct rvu *rvu, struct msg_req *req,
 
 	rvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_idx, &lmac);
 	cgxd = rvu_cgx_pdata(cgx_idx, rvu);
-	mac_ops = cgx_get_mac_ops(cgxd);
+	mac_ops = get_mac_ops(cgxd);
 
 	while (stat < mac_ops->rx_stats_cnt) {
 		err = mac_ops->mac_get_rx_stats(cgxd, lmac, stat, &rx_stat);
@@ -858,14 +859,14 @@ int rvu_mbox_handler_cgx_get_linkinfo(struct rvu *rvu, struct msg_req *req,
 static int rvu_cgx_config_intlbk(struct rvu *rvu, u16 pcifunc, bool en)
 {
 	int pf = rvu_get_pf(pcifunc);
-	struct cgx_mac_ops *mac_ops;
+	struct mac_ops *mac_ops;
 	u8 cgx_id, lmac_id;
 
 	if (!is_cgx_config_permitted(rvu, pcifunc))
 		return -EPERM;
 
 	rvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_id, &lmac_id);
-	mac_ops = cgx_get_mac_ops(rvu_cgx_pdata(cgx_id, rvu));
+	mac_ops = get_mac_ops(rvu_cgx_pdata(cgx_id, rvu));
 
 	return mac_ops->mac_lmac_intl_lbk(rvu_cgx_pdata(cgx_id, rvu),
 					  lmac_id, en);
@@ -890,7 +891,7 @@ int rvu_mbox_handler_cgx_cfg_pause_frm(struct rvu *rvu,
 				       struct cgx_pause_frm_cfg *rsp)
 {
 	int pf = rvu_get_pf(req->hdr.pcifunc);
-	struct cgx_mac_ops *mac_ops;
+	struct mac_ops *mac_ops;
 	u8 cgx_id, lmac_id;
 	void *cgxd;
 
@@ -905,7 +906,7 @@ int rvu_mbox_handler_cgx_cfg_pause_frm(struct rvu *rvu,
 
 	rvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_id, &lmac_id);
 	cgxd = rvu_cgx_pdata(cgx_id, rvu);
-	mac_ops = cgx_get_mac_ops(cgxd);
+	mac_ops = get_mac_ops(cgxd);
 
 	if (req->set)
 		mac_ops->mac_enadis_pause_frm(cgxd, lmac_id,
@@ -1185,11 +1186,11 @@ int rvu_mbox_handler_cgx_features_get(struct rvu *rvu,
 
 u32 rvu_cgx_get_fifolen(struct rvu *rvu)
 {
-	struct cgx_mac_ops *mac_ops;
+	struct mac_ops *mac_ops;
 	int rvu_def_cgx_id = 0;
 	u32 fifo_len;
 
-	mac_ops = cgx_get_mac_ops(rvu_cgx_pdata(rvu_def_cgx_id, rvu));
+	mac_ops = get_mac_ops(rvu_cgx_pdata(rvu_def_cgx_id, rvu));
 	fifo_len = mac_ops ? mac_ops->fifo_len : 0;
 
 	return fifo_len;
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_debugfs.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_debugfs.c
index d5a54c7120c8..21d9218da5aa 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_debugfs.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_debugfs.c
@@ -19,6 +19,7 @@
 #include "rvu_reg.h"
 #include "rvu.h"
 #include "cgx.h"
+#include "lmac_common.h"
 #include "npc.h"
 
 #define DEBUGFS_DIR_NAME "octeontx2"
@@ -311,7 +312,7 @@ static int rvu_dbg_rvu_pf_cgx_map_display(struct seq_file *filp, void *unused)
 {
 	struct rvu *rvu = filp->private;
 	struct pci_dev *pdev = NULL;
-	struct cgx_mac_ops *mac_ops;
+	struct mac_ops *mac_ops;
 	int rvu_def_cgx_id = 0;
 	char cgx[10], lmac[10];
 	struct rvu_pfvf *pfvf;
@@ -320,7 +321,7 @@ static int rvu_dbg_rvu_pf_cgx_map_display(struct seq_file *filp, void *unused)
 	u16 pcifunc;
 
 	domain = 2;
-	mac_ops = cgx_get_mac_ops(rvu_cgx_pdata(rvu_def_cgx_id, rvu));
+	mac_ops = get_mac_ops(rvu_cgx_pdata(rvu_def_cgx_id, rvu));
 	seq_printf(filp, "PCI dev\t\tRVU PF Func\tNIX block\t%s\tLMAC\n",
 		   mac_ops->name);
 	for (pf = 0; pf < rvu->hw->total_pfs; pf++) {
@@ -1025,7 +1026,7 @@ RVU_DEBUG_SEQ_FOPS(nix_ndc_tx_hits_miss, nix_ndc_tx_hits_miss_display, NULL);
 static int cgx_print_stats(struct seq_file *s, int lmac_id)
 {
 	struct cgx_link_user_info linfo;
-	struct cgx_mac_ops *mac_ops;
+	struct mac_ops *mac_ops;
 	void *cgxd = s->private;
 	u64 ucast, mcast, bcast;
 	int stat = 0, err = 0;
@@ -1037,7 +1038,7 @@ static int cgx_print_stats(struct seq_file *s, int lmac_id)
 	if (!rvu)
 		return -ENODEV;
 
-	mac_ops = cgx_get_mac_ops(cgxd);
+	mac_ops = get_mac_ops(cgxd);
 	/* There can be no CGX devices at all */
 	if (!mac_ops)
 		return 0;
@@ -2201,7 +2202,7 @@ static void rvu_dbg_nix_init(struct rvu *rvu, int blkaddr)
 static void rvu_dbg_cgx_init(struct rvu *rvu)
 {
 	const struct device *dev = &rvu->pdev->dev;
-	struct cgx_mac_ops *mac_ops;
+	struct mac_ops *mac_ops;
 	unsigned long lmac_bmap;
 	int rvu_def_cgx_id = 0;
 	struct dentry *pfile;
@@ -2212,7 +2213,7 @@ static void rvu_dbg_cgx_init(struct rvu *rvu)
 	if (!cgx_get_cgxcnt_max())
 		return;
 
-	mac_ops = cgx_get_mac_ops(rvu_cgx_pdata(rvu_def_cgx_id, rvu));
+	mac_ops = get_mac_ops(rvu_cgx_pdata(rvu_def_cgx_id, rvu));
 	/* There can be no CGX devices at all */
 	if (!mac_ops)
 		return;
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c
index cd5c2ad2d3d7..cef1853400cf 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c
@@ -16,6 +16,7 @@
 #include "rvu.h"
 #include "npc.h"
 #include "cgx.h"
+#include "lmac_common.h"
 #include "rvu_fixes.h"
 
 static void nix_free_tx_vtag_entries(struct rvu *rvu, u16 pcifunc);
@@ -226,7 +227,7 @@ static int nix_interface_init(struct rvu *rvu, u16 pcifunc, int type, int nixlf,
 	struct rvu_hwinfo *hw = rvu->hw;
 	struct sdp_node_info *sdp_info;
 	int pkind, pf, vf, lbkid, vfid;
-	struct cgx_mac_ops *mac_ops;
+	struct mac_ops *mac_ops;
 	u8 cgx_id, lmac_id;
 	bool from_vf;
 	int err;
@@ -259,7 +260,7 @@ static int nix_interface_init(struct rvu *rvu, u16 pcifunc, int type, int nixlf,
 			rvu_npc_set_pkind(rvu, pkind, pfvf);
 		}
 
-		mac_ops = cgx_get_mac_ops(rvu_cgx_pdata(cgx_id, rvu));
+		mac_ops = get_mac_ops(rvu_cgx_pdata(cgx_id, rvu));
 
 		/* By default we enable pause frames */
 		if ((pcifunc & RVU_PFVF_FUNC_MASK) == 0)
-- 
2.31.1

