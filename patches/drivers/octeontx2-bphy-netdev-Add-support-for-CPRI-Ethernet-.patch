From 0c7558cb6b39551761b52dafa5f51adc6e49a354 Mon Sep 17 00:00:00 2001
From: Naveen Mamindlapalli <naveenm@marvell.com>
Date: Mon, 22 Jun 2020 20:04:03 +0530
Subject: [PATCH 584/767] octeontx2-bphy-netdev: Add support for CPRI Ethernet
 packet processing

commit 40529cdad4607a7bf36c8af7bddd9f3aba4e6e39 from
git@git.assembla.com:cavium/WindRiver.linux.git

This patch adds support for processing Ethernet packets which are
received and transmitted by CPRI MHAB. The ODP BPHY application
shares the CPRI ETH UL/DL configuration information using ioctl.
The Rx packet reception notification is sent to netdev using
PSM GPINT.

Change-Id: I158dcd48771f0e9a793079954e1c3271ddd69cfc
Signed-off-by: Naveen Mamindlapalli <naveenm@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/31330
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Tested-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../ethernet/marvell/octeontx2/bphy/Makefile  |   3 +-
 .../marvell/octeontx2/bphy/otx2_bphy.h        |   5 +-
 .../marvell/octeontx2/bphy/otx2_bphy_hw.h     |  89 ++-
 .../marvell/octeontx2/bphy/otx2_bphy_main.c   |  66 +-
 .../marvell/octeontx2/bphy/otx2_cpri.c        | 604 ++++++++++++++++++
 .../marvell/octeontx2/bphy/otx2_cpri.h        | 132 ++++
 .../octeontx2/bphy/otx2_cpri_ethtool.c        | 102 +++
 .../marvell/octeontx2/bphy/otx2_rfoe.c        |  11 +-
 .../marvell/octeontx2/bphy/otx2_rfoe.h        |   2 +-
 .../octeontx2/bphy/otx2_rfoe_ethtool.c        |   2 +-
 .../octeontx2/bphy/rfoe_bphy_netdev_comm_if.h |  70 +-
 11 files changed, 1064 insertions(+), 22 deletions(-)
 create mode 100644 drivers/net/ethernet/marvell/octeontx2/bphy/otx2_cpri.c
 create mode 100644 drivers/net/ethernet/marvell/octeontx2/bphy/otx2_cpri.h
 create mode 100644 drivers/net/ethernet/marvell/octeontx2/bphy/otx2_cpri_ethtool.c

diff --git a/drivers/net/ethernet/marvell/octeontx2/bphy/Makefile b/drivers/net/ethernet/marvell/octeontx2/bphy/Makefile
index 16d661404577..ed2d966da3f1 100644
--- a/drivers/net/ethernet/marvell/octeontx2/bphy/Makefile
+++ b/drivers/net/ethernet/marvell/octeontx2/bphy/Makefile
@@ -7,4 +7,5 @@ obj-$(CONFIG_OCTEONTX2_BPHY_RFOE_NETDEV) += octeontx2_bphy_netdev.o
 
 #EXTRA_CFLAGS += -DDEBUG
 
-octeontx2_bphy_netdev-y := otx2_bphy_main.o otx2_rfoe.o otx2_rfoe_ethtool.o
+octeontx2_bphy_netdev-y := otx2_bphy_main.o otx2_rfoe.o otx2_rfoe_ethtool.o \
+				otx2_cpri.o otx2_cpri_ethtool.o
diff --git a/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_bphy.h b/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_bphy.h
index 2fb3b5ae6626..f5b4b7a9b4c5 100644
--- a/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_bphy.h
+++ b/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_bphy.h
@@ -1,5 +1,5 @@
 /* SPDX-License-Identifier: GPL-2.0
- * Marvell OcteonTx2 BPHY RFOE Ethernet Driver
+ * Marvell OcteonTx2 BPHY RFOE/CPRI Ethernet Driver
  *
  * Copyright (C) 2020 Marvell International Ltd.
  *
@@ -29,10 +29,11 @@ extern void __iomem *psm_reg_base;
 extern void __iomem *rfoe_reg_base;
 extern void __iomem *bcn_reg_base;
 extern void __iomem *ptp_reg_base;
+extern void __iomem *cpri_reg_base;
 
 #define DEVICE_NAME		"otx2_rfoe"
 #define DRV_NAME		"octeontx2-bphy-netdev"
-#define DRV_STRING		"Marvell OcteonTX2 BPHY RFOE Ethernet Driver"
+#define DRV_STRING		"Marvell OcteonTX2 BPHY Ethernet Driver"
 
 /* char device ioctl numbers */
 #define OTX2_RFOE_IOCTL_BASE		0xCC	/* Temporary */
diff --git a/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_bphy_hw.h b/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_bphy_hw.h
index a7c565cca088..efa34dee4ea8 100644
--- a/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_bphy_hw.h
+++ b/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_bphy_hw.h
@@ -1,5 +1,5 @@
 /* SPDX-License-Identifier: GPL-2.0
- * Marvell OcteonTx2 BPHY RFOE Ethernet Driver
+ * Marvell OcteonTx2 BPHY RFOE/CPRI Ethernet Driver
  *
  * Copyright (C) 2020 Marvell International Ltd.
  *
@@ -79,6 +79,68 @@
 #define CAPT_EN				BIT(0)
 #define CAPT_TRIG_SW			(3UL << 8)
 
+/* CPRI register offsets */
+#define CPRIX_RXD_GMII_UL_CBUF_CFG1(a)		(0x1000ULL | \
+						 ((unsigned long)(a) << 36))
+#define CPRIX_RXD_GMII_UL_CBUF_CFG2(a)		(0x1008ULL | \
+						 ((unsigned long)(a) << 36))
+#define CPRIX_RXD_GMII_UL_RD_DOORBELL(a)	(0x1010ULL | \
+						 ((unsigned long)(a) << 36))
+#define CPRIX_RXD_GMII_UL_SW_RD_PTR(a)		(0x1018ULL | \
+						 ((unsigned long)(a) << 36))
+#define CPRIX_RXD_GMII_UL_NXT_WR_PTR(a)		(0x1020ULL | \
+						 ((unsigned long)(a) << 36))
+#define CPRIX_RXD_GMII_UL_PKT_COUNT(a)		(0x1028ULL | \
+						 ((unsigned long)(a) << 36))
+#define CPRIX_TXD_GMII_DL_CBUF_CFG1(a)		(0x1100ULL | \
+						 ((unsigned long)(a) << 36))
+#define CPRIX_TXD_GMII_DL_CBUF_CFG2(a)		(0x1108ULL | \
+						 ((unsigned long)(a) << 36))
+#define CPRIX_TXD_GMII_DL_WR_DOORBELL(a)	(0x1110ULL | \
+						 ((unsigned long)(a) << 36))
+#define CPRIX_TXD_GMII_DL_SW_WR_PTR(a)		(0x1118ULL | \
+						 ((unsigned long)(a) << 36))
+#define CPRIX_TXD_GMII_DL_NXT_RD_PTR(a)		(0x1120ULL | \
+						 ((unsigned long)(a) << 36))
+#define CPRIX_ETH_UL_INT(a)			(0x280ULL | \
+						 ((unsigned long)(a) << 36))
+#define CPRIX_ETH_UL_INT_ENA_W1S(a)		(0x288ULL | \
+						 ((unsigned long)(a) << 36))
+#define CPRIX_ETH_UL_INT_ENA_W1C(a)		(0x290ULL | \
+						 ((unsigned long)(a) << 36))
+#define CPRIX_ETH_UL_INT_W1S(a)			(0x298ULL | \
+						 ((unsigned long)(a) << 36))
+#define CPRIX_ETH_BAD_CRC_CNT(a, b)		(0x400ULL | \
+						 ((unsigned long)(a) << 36) | \
+						 ((unsigned long)(b) << 11))
+#define CPRIX_ETH_UL_ERR_CNT(a, b)		(0x408ULL | \
+						 ((unsigned long)(a) << 36) | \
+						 ((unsigned long)(b) << 11))
+#define CPRIX_ETH_UL_OSIZE_CNT(a, b)		(0x410ULL | \
+						 ((unsigned long)(a) << 36) | \
+						 ((unsigned long)(b) << 11))
+#define CPRIX_ETH_UL_USIZE_CNT(a, b)		(0x418ULL | \
+						 ((unsigned long)(a) << 36) | \
+						 ((unsigned long)(b) << 11))
+#define CPRIX_ETH_UL_FIFO_ORUN_CNT(a, b)	(0x420ULL | \
+						 ((unsigned long)(a) << 36) | \
+						 ((unsigned long)(b) << 11))
+#define CPRIX_ETH_UL_GPKTS_CNT(a, b)		(0x428ULL | \
+						 ((unsigned long)(a) << 36) | \
+						 ((unsigned long)(b) << 11))
+#define CPRIX_ETH_UL_BOCT_CNT(a, b)		(0x430ULL | \
+						 ((unsigned long)(a) << 36) | \
+						 ((unsigned long)(b) << 11))
+#define CPRIX_ETH_UL_GOCT_CNT(a, b)		(0x438ULL | \
+						 ((unsigned long)(a) << 36) | \
+						 ((unsigned long)(b) << 11))
+#define CPRIX_ETH_DL_GOCTETS_CNT(a, b)		(0x440ULL | \
+						 ((unsigned long)(a) << 36) | \
+						 ((unsigned long)(b) << 11))
+#define CPRIX_ETH_DL_GPKTS_CNT(a, b)		(0x448ULL | \
+						 ((unsigned long)(a) << 36) | \
+						 ((unsigned long)(b) << 11))
+
 /* MHAB definitions */
 struct mhbw_jd_dma_cfg_word_0_s {
 	u64 dma_mode		: 3;
@@ -273,4 +335,29 @@ struct mhab_job_desc_cfg {
 	struct rfoex_abx_slotx_configuration2 cfg2;
 } __packed;
 
+/* CPRI definitions */
+struct cpri_pkt_dl_wqe_hdr {
+	u64 lane_id		: 2;
+	u64 reserved1		: 2;
+	u64 mhab_id		: 2;
+	u64 reserved2		: 2;
+	u64 pkt_length		: 11;
+	u64 reserved3		: 45;
+	u64 w1;
+};
+
+struct cpri_pkt_ul_wqe_hdr {
+	u64 lane_id		: 2;
+	u64 reserved1		: 2;
+	u64 mhab_id		: 2;
+	u64 reserved2		: 2;
+	u64 pkt_length		: 11;
+	u64 reserved3		: 5;
+	u64 fcserr		: 1;
+	u64 rsp_ferr		: 1;
+	u64 rsp_nferr		: 1;
+	u64 reserved4		: 37;
+	u64 w1;
+};
+
 #endif	/* _OTX2_BPHY_HW_H_ */
diff --git a/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_bphy_main.c b/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_bphy_main.c
index c3fd0ded4266..3fa6afe74cdc 100644
--- a/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_bphy_main.c
+++ b/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_bphy_main.c
@@ -1,5 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0
-/* Marvell OcteonTx2 BPHY RFOE Ethernet Driver
+/* Marvell OcteonTx2 BPHY RFOE/CPRI Ethernet Driver
  *
  * Copyright (C) 2020 Marvell International Ltd.
  *
@@ -17,6 +17,7 @@
 
 #include "otx2_bphy.h"
 #include "otx2_rfoe.h"
+#include "otx2_cpri.h"
 
 MODULE_AUTHOR("Marvell International Ltd.");
 MODULE_DESCRIPTION(DRV_STRING);
@@ -36,6 +37,7 @@ void __iomem *psm_reg_base;
 void __iomem *rfoe_reg_base;
 void __iomem *bcn_reg_base;
 void __iomem *ptp_reg_base;
+void __iomem *cpri_reg_base;
 
 /* GPINT(1) interrupt handler routine */
 static irqreturn_t otx2_bphy_intr_handler(int irq, void *dev_id)
@@ -43,8 +45,8 @@ static irqreturn_t otx2_bphy_intr_handler(int irq, void *dev_id)
 	struct otx2_rfoe_drv_ctx *drv_ctx;
 	struct otx2_rfoe_ndev_priv *priv;
 	struct net_device *netdev;
+	int rfoe_num, cpri_num, i;
 	u32 intr_mask, status;
-	int rfoe_num, i;
 
 	/* clear interrupt status */
 	status = readq(bphy_reg_base + PSM_INT_GP_SUM_W1C(1)) & 0xFFFFFFFF;
@@ -58,6 +60,15 @@ static irqreturn_t otx2_bphy_intr_handler(int irq, void *dev_id)
 			otx2_rfoe_rx_napi_schedule(rfoe_num, status);
 	}
 
+	for (cpri_num = 0; cpri_num < OTX2_BPHY_CPRI_MAX_MHAB; cpri_num++) {
+		intr_mask = CPRI_RX_INTR_MASK(cpri_num);
+		if (status & intr_mask) {
+			/* clear UL ETH interrupt */
+			writeq(0x1, cpri_reg_base + CPRIX_ETH_UL_INT(cpri_num));
+			otx2_cpri_rx_napi_schedule(cpri_num, status);
+		}
+	}
+
 	/* tx intr processing */
 	for (i = 0; i < RFOE_MAX_INTF; i++) {
 		drv_ctx = &rfoe_drv_ctx[i];
@@ -90,7 +101,8 @@ static long otx2_bphy_cdev_ioctl(struct file *filp, unsigned int cmd,
 	switch (cmd) {
 	case OTX2_RFOE_IOCTL_ODP_INTF_CFG:
 	{
-		struct bphy_netdev_comm_intf_cfg intf_cfg[MAX_RFOE_INTF];
+		struct bphy_netdev_comm_intf_cfg *intf_cfg;
+		int idx;
 
 		if (cdev->odp_intf_cfg) {
 			dev_info(cdev->dev, "odp interface cfg already done\n");
@@ -98,7 +110,14 @@ static long otx2_bphy_cdev_ioctl(struct file *filp, unsigned int cmd,
 			goto out;
 		}
 
-		if (copy_from_user(&intf_cfg, (void __user *)arg,
+		intf_cfg = kzalloc(MAX_RFOE_INTF * sizeof(*intf_cfg),
+				   GFP_KERNEL);
+		if (!intf_cfg) {
+			ret = -ENOMEM;
+			goto out;
+		}
+
+		if (copy_from_user(intf_cfg, (void __user *)arg,
 				   (MAX_RFOE_INTF *
 				   sizeof(struct bphy_netdev_comm_intf_cfg)))) {
 			dev_err(cdev->dev, "copy from user fault\n");
@@ -106,23 +125,39 @@ static long otx2_bphy_cdev_ioctl(struct file *filp, unsigned int cmd,
 			goto out;
 		}
 
-		ret = otx2_rfoe_parse_and_init_intf(cdev, &intf_cfg[0]);
+		ret = otx2_rfoe_parse_and_init_intf(cdev, intf_cfg);
+		if (ret < 0) {
+			dev_err(cdev->dev, "odp <-> netdev parse error\n");
+			goto out;
+		}
+
+		ret = otx2_cpri_parse_and_init_intf(cdev, intf_cfg);
 		if (ret < 0) {
 			dev_err(cdev->dev, "odp <-> netdev parse error\n");
 			goto out;
 		}
 
+		/* Enable CPRI ETH UL INT */
+		for (idx = 0; idx < OTX2_BPHY_CPRI_MAX_MHAB; idx++) {
+			if (intf_cfg[idx].if_type == IF_TYPE_CPRI)
+				writeq(0x1, cpri_reg_base +
+				       CPRIX_ETH_UL_INT_ENA_W1S(idx));
+		}
+
 		/* Enable GPINT Rx and Tx interrupts */
 		writeq(0xFFFFFFFF, bphy_reg_base + PSM_INT_GP_ENA_W1S(1));
 
 		cdev->odp_intf_cfg = 1;
 
+		kfree(intf_cfg);
+
 		ret = 0;
 		goto out;
 	}
 	case OTX2_RFOE_IOCTL_ODP_DEINIT:
 	{
 		otx2_bphy_rfoe_cleanup();
+		otx2_bphy_cpri_cleanup();
 
 		/* Disable GPINT Rx and Tx interrupts */
 		writeq(0xFFFFFFFF,
@@ -320,6 +355,7 @@ static int otx2_bphy_cdev_release(struct inode *inode, struct file *filp)
 		goto cdev_release_exit;
 
 	otx2_bphy_rfoe_cleanup();
+	otx2_bphy_cpri_cleanup();
 
 	/* Disable GPINT Rx and Tx interrupts */
 	writeq(0xFFFFFFFF, bphy_reg_base + PSM_INT_GP_ENA_W1C(1));
@@ -442,18 +478,31 @@ static int otx2_bphy_probe(struct platform_device *pdev)
 		err = PTR_ERR(ptp_reg_base);
 		goto out_unmap_bcn_reg;
 	}
+	/* cpri registers ioremap */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 5);
+	if (!res) {
+		dev_err(&pdev->dev, "failed to get cpri resource\n");
+		err = -ENXIO;
+		goto out_unmap_ptp_reg;
+	}
+	cpri_reg_base = ioremap_nocache(res->start, resource_size(res));
+	if (IS_ERR(cpri_reg_base)) {
+		dev_err(&pdev->dev, "failed to ioremap cpri registers\n");
+		err = PTR_ERR(cpri_reg_base);
+		goto out_unmap_ptp_reg;
+	}
 	/* get irq */
 	cdev_priv->irq = platform_get_irq(pdev, 0);
 	if (cdev_priv->irq <= 0) {
 		dev_err(&pdev->dev, "irq resource not found\n");
-		goto out_unmap_ptp_reg;
+		goto out_unmap_cpri_reg;
 	}
 
 	/* create a character device */
 	err = alloc_chrdev_region(&devt, 0, 1, DEVICE_NAME);
 	if (err < 0) {
 		dev_err(&pdev->dev, "failed to alloc chrdev device region\n");
-		goto out_unmap_ptp_reg;
+		goto out_unmap_cpri_reg;
 	}
 
 	otx2rfoe_class = class_create(THIS_MODULE, DEVICE_NAME);
@@ -507,6 +556,8 @@ static int otx2_bphy_probe(struct platform_device *pdev)
 	class_destroy(otx2rfoe_class);
 out_unregister_chrdev_region:
 	unregister_chrdev_region(devt, 1);
+out_unmap_cpri_reg:
+	iounmap(cpri_reg_base);
 out_unmap_ptp_reg:
 	iounmap(ptp_reg_base);
 out_unmap_bcn_reg:
@@ -528,6 +579,7 @@ static int otx2_bphy_remove(struct platform_device *pdev)
 	struct otx2_bphy_cdev_priv *cdev_priv = dev_get_drvdata(&pdev->dev);
 
 	/* unmap register regions */
+	iounmap(cpri_reg_base);
 	iounmap(ptp_reg_base);
 	iounmap(bcn_reg_base);
 	iounmap(rfoe_reg_base);
diff --git a/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_cpri.c b/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_cpri.c
new file mode 100644
index 000000000000..0c8bac936005
--- /dev/null
+++ b/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_cpri.c
@@ -0,0 +1,604 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Marvell OcteonTx2 BPHY RFOE/CPRI Ethernet Driver
+ *
+ * Copyright (C) 2020 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "otx2_cpri.h"
+
+/*	Theory of Operation
+ *
+ *	I.   General
+ *
+ *	The BPHY CPRI netdev processes ethernet packets which are received
+ *	and transmitted by CPRI MHAB. The ODP BPHY application shares the
+ *	CPRI ETH UL/DL configuration information using ioctl. The Rx
+ *	notification is sent to netdev using PSM GPINT.
+ *
+ *	II.  Driver Operation
+ *
+ *	This driver register's a character device and provides ioctl for
+ *	ODP application to initialize the netdev(s) to process CPRI Ethernet
+ *	packets. Each netdev instance created by the driver corresponds to
+ *	a unique CPRI MHAB id and Lane id. The ODP application shares the
+ *	information such as CPRI ETH UL/DL circular buffers and Rx GPINT
+ *	number per CPRI MHAB. The CPRI ETH UL/DL circular buffers are shared
+ *	per each CPRI MHAB id. The Rx/Tx packet memory(DDR) is also allocated
+ *	by ODP application. The GPINT is setup using CPRI_ETH_UL_INT_PSM_MSG_W0
+ *	and CPRI_ETH_UL_INT_PSM_MSG_W1 registers.
+ *
+ *	III. Transmit
+ *
+ *	The driver xmit routine selects DL circular buffer ring based on MHAB
+ *	id and if there is a free entry available, the driver updates the WQE
+ *	header and packet data to the DL entry and updates the DL_WR_DOORBELL
+ *	with number of packets written for the hardware to process.
+ *
+ *	IV.  Receive
+ *
+ *	The driver receives GPINT interrupt notification per each MHAB and
+ *	invokes NAPI handler. The NAPI handler reads the UL circular buffer
+ *	ring parameters UL_SW_RD_PTR and UL_NXT_WR_PTR to get the count of
+ *	packets to be processed. For each packet received, the driver allocates
+ *	skb and copies the packet data to skb. The driver updates
+ *	UL_RD_DOORBELL register with count of packets processed by the driver.
+ *
+ *	V.   Miscellaneous
+ *
+ *	Ethtool:
+ *	The ethtool stats shows packet stats for each netdev instance.
+ *
+ */
+
+/* global driver ctx */
+struct otx2_cpri_drv_ctx cpri_drv_ctx[OTX2_BPHY_CPRI_MAX_INTF];
+
+struct net_device *otx2_cpri_get_netdev(int mhab_id, int lmac_id)
+{
+	struct net_device *netdev = NULL;
+	int idx;
+
+	for (idx = 0; idx < OTX2_BPHY_CPRI_MAX_INTF; idx++) {
+		if (cpri_drv_ctx[idx].cpri_num == mhab_id &&
+		    cpri_drv_ctx[idx].lmac_id == lmac_id &&
+		    cpri_drv_ctx[idx].valid) {
+			netdev = cpri_drv_ctx[idx].netdev;
+			break;
+		}
+	}
+
+	return netdev;
+}
+
+void otx2_bphy_cpri_cleanup(void)
+{
+	struct otx2_cpri_drv_ctx *drv_ctx = NULL;
+	struct otx2_cpri_ndev_priv *priv;
+	struct net_device *netdev;
+	int i;
+
+	for (i = 0; i < OTX2_BPHY_CPRI_MAX_INTF; i++) {
+		drv_ctx = &cpri_drv_ctx[i];
+		if (drv_ctx->valid) {
+			netdev = drv_ctx->netdev;
+			priv = netdev_priv(netdev);
+			if (drv_ctx->netdev_registered)
+				unregister_netdev(netdev);
+			netif_napi_del(&priv->napi);
+			kfree(priv->cpri_common);
+			free_netdev(netdev);
+			drv_ctx->valid = 0;
+		}
+	}
+
+	/* Disable CPRI ETH UL INT */
+	for (i = 0; i < OTX2_BPHY_CPRI_MAX_MHAB; i++)
+		writeq(0x1, cpri_reg_base +
+		       CPRIX_ETH_UL_INT_ENA_W1C(i));
+}
+
+static int otx2_cpri_process_rx_pkts(struct otx2_cpri_ndev_priv *priv,
+				     int budget)
+{
+	int count, head, processed_pkts = 0;
+	struct otx2_cpri_ndev_priv *priv2;
+	struct cpri_pkt_ul_wqe_hdr *wqe;
+	struct ul_cbuf_cfg *ul_cfg;
+	u16 sw_rd_ptr, nxt_wr_ptr;
+	struct net_device *netdev;
+	struct sk_buff *skb;
+	u8 *pkt_buf;
+	u16 len;
+
+	ul_cfg = &priv->cpri_common->ul_cfg;
+
+	sw_rd_ptr = readq(priv->cpri_reg_base +
+			  CPRIX_RXD_GMII_UL_SW_RD_PTR(priv->cpri_num)) & 0xFFFF;
+	nxt_wr_ptr = readq(priv->cpri_reg_base +
+			   CPRIX_RXD_GMII_UL_NXT_WR_PTR(priv->cpri_num)) &
+			0xFFFF;
+	/* get the HW head */
+	head = CIRC_BUF_ENTRY(nxt_wr_ptr);
+
+	if (ul_cfg->sw_rd_ptr > head) {
+		count = ul_cfg->num_entries - ul_cfg->sw_rd_ptr;
+		count += head;
+	} else {
+		count = head - ul_cfg->sw_rd_ptr;
+	}
+
+	while (likely((processed_pkts < budget) && (processed_pkts < count))) {
+		pkt_buf = (u8 *)ul_cfg->cbuf_virt_addr +
+			  (OTX2_BPHY_CPRI_PKT_BUF_SIZE * ul_cfg->sw_rd_ptr);
+		wqe = (struct cpri_pkt_ul_wqe_hdr *)pkt_buf;
+		netdev = otx2_cpri_get_netdev(wqe->mhab_id, wqe->lane_id);
+		if (unlikely(!netdev)) {
+			pr_err("CPRI Rx netdev not found, cpri%d lmac%d\n",
+			       wqe->mhab_id, wqe->lane_id);
+			priv->stats.rx_dropped++;
+			processed_pkts++;
+			continue;
+		}
+		priv2 = netdev_priv(netdev);
+		if (wqe->fcserr || wqe->rsp_ferr || wqe->rsp_nferr) {
+			netif_err(priv2, rx_err, netdev,
+				  "CPRI Rx err,cpri%d lmac%d sw_rd_ptr=%d\n",
+				  wqe->mhab_id, wqe->lane_id,
+				  ul_cfg->sw_rd_ptr);
+			priv2->stats.rx_dropped++;
+			processed_pkts++;
+			continue;
+		}
+		if (unlikely(!netif_carrier_ok(netdev))) {
+			netif_err(priv2, rx_err, netdev,
+				  "%s {cpri%d lmac%d} link down, drop pkt\n",
+				  netdev->name, priv2->cpri_num,
+				  priv2->lmac_id);
+			priv2->stats.rx_dropped++;
+			processed_pkts++;
+			continue;
+		}
+
+		len = wqe->pkt_length;
+
+		if (unlikely(netif_msg_pktdata(priv2))) {
+			netdev_printk(KERN_DEBUG, priv2->netdev, "RX DATA:");
+			print_hex_dump(KERN_DEBUG, "", DUMP_PREFIX_OFFSET, 16,
+				       4, pkt_buf,
+				       len + OTX2_BPHY_CPRI_WQE_SIZE, true);
+		}
+
+		pkt_buf += OTX2_BPHY_CPRI_WQE_SIZE;
+
+		skb = netdev_alloc_skb_ip_align(netdev, len);
+		if (!skb) {
+			netif_err(priv2, rx_err, netdev,
+				  "CPRI Rx: alloc skb failed\n");
+			priv->stats.rx_dropped++;
+			processed_pkts++;
+			continue;
+		}
+
+		memcpy(skb->data, pkt_buf, len);
+		skb_put(skb, len);
+		skb->protocol = eth_type_trans(skb, netdev);
+
+		netif_receive_skb(skb);
+
+		processed_pkts++;
+		ul_cfg->sw_rd_ptr++;
+		if (ul_cfg->sw_rd_ptr == ul_cfg->num_entries)
+			ul_cfg->sw_rd_ptr = 0;
+	}
+
+	if (processed_pkts)
+		writeq(processed_pkts, priv->cpri_reg_base +
+		       CPRIX_RXD_GMII_UL_RD_DOORBELL(priv->cpri_num));
+
+	return processed_pkts;
+}
+
+/* napi poll routine */
+static int otx2_cpri_napi_poll(struct napi_struct *napi, int budget)
+{
+	struct otx2_bphy_cdev_priv *cdev_priv;
+	struct otx2_cpri_ndev_priv *priv;
+	u64 intr_en, regval;
+	int workdone = 0;
+
+	priv = container_of(napi, struct otx2_cpri_ndev_priv, napi);
+	cdev_priv = priv->cdev_priv;
+
+	/* pkt processing loop */
+	workdone += otx2_cpri_process_rx_pkts(priv, budget);
+
+	if (workdone < budget) {
+		napi_complete_done(napi, workdone);
+
+		/* Re enable the Rx interrupts */
+		intr_en = 1 << CPRI_RX_INTR_SHIFT(priv->cpri_num);
+		spin_lock(&cdev_priv->lock);
+		regval = readq(priv->bphy_reg_base + PSM_INT_GP_ENA_W1S(1));
+		regval |= intr_en;
+		writeq(regval, priv->bphy_reg_base + PSM_INT_GP_ENA_W1S(1));
+		spin_unlock(&cdev_priv->lock);
+	}
+
+	return workdone;
+}
+
+void otx2_cpri_rx_napi_schedule(int cpri_num, u32 status)
+{
+	struct otx2_cpri_drv_ctx *drv_ctx;
+	struct otx2_cpri_ndev_priv *priv;
+	u64 regval;
+	int idx;
+
+	for (idx = 0; idx < OTX2_BPHY_CPRI_MAX_INTF; idx++) {
+		drv_ctx = &cpri_drv_ctx[idx];
+		/* ignore lmac, one UL interrupt/cpri */
+		if (!(drv_ctx->valid && drv_ctx->cpri_num == cpri_num))
+			continue;
+		/* check if i/f down, napi disabled */
+		priv = netdev_priv(drv_ctx->netdev);
+		if (test_bit(CPRI_INTF_DOWN, &priv->state))
+			continue;
+		/* clear intr enable bit, re-enable in napi handler */
+		regval = 1 << CPRI_RX_INTR_SHIFT(cpri_num);
+		writeq(regval, priv->bphy_reg_base + PSM_INT_GP_ENA_W1C(1));
+		/* schedule napi */
+		napi_schedule(&priv->napi);
+		/* napi scheduled per MHAB, return */
+		return;
+	}
+}
+
+void otx2_cpri_update_stats(struct otx2_cpri_ndev_priv *priv)
+{
+	struct otx2_cpri_stats *dev_stats = &priv->stats;
+
+	dev_stats->rx_frames += readq(priv->cpri_reg_base +
+				      CPRIX_ETH_UL_GPKTS_CNT(priv->cpri_num,
+							     priv->lmac_id));
+	dev_stats->rx_octets += readq(priv->cpri_reg_base +
+				      CPRIX_ETH_UL_GOCT_CNT(priv->cpri_num,
+							    priv->lmac_id));
+	dev_stats->rx_err += readq(priv->cpri_reg_base +
+				      CPRIX_ETH_UL_ERR_CNT(priv->cpri_num,
+							   priv->lmac_id));
+	dev_stats->bad_crc += readq(priv->cpri_reg_base +
+				    CPRIX_ETH_BAD_CRC_CNT(priv->cpri_num,
+							  priv->lmac_id));
+	dev_stats->oversize += readq(priv->cpri_reg_base +
+				     CPRIX_ETH_UL_OSIZE_CNT(priv->cpri_num,
+							    priv->lmac_id));
+	dev_stats->undersize += readq(priv->cpri_reg_base +
+				      CPRIX_ETH_UL_USIZE_CNT(priv->cpri_num,
+							     priv->lmac_id));
+	dev_stats->fifo_ovr += readq(priv->cpri_reg_base +
+				     CPRIX_ETH_UL_FIFO_ORUN_CNT(priv->cpri_num,
+								priv->lmac_id));
+	dev_stats->tx_frames += readq(priv->cpri_reg_base +
+				      CPRIX_ETH_DL_GPKTS_CNT(priv->cpri_num,
+							     priv->lmac_id));
+	dev_stats->tx_octets += readq(priv->cpri_reg_base +
+				      CPRIX_ETH_DL_GOCTETS_CNT(priv->cpri_num,
+							       priv->lmac_id));
+}
+
+static void otx2_cpri_get_stats64(struct net_device *netdev,
+				  struct rtnl_link_stats64 *stats)
+{
+	struct otx2_cpri_ndev_priv *priv = netdev_priv(netdev);
+	struct otx2_cpri_stats *dev_stats = &priv->stats;
+
+	otx2_cpri_update_stats(priv);
+
+	stats->rx_bytes = dev_stats->rx_octets;
+	stats->rx_packets = dev_stats->rx_frames;
+	stats->rx_dropped = dev_stats->rx_dropped;
+	stats->rx_errors = dev_stats->rx_err;
+	stats->rx_crc_errors = dev_stats->bad_crc;
+	stats->rx_fifo_errors = dev_stats->fifo_ovr;
+	stats->rx_length_errors = dev_stats->oversize + dev_stats->undersize;
+
+	stats->tx_bytes = dev_stats->tx_octets;
+	stats->tx_packets = dev_stats->tx_frames;
+}
+
+/* netdev ioctl */
+static int otx2_cpri_ioctl(struct net_device *netdev, struct ifreq *req,
+			   int cmd)
+{
+	return -EOPNOTSUPP;
+}
+
+/* netdev xmit */
+static netdev_tx_t otx2_cpri_eth_start_xmit(struct sk_buff *skb,
+					    struct net_device *netdev)
+{
+	struct otx2_cpri_ndev_priv *priv = netdev_priv(netdev);
+	struct cpri_pkt_dl_wqe_hdr *wqe;
+	struct dl_cbuf_cfg *dl_cfg;
+	unsigned long flags;
+	u8 *buf_ptr;
+	int tail, count;
+	u16 nxt_rd_ptr;
+
+	dl_cfg = &priv->cpri_common->dl_cfg;
+
+	spin_lock_irqsave(&dl_cfg->lock, flags);
+
+	if (unlikely(!netif_carrier_ok(netdev))) {
+		/* update stats */
+		priv->stats.tx_dropped++;
+		goto exit;
+	}
+
+	/* Read CPRI(0..2)_TXD_GMII_DL_WR_DOORBELL to become 0 */
+	while ((readq(priv->cpri_reg_base +
+		      CPRIX_TXD_GMII_DL_WR_DOORBELL(priv->cpri_num)) & 0xFF))
+		cpu_relax();
+
+	nxt_rd_ptr = readq(priv->cpri_reg_base +
+			   CPRIX_TXD_GMII_DL_NXT_RD_PTR(priv->cpri_num)) &
+			0xFFFF;
+	/* get the HW tail */
+	tail = CIRC_BUF_ENTRY(nxt_rd_ptr);
+	if (dl_cfg->sw_wr_ptr >= tail)
+		count = dl_cfg->num_entries - dl_cfg->sw_wr_ptr + tail;
+	else
+		count = tail - dl_cfg->sw_wr_ptr;
+
+	if (count == 0) {
+		spin_unlock_irqrestore(&dl_cfg->lock, flags);
+		return NETDEV_TX_BUSY;
+	}
+
+	if (unlikely(netif_msg_pktdata(priv))) {
+		netdev_printk(KERN_DEBUG, priv->netdev, "Tx: skb %pS len=%d\n",
+			      skb, skb->len);
+		print_hex_dump(KERN_DEBUG, "", DUMP_PREFIX_OFFSET, 16, 4,
+			       skb->data, skb->len, true);
+	}
+
+	buf_ptr = (u8 *)dl_cfg->cbuf_virt_addr +
+		  (OTX2_BPHY_CPRI_PKT_BUF_SIZE * dl_cfg->sw_wr_ptr);
+	wqe = (struct cpri_pkt_dl_wqe_hdr *)buf_ptr;
+	wqe->mhab_id = priv->cpri_num;
+	wqe->lane_id = priv->lmac_id;
+	buf_ptr += OTX2_BPHY_CPRI_WQE_SIZE;
+	memcpy(buf_ptr, skb->data, skb->len);
+	wqe->pkt_length = skb->len;
+
+	/* ensure the memory is updated before ringing doorbell */
+	dma_wmb();
+	writeq(1, priv->cpri_reg_base +
+	       CPRIX_TXD_GMII_DL_WR_DOORBELL(priv->cpri_num));
+
+	/* increment queue index */
+	dl_cfg->sw_wr_ptr++;
+	if (dl_cfg->sw_wr_ptr == dl_cfg->num_entries)
+		dl_cfg->sw_wr_ptr = 0;
+exit:
+	dev_kfree_skb_any(skb);
+	spin_unlock_irqrestore(&dl_cfg->lock, flags);
+
+	return NETDEV_TX_OK;
+}
+
+/* netdev open */
+static int otx2_cpri_eth_open(struct net_device *netdev)
+{
+	struct otx2_cpri_ndev_priv *priv = netdev_priv(netdev);
+
+	napi_enable(&priv->napi);
+
+	netif_carrier_on(netdev);
+	netif_start_queue(netdev);
+
+	clear_bit(CPRI_INTF_DOWN, &priv->state);
+
+	return 0;
+}
+
+/* netdev close */
+static int otx2_cpri_eth_stop(struct net_device *netdev)
+{
+	struct otx2_cpri_ndev_priv *priv = netdev_priv(netdev);
+
+	if (test_and_set_bit(CPRI_INTF_DOWN, &priv->state))
+		return 0;
+
+	netif_stop_queue(netdev);
+	netif_carrier_off(netdev);
+
+	napi_disable(&priv->napi);
+
+	return 0;
+}
+
+static const struct net_device_ops otx2_cpri_netdev_ops = {
+	.ndo_open		= otx2_cpri_eth_open,
+	.ndo_stop		= otx2_cpri_eth_stop,
+	.ndo_start_xmit		= otx2_cpri_eth_start_xmit,
+	.ndo_do_ioctl		= otx2_cpri_ioctl,
+	.ndo_set_mac_address	= eth_mac_addr,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_get_stats64	= otx2_cpri_get_stats64,
+};
+
+static void otx2_cpri_dump_ul_cbuf(struct otx2_cpri_ndev_priv *priv)
+{
+	struct ul_cbuf_cfg *ul_cfg = &priv->cpri_common->ul_cfg;
+
+	pr_debug("%s: num_entries=%d iova=0x%llx\n",
+		 __func__, ul_cfg->num_entries, ul_cfg->cbuf_iova_addr);
+}
+
+static void otx2_cpri_dump_dl_cbuf(struct otx2_cpri_ndev_priv *priv)
+{
+	struct dl_cbuf_cfg *dl_cfg = &priv->cpri_common->dl_cfg;
+
+	pr_debug("%s: num_entries=%d iova=0x%llx\n",
+		 __func__, dl_cfg->num_entries, dl_cfg->cbuf_iova_addr);
+}
+
+static void otx2_cpri_fill_dl_ul_cfg(struct otx2_cpri_ndev_priv *priv,
+				     struct bphy_netdev_cpri_if *cpri_cfg)
+{
+	struct dl_cbuf_cfg *dl_cfg;
+	struct ul_cbuf_cfg *ul_cfg;
+	u64 iova;
+
+	dl_cfg = &priv->cpri_common->dl_cfg;
+	dl_cfg->num_entries = cpri_cfg->num_dl_buf;
+	iova = cpri_cfg->dl_buf_iova_addr;
+	dl_cfg->cbuf_iova_addr = iova;
+	dl_cfg->cbuf_virt_addr = otx2_iova_to_virt(priv->iommu_domain, iova);
+	dl_cfg->sw_wr_ptr = 0;
+	spin_lock_init(&dl_cfg->lock);
+	otx2_cpri_dump_dl_cbuf(priv);
+
+	ul_cfg = &priv->cpri_common->ul_cfg;
+	ul_cfg->num_entries = cpri_cfg->num_ul_buf;
+	iova = cpri_cfg->ul_buf_iova_addr;
+	ul_cfg->cbuf_iova_addr = iova;
+	ul_cfg->cbuf_virt_addr = otx2_iova_to_virt(priv->iommu_domain, iova);
+	ul_cfg->sw_rd_ptr = 0;
+	spin_lock_init(&ul_cfg->lock);
+	otx2_cpri_dump_ul_cbuf(priv);
+}
+
+int otx2_cpri_parse_and_init_intf(struct otx2_bphy_cdev_priv *cdev,
+				  struct bphy_netdev_comm_intf_cfg *cfg)
+{
+	struct otx2_cpri_drv_ctx *drv_ctx = NULL;
+	struct otx2_cpri_ndev_priv *priv, *priv2;
+	struct bphy_netdev_cpri_if *cpri_cfg;
+	int i, intf_idx = 0, lmac, ret;
+	struct net_device *netdev;
+	int netdev_registered;
+
+	for (i = 0; i < OTX2_BPHY_CPRI_MAX_MHAB; i++) {
+		priv2 = NULL;
+		cpri_cfg = &cfg[i].cpri_if_cfg;
+		for (lmac = 0; lmac < OTX2_BPHY_CPRI_MAX_LMAC; lmac++) {
+			if (!(cpri_cfg->active_lane_mask & (1 << lmac)))
+				continue;
+			netdev_registered = 0;
+			netdev =
+			    alloc_etherdev(sizeof(struct otx2_cpri_ndev_priv));
+			if (!netdev) {
+				dev_err(cdev->dev,
+					"error allocating net device\n");
+				ret = -ENOMEM;
+				goto err_exit;
+			}
+			priv = netdev_priv(netdev);
+			memset(priv, 0, sizeof(*priv));
+			if (!priv2) {
+				priv->cpri_common =
+					kzalloc(sizeof(struct cpri_common_cfg),
+						GFP_KERNEL);
+				if (!priv->cpri_common) {
+					dev_err(cdev->dev, "kzalloc failed\n");
+					free_netdev(netdev);
+					ret = -ENOMEM;
+					goto err_exit;
+				}
+			}
+			spin_lock_init(&priv->lock);
+			priv->netdev = netdev;
+			priv->cdev_priv = cdev;
+			priv->msg_enable = netif_msg_init(-1, 0);
+			spin_lock_init(&priv->stats.lock);
+			priv->cpri_num = cpri_cfg->id;
+			priv->lmac_id = lmac;
+			memcpy(priv->mac_addr, &cpri_cfg->eth_addr[lmac],
+			       ETH_ALEN);
+			if (is_valid_ether_addr(priv->mac_addr))
+				ether_addr_copy(netdev->dev_addr,
+						priv->mac_addr);
+			else
+				random_ether_addr(netdev->dev_addr);
+			priv->pdev = pci_get_device(OTX2_BPHY_PCI_VENDOR_ID,
+						    OTX2_BPHY_PCI_DEVICE_ID,
+						    NULL);
+			priv->iommu_domain =
+				iommu_get_domain_for_dev(&priv->pdev->dev);
+			priv->bphy_reg_base = bphy_reg_base;
+			priv->cpri_reg_base = cpri_reg_base;
+
+			if (!priv2) {
+				otx2_cpri_fill_dl_ul_cfg(priv, cpri_cfg);
+			} else {
+				/* share cpri_common data */
+				priv->cpri_common = priv2->cpri_common;
+			}
+
+			netif_napi_add(priv->netdev, &priv->napi,
+				       otx2_cpri_napi_poll, NAPI_POLL_WEIGHT);
+
+			/* keep last (cpri + lmac) priv structure */
+			if (!priv2)
+				priv2 = priv;
+
+			intf_idx = (i * 4) + lmac;
+			snprintf(netdev->name, sizeof(netdev->name),
+				 "cpri%d", intf_idx);
+			netdev->netdev_ops = &otx2_cpri_netdev_ops;
+			otx2_cpri_set_ethtool_ops(netdev);
+			netdev->mtu = 1500U;
+			netdev->min_mtu = ETH_MIN_MTU;
+			netdev->max_mtu = 1500U;
+			if (cfg[i].if_type == IF_TYPE_CPRI) {
+				ret = register_netdev(netdev);
+				if (ret < 0) {
+					dev_err(cdev->dev,
+						"failed to register net device %s\n",
+						netdev->name);
+					free_netdev(netdev);
+					ret = -ENODEV;
+					goto err_exit;
+				}
+				dev_dbg(cdev->dev, "net device %s registered\n",
+					netdev->name);
+
+				netif_carrier_off(netdev);
+				netif_stop_queue(netdev);
+				netdev_registered = 1;
+			}
+			set_bit(CPRI_INTF_DOWN, &priv->state);
+
+			/* initialize global ctx */
+			drv_ctx = &cpri_drv_ctx[intf_idx];
+			drv_ctx->cpri_num = priv->cpri_num;
+			drv_ctx->lmac_id = priv->lmac_id;
+			drv_ctx->valid = 1;
+			drv_ctx->netdev = netdev;
+			drv_ctx->netdev_registered = netdev_registered;
+		}
+	}
+
+	return 0;
+
+err_exit:
+	for (i = 0; i < OTX2_BPHY_CPRI_MAX_INTF; i++) {
+		drv_ctx = &cpri_drv_ctx[i];
+		if (drv_ctx->valid) {
+			netdev = drv_ctx->netdev;
+			priv = netdev_priv(netdev);
+			unregister_netdev(netdev);
+			netif_napi_del(&priv->napi);
+			kfree(priv->cpri_common);
+			free_netdev(netdev);
+			drv_ctx->valid = 0;
+		}
+	}
+	return ret;
+}
diff --git a/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_cpri.h b/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_cpri.h
new file mode 100644
index 000000000000..895433c3e745
--- /dev/null
+++ b/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_cpri.h
@@ -0,0 +1,132 @@
+/* SPDX-License-Identifier: GPL-2.0
+ * Marvell OcteonTx2 BPHY RFOE/CPRI Ethernet Driver
+ *
+ * Copyright (C) 2020 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _OTX2_CPRI_H_
+#define _OTX2_CPRI_H_
+
+#include <linux/pci.h>
+#include <linux/slab.h>
+#include <linux/iommu.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/if_ether.h>
+#include <linux/net_tstamp.h>
+
+#include "otx2_bphy.h"
+#include "otx2_bphy_hw.h"
+#include "rfoe_bphy_netdev_comm_if.h"
+
+#define OTX2_BPHY_CPRI_MAX_MHAB		3
+#define OTX2_BPHY_CPRI_MAX_LMAC		4
+#define OTX2_BPHY_CPRI_MAX_INTF		10
+
+#define OTX2_BPHY_CPRI_PKT_BUF_SIZE	1664	/* wqe 128 bytes + 1536 bytes */
+#define OTX2_BPHY_CPRI_WQE_SIZE		128
+
+#define CPRI_RX_INTR_MASK(a)		((1UL << (a)) << 13)
+#define CPRI_RX_INTR_SHIFT(a)		(13 + (a))
+
+/* Each entry increments by cnt 0x68, 1 unit = 16 bytes */
+#define CIRC_BUF_ENTRY(a)		((a) / 0x68)
+
+enum cpri_state {
+	CPRI_INTF_DOWN = 1,
+};
+
+/* CPRI support */
+struct otx2_cpri_drv_ctx {
+	u8				cpri_num;
+	u8				lmac_id;
+	int				valid;
+	struct net_device               *netdev;
+	int				netdev_registered;
+};
+
+extern struct otx2_cpri_drv_ctx cpri_drv_ctx[OTX2_BPHY_CPRI_MAX_INTF];
+
+struct otx2_cpri_stats {
+	/* Rx */
+	u64				rx_frames;
+	u64				rx_octets;
+	u64				rx_err;
+	u64				bad_crc;
+	u64				oversize;
+	u64				undersize;
+	u64				fifo_ovr;
+	u64				rx_dropped;
+	/* Tx */
+	u64				tx_frames;
+	u64				tx_octets;
+	u64				tx_dropped;
+	/* stats lock */
+	spinlock_t			lock;
+};
+
+/* cpri dl cbuf cfg */
+struct dl_cbuf_cfg {
+	int				num_entries;
+	u64				cbuf_iova_addr;
+	void __iomem			*cbuf_virt_addr;
+	/* sw */
+	u64				sw_wr_ptr;
+	/* dl lock */
+	spinlock_t			lock;
+};
+
+/* cpri ul cbuf cfg */
+struct ul_cbuf_cfg {
+	int				num_entries;
+	u64				cbuf_iova_addr;
+	void __iomem			*cbuf_virt_addr;
+	/* sw */
+	int				sw_rd_ptr;
+	/* ul lock */
+	spinlock_t			lock;
+};
+
+struct cpri_common_cfg {
+	struct dl_cbuf_cfg		dl_cfg;
+	struct ul_cbuf_cfg		ul_cfg;
+};
+
+/* cpri netdev priv */
+struct otx2_cpri_ndev_priv {
+	u8				cpri_num;
+	u8				lmac_id;
+	struct net_device		*netdev;
+	struct pci_dev			*pdev;
+	struct otx2_bphy_cdev_priv	*cdev_priv;
+	u32				msg_enable;
+	void __iomem			*bphy_reg_base;
+	void __iomem			*cpri_reg_base;
+	struct iommu_domain		*iommu_domain;
+	struct cpri_common_cfg		*cpri_common;
+	struct napi_struct		napi;
+	unsigned long			state;
+	struct otx2_cpri_stats		stats;
+	u8				mac_addr[ETH_ALEN];
+	/* priv lock */
+	spinlock_t			lock;
+};
+
+int otx2_cpri_parse_and_init_intf(struct otx2_bphy_cdev_priv *cdev,
+				  struct bphy_netdev_comm_intf_cfg *cfg);
+
+void otx2_cpri_rx_napi_schedule(int cpri_num, u32 status);
+
+void otx2_cpri_update_stats(struct otx2_cpri_ndev_priv *priv);
+
+void otx2_bphy_cpri_cleanup(void);
+
+/* ethtool */
+void otx2_cpri_set_ethtool_ops(struct net_device *netdev);
+
+#endif
diff --git a/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_cpri_ethtool.c b/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_cpri_ethtool.c
new file mode 100644
index 000000000000..ae70cfa36043
--- /dev/null
+++ b/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_cpri_ethtool.c
@@ -0,0 +1,102 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Marvell OcteonTx2 BPHY RFOE/CPRI Ethernet Driver
+ *
+ * Copyright (C) 2020 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/netdevice.h>
+#include <linux/ethtool.h>
+#include <linux/net_tstamp.h>
+
+#include "otx2_cpri.h"
+
+static const char ethtool_stat_strings[][ETH_GSTRING_LEN] = {
+	"rx_frames",
+	"rx_octets",
+	"rx_err",
+	"bad_crc",
+	"oversize",
+	"undersize",
+	"rx_fifo_overrun",
+	"rx_dropped",
+	"tx_frames",
+	"tx_octets",
+	"tx_dropped",
+};
+
+static void otx2_cpri_get_strings(struct net_device *netdev, u32 sset, u8 *data)
+{
+	switch (sset) {
+	case ETH_SS_STATS:
+		memcpy(data, *ethtool_stat_strings,
+		       sizeof(ethtool_stat_strings));
+		break;
+	}
+}
+
+static int otx2_cpri_get_sset_count(struct net_device *netdev, int sset)
+{
+	switch (sset) {
+	case ETH_SS_STATS:
+		return ARRAY_SIZE(ethtool_stat_strings);
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+static void otx2_cpri_get_ethtool_stats(struct net_device *netdev,
+					struct ethtool_stats *stats,
+					u64 *data)
+{
+	struct otx2_cpri_ndev_priv *priv = netdev_priv(netdev);
+
+	otx2_cpri_update_stats(priv);
+
+	spin_lock(&priv->stats.lock);
+	memcpy(data, &priv->stats,
+	       ARRAY_SIZE(ethtool_stat_strings) * sizeof(u64));
+	spin_unlock(&priv->stats.lock);
+}
+
+static void otx2_cpri_get_drvinfo(struct net_device *netdev,
+				  struct ethtool_drvinfo *p)
+{
+	struct otx2_cpri_ndev_priv *priv = netdev_priv(netdev);
+
+	snprintf(p->driver, sizeof(p->driver), "otx2_cpri {cpri%d lmac%d}",
+		 priv->cpri_num, priv->lmac_id);
+	strlcpy(p->bus_info, "platform", sizeof(p->bus_info));
+}
+
+static u32 otx2_cpri_get_msglevel(struct net_device *netdev)
+{
+	struct otx2_cpri_ndev_priv *priv = netdev_priv(netdev);
+
+	return priv->msg_enable;
+}
+
+static void otx2_cpri_set_msglevel(struct net_device *netdev, u32 level)
+{
+	struct otx2_cpri_ndev_priv *priv = netdev_priv(netdev);
+
+	priv->msg_enable = level;
+}
+
+static const struct ethtool_ops otx2_cpri_ethtool_ops = {
+	.get_drvinfo		= otx2_cpri_get_drvinfo,
+	.get_link		= ethtool_op_get_link,
+	.get_strings		= otx2_cpri_get_strings,
+	.get_sset_count		= otx2_cpri_get_sset_count,
+	.get_ethtool_stats	= otx2_cpri_get_ethtool_stats,
+	.get_msglevel		= otx2_cpri_get_msglevel,
+	.set_msglevel		= otx2_cpri_set_msglevel,
+};
+
+void otx2_cpri_set_ethtool_ops(struct net_device *netdev)
+{
+	netdev->ethtool_ops = &otx2_cpri_ethtool_ops;
+}
diff --git a/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_rfoe.c b/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_rfoe.c
index 0fe7d17dbbc8..cc63f2eafbc6 100644
--- a/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_rfoe.c
+++ b/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_rfoe.c
@@ -1,5 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0
-/* Marvell OcteonTx2 BPHY RFOE Ethernet Driver
+/* Marvell OcteonTx2 BPHY RFOE/CPRI Ethernet Driver
  *
  * Copyright (C) 2020 Marvell International Ltd.
  *
@@ -1143,9 +1143,9 @@ int otx2_rfoe_parse_and_init_intf(struct otx2_bphy_cdev_priv *cdev,
 {
 	int i, intf_idx = 0, num_entries, lmac, idx, ret;
 	struct bphy_netdev_tx_psm_cmd_info *tx_info;
-	struct bphy_netdev_comm_intf_cfg *rfoe_cfg;
 	struct otx2_rfoe_drv_ctx *drv_ctx = NULL;
 	struct otx2_rfoe_ndev_priv *priv, *priv2;
+	struct bphy_netdev_rfoe_if *rfoe_cfg;
 	struct bphy_netdev_comm_if *if_cfg;
 	struct tx_job_queue_cfg *tx_cfg;
 	struct ptp_bcn_off_cfg *ptp_cfg;
@@ -1160,8 +1160,13 @@ int otx2_rfoe_parse_and_init_intf(struct otx2_bphy_cdev_priv *cdev,
 	spin_lock_init(&ptp_cfg->lock);
 
 	for (i = 0; i < MAX_RFOE_INTF; i++) {
+		/* Don't initialize rfoe i/f when cpri is default mode.
+		 * The mode switching from cpri to rfoe is not supported.
+		 */
+		if (cfg[i].if_type != IF_TYPE_ETHERNET)
+			continue;
 		priv2 = NULL;
-		rfoe_cfg = &cfg[i];
+		rfoe_cfg = &cfg[i].rfoe_if_cfg;
 		pkt_type_mask = rfoe_cfg->pkt_type_mask;
 		for (lmac = 0; lmac < MAX_LMAC_PER_RFOE; lmac++) {
 			if_cfg = &rfoe_cfg->if_cfg[lmac];
diff --git a/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_rfoe.h b/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_rfoe.h
index f10b756d496c..bcc3241db41d 100644
--- a/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_rfoe.h
+++ b/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_rfoe.h
@@ -1,5 +1,5 @@
 /* SPDX-License-Identifier: GPL-2.0
- * Marvell OcteonTx2 BPHY RFOE Ethernet Driver
+ * Marvell OcteonTx2 BPHY RFOE/CPRI Ethernet Driver
  *
  * Copyright (C) 2020 Marvell International Ltd.
  *
diff --git a/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_rfoe_ethtool.c b/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_rfoe_ethtool.c
index ef4c820d827e..5ba9def44644 100644
--- a/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_rfoe_ethtool.c
+++ b/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_rfoe_ethtool.c
@@ -1,5 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0
-/* Marvell OcteonTx2 BPHY RFOE Ethernet Driver
+/* Marvell OcteonTx2 BPHY RFOE/CPRI Ethernet Driver
  *
  * Copyright (C) 2020 Marvell International Ltd.
  *
diff --git a/drivers/net/ethernet/marvell/octeontx2/bphy/rfoe_bphy_netdev_comm_if.h b/drivers/net/ethernet/marvell/octeontx2/bphy/rfoe_bphy_netdev_comm_if.h
index b3dd4f4cb051..d8ae5906f1a3 100644
--- a/drivers/net/ethernet/marvell/octeontx2/bphy/rfoe_bphy_netdev_comm_if.h
+++ b/drivers/net/ethernet/marvell/octeontx2/bphy/rfoe_bphy_netdev_comm_if.h
@@ -1,5 +1,5 @@
 /* SPDX-License-Identifier: GPL-2.0
- * Marvell OcteonTx2 BPHY RFOE Ethernet Driver
+ * Marvell OcteonTx2 BPHY RFOE/CPRI Ethernet Driver
  *
  * Copyright (C) 2020 Marvell International Ltd.
  *
@@ -8,8 +8,8 @@
  * published by the Free Software Foundation.
  */
 
-#ifndef _RFOE_BPHY_NETDEV_COMM_IF_H_
-#define _RFOE_BPHY_NETDEV_COMM_IF_H_
+#ifndef _BPHY_NETDEV_COMM_IF_H_
+#define _BPHY_NETDEV_COMM_IF_H_
 
 #define ETH_ADDR_LEN		6	/* ethernet address len */
 #define MAX_RFOE_INTF		3	/* Max RFOE instances */
@@ -22,6 +22,16 @@
 /* 64 per RFoE; RFoE2 shall have 32 entries */
 #define MAX_OTH_MSG_PER_RFOE	(MAX_OTH_MSG_PER_LMAC * MAX_LMAC_PER_RFOE)
 
+/* CPRI ETH Macros */
+#define MAX_NUM_CPRI                3
+#define MAX_LANE_PER_CPRI           4
+#define CPRI_ETH_PAYLOAD_SIZE_MIN   64
+#define CPRI_ETH_PAYLOAD_SIZE_MAX   1536
+#define CPRI_ETH_PKT_HDR_SIZE       128
+
+#define CPRI_ETH_PKT_SIZE           (CPRI_ETH_PKT_HDR_SIZE + \
+				     CPRI_ETH_PAYLOAD_SIZE_MAX)
+
 /**
  * @enum bphy_netdev_tx_gpint
  * @brief GP_INT numbers for packet notification by netdev to BPHY.
@@ -61,6 +71,17 @@ enum bphy_netdev_rx_gpint {
 	RX_GP_INT_RFOE2_GENERIC   = 55, //PSM_GPINT55
 };
 
+/**
+ * @enum bphy_netdev_cpri_rx_gpint
+ * @brief GP_INT numbers for CPRI Ethernet packet Rx notification to netdev.
+ *
+ */
+enum bphy_netdev_cpri_rx_gpint {
+	RX_GP_INT_CPRI0_ETH = 45, //PSM_GPINT45,
+	RX_GP_INT_CPRI1_ETH = 46, //PSM_GPINT46,
+	RX_GP_INT_CPRI2_ETH = 47, //PSM_GPINT47
+};
+
 /**
  * @enum bphy_netdev_if_type
  * @brief BPHY Interface Types
@@ -153,21 +174,58 @@ struct bphy_netdev_tx_psm_cmd_info {
  *
  */
 struct bphy_netdev_comm_if {
-	enum bphy_netdev_if_type type;
 	struct bphy_netdev_intf_info lmac_info;
 	struct bphy_netdev_rbuf_info rbuf_info[PACKET_TYPE_MAX];
 	/* Defining single array to handle both PTP and OTHER cmds info */
 	struct bphy_netdev_tx_psm_cmd_info ptp_pkt_info[MAX_PTP_MSG_PER_LMAC];
 };
 
-struct bphy_netdev_comm_intf_cfg {
+/**
+ * @struct bphy_netdev_cpri_if
+ * @brief communication interface structure defnition to be used by
+ *        BPHY and NETDEV applications for CPRI Interface.
+ *
+ */
+struct bphy_netdev_cpri_if {
+	u8 id;                 /* CPRI ID 0..2 */
+	u8 active_lane_mask;   /* lane mask */
+	u8 ul_gp_int_num;      /* UL GP INT NUM */
+	u8 ul_int_threshold;   /* UL INT THRESHOLD */
+	u8 num_ul_buf;         /* Num UL Buffers */
+	u8 num_dl_buf;         /* Num DL Buffers */
+	u8 reserved[2];
+	u64 ul_buf_iova_addr;
+	u64 dl_buf_iova_addr;
+	u8 eth_addr[MAX_LANE_PER_CPRI][ETH_ADDR_LEN];
+};
+
+/**
+ * @struct bphy_netdev_rfoe_if
+ * @brief communication interface structure defnition to be used by
+ *        BPHY and NETDEV applications for RFOE Interface.
+ *
+ */
+struct bphy_netdev_rfoe_if {
 	/* Interface configuration */
 	struct bphy_netdev_comm_if if_cfg[MAX_LMAC_PER_RFOE];
 	/* TX JD cmds to send packets other than PTP;
 	 * These are defined per RFoE and all LMAC can share
 	 */
 	struct bphy_netdev_tx_psm_cmd_info oth_pkt_info[MAX_OTH_MSG_PER_RFOE];
+	/* Packet types for which the RX flows are configured.*/
 	u8 pkt_type_mask;
 };
 
-#endif //_RFOE_BPHY_NETDEV_COMM_IF_H_
+/**
+ * @struct bphy_netdev_comm_intf_cfg
+ * @brief ODP-NETDEV communication interface defnition structure to share
+ *        the RX/TX intrefaces information.
+ *
+ */
+struct bphy_netdev_comm_intf_cfg {
+	enum bphy_netdev_if_type if_type;     /* 0 --> ETHERNET, 1 --> CPRI */
+	struct bphy_netdev_rfoe_if rfoe_if_cfg; /* RFOE INTF configuration */
+	struct bphy_netdev_cpri_if cpri_if_cfg; /* CPRI INTF configuration */
+};
+
+#endif //_BPHY_NETDEV_COMM_IF_H_
-- 
2.31.1

