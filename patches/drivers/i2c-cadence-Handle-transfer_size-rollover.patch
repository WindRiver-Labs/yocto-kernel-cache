From cac9f2c0ee152d809edb465a6618f5061adc590c Mon Sep 17 00:00:00 2001
From: Alex Williams <alex.williams@ni.com>
Date: Mon, 15 Jun 2020 14:32:51 +0530
Subject: [PATCH 1385/1852] i2c: cadence: Handle transfer_size rollover

commit 6a6ac3f1be708f1d27cb3d3b488331db94331742 from
https://github.com/Xilinx/linux-xlnx.git

Under certain conditions, Cadence's I2C controller's transfer_size
register will roll over and generate invalid read transactions. Before
this change, the ISR relied solely on the RXDV bit to determine when to
write more data to the user's buffer. The invalid read data would cause
overruns, smashing stacks and worse.

This change stops the buffer writes to the requested boundary and
reports the error. The controller will be reset so normal transactions
may resume.

Signed-off-by: Alex Williams <alex.williams@ni.com>
Reviewed-by: Shubhrajyoti Datta <shubhrajyoti.datta@xilinx.com>
Reviewed-by: Michal Simek <michal.simek@xilinx.com> # in a seperate mail
Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
link: https://lore.kernel.org/linux-arm-kernel/20200130080307.GA2208@ninjato/T/
Signed-off-by: Raviteja Narayanam <raviteja.narayanam@xilinx.com>
State: upstream (bbf967b223b3f1b55eb494d735226152afbad64e)
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 drivers/i2c/busses/i2c-cadence.c | 18 +++++++++++++-----
 1 file changed, 13 insertions(+), 5 deletions(-)

diff --git a/drivers/i2c/busses/i2c-cadence.c b/drivers/i2c/busses/i2c-cadence.c
index 999534948829..84c247398196 100644
--- a/drivers/i2c/busses/i2c-cadence.c
+++ b/drivers/i2c/busses/i2c-cadence.c
@@ -387,6 +387,7 @@ static irqreturn_t cdns_i2c_master_isr(void *ptr)
 
 	isr_status = cdns_i2c_readreg(CDNS_I2C_ISR_OFFSET);
 	cdns_i2c_writereg(isr_status, CDNS_I2C_ISR_OFFSET);
+	id->err_status = 0;
 
 	/* Handling nack and arbitration lost interrupt */
 	if (isr_status & (CDNS_I2C_IXR_NACK | CDNS_I2C_IXR_ARB_LOST)) {
@@ -420,10 +421,17 @@ static irqreturn_t cdns_i2c_master_isr(void *ptr)
 			    !id->bus_hold_flag)
 				cdns_i2c_clear_bus_hold(id);
 
-			*(id->p_recv_buf)++ =
-				cdns_i2c_readreg(CDNS_I2C_DATA_OFFSET);
-			id->recv_count--;
-			id->curr_recv_count--;
+			if (id->recv_count > 0) {
+				*id->p_recv_buf++ =
+					cdns_i2c_readreg(CDNS_I2C_DATA_OFFSET);
+				id->recv_count--;
+				id->curr_recv_count--;
+			} else {
+				dev_err(id->adap.dev.parent,
+					"xfer_size reg rollover. xfer aborted!\n");
+				id->err_status |= CDNS_I2C_IXR_TO;
+				break;
+			}
 
 			if (cdns_is_holdquirk(id, hold_quirk))
 				break;
@@ -538,7 +546,7 @@ static irqreturn_t cdns_i2c_master_isr(void *ptr)
 	}
 
 	/* Update the status for errors */
-	id->err_status = isr_status & CDNS_I2C_IXR_ERR_INTR_MASK;
+	id->err_status |= isr_status & CDNS_I2C_IXR_ERR_INTR_MASK;
 	if (id->err_status)
 		status = IRQ_HANDLED;
 
-- 
2.31.1

