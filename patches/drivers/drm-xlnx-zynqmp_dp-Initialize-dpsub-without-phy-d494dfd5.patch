From 338b1eb7a9ef46560ad70a65d953cc19da6cc918 Mon Sep 17 00:00:00 2001
From: Hyun Kwon <hyun.kwon@xilinx.com>
Date: Fri, 18 May 2018 15:10:32 -0700
Subject: [PATCH 0356/1851] drm: xlnx: zynqmp_dp: Initialize dpsub without phy

commit 379d530bc34d0caaac7d4e0096ae6cf668bf6897 from
https://github.com/Xilinx/linux-xlnx.git

In some use cases, such as using the live output to the FPGA logic only,
the DisplayPort subsystem can be used without having the DisplayPort Tx
enabled. Such design will explicitly disable and not assign any phy lanes
to the DisplayPort Tx controller. This patch allows the DP subsystem
to initialize without the DP Tx when there's no phy lane assigned in
device tree.

Signed-off-by: Hyun Kwon <hyun.kwon@xilinx.com>
Tested-by: Tejas Upadhyay <tejas.upadhyay@xilinx.com>
Reviewed-by: Satish Kumar Nagireddy <Satish.nagireddy.nagireddy@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
State: pending
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 drivers/gpu/drm/xlnx/zynqmp_dp.c | 45 ++++++++++++++++++++++++--------
 1 file changed, 34 insertions(+), 11 deletions(-)

diff --git a/drivers/gpu/drm/xlnx/zynqmp_dp.c b/drivers/gpu/drm/xlnx/zynqmp_dp.c
index 4a78ef8bfaa9..d61fb614c136 100644
--- a/drivers/gpu/drm/xlnx/zynqmp_dp.c
+++ b/drivers/gpu/drm/xlnx/zynqmp_dp.c
@@ -1631,6 +1631,9 @@ int zynqmp_dp_bind(struct device *dev, struct device *master, void *data)
 	struct device_node *port;
 	int ret;
 
+	if (!dp->num_lanes)
+		return 0;
+
 	encoder->possible_crtcs |= zynqmp_disp_get_crtc_mask(dpsub->disp);
 	for_each_child_of_node(dev->of_node, port) {
 		if (!port->name || of_node_cmp(port->name, "port"))
@@ -1693,8 +1696,11 @@ void zynqmp_dp_unbind(struct device *dev, struct device *master, void *data)
 	struct zynqmp_dpsub *dpsub = dev_get_drvdata(dev);
 	struct zynqmp_dp *dp = dpsub->dp;
 
-	cancel_delayed_work_sync(&dp->hpd_work);
 	disable_irq(dp->irq);
+	if (!dp->num_lanes)
+		return;
+
+	cancel_delayed_work_sync(&dp->hpd_work);
 	zynqmp_dp_exit_aux(dp);
 	drm_property_destroy(dp->drm, dp->bpc_prop);
 	drm_property_destroy(dp->drm, dp->sync_prop);
@@ -1786,18 +1792,30 @@ int zynqmp_dp_probe(struct platform_device *pdev)
 		snprintf(phy_name, sizeof(phy_name), "dp-phy%d", i);
 		dp->phy[i] = devm_phy_get(dp->dev, phy_name);
 		if (IS_ERR(dp->phy[i])) {
+			ret = PTR_ERR(dp->phy[i]);
+			dp->phy[i] = NULL;
+
 			/* 2nd lane is optional */
-			if (i == 0 || PTR_ERR(dp->phy[i]) != -ENODEV) {
-				if (PTR_ERR(dp->phy[i]) != -EPROBE_DEFER) {
-					dev_err(dp->dev,
-						"failed to get phy lane\n");
-				}
-				ret = PTR_ERR(dp->phy[i]);
-				dp->phy[i] = NULL;
-				return ret;
+			if (i == 1 && ret == -ENODEV) {
+				dp->num_lanes = 1;
+				break;
 			}
-			dp->phy[i] = NULL;
-			dp->num_lanes = 1;
+
+			/*
+			 * If no phy lane is assigned, the DP Tx gets disabled.
+			 * The display part of the DP subsystem can still be
+			 * used to drive the output to FPGA, thus let the DP
+			 * subsystem driver to proceed without this DP Tx.
+			 */
+			if (i == 0 && ret == -ENODEV) {
+				dp->num_lanes = 0;
+				goto out;
+			}
+
+			if (ret != -EPROBE_DEFER)
+				dev_err(dp->dev, "failed to get phy lane\n");
+
+			return ret;
 		}
 	}
 
@@ -1814,6 +1832,7 @@ int zynqmp_dp_probe(struct platform_device *pdev)
 		goto error;
 	}
 
+out:
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0) {
 		ret = irq;
@@ -1831,6 +1850,10 @@ int zynqmp_dp_probe(struct platform_device *pdev)
 	dpsub->dp = dp;
 	dp->dpsub = dpsub;
 
+	dev_dbg(dp->dev,
+		"ZynqMP DisplayPort Tx driver probed with %u phy lanes\n",
+		dp->num_lanes);
+
 	return 0;
 
 error:
-- 
2.31.1

