From b3a9fa059764e88589f5c9367af0d8d4d96248e9 Mon Sep 17 00:00:00 2001
From: Devarsh Thakkar <devarsh.thakkar@xilinx.com>
Date: Tue, 6 Oct 2020 09:30:32 -0700
Subject: [PATCH 1704/1852] staging: xlnxsync: Add new ioctl to set interrupt
 mask

commit 9c5b35feda763aa0a0a2f3afef77de619497ad65 from
https://github.com/Xilinx/linux-xlnx.git

New SyncIP RTL supports selective masking of interrupts which was not
working previously. So it's possible now for application to selectively
mask interrupts which it is not using to make any decisions or gain
any information.

For this New IOCTL XLNXSYNC_CHAN_SET_INTR_MASK is implemented along with
interrupt context structure using which application can pass to driver
the interrupts which it doesn't require and thus need to be masked.

So for e.g. if an application doen't use frame done event from syncip
driver then it can mask the corresponding interrupts using this ioctl
thus reducing the overall system overhead and maximizing the
performance.

Also Updated the IOCTL version as API changes.

Signed-off-by: Devarsh Thakkar <devarsh.thakkar@xilinx.com>
Reviewed-by: Hyun Kwon <hyun.kwon@xilinx.com>
State: pending
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 drivers/staging/xlnxsync/xlnxsync.c | 57 +++++++++++++++++++++++++++++
 include/uapi/linux/xlnxsync.h       | 42 ++++++++++++++++++++-
 2 files changed, 98 insertions(+), 1 deletion(-)

diff --git a/drivers/staging/xlnxsync/xlnxsync.c b/drivers/staging/xlnxsync/xlnxsync.c
index 72aaf6cc7bc0..935764da52a1 100644
--- a/drivers/staging/xlnxsync/xlnxsync.c
+++ b/drivers/staging/xlnxsync/xlnxsync.c
@@ -758,6 +758,57 @@ static int xlnxsync_chan_clr_fbdone_status(struct xlnxsync_channel *channel,
 	return 0;
 }
 
+static int xlnxsync_chan_set_int_mask(struct xlnxsync_channel *channel,
+				      void __user *arg)
+{
+	struct xlnxsync_device *dev = channel->dev;
+	struct xlnxsync_intr intr_mask;
+	u32 intr_mask_val = 0;
+	int ret;
+
+	ret = copy_from_user(&intr_mask, arg, sizeof(intr_mask));
+	if (ret) {
+		dev_err(dev->dev, "%s : Failed to copy from user\n", __func__);
+		return ret;
+	}
+
+	/* check driver header version */
+	if (intr_mask.hdr_ver != XLNXSYNC_IOCTL_HDR_VER) {
+		dev_err(dev->dev, "%s : ioctl version mismatch\n", __func__);
+		dev_err(dev->dev,
+			"ioctl ver = 0x%llx expected ver = 0x%llx\n",
+			intr_mask.hdr_ver, (u64)XLNXSYNC_IOCTL_HDR_VER);
+		return -EINVAL;
+	}
+
+	if (intr_mask.err.prod_sync)
+		intr_mask_val |= XLNXSYNC_IER_PROD_SYNC_FAIL_MASK;
+	if (intr_mask.err.prod_wdg)
+		intr_mask_val |= XLNXSYNC_IER_PROD_WDG_ERR_MASK;
+	if (intr_mask.err.cons_sync)
+		intr_mask_val |= XLNXSYNC_IER_CONS_SYNC_FAIL_MASK;
+	if (intr_mask.err.cons_wdg)
+		intr_mask_val |= XLNXSYNC_IER_CONS_WDG_ERR_MASK;
+	if (intr_mask.err.ldiff)
+		intr_mask_val |= XLNXSYNC_IER_LDIFF;
+	if (intr_mask.err.cdiff)
+		intr_mask_val |= XLNXSYNC_IER_CDIFF;
+	if (intr_mask.prod_lfbdone)
+		intr_mask_val |= XLNXSYNC_IER_PLVALID_MASK;
+	if (intr_mask.prod_cfbdone)
+		intr_mask_val |= XLNXSYNC_IER_PCVALID_MASK;
+	if (intr_mask.cons_lfbdone)
+		intr_mask_val |= XLNXSYNC_IER_CLVALID_MASK;
+	if (intr_mask.cons_cfbdone)
+		intr_mask_val |= XLNXSYNC_IER_CCVALID_MASK;
+
+	dev_dbg(dev->dev, "Set interrupt mask: 0x%x for channel: %d\n",
+		intr_mask_val, channel->id);
+
+	xlnxsync_write(dev, channel->id, XLNXSYNC_IER_REG, intr_mask_val);
+
+	return ret;
+}
 
 static long xlnxsync_ioctl(struct file *fptr, unsigned int cmd,
 			   unsigned long data)
@@ -824,6 +875,12 @@ static long xlnxsync_ioctl(struct file *fptr, unsigned int cmd,
 		ret = xlnxsync_chan_clr_fbdone_status(channel, arg);
 		mutex_unlock(&channel->mutex);
 		break;
+	case XLNXSYNC_CHAN_SET_INTR_MASK:
+		if (mutex_lock_interruptible(&channel->mutex))
+			return -ERESTARTSYS;
+		ret = xlnxsync_chan_set_int_mask(channel, arg);
+		mutex_unlock(&channel->mutex);
+		break;
 	}
 
 	return ret;
diff --git a/include/uapi/linux/xlnxsync.h b/include/uapi/linux/xlnxsync.h
index 56afa5606449..f2f7aa19c03c 100644
--- a/include/uapi/linux/xlnxsync.h
+++ b/include/uapi/linux/xlnxsync.h
@@ -3,7 +3,7 @@
 #ifndef __XLNXSYNC_H__
 #define __XLNXSYNC_H__
 
-#define XLNXSYNC_IOCTL_HDR_VER		0x10003
+#define XLNXSYNC_IOCTL_HDR_VER		0x10004
 
 /*
  * This is set in the fb_id of struct xlnxsync_chan_config when
@@ -21,6 +21,43 @@
 #define XLNXSYNC_IO			2
 
 #define XLNXSYNC_MAX_CORES		4
+
+/**
+ * struct xlnxsync_err_intr - Channel error interrupt types
+ * @prod_sync: Producer synchronization error interrupt
+ * @prod_wdg: Producer watchdog interrupt
+ * @cons_sync: Consumer synchronization error interrupt
+ * @cons_wdg: Consumer watchdog interrupt
+ * @ldiff: Luma buffer difference interrupt
+ * @cdiff: Chroma buffer difference interrupt
+ */
+struct xlnxsync_err_intr {
+	u8 prod_sync : 1;
+	u8 prod_wdg : 1;
+	u8 cons_sync : 1;
+	u8 cons_wdg : 1;
+	u8 ldiff : 1;
+	u8 cdiff : 1;
+};
+
+/**
+ * struct xlnxsync_intr - Channel Interrupt types
+ * @hdr_ver: IOCTL header version
+ * @err: Structure for error interrupts
+ * @prod_lfbdone: Producer luma frame buffer done interrupt
+ * @prod_cfbdone: Producer chroma frame buffer done interrupt
+ * @cons_lfbdone: Consumer luma frame buffer done interrupt
+ * @cons_cfbdone: Consumer chroma frame buffer done interrupt
+ */
+struct xlnxsync_intr {
+	u64 hdr_ver;
+	struct xlnxsync_err_intr err;
+	u8 prod_lfbdone : 1;
+	u8 prod_cfbdone : 1;
+	u8 cons_lfbdone : 1;
+	u8 cons_cfbdone : 1;
+};
+
 /**
  * struct xlnxsync_chan_config - Synchronizer channel configuration struct
  * @hdr_ver: IOCTL header version
@@ -152,4 +189,7 @@ struct xlnxsync_stat {
 /* This is used to clear the framebuffer done status for a channel */
 #define XLNXSYNC_CHAN_CLR_FBDONE_STAT	_IOW(XLNXSYNC_MAGIC, 8,\
 					     struct xlnxsync_fbdone *)
+/* This is used to set interrupt mask */
+#define XLNXSYNC_CHAN_SET_INTR_MASK	_IOW(XLNXSYNC_MAGIC, 9,\
+					     struct xlnxsync_intr *)
 #endif
-- 
2.31.1

