From f095833af1ddd52ead7dfc103fc699789bf97b88 Mon Sep 17 00:00:00 2001
From: Dylan Yip <dylan.yip@xilinx.com>
Date: Tue, 9 Mar 2021 12:36:39 -0800
Subject: [PATCH 1767/1851] drm: xlnx: zynqmp_disp: Move bridge functions

commit bb78aaa7c1f70f1164556407c62e1ad5d209a539 from
https://github.com/Xilinx/linux-xlnx.git

Move bridge functions below DRM CRTC functions so that we can reuse code
for setting the DP encoder and video clock. This is useful when an
external CRTC is used instead of the PS DP CRTC because we require the
bridge to enable the DP encoder and provide video timing.

Signed-off-by: Dylan Yip <dylan.yip@xilinx.com>
Signed-off-by: Jianqiang Chen <jianqiang.chen@xilinx.com>
Acked-by: Varunkumar Allagadapa <varunkumar.allagadapa@xilinx.com>
State: pending
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 drivers/gpu/drm/xlnx/zynqmp_disp.c | 204 +++++++++++++++--------------
 1 file changed, 103 insertions(+), 101 deletions(-)

diff --git a/drivers/gpu/drm/xlnx/zynqmp_disp.c b/drivers/gpu/drm/xlnx/zynqmp_disp.c
index 2fd0b71ded71..8a293589b488 100644
--- a/drivers/gpu/drm/xlnx/zynqmp_disp.c
+++ b/drivers/gpu/drm/xlnx/zynqmp_disp.c
@@ -2357,107 +2357,6 @@ uint32_t zynqmp_disp_get_crtc_mask(struct zynqmp_disp *disp)
 	return drm_crtc_mask(&disp->xlnx_crtc.crtc);
 }
 
-/*
- * Xlnx bridge functions
- */
-
-static inline struct zynqmp_disp_layer
-*bridge_to_layer(struct xlnx_bridge *bridge)
-{
-	return container_of(bridge, struct zynqmp_disp_layer, bridge);
-}
-
-static int zynqmp_disp_bridge_enable(struct xlnx_bridge *bridge)
-{
-	struct zynqmp_disp_layer *layer = bridge_to_layer(bridge);
-	struct zynqmp_disp *disp = layer->disp;
-	int ret;
-
-	if (!disp->_pl_pclk) {
-		dev_err(disp->dev, "PL clock is required for live\n");
-		return -ENODEV;
-	}
-
-	ret = zynqmp_disp_layer_check_size(disp, layer, layer->w, layer->h);
-	if (ret)
-		return ret;
-
-	zynqmp_disp_set_g_alpha(disp, disp->alpha_en);
-	zynqmp_disp_set_alpha(disp, disp->alpha);
-	ret = zynqmp_disp_layer_enable(layer->disp, layer,
-				       ZYNQMP_DISP_LAYER_LIVE);
-	if (ret)
-		return ret;
-
-	if (layer->id == ZYNQMP_DISP_LAYER_GFX && disp->tpg_on) {
-		layer = &disp->layers[ZYNQMP_DISP_LAYER_VID];
-		zynqmp_disp_layer_set_tpg(disp, layer, disp->tpg_on);
-	}
-
-	if (zynqmp_disp_av_buf_vid_timing_src_is_int(&disp->av_buf) ||
-	    zynqmp_disp_av_buf_vid_clock_src_is_ps(&disp->av_buf)) {
-		dev_info(disp->dev,
-			 "Disabling the pipeline to change the clk/timing src");
-		zynqmp_disp_disable(disp, true);
-		zynqmp_disp_av_buf_set_vid_clock_src(&disp->av_buf, false);
-		zynqmp_disp_av_buf_set_vid_timing_src(&disp->av_buf, false);
-	}
-
-	zynqmp_disp_enable(disp);
-
-	return 0;
-}
-
-static void zynqmp_disp_bridge_disable(struct xlnx_bridge *bridge)
-{
-	struct zynqmp_disp_layer *layer = bridge_to_layer(bridge);
-	struct zynqmp_disp *disp = layer->disp;
-
-	zynqmp_disp_disable(disp, false);
-
-	zynqmp_disp_layer_disable(disp, layer, ZYNQMP_DISP_LAYER_LIVE);
-	if (layer->id == ZYNQMP_DISP_LAYER_VID && disp->tpg_on)
-		zynqmp_disp_layer_set_tpg(disp, layer, disp->tpg_on);
-
-	if (!zynqmp_disp_layer_is_live(disp)) {
-		dev_info(disp->dev,
-			 "Disabling the pipeline to change the clk/timing src");
-		zynqmp_disp_disable(disp, true);
-		zynqmp_disp_av_buf_set_vid_clock_src(&disp->av_buf, true);
-		zynqmp_disp_av_buf_set_vid_timing_src(&disp->av_buf, true);
-		if (zynqmp_disp_layer_is_enabled(disp))
-			zynqmp_disp_enable(disp);
-	}
-}
-
-static int zynqmp_disp_bridge_set_input(struct xlnx_bridge *bridge,
-					u32 width, u32 height, u32 bus_fmt)
-{
-	struct zynqmp_disp_layer *layer = bridge_to_layer(bridge);
-	int ret;
-
-	ret = zynqmp_disp_layer_check_size(layer->disp, layer, width, height);
-	if (ret)
-		return ret;
-
-	ret = zynqmp_disp_layer_set_live_fmt(layer->disp,  layer, bus_fmt);
-	if (ret)
-		dev_err(layer->disp->dev, "failed to set live fmt\n");
-
-	return ret;
-}
-
-static int zynqmp_disp_bridge_get_input_fmts(struct xlnx_bridge *bridge,
-					     const u32 **fmts, u32 *count)
-{
-	struct zynqmp_disp_layer *layer = bridge_to_layer(bridge);
-
-	*fmts = layer->bus_fmts;
-	*count = layer->num_bus_fmts;
-
-	return 0;
-}
-
 /*
  * DRM plane functions
  */
@@ -3113,6 +3012,109 @@ static void zynqmp_disp_map_crtc_to_plane(struct zynqmp_disp *disp)
 		disp->layers[i].plane.possible_crtcs = possible_crtcs;
 }
 
+/*
+ * Xlnx bridge functions
+ */
+
+static inline struct zynqmp_disp_layer
+*bridge_to_layer(struct xlnx_bridge *bridge)
+{
+	return container_of(bridge, struct zynqmp_disp_layer, bridge);
+}
+
+static int zynqmp_disp_bridge_enable(struct xlnx_bridge *bridge)
+{
+	struct zynqmp_disp_layer *layer = bridge_to_layer(bridge);
+	struct zynqmp_disp *disp = layer->disp;
+	struct drm_crtc *crtc = &disp->xlnx_crtc.crtc;
+	struct drm_display_mode *adjusted_mode = &crtc->state->adjusted_mode;
+	int ret, vrefresh;
+
+	if (!disp->_pl_pclk) {
+		dev_err(disp->dev, "PL clock is required for live\n");
+		return -ENODEV;
+	}
+
+	ret = zynqmp_disp_layer_check_size(disp, layer, layer->w, layer->h);
+	if (ret)
+		return ret;
+
+	zynqmp_disp_set_g_alpha(disp, disp->alpha_en);
+	zynqmp_disp_set_alpha(disp, disp->alpha);
+	ret = zynqmp_disp_layer_enable(layer->disp, layer,
+				       ZYNQMP_DISP_LAYER_LIVE);
+	if (ret)
+		return ret;
+
+	if (layer->id == ZYNQMP_DISP_LAYER_GFX && disp->tpg_on) {
+		layer = &disp->layers[ZYNQMP_DISP_LAYER_VID];
+		zynqmp_disp_layer_set_tpg(disp, layer, disp->tpg_on);
+	}
+
+	if (zynqmp_disp_av_buf_vid_timing_src_is_int(&disp->av_buf) ||
+	    zynqmp_disp_av_buf_vid_clock_src_is_ps(&disp->av_buf)) {
+		dev_info(disp->dev,
+			 "Disabling the pipeline to change the clk/timing src");
+		zynqmp_disp_disable(disp, true);
+		zynqmp_disp_av_buf_set_vid_clock_src(&disp->av_buf, false);
+		zynqmp_disp_av_buf_set_vid_timing_src(&disp->av_buf, false);
+	}
+
+	zynqmp_disp_enable(disp);
+
+	return 0;
+}
+
+static void zynqmp_disp_bridge_disable(struct xlnx_bridge *bridge)
+{
+	struct zynqmp_disp_layer *layer = bridge_to_layer(bridge);
+	struct zynqmp_disp *disp = layer->disp;
+
+	zynqmp_disp_disable(disp, false);
+
+	zynqmp_disp_layer_disable(disp, layer, ZYNQMP_DISP_LAYER_LIVE);
+	if (layer->id == ZYNQMP_DISP_LAYER_VID && disp->tpg_on)
+		zynqmp_disp_layer_set_tpg(disp, layer, disp->tpg_on);
+
+	if (!zynqmp_disp_layer_is_live(disp)) {
+		dev_info(disp->dev,
+			 "Disabling the pipeline to change the clk/timing src");
+		zynqmp_disp_disable(disp, true);
+		zynqmp_disp_av_buf_set_vid_clock_src(&disp->av_buf, true);
+		zynqmp_disp_av_buf_set_vid_timing_src(&disp->av_buf, true);
+		if (zynqmp_disp_layer_is_enabled(disp))
+			zynqmp_disp_enable(disp);
+	}
+}
+
+static int zynqmp_disp_bridge_set_input(struct xlnx_bridge *bridge,
+					u32 width, u32 height, u32 bus_fmt)
+{
+	struct zynqmp_disp_layer *layer = bridge_to_layer(bridge);
+	int ret;
+
+	ret = zynqmp_disp_layer_check_size(layer->disp, layer, width, height);
+	if (ret)
+		return ret;
+
+	ret = zynqmp_disp_layer_set_live_fmt(layer->disp,  layer, bus_fmt);
+	if (ret)
+		dev_err(layer->disp->dev, "failed to set live fmt\n");
+
+	return ret;
+}
+
+static int zynqmp_disp_bridge_get_input_fmts(struct xlnx_bridge *bridge,
+					     const u32 **fmts, u32 *count)
+{
+	struct zynqmp_disp_layer *layer = bridge_to_layer(bridge);
+
+	*fmts = layer->bus_fmts;
+	*count = layer->num_bus_fmts;
+
+	return 0;
+}
+
 /*
  * Component functions
  */
-- 
2.31.1

