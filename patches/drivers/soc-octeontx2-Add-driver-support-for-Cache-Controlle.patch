From e757b9cafbd7063782ed0c0c9894b847fd275460 Mon Sep 17 00:00:00 2001
From: Linu Cherian <lcherian@marvell.com>
Date: Thu, 24 Jan 2019 06:54:35 +0530
Subject: [PATCH 01/12] soc: octeontx2: Add driver support for Cache Controller
 Unit

commit 6ff7af6ad697270fe474e153fb476ccab0f6e686 from
git@git.assembla.com:cavium/WindRiver.linux.git

- Added new platform driver for CCU
- API support for CCU/CCS register access
- Low level APIs for cache partitioning
- Debugfs hooks for using the cache partitioning APIs

Change-Id: I6bc2bd94d4694a74df10ab92b5de0c9fd1601f77
Signed-off-by: Linu Cherian <lcherian@marvell.com>
Signed-off-by: Tanmay Jagdale <tanmay@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/67901
Reviewed-by: Sunil Kovvuri Goutham <sgoutham@marvell.com>
Tested-by: Sunil Kovvuri Goutham <sgoutham@marvell.com>
Integrated-by: Abhishek Paliwal <paliwal.abhishek@windriver.com>
---
 drivers/soc/marvell/Kconfig                |  13 +
 drivers/soc/marvell/Makefile               |   1 +
 drivers/soc/marvell/octeontx2-ccu/Makefile |   8 +
 drivers/soc/marvell/octeontx2-ccu/README   |  97 ++++++++
 drivers/soc/marvell/octeontx2-ccu/ccu.c    | 274 +++++++++++++++++++++
 5 files changed, 393 insertions(+)
 create mode 100644 drivers/soc/marvell/octeontx2-ccu/Makefile
 create mode 100644 drivers/soc/marvell/octeontx2-ccu/README
 create mode 100644 drivers/soc/marvell/octeontx2-ccu/ccu.c

diff --git a/drivers/soc/marvell/Kconfig b/drivers/soc/marvell/Kconfig
index 5b8e9d2c200c..c47990d8cfcf 100644
--- a/drivers/soc/marvell/Kconfig
+++ b/drivers/soc/marvell/Kconfig
@@ -196,4 +196,17 @@ config HW_CSR_ACCESS
 	help
 	  provides an interface which enables user space utility to read from or to write
 	  to HW Device Config Space Registers, Contexts, Memory.
+
+config OCTEONTX2_CCU
+	tristate "OcteonTX2 Cache Controller Unit (CCU) driver"
+	depends on ARM64
+	default n
+	help
+	  This driver supports configuring and monitoring the OcteonTX2 Cache
+	  Controller Unit. The driver provides debugfs files to mask LLC ways
+	  for a single or multiple cpus. A README file is included which
+	  provides details on how to configure the LLC ways.
+
+	  To compile as a module choose M here.
+
 endmenu
diff --git a/drivers/soc/marvell/Makefile b/drivers/soc/marvell/Makefile
index 710076376678..152820bc7c14 100644
--- a/drivers/soc/marvell/Makefile
+++ b/drivers/soc/marvell/Makefile
@@ -4,6 +4,7 @@ obj-y		+= octeontx2-dpi/
 obj-y		+= octeontx2-sdp/
 obj-y		+= octeontx2-npa/
 obj-$(CONFIG_OCTEONTX_SERDES) += octeontx2-serdes/
+obj-y		+= octeontx2-ccu/
 obj-y 		+= hw-access/
 obj-$(CONFIG_MDIO_DEBUGFS) += mdio_debugfs.o
 obj-y		+= octeontx2-ghes/
diff --git a/drivers/soc/marvell/octeontx2-ccu/Makefile b/drivers/soc/marvell/octeontx2-ccu/Makefile
new file mode 100644
index 000000000000..ee0aa0480268
--- /dev/null
+++ b/drivers/soc/marvell/octeontx2-ccu/Makefile
@@ -0,0 +1,8 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for Marvell's OcteonTX2 CCU driver
+#
+
+obj-$(CONFIG_OCTEONTX2_CCU) += octeontx2_ccu.o
+
+octeontx2_ccu-y := ccu.o
diff --git a/drivers/soc/marvell/octeontx2-ccu/README b/drivers/soc/marvell/octeontx2-ccu/README
new file mode 100644
index 000000000000..015d94fe06b0
--- /dev/null
+++ b/drivers/soc/marvell/octeontx2-ccu/README
@@ -0,0 +1,97 @@
+
+OCTEONTX2 Cache Controller Unit (CCU)
+-------------------------------------
+
+The Cache Controller Unit allows partitioning the LLC ways into
+different partitions (mparid) and associate them with a cpu or a
+set of CPUs.
+
+This driver creates a debugfs directory (ccu) in /sys/kernel/debug
+with the following files
+    $ ls /sys/kernel/debug/ccu
+    config  counter  cpumask  mparid  waymask
+
+mparid  - Create a new parition ID. Valid values are 0 - 255.
+waymask - Set the LLC ways that will be masked for the associated mparid.
+          CCU has 14 LTG ways and 20 DTG ways. The mask value is as follows
+          [13:0]  - LTG Ways
+          [33:14] - DTG Ways
+cpumask - Set the CPU mask to which the LLC way partitioning will be applied.
+config  - Write 1 to enable the CCU partitioning with values set in the files
+          mparid, waymask and cpumask.
+          Read prints the cache configuration.
+counter - Prints the Allocate and Hit counter values for the MPARIDs that
+          are configured.
+
+Usage Steps
+-----------
+    1. Create a new parition
+        $ echo <mparid> > /sys/kernel/debug/ccu/mparid
+
+    2. Set the LLC ways that need to be masked.
+        $ echo <waymask> > /sys/kernel/debug/ccu/waymask
+
+    3. Set cpumask to which waymasking will be applied to.
+        $ echo <cpu-mask> > /sys/kernel/debug/ccu/cpumask
+
+    4. Enable this configuration
+        $ echo 1 > /sys/kernel/debug/ccu/config
+
+The above 4 steps can be repeated the with different mparid, waymask and
+cpumask values. Finally the hardware configuration can be read by
+        $ cat /sys/kernel/debug/ccu/config
+
+To check the Allocate and Hit counter for the configured MPARIDs
+        $ cat /sys/kernel/debug/ccu/counter
+
+Example
+-------
+Lets create mparid 10, with all LTG ways masked and associate it with cpus 12-23
+        $ echo 10 > /sys/kernel/debug/ccu/mparid
+        $ echo 0x3fff > /sys/kernel/debug/ccu/waymask
+        $ echo 0xfff000 > /sys/kernel/debug/ccu/cpumask
+        $ echo 1 > /sys/kernel/debug/ccu/config
+
+        $ cat /sys/kernel/debug/ccu/config
+        core:0 mparid:0 waymask:0x0
+        core:1 mparid:0 waymask:0x0
+        core:2 mparid:0 waymask:0x0
+        core:3 mparid:0 waymask:0x0
+        core:4 mparid:0 waymask:0x0
+        core:5 mparid:0 waymask:0x0
+        core:6 mparid:0 waymask:0x0
+        core:7 mparid:0 waymask:0x0
+        core:8 mparid:0 waymask:0x0
+        core:9 mparid:0 waymask:0x0
+        core:10 mparid:0 waymask:0x0
+        core:11 mparid:0 waymask:0x0
+        core:12 mparid:10 waymask:0x3fff
+        core:13 mparid:10 waymask:0x3fff
+        core:14 mparid:10 waymask:0x3fff
+        core:15 mparid:10 waymask:0x3fff
+        core:16 mparid:10 waymask:0x3fff
+        core:17 mparid:10 waymask:0x3fff
+        core:18 mparid:10 waymask:0x3fff
+        core:19 mparid:10 waymask:0x3fff
+        core:20 mparid:10 waymask:0x3fff
+        core:21 mparid:10 waymask:0x3fff
+        core:22 mparid:10 waymask:0x3fff
+        core:23 mparid:10 waymask:0x3fff
+
+        $ cat /sys/kernel/debug/ccu/counter
+        CCU:0 TAD:0 MPARID:0 ALLOC:0x20a469e HIT:0x1ca8fa09
+        CCU:0 TAD:1 MPARID:0 ALLOC:0x20a48ea HIT:0x32dc7712
+        CCU:1 TAD:0 MPARID:0 ALLOC:0x20a45ee HIT:0x326f8834
+        CCU:1 TAD:1 MPARID:0 ALLOC:0x20a470e HIT:0x19aa9ce8
+        CCU:2 TAD:0 MPARID:0 ALLOC:0x20a4719 HIT:0x3204242a
+        CCU:2 TAD:1 MPARID:0 ALLOC:0x20a474f HIT:0x32234456
+        CCU:3 TAD:0 MPARID:0 ALLOC:0x20a45a2 HIT:0x19e723c9
+        CCU:3 TAD:1 MPARID:0 ALLOC:0x20a46c2 HIT:0x1aae638a
+        CCU:0 TAD:0 MPARID:10 ALLOC:0x8 HIT:0x2a1
+        CCU:0 TAD:1 MPARID:10 ALLOC:0xb HIT:0x273
+        CCU:1 TAD:0 MPARID:10 ALLOC:0x13 HIT:0x22d
+        CCU:1 TAD:1 MPARID:10 ALLOC:0xb HIT:0x26d
+        CCU:2 TAD:0 MPARID:10 ALLOC:0x11 HIT:0x206
+        CCU:2 TAD:1 MPARID:10 ALLOC:0x10 HIT:0x1f2
+        CCU:3 TAD:0 MPARID:10 ALLOC:0x10 HIT:0x2b2
+        CCU:3 TAD:1 MPARID:10 ALLOC:0x14 HIT:0x26f
diff --git a/drivers/soc/marvell/octeontx2-ccu/ccu.c b/drivers/soc/marvell/octeontx2-ccu/ccu.c
new file mode 100644
index 000000000000..9158337bc8ed
--- /dev/null
+++ b/drivers/soc/marvell/octeontx2-ccu/ccu.c
@@ -0,0 +1,274 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Marvell OcteonTx2 CCU controller driver
+ *
+ * Copyright (C) 2021 Marvell.
+ */
+
+#include <linux/bitops.h>
+#include <linux/bitfield.h>
+#include <linux/debugfs.h>
+#include <linux/io.h>
+#include <linux/gfp.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+
+#define CCU_BASE	0x87E050000000
+#define CCS_BASE	0x87E087100000
+
+/* m - bit mask
+ * y - value to be written in the bitrange
+ * x - input value whose bitrange to be modified
+ */
+#define FIELD_SET(m, y, x)		\
+	(((x) & ~(m)) |			\
+	FIELD_PREP((m), (y)))
+
+#define CCS_MPARX_MASK(pid)	\
+	(0x1000		|	\
+	((pid) & 0xff) << 3)
+
+#define MPARX_MASK_LTG		GENMASK_ULL(13, 0)
+#define MPARX_MASK_DTG		GENMASK_ULL(33, 14)
+
+#define CCUX_TADX_MPARX_ACNT(ccu, tad, pid)	\
+	(0x401000		|		\
+	((ccu) & 0x3) << 24	|		\
+	((tad) & 0x1) << 21	|		\
+	((pid) & 0xff) << 4)
+
+#define CCUX_TADX_MPARX_HCNT(ccu, tad, pid)	\
+	(0x401008		|		\
+	(((ccu) & 0x3) << 24)	|		\
+	(((tad) & 0x1) << 21)	|		\
+	(((pid) & 0xff) << 4))
+
+#define MPARID_MAX	256
+
+/* Global variables */
+void __iomem *ccu_base;
+void __iomem *ccs_base;
+static u8 mparid;
+static u64 waymask;
+static u32 cpid_mask;
+struct dentry *ccu_dent;
+struct cpumask cpid_cpumask;
+static u8 mparid_configured[MPARID_MAX];
+
+#define COUNTER_BUF_SIZE	65536
+#define	CONFIG_BUF_SIZE		4096
+char *counter_buf;
+char *config_buf;
+
+/* Low level accessor functions */
+static inline void apsys_cpidel2_read_remote(void *data)
+{
+	u64 val;
+
+	asm volatile ("mrs %0, s3_4_c11_c6_4" : "=r" (val) : );
+	*(u64 *)data = val;
+}
+
+static inline void apsys_cpidel2_write_remote(void *data)
+{
+	u64 val;
+
+	val = *(u64 *)data;
+	asm volatile ("msr s3_4_c11_c6_4, %0" : : "r" (val));
+}
+
+static inline u64 ccsreg_read(u64 offset)
+{
+	return readq(ccs_base + offset);
+}
+
+static inline void ccsreg_write(u64 offset, u64 val)
+{
+	writeq(val, ccs_base + offset);
+}
+
+static inline u64 ccureg_read(u64 offset)
+{
+	return readq(ccu_base + offset);
+}
+
+static inline void ccureg_write(u64 offset, u64 val)
+{
+	writeq(val, ccu_base + offset);
+}
+
+/* Mask LLC ways for a partition id */
+static inline void ccsreg_mparmask_set(int mparid, u32 waymask)
+{
+	u64 val;
+
+	val = ccsreg_read(CCS_MPARX_MASK(mparid));
+	val = FIELD_SET(MPARX_MASK_LTG, waymask, val);
+	val = FIELD_SET(MPARX_MASK_DTG, waymask, val);
+	ccsreg_write(CCS_MPARX_MASK(mparid), val);
+}
+
+static ssize_t otx2_ccu_config_write(struct file *file, const char *buf,
+				     size_t count, loff_t *position)
+{
+	int cpu;
+
+	pr_info("ccu: configuring mparid:%d waymask:0x%llx cpumask:0x%x\n",
+		mparid, waymask, cpid_mask);
+
+	/* Configure the LLC ways */
+	ccsreg_mparmask_set(mparid, waymask);
+
+	/* Create a bitmap */
+	cpumask_clear(&cpid_cpumask);
+	for_each_set_bit(cpu, (unsigned long *)&cpid_mask, num_present_cpus())
+		cpumask_set_cpu(cpu, &cpid_cpumask);
+
+	/* Configure mparid for all cpus in the bitmap */
+	for_each_cpu(cpu, &cpid_cpumask) {
+		smp_call_function_single(cpu, apsys_cpidel2_write_remote,
+					 &mparid, true);
+	}
+
+	/* Some book keeping */
+	mparid_configured[mparid] = 1;
+
+	return count;
+}
+
+static ssize_t otx2_ccu_config_read(struct file *file, char __user *buf,
+				    size_t count, loff_t *position)
+{
+	u64 val, waymask;
+	u32 cpu, sz = 0;
+	u8 mparid;
+
+	memset(config_buf, 0, CONFIG_BUF_SIZE);
+
+	/* Read the mparid configured for each cpu and then read
+	 * the associated waymask for that mparid.
+	 */
+	for_each_cpu(cpu, cpu_present_mask) {
+		smp_call_function_single(cpu, apsys_cpidel2_read_remote,
+					 &val, true);
+		mparid = (u8)val;
+		waymask = ccsreg_read(CCS_MPARX_MASK(mparid));
+		sz += snprintf(config_buf + sz, CONFIG_BUF_SIZE - sz,
+			       "core:%d mparid:%d waymask:0x%llx\n",
+			       cpu, mparid, waymask);
+	}
+
+	/* Copy to the user buffer */
+	return simple_read_from_buffer(buf, count, position, config_buf, sz);
+}
+
+static const struct file_operations otx2_ccu_config_fops = {
+	.read = otx2_ccu_config_read,
+	.write = otx2_ccu_config_write,
+};
+
+static ssize_t otx2_ccu_counter_read(struct file *file, char __user *buf,
+				 size_t count, loff_t *position)
+{
+	int ccu, tad, pid;
+	u64 acnt, hcnt;
+	u32 sz = 0;
+
+	memset(counter_buf, 0, COUNTER_BUF_SIZE);
+
+	/* Read the Allocate and Hit counter values only for MPARIDs
+	 * that were configured.
+	 */
+	for (pid = 0; pid < MPARID_MAX; pid++) {
+		if (!mparid_configured[pid])
+			continue;
+
+		for (ccu = 0; ccu < 4; ccu++) {
+			for (tad = 0; tad < 2; tad++) {
+				acnt = ccureg_read(CCUX_TADX_MPARX_ACNT(ccu, tad, pid));
+				hcnt = ccureg_read(CCUX_TADX_MPARX_HCNT(ccu, tad, pid));
+				sz += snprintf(counter_buf + sz, COUNTER_BUF_SIZE - sz,
+					      "CCU:%d TAD:%d MPARID:%d ALLOC:0x%llx HIT:0x%llx\n",
+					      ccu, tad, pid, acnt, hcnt);
+			}
+		}
+	}
+
+	/* Copy to the user buffer */
+	return simple_read_from_buffer(buf, count, position, counter_buf, sz);
+}
+
+static const struct file_operations otx2_ccu_counter_fops = {
+	.read = otx2_ccu_counter_read,
+};
+
+static int __init otx2_ccu_init(void)
+{
+	u32 cpuid = read_cpuid_id();
+
+	cpuid &= (MIDR_IMPLEMENTOR_MASK | (0xff0 << MIDR_PARTNUM_SHIFT));
+
+	/* Valid only for OcteonTX2 Family */
+	if (((ARM_CPU_IMP_CAVIUM << MIDR_IMPLEMENTOR_SHIFT) |
+	    (0xB0 << MIDR_PARTNUM_SHIFT)) != cpuid)
+		return -ENODEV;
+
+	/* CCU Base address */
+	ccu_base = ioremap(CCU_BASE, 0x4000000);
+	if (IS_ERR(ccu_base)) {
+		pr_err("%s: CCU ioremap failed\n", __func__);
+		return PTR_ERR(ccu_base);
+	}
+
+	/* CCS Base address */
+	ccs_base = ioremap(CCS_BASE, 0x1000);
+	if (IS_ERR(ccs_base)) {
+		pr_err("%s: CCS ioremap failed\n", __func__);
+		return PTR_ERR(ccs_base);
+	}
+
+	/* Add debufs hooks */
+	ccu_dent = debugfs_create_dir("ccu", NULL);
+
+	debugfs_create_u8("mparid", 0644, ccu_dent, &mparid);
+
+	debugfs_create_u64("waymask", 0644, ccu_dent, &waymask);
+
+	debugfs_create_u32("cpumask", 0644, ccu_dent, &cpid_mask);
+
+	debugfs_create_file("config", 0644, ccu_dent, NULL, &otx2_ccu_config_fops);
+
+	debugfs_create_file("counter", 0644, ccu_dent, NULL, &otx2_ccu_counter_fops);
+
+	counter_buf = kzalloc(COUNTER_BUF_SIZE, GFP_KERNEL);
+	if (IS_ERR(counter_buf)) {
+		pr_err("Failed to allocate memory for counter buffer\n");
+		return PTR_ERR(counter_buf);
+	}
+
+	config_buf = kzalloc(CONFIG_BUF_SIZE, GFP_KERNEL);
+	if (IS_ERR(config_buf)) {
+		pr_err("Failed to allocate memory for config buffer\n");
+		kfree(counter_buf);
+		return PTR_ERR(config_buf);
+	}
+
+	/* Zero MPARID is the default configuration for all CPUs at bootup */
+	mparid_configured[0] = 1;
+	return 0;
+}
+
+static void __exit otx2_ccu_exit(void)
+{
+	kfree(config_buf);
+	kfree(counter_buf);
+	debugfs_remove_recursive(ccu_dent);
+}
+
+module_init(otx2_ccu_init);
+module_exit(otx2_ccu_exit);
+
+MODULE_AUTHOR("Marvell International Ltd.");
+MODULE_DESCRIPTION("Marvell OcteonTX2 CCU controller Driver");
+MODULE_LICENSE("GPL v2");
-- 
2.34.1

