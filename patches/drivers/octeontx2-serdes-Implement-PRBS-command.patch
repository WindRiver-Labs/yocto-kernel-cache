From 5a52bbe167193c9522b7d651b2686786112c0419 Mon Sep 17 00:00:00 2001
From: Tomasz Michalec <tomasz@marvell.com>
Date: Thu, 30 Jan 2020 16:22:40 +0100
Subject: [PATCH 484/767] octeontx2-serdes: Implement PRBS command

commit 128bdf7581fb9f7d92e8714ed679363d3ad06953 from
git@git.assembla.com:cavium/WindRiver.linux.git

This patch introduce PRBS command to serdes debugfs by adding
octeontx2_serdes/prbs file. It allows to start and stop PRBS on
specified QLM. When PRBS is running, errors for each QLM lane can be
collected.

debugfs/octeontx2_serdes# echo 2 start 7 > prbs
Above command will start PRBS-7 on QLM2.

debugfs/octeontx2_serdes# cat > prbs
This command output will look like this:
Time: 10 seconds QLM2.Lane0: errors: 3
Time: 10 seconds QLM2.Lane1: errors: 0
Time: 10 seconds QLM2.Lane2: errors: 2
Time: 10 seconds QLM2.Lane3: errors: 3

If PRBS is started on multiple QLMs, the QLM from which output will be
printed is selected by running:
debugfs/octeontx2_serdes# echo <qlm> > prbs

To stop PRBS on QLM2 following command is used:
debugfs/octeontx2_serdes# echo 2 stop > prbs

Change-Id: I3dc7a27e7fc6741cddaddad60e229bc6a5896a4f
Signed-off-by: Tomasz Michalec <tomasz@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/23212
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Chandrakala Chavva <cchavva@marvell.com>
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../marvell/octeontx2-serdes/serdes_debugfs.c | 291 +++++++++++++++++-
 1 file changed, 287 insertions(+), 4 deletions(-)

diff --git a/drivers/soc/marvell/octeontx2-serdes/serdes_debugfs.c b/drivers/soc/marvell/octeontx2-serdes/serdes_debugfs.c
index ebfecbffd4bf..d7f65314829d 100644
--- a/drivers/soc/marvell/octeontx2-serdes/serdes_debugfs.c
+++ b/drivers/soc/marvell/octeontx2-serdes/serdes_debugfs.c
@@ -9,13 +9,15 @@
 
 #ifdef CONFIG_DEBUG_FS
 
-#include <linux/fs.h>
+#include <linux/arm-smccc.h>
 #include <linux/debugfs.h>
+#include <linux/fs.h>
+#include <linux/list.h>
 #include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/string.h>
+#include <linux/time.h>
 #include <linux/uaccess.h>
-#include <linux/arm-smccc.h>
 
 MODULE_AUTHOR("Marvell International Ltd.");
 MODULE_DESCRIPTION("Serdes diagnostic commands for OcteonTX2");
@@ -24,6 +26,9 @@ MODULE_LICENSE("GPL v2");
 #define OCTEONTX_SERDES_DBG_GET_MEM	0xc2000d04
 #define OCTEONTX_SERDES_DBG_GET_EYE	0xc2000d05
 #define OCTEONTX_SERDES_DBG_GET_CONF	0xc2000d06
+#define OCTEONTX_SERDES_DBG_PRBS	0xc2000d07
+
+#define MAX_LMAC_PER_CGX		4
 
 #define OCTEONTX_SMC_PENDING		0x1
 
@@ -36,6 +41,30 @@ enum qlm_type {
 
 struct dentry *pserdes_root;
 
+enum cgx_prbs_cmd {
+	CGX_PRBS_START_CMD = 1,
+	CGX_PRBS_STOP_CMD,
+	CGX_PRBS_GET_DATA_CMD
+};
+
+struct cgx_prbs_errors {
+	u64 err;
+	u64 phy_host;
+	u64 phy_line;
+};
+
+struct cgx_prbs_data {
+	u64 num_lanes;
+	struct cgx_prbs_errors errors[MAX_LMAC_PER_CGX];
+};
+
+struct prbs_status {
+	struct list_head list;
+	int qlm;
+	long start_time;
+	struct prbs_status *next;
+};
+
 struct eye_data {
 	int width;
 	int height;
@@ -55,6 +84,12 @@ static struct {
 	char *res;
 } serdes_cmd_data;
 
+static struct {
+	int qlm;
+	struct prbs_status status_list;
+	struct cgx_prbs_data *res;
+} prbs_cmd_data;
+
 static int serdes_dbg_lane_parse(const char __user *buffer,
 				 size_t count, int *qlm, int *lane)
 {
@@ -78,14 +113,14 @@ static int serdes_dbg_lane_parse(const char __user *buffer,
 	ec = subtoken ? kstrtoint(subtoken, 10, qlm) : -EINVAL;
 
 	if (ec < 0) {
-		kfree(cmd_buf);
+		kfree(cmd_buf_tmp);
 		return ec;
 	}
 
 	subtoken = strsep(&cmd_buf, " ");
 	ec = subtoken ? kstrtoint(subtoken, 10, lane) : -EINVAL;
 
-	kfree(cmd_buf);
+	kfree(cmd_buf_tmp);
 	return ec;
 }
 
@@ -212,6 +247,229 @@ static const struct file_operations serdes_dbg_settings_fops = {
 	.release	= single_release,
 };
 
+static int serdes_dbg_prbs_lane_parse(const char __user *buffer,
+				      size_t count, int *qlm,
+				      enum cgx_prbs_cmd *cmd, int *mode)
+{
+	char *cmd_buf, *cmd_buf_tmp, *subtoken;
+	int ec;
+
+	cmd_buf = memdup_user(buffer, count);
+	if (IS_ERR(cmd_buf))
+		return -ENOMEM;
+
+	cmd_buf[count] = '\0';
+
+	cmd_buf_tmp = strchr(cmd_buf, '\n');
+	if (cmd_buf_tmp) {
+		*cmd_buf_tmp = '\0';
+		count = cmd_buf_tmp - cmd_buf + 1;
+	}
+
+	cmd_buf_tmp = cmd_buf;
+	subtoken = strsep(&cmd_buf, " ");
+	ec = subtoken ? kstrtoint(subtoken, 10, qlm) : -EINVAL;
+
+	if (ec < 0) {
+		kfree(cmd_buf_tmp);
+		return ec;
+	}
+
+	subtoken = strsep(&cmd_buf, " ");
+	if (subtoken == NULL) {
+		*cmd = CGX_PRBS_GET_DATA_CMD;
+	} else {
+		if (!strcmp(subtoken, "start")) {
+			*cmd = CGX_PRBS_START_CMD;
+			subtoken = strsep(&cmd_buf, " ");
+			ec = subtoken ? kstrtoint(subtoken, 10, mode) :
+					-EINVAL;
+		} else if (!strcmp(subtoken, "stop")) {
+			*cmd = CGX_PRBS_STOP_CMD;
+		} else {
+			ec = -EINVAL;
+		}
+	}
+
+	kfree(cmd_buf_tmp);
+	return ec;
+}
+
+static ssize_t serdes_dbg_prbs_write_op(struct file *filp,
+					const char __user *buffer,
+					size_t count, loff_t *ppos)
+{
+	struct prbs_status *status = NULL;
+	struct arm_smccc_res res;
+	enum cgx_prbs_cmd cmd;
+	int mode;
+	int qlm;
+	int ec;
+
+	ec = serdes_dbg_prbs_lane_parse(buffer, count, &prbs_cmd_data.qlm,
+					&cmd, &mode);
+	if (ec < 0) {
+		pr_info("Usage: echo <qlm> [{start <mode>|stop}] > prbs\n");
+		return ec;
+	}
+
+	qlm = prbs_cmd_data.qlm;
+
+	switch (cmd) {
+	case CGX_PRBS_START_CMD:
+		arm_smccc_smc(OCTEONTX_SERDES_DBG_PRBS, cmd,
+			      prbs_cmd_data.qlm, mode, 0, 0, 0, 0, &res);
+
+		list_for_each_entry(status,
+				    &prbs_cmd_data.status_list.list,
+				    list) {
+			if (status->qlm == qlm)
+				break;
+		}
+
+		/*
+		 * If status is head of the list, status for specific
+		 * qlm doesn't exist
+		 */
+		if (&status->list == &prbs_cmd_data.status_list.list)
+			status = NULL;
+
+		if (res.a0 != SMCCC_RET_SUCCESS) {
+			if (status != NULL) {
+				list_del(&status->list);
+				kfree(status);
+			}
+			pr_info("CGX prbs start command failed.\n");
+			return -EIO;
+		}
+
+		if (status == NULL) {
+			status = kmalloc(sizeof(struct prbs_status),
+					 GFP_KERNEL);
+			if (status == NULL)
+				return -ENOMEM;
+			status->qlm = qlm;
+			list_add(&status->list,
+				 &prbs_cmd_data.status_list.list);
+		}
+		status->start_time = get_seconds();
+		pr_info("CGX PRBS-%d start on QLM %d.\n", mode, qlm);
+		break;
+
+	case CGX_PRBS_STOP_CMD:
+		arm_smccc_smc(OCTEONTX_SERDES_DBG_PRBS, cmd,
+			      prbs_cmd_data.qlm, 0, 0, 0, 0, 0, &res);
+		if (res.a0 != SMCCC_RET_SUCCESS) {
+			pr_info("CGX prbs stop command failed.\n");
+			return -EIO;
+		}
+		list_for_each_entry(status,
+				    &prbs_cmd_data.status_list.list,
+				    list) {
+			if (status->qlm == qlm) {
+				list_del(&status->list);
+				kfree(status);
+				break;
+			}
+		}
+		pr_info("CGX PRBS stop on QLM %d.\n", qlm);
+		break;
+
+	default:
+		pr_info("CGX PRBS set QLM %d to read.\n", qlm);
+		break;
+	}
+
+	return count;
+}
+
+static int serdes_dbg_prbs_read_op(struct seq_file *s, void *unused)
+{
+	struct prbs_status *status = NULL;
+	struct cgx_prbs_errors *errors;
+	struct arm_smccc_res res;
+	long time = -1;
+	int num_lanes;
+	int lane;
+	int qlm;
+
+	qlm = prbs_cmd_data.qlm;
+
+	list_for_each_entry(status,
+			    &prbs_cmd_data.status_list.list,
+			    list) {
+		if (status->qlm == qlm) {
+			time = status->start_time;
+			break;
+		}
+	}
+
+	if (time == -1) {
+		seq_printf(s, "CGX PRBS not started for qlm %d.\n", qlm);
+		return 0;
+	}
+	time = get_seconds() - time;
+
+	arm_smccc_smc(OCTEONTX_SERDES_DBG_PRBS, CGX_PRBS_GET_DATA_CMD,
+		      qlm, 0, 0, 0, 0, 0, &res);
+
+	if (res.a0 != SMCCC_RET_SUCCESS) {
+		seq_printf(s, "CGX prbs get command failed for qlm %d.\n", qlm);
+		return 0;
+	}
+
+	errors = prbs_cmd_data.res->errors;
+	num_lanes = prbs_cmd_data.res->num_lanes;
+	if (num_lanes > MAX_LMAC_PER_CGX) {
+		seq_printf(s, "ATF returned status for %d lanes.\n", num_lanes);
+		seq_printf(s, "Kernel support only %d lanes.\n",
+			   MAX_LMAC_PER_CGX);
+		num_lanes = MAX_LMAC_PER_CGX;
+	}
+
+	for (lane = 0; lane < num_lanes; lane++) {
+		seq_printf(s, "Time: %ld seconds QLM%d.Lane%d: errors: ",
+			   time, qlm, lane);
+		if (errors[lane].err != -1)
+			seq_printf(s, "%lld", errors[lane].err);
+		else
+			seq_puts(s, "No lock");
+
+		if (errors[lane].phy_host != -2) {
+			seq_puts(s, ", PHY Host errors: ");
+			if (errors[lane].phy_host != -1)
+				seq_printf(s, "%lld", errors[lane].phy_host);
+			else
+				seq_puts(s, "No lock");
+		}
+
+		if (errors[lane].phy_line != -2) {
+			seq_puts(s, ", PHY Line errors: ");
+			if (errors[lane].phy_line != -1)
+				seq_printf(s, "%lld", errors[lane].phy_line);
+			else
+				seq_puts(s, "No lock");
+		}
+		seq_puts(s, "\n");
+	}
+
+	return 0;
+}
+
+static int serdes_dbg_open_prbs(struct inode *inode, struct file *file)
+{
+	return single_open(file, serdes_dbg_prbs_read_op, inode->i_private);
+}
+
+static const struct file_operations serdes_dbg_prbs_fops = {
+	.owner		= THIS_MODULE,
+	.open		= serdes_dbg_open_prbs,
+	.read		= seq_read,
+	.write		= serdes_dbg_prbs_write_op,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
 static int serdes_dbg_setup_debugfs(void)
 {
 	struct dentry *pfile;
@@ -228,6 +486,11 @@ static int serdes_dbg_setup_debugfs(void)
 	if (!pfile)
 		goto create_failed;
 
+	pfile = debugfs_create_file("prbs", 0644, pserdes_root, NULL,
+				    &serdes_dbg_prbs_fops);
+	if (!pfile)
+		goto create_failed;
+
 	return 0;
 
 create_failed:
@@ -258,10 +521,16 @@ static int serdes_dbg_init(void)
 	if (!serdes_cmd_data.res)
 		goto serdes_mem_init_failed;
 
+	prbs_cmd_data.res = ioremap_wc(res.a3, sizeof(struct cgx_prbs_data));
+	if (!prbs_cmd_data.res)
+		goto serdes_mem_init_failed;
+
 	ec = serdes_dbg_setup_debugfs();
 	if (ec)
 		goto serdes_debugfs_failed;
 
+	INIT_LIST_HEAD(&prbs_cmd_data.status_list.list);
+
 	return 0;
 
 serdes_mem_init_failed:
@@ -274,11 +543,16 @@ static int serdes_dbg_init(void)
 	if (serdes_cmd_data.res)
 		iounmap(serdes_cmd_data.res);
 
+	if (prbs_cmd_data.res)
+		iounmap(prbs_cmd_data.res);
+
 	return 0;
 }
 
 static void serdes_dbg_exit(void)
 {
+	struct prbs_status *status, *n;
+
 	debugfs_remove_recursive(pserdes_root);
 
 	if (eye_cmd_data.res)
@@ -286,6 +560,15 @@ static void serdes_dbg_exit(void)
 
 	if (serdes_cmd_data.res)
 		iounmap(serdes_cmd_data.res);
+
+	if (prbs_cmd_data.res)
+		iounmap(prbs_cmd_data.res);
+
+	list_for_each_entry_safe(status, n,
+				 &prbs_cmd_data.status_list.list,
+				 list) {
+		kfree(status);
+	}
 }
 
 module_init(serdes_dbg_init);
-- 
2.31.1

