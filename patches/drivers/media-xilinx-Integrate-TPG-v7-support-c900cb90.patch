From 169b633affe30931cb16ee3ccce1d22a33d7dd04 Mon Sep 17 00:00:00 2001
From: Radhey Shyam Pandey <radhey.shyam.pandey@xilinx.com>
Date: Wed, 18 Nov 2015 20:55:47 +0530
Subject: [PATCH 0199/1851] media: xilinx: Integrate TPG v7 support

commit 0c5dac4600368e654da33fac284468e669e13c65 from
https://github.com/Xilinx/linux-xlnx.git

Video Test Pattern Generator is a redesigned IP using
Vivado HLS. TPG v7 is functionally similar to previous
TPG versions only difference is in AXI-4 Lite
interface, configuration and programming steps.

media: xilinx: Set correct HLS color mask range
media: xilinx: Fix TPG moving box and cross-hair states
media: xilinx: Correct color mask control max value
media: xilinx: Fix coding style
media: xilinx: Create menu based control for foreground pattern
media: xilinx: Remove HLS based v4l2_ctrl_ops

Signed-off-by: Radhey Shyam Pandey <radhey.shyam.pandey@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
State: pending
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 .../bindings/media/xilinx/xlnx,v-tpg.txt      |   1 +
 drivers/media/platform/xilinx/xilinx-tpg.c    | 411 +++++++++++++-----
 include/uapi/linux/xilinx-v4l2-controls.h     |   2 +
 3 files changed, 310 insertions(+), 104 deletions(-)

diff --git a/Documentation/devicetree/bindings/media/xilinx/xlnx,v-tpg.txt b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-tpg.txt
index 439351ab2a79..ef146e5de49c 100644
--- a/Documentation/devicetree/bindings/media/xilinx/xlnx,v-tpg.txt
+++ b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-tpg.txt
@@ -7,6 +7,7 @@ Required properties:
 
     "xlnx,v-tpg-5.0" (TPG version 5.0)
     "xlnx,v-tpg-6.0" (TPG version 6.0)
+    "xlnx,v-tpg-7.0" (TPG version 7.0)
 
   TPG versions backward-compatible with previous versions should list all
   compatible versions in the newer to older order.
diff --git a/drivers/media/platform/xilinx/xilinx-tpg.c b/drivers/media/platform/xilinx/xilinx-tpg.c
index ed01bedb5db6..c86f0965aecd 100644
--- a/drivers/media/platform/xilinx/xilinx-tpg.c
+++ b/drivers/media/platform/xilinx/xilinx-tpg.c
@@ -20,6 +20,7 @@
 #include <media/v4l2-ctrls.h>
 #include <media/v4l2-subdev.h>
 
+#include "xilinx-hls-common.h"
 #include "xilinx-vip.h"
 #include "xilinx-vtc.h"
 
@@ -58,6 +59,36 @@
 #define XTPG_BAYER_PHASE_BGGR			3
 #define XTPG_BAYER_PHASE_OFF			4
 
+/* TPG v7 is a completely redesigned IP using Vivado HLS
+ * having a different AXI4-Lite interface
+ */
+#define XTPG_HLS_BG_PATTERN			0x0020
+#define XTPG_HLS_FG_PATTERN			0x0028
+#define XTPG_HLS_FG_PATTERN_CROSS_HAIR		(1 << 1)
+#define XTPG_HLS_MASK_ID			0x0030
+#define XTPG_HLS_MOTION_SPEED			0x0038
+#define XTPG_HLS_COLOR_FORMAT			0x0040
+#define XTPG_HLS_COLOR_FORMAT_RGB		0
+#define XTPG_HLS_COLOR_FORMAT_YUV_444		1
+#define XTPG_HLS_COLOR_FORMAT_YUV_422		2
+#define XTPG_HLS_COLOR_FORMAT_YUV_420		3
+#define XTPG_HLS_CROSS_HAIR_HOR			0x0048
+#define XTPG_HLS_CROSS_HAIR_VER			0x0050
+#define XTPG_HLS_ZPLATE_HOR_CNTL_START		0x0058
+#define XTPG_HLS_ZPLATE_HOR_CNTL_DELTA		0x0060
+#define XTPG_HLS_ZPLATE_VER_CNTL_START		0x0068
+#define XTPG_HLS_ZPLATE_VER_CNTL_DELTA		0x0070
+#define XTPG_HLS_BOX_SIZE			0x0078
+#define XTPG_HLS_BOX_COLOR_RED_CB		0x0080
+#define XTPG_HLS_BOX_COLOR_GREEN_CR		0x0088
+#define XTPG_HLS_BOX_COLOR_BLUE_Y		0x0090
+#define XTPG_HLS_ENABLE_INPUT			0x0098
+#define XTPG_HLS_USE_INPUT_VID_STREAM		(1 << 0)
+#define XTPG_HLS_PASS_THRU_START_X		0x00a0
+#define XTPG_HLS_PASS_THRU_START_Y		0x00a8
+#define XTPG_HLS_PASS_THRU_END_X		0x00b0
+#define XTPG_HLS_PASS_THRU_END_Y		0x00b8
+
 /*
  * The minimum blanking value is one clock cycle for the front porch, one clock
  * cycle for the sync pulse and one clock cycle for the back porch.
@@ -82,6 +113,7 @@
  * @vblank: vertical blanking control
  * @pattern: test pattern control
  * @streaming: is the video stream active
+ * @is_hls: whether the IP core is HLS based
  * @vtc: video timing controller
  * @vtmux_gpio: video timing mux GPIO
  */
@@ -102,6 +134,7 @@ struct xtpg_device {
 	struct v4l2_ctrl *vblank;
 	struct v4l2_ctrl *pattern;
 	bool streaming;
+	bool is_hls;
 
 	struct xvtc_device *vtc;
 	struct gpio_desc *vtmux_gpio;
@@ -171,9 +204,15 @@ static int xtpg_s_stream(struct v4l2_subdev *subdev, int enable)
 	unsigned int height = xtpg->formats[0].height;
 	bool passthrough;
 	u32 bayer_phase;
+	u32 xtpg_pattern_offset;
 
 	if (!enable) {
-		xvip_stop(&xtpg->xvip);
+		if (xtpg->is_hls)
+			/* Disable auto-start */
+			xvip_write(&xtpg->xvip, XVIP_CTRL_CONTROL, 0x0);
+		else
+			xvip_stop(&xtpg->xvip);
+
 		if (xtpg->vtc)
 			xvtc_generator_stop(xtpg->vtc);
 
@@ -182,7 +221,28 @@ static int xtpg_s_stream(struct v4l2_subdev *subdev, int enable)
 		return 0;
 	}
 
-	xvip_set_frame_size(&xtpg->xvip, &xtpg->formats[0]);
+	if (xtpg->is_hls) {
+		u32 fmt;
+
+		switch (xtpg->vip_format->fourcc) {
+		case V4L2_PIX_FMT_YUYV:
+			fmt = XTPG_HLS_COLOR_FORMAT_YUV_422;
+			break;
+		case V4L2_PIX_FMT_YUV444:
+			fmt = XTPG_HLS_COLOR_FORMAT_YUV_444;
+			break;
+		case V4L2_PIX_FMT_RGB24:
+			fmt = XTPG_HLS_COLOR_FORMAT_RGB;
+			break;
+		}
+		xvip_write(&xtpg->xvip, XTPG_HLS_COLOR_FORMAT, fmt);
+		xvip_write(&xtpg->xvip, XHLS_REG_COLS, width);
+		xvip_write(&xtpg->xvip, XHLS_REG_ROWS, height);
+		xtpg_pattern_offset = XTPG_HLS_BG_PATTERN;
+	} else {
+		xvip_set_frame_size(&xtpg->xvip, &xtpg->formats[0]);
+		xtpg_pattern_offset = XTPG_PATTERN_CONTROL;
+	}
 
 	if (xtpg->vtc) {
 		struct xvtc_config config = {
@@ -215,7 +275,7 @@ static int xtpg_s_stream(struct v4l2_subdev *subdev, int enable)
 	 */
 	mutex_lock(xtpg->ctrl_handler.lock);
 
-	xvip_clr_and_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,
+	xvip_clr_and_set(&xtpg->xvip, xtpg_pattern_offset,
 			 XTPG_PATTERN_MASK, xtpg->pattern->cur.val);
 
 	/*
@@ -229,18 +289,26 @@ static int xtpg_s_stream(struct v4l2_subdev *subdev, int enable)
 
 	mutex_unlock(xtpg->ctrl_handler.lock);
 
-	/*
-	 * For TPG v5.0, the bayer phase needs to be off for the pass through
-	 * mode, otherwise the external input would be subsampled.
-	 */
-	bayer_phase = passthrough ? XTPG_BAYER_PHASE_OFF
-		    : xtpg_get_bayer_phase(xtpg->formats[0].code);
-	xvip_write(&xtpg->xvip, XTPG_BAYER_PHASE, bayer_phase);
-
 	if (xtpg->vtmux_gpio)
 		gpiod_set_value_cansleep(xtpg->vtmux_gpio, !passthrough);
 
-	xvip_start(&xtpg->xvip);
+	if (xtpg->is_hls) {
+		xvip_set(&xtpg->xvip, XTPG_HLS_ENABLE_INPUT,
+			 XTPG_HLS_USE_INPUT_VID_STREAM);
+		xvip_set(&xtpg->xvip, XVIP_CTRL_CONTROL,
+			 XHLS_REG_CTRL_AUTO_RESTART |
+			 XVIP_CTRL_CONTROL_SW_ENABLE);
+	} else {
+		/*
+		 * For TPG v5.0, the bayer phase needs to be off for the pass
+		 * through mode, otherwise the external input would
+		 * be subsampled.
+		 */
+		bayer_phase = passthrough ? XTPG_BAYER_PHASE_OFF
+			    : xtpg_get_bayer_phase(xtpg->formats[0].code);
+		xvip_write(&xtpg->xvip, XTPG_BAYER_PHASE, bayer_phase);
+		xvip_start(&xtpg->xvip);
+	}
 
 	return 0;
 }
@@ -374,8 +442,12 @@ static int xtpg_s_ctrl(struct v4l2_ctrl *ctrl)
 						ctrl_handler);
 	switch (ctrl->id) {
 	case V4L2_CID_TEST_PATTERN:
-		xvip_clr_and_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,
-				 XTPG_PATTERN_MASK, ctrl->val);
+		if (xtpg->is_hls)
+			xvip_write(&xtpg->xvip, XTPG_HLS_BG_PATTERN,
+				   ctrl->val);
+		else
+			xvip_clr_and_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,
+					 XTPG_PATTERN_MASK, ctrl->val);
 		return 0;
 	case V4L2_CID_XILINX_TPG_CROSS_HAIRS:
 		xvip_clr_or_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,
@@ -386,10 +458,13 @@ static int xtpg_s_ctrl(struct v4l2_ctrl *ctrl)
 				XTPG_PATTERN_CONTROL_MOVING_BOX, ctrl->val);
 		return 0;
 	case V4L2_CID_XILINX_TPG_COLOR_MASK:
-		xvip_clr_and_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,
-				 XTPG_PATTERN_CONTROL_COLOR_MASK_MASK,
-				 ctrl->val <<
-				 XTPG_PATTERN_CONTROL_COLOR_MASK_SHIFT);
+		if (xtpg->is_hls)
+			xvip_write(&xtpg->xvip, XTPG_HLS_MASK_ID, ctrl->val);
+		else
+			xvip_clr_and_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,
+				      XTPG_PATTERN_CONTROL_COLOR_MASK_MASK,
+				      ctrl->val <<
+				      XTPG_PATTERN_CONTROL_COLOR_MASK_SHIFT);
 		return 0;
 	case V4L2_CID_XILINX_TPG_STUCK_PIXEL:
 		xvip_clr_or_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,
@@ -404,43 +479,85 @@ static int xtpg_s_ctrl(struct v4l2_ctrl *ctrl)
 				XTPG_PATTERN_CONTROL_MOTION, ctrl->val);
 		return 0;
 	case V4L2_CID_XILINX_TPG_MOTION_SPEED:
-		xvip_write(&xtpg->xvip, XTPG_MOTION_SPEED, ctrl->val);
+		if (xtpg->is_hls)
+			xvip_write(&xtpg->xvip, XTPG_HLS_MOTION_SPEED,
+				   ctrl->val);
+		else
+			xvip_write(&xtpg->xvip, XTPG_MOTION_SPEED, ctrl->val);
 		return 0;
 	case V4L2_CID_XILINX_TPG_CROSS_HAIR_ROW:
-		xvip_clr_and_set(&xtpg->xvip, XTPG_CROSS_HAIRS,
-				 XTPG_CROSS_HAIRS_ROW_MASK,
-				 ctrl->val << XTPG_CROSS_HAIRS_ROW_SHIFT);
+		if (xtpg->is_hls)
+			xvip_write(&xtpg->xvip, XTPG_HLS_CROSS_HAIR_HOR,
+				    ctrl->val);
+		else
+			xvip_clr_and_set(&xtpg->xvip, XTPG_CROSS_HAIRS,
+					 XTPG_CROSS_HAIRS_ROW_MASK,
+					 ctrl->val <<
+					 XTPG_CROSS_HAIRS_ROW_SHIFT);
 		return 0;
 	case V4L2_CID_XILINX_TPG_CROSS_HAIR_COLUMN:
-		xvip_clr_and_set(&xtpg->xvip, XTPG_CROSS_HAIRS,
-				 XTPG_CROSS_HAIRS_COLUMN_MASK,
-				 ctrl->val << XTPG_CROSS_HAIRS_COLUMN_SHIFT);
+		if (xtpg->is_hls)
+			xvip_write(&xtpg->xvip, XTPG_HLS_CROSS_HAIR_VER,
+				   ctrl->val);
+		else
+			xvip_clr_and_set(&xtpg->xvip, XTPG_CROSS_HAIRS,
+					 XTPG_CROSS_HAIRS_COLUMN_MASK,
+					 ctrl->val <<
+					 XTPG_CROSS_HAIRS_COLUMN_SHIFT);
 		return 0;
 	case V4L2_CID_XILINX_TPG_ZPLATE_HOR_START:
-		xvip_clr_and_set(&xtpg->xvip, XTPG_ZPLATE_HOR_CONTROL,
-				 XTPG_ZPLATE_START_MASK,
-				 ctrl->val << XTPG_ZPLATE_START_SHIFT);
+		if (xtpg->is_hls)
+			xvip_write(&xtpg->xvip, XTPG_HLS_ZPLATE_HOR_CNTL_START,
+				   ctrl->val);
+		else
+			xvip_clr_and_set(&xtpg->xvip, XTPG_ZPLATE_HOR_CONTROL,
+					 XTPG_ZPLATE_START_MASK,
+					 ctrl->val << XTPG_ZPLATE_START_SHIFT);
 		return 0;
 	case V4L2_CID_XILINX_TPG_ZPLATE_HOR_SPEED:
-		xvip_clr_and_set(&xtpg->xvip, XTPG_ZPLATE_HOR_CONTROL,
-				 XTPG_ZPLATE_SPEED_MASK,
-				 ctrl->val << XTPG_ZPLATE_SPEED_SHIFT);
+		if (xtpg->is_hls)
+			xvip_write(&xtpg->xvip, XTPG_HLS_ZPLATE_HOR_CNTL_DELTA,
+				   ctrl->val);
+		else
+			xvip_clr_and_set(&xtpg->xvip, XTPG_ZPLATE_HOR_CONTROL,
+					 XTPG_ZPLATE_SPEED_MASK,
+					 ctrl->val << XTPG_ZPLATE_SPEED_SHIFT);
 		return 0;
 	case V4L2_CID_XILINX_TPG_ZPLATE_VER_START:
-		xvip_clr_and_set(&xtpg->xvip, XTPG_ZPLATE_VER_CONTROL,
-				 XTPG_ZPLATE_START_MASK,
-				 ctrl->val << XTPG_ZPLATE_START_SHIFT);
+		if (xtpg->is_hls)
+			xvip_write(&xtpg->xvip, XTPG_HLS_ZPLATE_VER_CNTL_START,
+				   ctrl->val);
+		else
+			xvip_clr_and_set(&xtpg->xvip, XTPG_ZPLATE_VER_CONTROL,
+					 XTPG_ZPLATE_START_MASK,
+					 ctrl->val << XTPG_ZPLATE_START_SHIFT);
 		return 0;
 	case V4L2_CID_XILINX_TPG_ZPLATE_VER_SPEED:
-		xvip_clr_and_set(&xtpg->xvip, XTPG_ZPLATE_VER_CONTROL,
-				 XTPG_ZPLATE_SPEED_MASK,
-				 ctrl->val << XTPG_ZPLATE_SPEED_SHIFT);
+		if (xtpg->is_hls)
+			xvip_write(&xtpg->xvip, XTPG_HLS_ZPLATE_VER_CNTL_DELTA,
+				   ctrl->val);
+		else
+			xvip_clr_and_set(&xtpg->xvip, XTPG_ZPLATE_VER_CONTROL,
+					 XTPG_ZPLATE_SPEED_MASK,
+					 ctrl->val << XTPG_ZPLATE_SPEED_SHIFT);
 		return 0;
 	case V4L2_CID_XILINX_TPG_BOX_SIZE:
-		xvip_write(&xtpg->xvip, XTPG_BOX_SIZE, ctrl->val);
+		if (xtpg->is_hls)
+			xvip_write(&xtpg->xvip, XTPG_HLS_BOX_SIZE, ctrl->val);
+		else
+			xvip_write(&xtpg->xvip, XTPG_BOX_SIZE, ctrl->val);
 		return 0;
 	case V4L2_CID_XILINX_TPG_BOX_COLOR:
-		xvip_write(&xtpg->xvip, XTPG_BOX_COLOR, ctrl->val);
+		if (xtpg->is_hls) {
+			xvip_write(&xtpg->xvip, XTPG_HLS_BOX_COLOR_RED_CB,
+				   ctrl->val >> 16);
+			xvip_write(&xtpg->xvip, XTPG_HLS_BOX_COLOR_GREEN_CR,
+				   ctrl->val >> 8);
+			xvip_write(&xtpg->xvip, XTPG_HLS_BOX_COLOR_BLUE_Y,
+				   ctrl->val);
+		} else {
+			xvip_write(&xtpg->xvip, XTPG_BOX_COLOR, ctrl->val);
+		}
 		return 0;
 	case V4L2_CID_XILINX_TPG_STUCK_PIXEL_THRESH:
 		xvip_write(&xtpg->xvip, XTPG_STUCK_PIXEL_THRESH, ctrl->val);
@@ -448,6 +565,9 @@ static int xtpg_s_ctrl(struct v4l2_ctrl *ctrl)
 	case V4L2_CID_XILINX_TPG_NOISE_GAIN:
 		xvip_write(&xtpg->xvip, XTPG_NOISE_GAIN, ctrl->val);
 		return 0;
+	case V4L2_CID_XILINX_TPG_HLS_FG_PATTERN:
+		xvip_write(&xtpg->xvip, XTPG_HLS_FG_PATTERN, ctrl->val);
+		return 0;
 	}
 
 	return 0;
@@ -505,60 +625,50 @@ static const char *const xtpg_pattern_strings[] = {
 	"Black/White Checker Board",
 };
 
-static struct v4l2_ctrl_config xtpg_ctrls[] = {
+static const char *const xtpg_hls_pattern_strings[] = {
+	"Passthrough",
+	"Horizontal Ramp",
+	"Vertical Ramp",
+	"Temporal Ramp",
+	"Solid Red",
+	"Solid Green",
+	"Solid Blue",
+	"Solid Black",
+	"Solid White",
+	"Color Bars",
+	"Zone Plate",
+	"Tartan Color Bars",
+	"Cross Hatch",
+	"Color Sweep",
+	"Vertical/Horizontal Ramps",
+	"Black/White Checker Board",
+};
+
+static const char *const xtpg_hls_fg_strings[] = {
+	"No Overlay",
+	"Moving Box",
+	"Cross Hairs",
+};
+
+static const struct v4l2_ctrl_config xtpg_hls_fg_ctrl = {
+	.ops	= &xtpg_ctrl_ops,
+	.id     = V4L2_CID_XILINX_TPG_HLS_FG_PATTERN,
+	.name   = "Test Pattern: Foreground Pattern",
+	.type   = V4L2_CTRL_TYPE_MENU,
+	.min	= 0,
+	.max	= ARRAY_SIZE(xtpg_hls_fg_strings) - 1,
+	.qmenu	= xtpg_hls_fg_strings,
+};
+
+static struct v4l2_ctrl_config xtpg_common_ctrls[] = {
 	{
-		.ops	= &xtpg_ctrl_ops,
-		.id	= V4L2_CID_XILINX_TPG_CROSS_HAIRS,
-		.name	= "Test Pattern: Cross Hairs",
-		.type	= V4L2_CTRL_TYPE_BOOLEAN,
-		.min	= false,
-		.max	= true,
-		.step	= 1,
-		.def	= 0,
-	}, {
-		.ops	= &xtpg_ctrl_ops,
-		.id	= V4L2_CID_XILINX_TPG_MOVING_BOX,
-		.name	= "Test Pattern: Moving Box",
-		.type	= V4L2_CTRL_TYPE_BOOLEAN,
-		.min	= false,
-		.max	= true,
-		.step	= 1,
-		.def	= 0,
-	}, {
-		.ops	= &xtpg_ctrl_ops,
-		.id	= V4L2_CID_XILINX_TPG_COLOR_MASK,
-		.name	= "Test Pattern: Color Mask",
-		.type	= V4L2_CTRL_TYPE_BITMASK,
-		.min	= 0,
-		.max	= 0xf,
-		.def	= 0,
-	}, {
-		.ops	= &xtpg_ctrl_ops,
-		.id	= V4L2_CID_XILINX_TPG_STUCK_PIXEL,
-		.name	= "Test Pattern: Stuck Pixel",
-		.type	= V4L2_CTRL_TYPE_BOOLEAN,
-		.min	= false,
-		.max	= true,
-		.step	= 1,
-		.def	= 0,
-	}, {
-		.ops	= &xtpg_ctrl_ops,
-		.id	= V4L2_CID_XILINX_TPG_NOISE,
-		.name	= "Test Pattern: Noise",
-		.type	= V4L2_CTRL_TYPE_BOOLEAN,
-		.min	= false,
-		.max	= true,
-		.step	= 1,
-		.def	= 0,
-	}, {
-		.ops	= &xtpg_ctrl_ops,
-		.id	= V4L2_CID_XILINX_TPG_MOTION,
-		.name	= "Test Pattern: Motion",
-		.type	= V4L2_CTRL_TYPE_BOOLEAN,
-		.min	= false,
-		.max	= true,
-		.step	= 1,
-		.def	= 0,
+		.ops    = &xtpg_ctrl_ops,
+		.id     = V4L2_CID_XILINX_TPG_COLOR_MASK,
+		.name   = "Test Pattern: Color Mask",
+		.type   = V4L2_CTRL_TYPE_BITMASK,
+		.min    = 0,
+		.max    = 0x7,
+		.def    = 0,
 	}, {
 		.ops	= &xtpg_ctrl_ops,
 		.id	= V4L2_CID_XILINX_TPG_MOTION_SPEED,
@@ -642,12 +752,61 @@ static struct v4l2_ctrl_config xtpg_ctrls[] = {
 	}, {
 		.ops	= &xtpg_ctrl_ops,
 		.id	= V4L2_CID_XILINX_TPG_BOX_COLOR,
-		.name	= "Test Pattern: Box Color(RGB)",
+		.name	= "Test Pattern: Box Color(RGB/YCbCr)",
 		.type	= V4L2_CTRL_TYPE_INTEGER,
 		.min	= 0,
 		.max	= (1 << 24) - 1,
 		.step	= 1,
 		.def	= 0,
+	},
+};
+
+static struct v4l2_ctrl_config xtpg_ctrls[] = {
+	{
+		.ops	= &xtpg_ctrl_ops,
+		.id	= V4L2_CID_XILINX_TPG_CROSS_HAIRS,
+		.name	= "Test Pattern: Cross Hairs",
+		.type	= V4L2_CTRL_TYPE_BOOLEAN,
+		.min	= false,
+		.max	= true,
+		.step	= 1,
+		.def	= 0,
+	}, {
+		.ops	= &xtpg_ctrl_ops,
+		.id	= V4L2_CID_XILINX_TPG_MOVING_BOX,
+		.name	= "Test Pattern: Moving Box",
+		.type	= V4L2_CTRL_TYPE_BOOLEAN,
+		.min	= false,
+		.max	= true,
+		.step	= 1,
+		.def	= 0,
+	}, {
+		.ops	= &xtpg_ctrl_ops,
+		.id	= V4L2_CID_XILINX_TPG_STUCK_PIXEL,
+		.name	= "Test Pattern: Stuck Pixel",
+		.type	= V4L2_CTRL_TYPE_BOOLEAN,
+		.min	= false,
+		.max	= true,
+		.step	= 1,
+		.def	= 0,
+	}, {
+		.ops	= &xtpg_ctrl_ops,
+		.id	= V4L2_CID_XILINX_TPG_NOISE,
+		.name	= "Test Pattern: Noise",
+		.type	= V4L2_CTRL_TYPE_BOOLEAN,
+		.min	= false,
+		.max	= true,
+		.step	= 1,
+		.def	= 0,
+	}, {
+		.ops	= &xtpg_ctrl_ops,
+		.id	= V4L2_CID_XILINX_TPG_MOTION,
+		.name	= "Test Pattern: Motion",
+		.type	= V4L2_CTRL_TYPE_BOOLEAN,
+		.min	= false,
+		.max	= true,
+		.step	= 1,
+		.def	= 0,
 	}, {
 		.ops	= &xtpg_ctrl_ops,
 		.id	= V4L2_CID_XILINX_TPG_STUCK_PIXEL_THRESH,
@@ -714,6 +873,9 @@ static int xtpg_parse_of(struct xtpg_device *xtpg)
 	unsigned int nports = 0;
 	bool has_endpoint = false;
 
+	if (of_device_is_compatible(dev->of_node, "xlnx,v-tpg-7.0"))
+		xtpg->is_hls = true;
+
 	ports = of_get_child_by_name(node, "ports");
 	if (ports == NULL)
 		ports = node;
@@ -769,6 +931,7 @@ static int xtpg_probe(struct platform_device *pdev)
 	struct v4l2_subdev *subdev;
 	struct xtpg_device *xtpg;
 	u32 i, bayer_phase;
+	u32 npatterns;
 	int ret;
 
 	xtpg = devm_kzalloc(&pdev->dev, sizeof(*xtpg), GFP_KERNEL);
@@ -798,8 +961,9 @@ static int xtpg_probe(struct platform_device *pdev)
 		goto error_resource;
 	}
 
-	/* Reset and initialize the core */
-	xvip_reset(&xtpg->xvip);
+	/* Reset and initialize the core - No reset for HLS based TPG version */
+	if (!xtpg->is_hls)
+		xvip_reset(&xtpg->xvip);
 
 	/* Initialize V4L2 subdevice and media entity. Pad numbers depend on the
 	 * number of pads.
@@ -815,10 +979,20 @@ static int xtpg_probe(struct platform_device *pdev)
 	xtpg->default_format.code = xtpg->vip_format->code;
 	xtpg->default_format.field = V4L2_FIELD_NONE;
 	xtpg->default_format.colorspace = V4L2_COLORSPACE_SRGB;
-	xvip_get_frame_size(&xtpg->xvip, &xtpg->default_format);
+
+	if (xtpg->is_hls) {
+		npatterns = ARRAY_SIZE(xtpg_hls_pattern_strings);
+		xtpg->default_format.width = xvip_read(&xtpg->xvip,
+						       XHLS_REG_COLS);
+		xtpg->default_format.height = xvip_read(&xtpg->xvip,
+							XHLS_REG_ROWS);
+	} else {
+		npatterns = ARRAY_SIZE(xtpg_pattern_strings);
+		xvip_get_frame_size(&xtpg->xvip, &xtpg->default_format);
+	}
 
 	bayer_phase = xtpg_get_bayer_phase(xtpg->vip_format->code);
-	if (bayer_phase != XTPG_BAYER_PHASE_OFF)
+	if (!xtpg->is_hls && bayer_phase != XTPG_BAYER_PHASE_OFF)
 		xtpg->bayer = true;
 
 	xtpg->formats[0] = xtpg->default_format;
@@ -839,7 +1013,13 @@ static int xtpg_probe(struct platform_device *pdev)
 	if (ret < 0)
 		goto error;
 
-	v4l2_ctrl_handler_init(&xtpg->ctrl_handler, 3 + ARRAY_SIZE(xtpg_ctrls));
+	if (xtpg->is_hls)
+		v4l2_ctrl_handler_init(&xtpg->ctrl_handler, 4 +
+				       ARRAY_SIZE(xtpg_common_ctrls));
+	else
+		v4l2_ctrl_handler_init(&xtpg->ctrl_handler, 3 +
+				       ARRAY_SIZE(xtpg_common_ctrls) +
+				       ARRAY_SIZE(xtpg_ctrls));
 
 	xtpg->vblank = v4l2_ctrl_new_std(&xtpg->ctrl_handler, &xtpg_ctrl_ops,
 					 V4L2_CID_VBLANK, XTPG_MIN_VBLANK,
@@ -847,19 +1027,41 @@ static int xtpg_probe(struct platform_device *pdev)
 	xtpg->hblank = v4l2_ctrl_new_std(&xtpg->ctrl_handler, &xtpg_ctrl_ops,
 					 V4L2_CID_HBLANK, XTPG_MIN_HBLANK,
 					 XTPG_MAX_HBLANK, 1, 100);
-	xtpg->pattern = v4l2_ctrl_new_std_menu_items(&xtpg->ctrl_handler,
-					&xtpg_ctrl_ops, V4L2_CID_TEST_PATTERN,
-					ARRAY_SIZE(xtpg_pattern_strings) - 1,
-					1, 9, xtpg_pattern_strings);
 
-	for (i = 0; i < ARRAY_SIZE(xtpg_ctrls); i++)
-		v4l2_ctrl_new_custom(&xtpg->ctrl_handler, &xtpg_ctrls[i], NULL);
+	if (xtpg->is_hls) {
+		xtpg->pattern =
+			v4l2_ctrl_new_std_menu_items(&xtpg->ctrl_handler,
+						     &xtpg_ctrl_ops,
+						     V4L2_CID_TEST_PATTERN,
+						     npatterns - 1,
+						     1, 9,
+						     xtpg_hls_pattern_strings);
+		v4l2_ctrl_new_custom(&xtpg->ctrl_handler,
+				     &xtpg_hls_fg_ctrl, NULL);
+	} else {
+		xtpg->pattern =
+			v4l2_ctrl_new_std_menu_items(&xtpg->ctrl_handler,
+						     &xtpg_ctrl_ops,
+						     V4L2_CID_TEST_PATTERN,
+						     npatterns - 1,
+						     1, 9,
+						     xtpg_pattern_strings);
+
+		for (i = 0; i < ARRAY_SIZE(xtpg_ctrls); i++)
+			v4l2_ctrl_new_custom(&xtpg->ctrl_handler,
+					     &xtpg_ctrls[i], NULL);
+	}
+
+	for (i = 0; i < ARRAY_SIZE(xtpg_common_ctrls); i++)
+		v4l2_ctrl_new_custom(&xtpg->ctrl_handler,
+				     &xtpg_common_ctrls[i], NULL);
 
 	if (xtpg->ctrl_handler.error) {
 		dev_err(&pdev->dev, "failed to add controls\n");
 		ret = xtpg->ctrl_handler.error;
 		goto error;
 	}
+
 	subdev->ctrl_handler = &xtpg->ctrl_handler;
 
 	xtpg_update_pattern_control(xtpg, true, true);
@@ -909,6 +1111,7 @@ static SIMPLE_DEV_PM_OPS(xtpg_pm_ops, xtpg_pm_suspend, xtpg_pm_resume);
 
 static const struct of_device_id xtpg_of_id_table[] = {
 	{ .compatible = "xlnx,v-tpg-5.0" },
+	{ .compatible = "xlnx,v-tpg-7.0" },
 	{ }
 };
 MODULE_DEVICE_TABLE(of, xtpg_of_id_table);
diff --git a/include/uapi/linux/xilinx-v4l2-controls.h b/include/uapi/linux/xilinx-v4l2-controls.h
index e3029c18b33d..9364551ec007 100644
--- a/include/uapi/linux/xilinx-v4l2-controls.h
+++ b/include/uapi/linux/xilinx-v4l2-controls.h
@@ -70,6 +70,8 @@
 #define V4L2_CID_XILINX_TPG_STUCK_PIXEL_THRESH	(V4L2_CID_XILINX_TPG + 16)
 /* Noise level */
 #define V4L2_CID_XILINX_TPG_NOISE_GAIN		(V4L2_CID_XILINX_TPG + 17)
+/* Foreground pattern (HLS)*/
+#define V4L2_CID_XILINX_TPG_HLS_FG_PATTERN     (V4L2_CID_XILINX_TPG + 18)
 
 /*
  * Xilinx CRESAMPLE Video IP
-- 
2.31.1

