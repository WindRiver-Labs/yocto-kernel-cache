From e9cd2d3ba4167e35776e38992c26d261c6946f43 Mon Sep 17 00:00:00 2001
From: Harman Kalra <hkalra@marvell.com>
Date: Tue, 18 May 2021 18:46:33 +0530
Subject: [PATCH 1536/1921] octeontx2-af: fix atomic load on NPA LF registers

As only 64 bit atomic load and add (ldadd) is permitted
on certain LF registers like NPA_LF_AURA_OP_CNT register,
any other operation on corresponding register addresses
results in EL3 exception from ASIM.
Currently atomic64_fetch_add_relaxed() is used to perform
required operation on NPA_LF_AURA_OP_CNT, but this doesn't
get translated to ldadd but to combinaton of
(ldxr, add, stxr, cbnz) which resulted in exception.
Enforcing the ldadd operation on required register using
asm call to resolve the issue.

Fixes: 5ef19744c58d ("octeontx2-af: drain XAQ buffers before lf teardown")

Change-Id: I9ca46fad62944ed58f873f021b967cb9cf756592
Signed-off-by: Harman Kalra <hkalra@marvell.com>
Signed-off-by: Pavan Nikhilesh <pbhagavatula@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/52031
Reviewed-by: Jerin Jacob Kollanukkaran <jerinj@marvell.com>
Reviewed-by: Sunil Kovvuri Goutham <sgoutham@marvell.com>
Tested-by: Sunil Kovvuri Goutham <sgoutham@marvell.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 .../net/ethernet/marvell/octeontx2/af/rvu_sso.c    | 14 +++++++++++++-
 1 file changed, 13 insertions(+), 1 deletion(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_sso.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_sso.c
index b19ba020ad54..0d667d8a8451 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_sso.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_sso.c
@@ -27,6 +27,14 @@
 			 :						\
 			 [x0]"r"(val0), [x1]"r"(val1), [p1]"r"(addr));	\
 	})
+
+#define rvu_sso_ldadd(result, incr, ptr) ({				\
+	__asm__ volatile(".cpu   generic+lse\n"                         \
+			 "ldadd %x[i], %x[r], [%[b]]"                   \
+			 : [r] "=r" (result), "+m" (*ptr)               \
+			 : [i] "r" (incr), [b] "r" (ptr)                \
+			 : "memory");                                   \
+	})
 #else
 #define rvu_sso_store_pair(val0, val1, addr)				\
 	do {								\
@@ -34,6 +42,10 @@
 		*addr1 = val0;						\
 		*(u64 *)(((u8 *)addr1) + 8) = val1;			\
 	} while (0)
+
+#define rvu_sso_ldadd(result, incr, ptr)				\
+	do {                                                            \
+	} while (0)
 #endif
 
 #define SSO_AF_INT_DIGEST_PRNT(reg)					\
@@ -669,7 +681,7 @@ int rvu_sso_poll_aura_cnt(struct rvu *rvu, int npa_blkaddr, int aura)
 	addr = rvu->afreg_base + ((npa_blkaddr << 28) |
 				  NPA_AF_BAR2_ALIASX(0, NPA_LF_AURA_OP_CNT));
 again:
-	res = atomic64_fetch_add_relaxed(wdata, (atomic64_t *)addr);
+	rvu_sso_ldadd(res, wdata, addr);
 	if (res & BIT_ULL(42))
 		return 0;
 	if (!(res & 0xFFFFFFFFF))
-- 
2.31.1

