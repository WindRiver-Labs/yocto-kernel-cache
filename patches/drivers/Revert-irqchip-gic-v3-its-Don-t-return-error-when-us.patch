From 357a83dc0a83c5b161a20d00aafa84bcdf0523a7 Mon Sep 17 00:00:00 2001
From: Haiqing Bai <Haiqing.Bai@windriver.com>
Date: Fri, 16 Oct 2020 07:39:02 +0000
Subject: [PATCH 645/767] Revert "irqchip/gic-v3-its: Don't return error when
 using mem region from atf"

This reverts commit fd2f0156e49a34bef3f97d10685079cf76aaccc4.

This patch is used to fix the crash caused by:
commit cefeae7aaa6a16eea5c7efe2926deae0370dc6ff
(drivers: gicv3: fetches atf mem region for LPI prop and pend tables)
It is confirmed that the commit should not be backported for there is
already the same function implemented in the kernel

Signed-off-by: Haiqing Bai <Haiqing.Bai@windriver.com>
---
 drivers/irqchip/irq-gic-v3-fixes.c |  1 -
 drivers/irqchip/irq-gic-v3-its.c   | 20 +++++++++++---------
 2 files changed, 11 insertions(+), 10 deletions(-)

diff --git a/drivers/irqchip/irq-gic-v3-fixes.c b/drivers/irqchip/irq-gic-v3-fixes.c
index 01a2f36ef87f..e9f7548ba7fe 100644
--- a/drivers/irqchip/irq-gic-v3-fixes.c
+++ b/drivers/irqchip/irq-gic-v3-fixes.c
@@ -187,7 +187,6 @@ struct page *its_prop_alloc_pages(struct rdists *gic_rdists,
 
 		gic_rdists->prop_table_pa = page_to_phys(prop_page);
 		gic_rdists->prop_table_va = page_address(prop_page);
-		gic_rdists->prop_page = prop_page;
 	}
 
 	return prop_page;
diff --git a/drivers/irqchip/irq-gic-v3-its.c b/drivers/irqchip/irq-gic-v3-its.c
index f8a17d81a357..e2003100639a 100644
--- a/drivers/irqchip/irq-gic-v3-its.c
+++ b/drivers/irqchip/irq-gic-v3-its.c
@@ -1710,11 +1710,13 @@ static int __init its_setup_lpi_prop_table(void)
 				    GICD_TYPER_ID_BITS(gic_rdists->gicd_typer),
 				    ITS_MAX_LPI_NRBITS);
 		page = its_allocate_prop_table(GFP_NOWAIT);
-		if (!page && !gic_rdists->prop_table_va) {
+		if (!page) {
 			pr_err("Failed to allocate PROPBASE\n");
 			return -ENOMEM;
 		}
 
+		gic_rdists->prop_table_pa = page_to_phys(page);
+		gic_rdists->prop_table_va = page_address(page);
 		WARN_ON(gic_reserve_range(gic_rdists->prop_table_pa,
 					  LPI_PROPBASE_SZ));
 	}
@@ -2075,7 +2077,7 @@ static int __init allocate_lpi_tables(void)
 		struct page *pend_page;
 
 		pend_page = its_allocate_pending_table(GFP_NOWAIT);
-		if (!pend_page && !gic_data_rdist()->pend_vaddr) {
+		if (!pend_page) {
 			pr_err("Failed to allocate PENDBASE for CPU%d\n", cpu);
 			return -ENOMEM;
 		}
@@ -2112,6 +2114,7 @@ static u64 its_clear_vpend_valid(void __iomem *vlpi_base)
 static void its_cpu_init_lpis(void)
 {
 	void __iomem *rbase = gic_data_rdist_rd_base();
+	struct page *pend_page;
 	phys_addr_t paddr;
 	u64 val, tmp;
 
@@ -2134,15 +2137,14 @@ static void its_cpu_init_lpis(void)
 		paddr &= GENMASK_ULL(51, 16);
 
 		WARN_ON(!gic_check_reserved_range(paddr, LPI_PENDBASE_SZ));
-		if (gic_data_rdist()->pend_page) {
-			its_free_pending_table(gic_data_rdist()->pend_page);
-			gic_data_rdist()->pend_page = NULL;
-		}
+		its_free_pending_table(gic_data_rdist()->pend_page);
+		gic_data_rdist()->pend_page = NULL;
 
 		goto out;
 	}
 
-	paddr = gic_data_rdist()->pend_paddr;
+	pend_page = gic_data_rdist()->pend_page;
+	paddr = page_to_phys(pend_page);
 	WARN_ON(gic_reserve_range(paddr, LPI_PENDBASE_SZ));
 
 	/* set PROPBASE */
@@ -3027,7 +3029,7 @@ static int its_vpe_init(struct its_vpe *vpe)
 
 	/* Allocate VPT */
 	vpt_page = its_allocate_pending_table(GFP_KERNEL);
-	if (!vpt_page && !gic_data_rdist()->pend_vaddr) {
+	if (!vpt_page) {
 		its_vpe_id_free(vpe_id);
 		return -ENOMEM;
 	}
@@ -3099,7 +3101,7 @@ static int its_vpe_irq_domain_alloc(struct irq_domain *domain, unsigned int virq
 	}
 
 	vprop_page = its_allocate_prop_table(GFP_KERNEL);
-	if (!vprop_page && !gic_rdists->prop_table_va) {
+	if (!vprop_page) {
 		its_lpi_free(bitmap, base, nr_ids);
 		return -ENOMEM;
 	}
-- 
2.31.1

