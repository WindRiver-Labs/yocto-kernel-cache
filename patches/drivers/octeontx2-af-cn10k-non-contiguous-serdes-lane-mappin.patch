From 33e1da6227d5662b7020426a4a0e25e079aa3d46 Mon Sep 17 00:00:00 2001
From: Hariprasad Kelam <hkelam@marvell.com>
Date: Tue, 3 Nov 2020 18:45:44 +0530
Subject: [PATCH 0924/1921] octeontx2-af: cn10k: non contiguous serdes lane
 mapping with RVU PF

Octeontx3 RPM(MAC) supports non contiguous serdes lanes. This patch
make sures RVU PF->LMAC is correct by mapping enabled serdes lanes.

Update csr_offset field to get correct CSR address of DMAC filter csrs.

Change-Id: I6501be48de4d41c9f51031ab28360dcdd189de1c
Signed-off-by: Hariprasad Kelam <hkelam@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/39257
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Tested-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Signed-off-by: Sunil Goutham <sgoutham@marvell.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 .../net/ethernet/marvell/octeontx2/af/cgx.c   | 27 +++++++++++++++++--
 .../net/ethernet/marvell/octeontx2/af/cgx.h   |  9 ++++---
 .../ethernet/marvell/octeontx2/af/rvu_cgx.c   |  6 +++--
 3 files changed, 35 insertions(+), 7 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/af/cgx.c b/drivers/net/ethernet/marvell/octeontx2/af/cgx.c
index eba0482a91f3..ab5f104c57ab 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/cgx.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/cgx.c
@@ -38,6 +38,7 @@ static struct cgx_mac_ops	otx2_mac_ops    = {
 	.irq_offset	=       9,
 	.int_ena_bit    =       FW_CGX_INT,
 	.lmac_fwi	=	CGX_LMAC_FWI,
+	.non_contiguous_serdes_lane = false,
 	.get_nr_lmacs	=	cgx_get_nr_lmacs,
 	.get_lmac_type  =       cgx_get_lmac_type,
 	.mac_lmac_intl_lbk =    cgx_lmac_internal_loopback,
@@ -45,13 +46,14 @@ static struct cgx_mac_ops	otx2_mac_ops    = {
 
 static struct cgx_mac_ops	cn10k_mac_ops   = {
 	.name		=       "rpm",
-	.csr_offset     =       0x4000,
+	.csr_offset     =       0x4e00,
 	.lmac_offset    =       20,
 	.int_register	=       RPMX_CMRX_SW_INT,
 	.int_set_reg    =       RPMX_CMRX_SW_INT_ENA_W1S,
 	.irq_offset     =       1,
 	.int_ena_bit    =       BIT_ULL(0),
 	.lmac_fwi	=	RPM_LMAC_FWI,
+	.non_contiguous_serdes_lane = true,
 	.get_nr_lmacs	=	rpm_get_nr_lmacs,
 	.get_lmac_type  =       rpm_get_lmac_type,
 	.mac_lmac_intl_lbk =    rpm_lmac_internal_loopback,
@@ -1574,14 +1576,29 @@ int cgx_get_nr_lmacs(void *cgxd)
 	return cgx_read(cgx, 0, CGXX_CMRX_RX_LMACS) & 0x7ULL;
 }
 
+u8 cgx_get_lmacid(void *cgxd, u8 lmac_index)
+{
+	struct cgx *cgx = cgxd;
+
+	return cgx->lmac_idmap[lmac_index]->lmac_id;
+}
+
 static int cgx_lmac_init(struct cgx *cgx)
 {
 	struct lmac *lmac;
+	u64 lmac_list;
 	int i, err;
 
 	cgx_lmac_get_fifolen(cgx);
 
 	cgx->lmac_count = cgx->mac_ops->get_nr_lmacs(cgx);
+
+	/* lmac_list specifies which lmacs are enabled
+	 * when bit n is set to 1, LMAC[n] is enabled
+	 */
+	if (cgx->mac_ops->non_contiguous_serdes_lane)
+		lmac_list = cgx_read(cgx, 0, CGXX_CMRX_RX_LMACS) & 0xFULL;
+
 	if (cgx->lmac_count > MAX_LMAC_PER_CGX)
 		cgx->lmac_count = MAX_LMAC_PER_CGX;
 
@@ -1595,7 +1612,13 @@ static int cgx_lmac_init(struct cgx *cgx)
 			goto err_lmac_free;
 		}
 		sprintf(lmac->name, "cgx_fwi_%d_%d", cgx->cgx_id, i);
-		lmac->lmac_id = i;
+		if (cgx->mac_ops->non_contiguous_serdes_lane) {
+			lmac->lmac_id = __ffs64(lmac_list);
+			lmac_list   &= ~BIT_ULL(lmac->lmac_id);
+		} else {
+			lmac->lmac_id = i;
+		}
+
 		lmac->cgx = cgx;
 		lmac->mac_to_index_bmap.max =
 				MAX_DMAC_ENTRIES_PER_CGX / cgx->lmac_count;
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/cgx.h b/drivers/net/ethernet/marvell/octeontx2/af/cgx.h
index c83b562a8ec7..bc964f3440b6 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/cgx.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/cgx.h
@@ -138,10 +138,10 @@ struct cgx_event_cb {
  */
 struct cgx_mac_ops {
 	char		       *name;
-	/* Features like RXSTAT, TXSTAT, DMAC FILTER csrs differs by fixed
+	/* Features like  DMAC FILTER csrs differs by fixed
 	 * bar offset for example
-	 * CGX RXSTAT0 starts at 0x070
-	 * RPM RXSTAT0 starts at 0x4070
+	 * CGX DMAC_CTL0  0x1f8
+	 * RPM DMAC_CTL0  0x4ff8
 	 */
 	u64			csr_offset;
 	/* lmac offset is different is RPM */
@@ -157,6 +157,8 @@ struct cgx_mac_ops {
 	u8			int_ena_bit;
 	u8			lmac_fwi;
 	u32			fifo_len;
+	bool			non_contiguous_serdes_lane;
+
 	/* Incase of RPM get number of lmacs from RPMX_CMR_RX_LMACS[LMAC_EXIST]
 	 * number of setbits in lmac_exist tells number of lmacs
 	 */
@@ -217,4 +219,5 @@ int cgx_get_nr_lmacs(void *cgxd);
 void cgx_lmac_write(int cgx_id, int lmac_id, u64 offset, u64 val);
 u64 cgx_lmac_read(int cgx_id, int lmac_id, u64 offset);
 u8 cgx_get_lmac_type(void *cgx, int lmac_id);
+u8 cgx_get_lmacid(void *cgxd, u8 lmac_index);
 #endif /* CGX_H */
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_cgx.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_cgx.c
index 13232ed54068..41546245f152 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_cgx.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_cgx.c
@@ -107,7 +107,7 @@ static int rvu_map_cgx_lmac_pf(struct rvu *rvu)
 {
 	struct npc_pkind *pkind = &rvu->hw->pkind;
 	int cgx_cnt_max = rvu->cgx_cnt_max;
-	int cgx, lmac_cnt, lmac;
+	int cgx, lmac_cnt, lmac, iter;
 	int pf = PF_CGXMAP_BASE;
 	int size, free_pkind;
 
@@ -141,7 +141,9 @@ static int rvu_map_cgx_lmac_pf(struct rvu *rvu)
 		if (!rvu_cgx_pdata(cgx, rvu))
 			continue;
 		lmac_cnt = cgx_get_lmac_cnt(rvu_cgx_pdata(cgx, rvu));
-		for (lmac = 0; lmac < lmac_cnt; lmac++, pf++) {
+		for (iter = 0; iter < lmac_cnt; iter++, pf++) {
+			lmac = cgx_get_lmacid(rvu_cgx_pdata(cgx, rvu),
+					      iter);
 			rvu->pf2cgxlmac_map[pf] = cgxlmac_id_to_bmap(cgx, lmac);
 			rvu->cgxlmac2pf_map[CGX_OFFSET(cgx) + lmac] = 1 << pf;
 			free_pkind = rvu_alloc_rsrc(&pkind->rsrc);
-- 
2.31.1

