From cfb994f62aba6d32dab34b6ca218a5d1f2a86790 Mon Sep 17 00:00:00 2001
From: Maruthi Srinivas Bayyavarapu <maruthi.srinivas.bayyavarapu@xilinx.com>
Date: Thu, 28 Feb 2019 05:46:28 -0800
Subject: [PATCH 0532/1851] ASoC: xlnx: use clock framework for clocks to SDI
 audio

commit 9d79e4bd2adac4d84d99d9701e5b71e7c95a0781 from
https://github.com/Xilinx/linux-xlnx.git

Different exclusive clocks and common clock are associated with SDI
audio embed and extract IPs. Use clock framework to explicitly enable
and disable them during initialization and deinitialization.

Signed-off-by: Maruthi Srinivas Bayyavarapu <maruthi.srinivas.bayyavarapu@xilinx.com>
Reviewed-by: Hyun Kwon <hyun.kwon@xilinx.com>
State: pending
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 sound/soc/xilinx/xlnx_sdi_audio.c | 98 ++++++++++++++++++++++++++++---
 1 file changed, 90 insertions(+), 8 deletions(-)

diff --git a/sound/soc/xilinx/xlnx_sdi_audio.c b/sound/soc/xilinx/xlnx_sdi_audio.c
index a391378bc734..75b0b3150b6f 100644
--- a/sound/soc/xilinx/xlnx_sdi_audio.c
+++ b/sound/soc/xilinx/xlnx_sdi_audio.c
@@ -6,6 +6,7 @@
  *
  */
 
+#include <linux/clk.h>
 #include <linux/interrupt.h>
 #include <linux/io.h>
 #include <linux/module.h>
@@ -97,6 +98,9 @@ struct dev_ctx {
 	struct device *dev;
 	struct drm_display_mode *video_mode;
 	struct snd_pcm_substream *stream;
+	struct clk *axi_clk;
+	struct clk *axis_clk;
+	struct clk *aud_clk;
 	bool rx_srate_updated;
 	wait_queue_head_t srate_q;
 };
@@ -417,16 +421,32 @@ static int xlnx_sdi_audio_probe(struct platform_device *pdev)
 	if (!ctx)
 		return -ENODEV;
 
+	ctx->axi_clk = devm_clk_get(&pdev->dev, "s_axi_aclk");
+	if (IS_ERR(ctx->axi_clk)) {
+		ret = PTR_ERR(ctx->axi_clk);
+		dev_err(&pdev->dev, "failed to get s_axi_aclk(%d)\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(ctx->axi_clk);
+	if (ret) {
+		dev_err(&pdev->dev,
+			"failed to enable s_axi_aclk(%d)\n", ret);
+		return ret;
+	}
+
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res) {
 		dev_err(&pdev->dev, "No IO MEM resource found\n");
-		return -ENODEV;
+		ret = -ENODEV;
+		goto err_axis;
 	}
 
 	ctx->base = devm_ioremap_resource(&pdev->dev, res);
 	if (!ctx->base) {
 		dev_err(&pdev->dev, "ioremap failed\n");
-		return -EADDRNOTAVAIL;
+		ret = -EADDRNOTAVAIL;
+		goto err_axis;
 	}
 
 	ctx->dev = &pdev->dev;
@@ -434,17 +454,36 @@ static int xlnx_sdi_audio_probe(struct platform_device *pdev)
 	val = readl(ctx->base + XSDIAUD_GUI_PARAM_REG_OFFSET);
 	if (val & BIT(6)) {
 		ctx->mode = EXTRACT;
+
+		ctx->axis_clk = devm_clk_get(&pdev->dev, "m_axis_clk");
+		if (IS_ERR(ctx->axis_clk)) {
+			ret = PTR_ERR(ctx->axis_clk);
+			dev_err(&pdev->dev, "failed to get m_axis_clk(%d)\n",
+				ret);
+			goto err_axis;
+		}
+
+		ctx->aud_clk = devm_clk_get(&pdev->dev, "sdi_extract_clk");
+		if (IS_ERR(ctx->aud_clk)) {
+			ret = PTR_ERR(ctx->aud_clk);
+			dev_err(&pdev->dev, "failed to get sdi_extract_clk(%d)\n",
+				ret);
+			goto err_axis;
+		}
+
 		res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
 		if (!res) {
 			dev_err(&pdev->dev, "No IRQ resource found\n");
-			return -ENODEV;
+			ret = -ENODEV;
+			goto err_axis;
 		}
 		ret = devm_request_irq(&pdev->dev, res->start,
 				       xtract_irq_handler,
 				       0, "XLNX_SDI_AUDIO_XTRACT", ctx);
 		if (ret) {
 			dev_err(&pdev->dev, "extract irq request failed\n");
-			return -ENODEV;
+			ret = -ENODEV;
+			goto err_axis;
 		}
 
 		init_waitqueue_head(&ctx->srate_q);
@@ -452,18 +491,35 @@ static int xlnx_sdi_audio_probe(struct platform_device *pdev)
 		snd_dai = &xlnx_sdi_rx_dai;
 	} else {
 		ctx->mode = EMBED;
+		ctx->axis_clk = devm_clk_get(&pdev->dev, "s_axis_clk");
+		if (IS_ERR(ctx->axis_clk)) {
+			ret = PTR_ERR(ctx->axis_clk);
+			dev_err(&pdev->dev, "failed to get s_axis_clk(%d)\n",
+				ret);
+			goto err_axis;
+		}
+
+		ctx->aud_clk = devm_clk_get(&pdev->dev, "sdi_embed_clk");
+		if (IS_ERR(ctx->aud_clk)) {
+			ret = PTR_ERR(ctx->aud_clk);
+			dev_err(&pdev->dev, "failed to get aud_clk(%d)\n",
+				ret);
+			goto err_axis;
+		}
 
 		video_node = of_graph_get_remote_node(pdev->dev.of_node, 0, 0);
 		if (!video_node) {
 			dev_err(ctx->dev, "video_node not found\n");
 			of_node_put(video_node);
-			return -ENODEV;
+			ret = -ENODEV;
+			goto err_axis;
 		}
 
 		video_pdev = of_find_device_by_node(video_node);
 		if (!video_pdev) {
 			of_node_put(video_node);
-			return -ENODEV;
+			ret = -ENODEV;
+			goto err_axis;
 		}
 
 		video_dev = &video_pdev->dev;
@@ -472,18 +528,33 @@ static int xlnx_sdi_audio_probe(struct platform_device *pdev)
 		/* invalid 'platform_data' implies video driver is not loaded */
 		if (!ctx->video_mode) {
 			of_node_put(video_node);
-			return -EPROBE_DEFER;
+			ret = -EPROBE_DEFER;
+			goto err_axis;
 		}
 
 		snd_dai = &xlnx_sdi_tx_dai;
 		of_node_put(video_node);
 	}
 
+	ret = clk_prepare_enable(ctx->axis_clk);
+	if (ret) {
+		dev_err(&pdev->dev,
+			"failed to enable s_axis_clk(%d)\n", ret);
+		goto err_axis;
+	}
+
+	ret = clk_prepare_enable(ctx->aud_clk);
+	if (ret) {
+		dev_err(&pdev->dev,
+			"failed to enable sdi_extract_clk(%d)\n", ret);
+		goto err_aud_clk;
+	}
+
 	ret = devm_snd_soc_register_component(&pdev->dev, &xlnx_sdi_component,
 					      snd_dai, 1);
 	if (ret) {
 		dev_err(&pdev->dev, "couldn't register codec DAI\n");
-		return ret;
+		goto err_clk;
 	}
 
 	dev_set_drvdata(&pdev->dev, ctx);
@@ -493,6 +564,14 @@ static int xlnx_sdi_audio_probe(struct platform_device *pdev)
 
 	dev_info(&pdev->dev, "xlnx sdi codec dai component registered\n");
 	return 0;
+
+err_clk:
+	clk_disable_unprepare(ctx->aud_clk);
+err_aud_clk:
+	clk_disable_unprepare(ctx->axis_clk);
+err_axis:
+	clk_disable_unprepare(ctx->axi_clk);
+	return ret;
 }
 
 static int xlnx_sdi_audio_remove(struct platform_device *pdev)
@@ -502,6 +581,9 @@ static int xlnx_sdi_audio_remove(struct platform_device *pdev)
 	audio_disable(ctx->base);
 	audio_reset_core(ctx->base, true);
 
+	clk_disable_unprepare(ctx->aud_clk);
+	clk_disable_unprepare(ctx->axis_clk);
+	clk_disable_unprepare(ctx->axi_clk);
 	return 0;
 }
 
-- 
2.31.1

