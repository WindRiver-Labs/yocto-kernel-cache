From 90d448a202a96db860dd88970bd6492778a26591 Mon Sep 17 00:00:00 2001
From: Bharat Bhushan <bbhushan2@marvell.com>
Date: Mon, 21 Jun 2021 16:20:56 +0530
Subject: [PATCH 1617/1921] clocksource: Add Marvell Errata-38627 workaround

CPU pipeline have unpredicted behavior when timer
interrupt appears and then disappears prior to the
exception happening. Time interrupt appears on timer
expiry and disappears when timer programming or timer
disable. This typically can happen when a load
instruction misses in the cache,  which can take
few hundreds of cycles, and an interrupt appears
after the load instruction starts executing but
disappears before the load instruction completes.

Workaround of this is to ensure maximum 2us of time
gap between timer interrupt and timer programming
which can de-assert timer interrupt.

Change-Id: I5146595a913bd0bdb693b5dff0b2ddbcc58ec840
Signed-off-by: Linu Cherian <lcherian@marvell.com>
Signed-off-by: Bharat Bhushan <bbhushan2@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/55116
Reviewed-by: Sunil Kovvuri Goutham <sgoutham@marvell.com>
Tested-by: Sunil Kovvuri Goutham <sgoutham@marvell.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 arch/arm64/include/asm/cpucaps.h     |  3 +-
 arch/arm64/include/asm/cputype.h     |  2 ++
 arch/arm64/kernel/cpu_errata.c       | 24 +++++++++++++
 drivers/clocksource/Kconfig          |  9 +++++
 drivers/clocksource/arm_arch_timer.c | 54 ++++++++++++++++++++++++++++
 5 files changed, 91 insertions(+), 1 deletion(-)

diff --git a/arch/arm64/include/asm/cpucaps.h b/arch/arm64/include/asm/cpucaps.h
index 514f9243ffb7..401909523fce 100644
--- a/arch/arm64/include/asm/cpucaps.h
+++ b/arch/arm64/include/asm/cpucaps.h
@@ -59,7 +59,8 @@
 #define ARM64_WORKAROUND_MRVL_38500		49
 #define ARM64_WORKAROUND_MRVL_38545		50
 #define ARM64_HAS_RNG				51
+#define ARM64_WORKAROUND_MRVL_38627		52
 
-#define ARM64_NCAPS				52
+#define ARM64_NCAPS				53
 
 #endif /* __ASM_CPUCAPS_H */
diff --git a/arch/arm64/include/asm/cputype.h b/arch/arm64/include/asm/cputype.h
index 725498330e2f..0cd2c9ad1de1 100644
--- a/arch/arm64/include/asm/cputype.h
+++ b/arch/arm64/include/asm/cputype.h
@@ -84,6 +84,7 @@
 #define MRVL_CPU_PART_OCTEONTX2_95XX	0x0B3
 #define MRVL_CPU_PART_OCTEONTX2_LOKI	0x0B4
 #define MRVL_CPU_PART_OCTEONTX2_95MM	0x0B5
+#define MRVL_CPU_PART_OCTEONTX2_95O	0x0B6
 
 #define BRCM_CPU_PART_BRAHMA_B53	0x100
 #define BRCM_CPU_PART_VULCAN		0x516
@@ -117,6 +118,7 @@
 #define MIDR_MRVL_OCTEONTX2_95XX MIDR_CPU_MODEL(ARM_CPU_IMP_CAVIUM, MRVL_CPU_PART_OCTEONTX2_95XX)
 #define MIDR_MRVL_OCTEONTX2_LOKI MIDR_CPU_MODEL(ARM_CPU_IMP_CAVIUM, MRVL_CPU_PART_OCTEONTX2_LOKI)
 #define MIDR_MRVL_OCTEONTX2_95MM MIDR_CPU_MODEL(ARM_CPU_IMP_CAVIUM, MRVL_CPU_PART_OCTEONTX2_95MM)
+#define MIDR_MRVL_OCTEONTX2_95O MIDR_CPU_MODEL(ARM_CPU_IMP_CAVIUM, MRVL_CPU_PART_OCTEONTX2_95O)
 #define MIDR_BRAHMA_B53 MIDR_CPU_MODEL(ARM_CPU_IMP_BRCM, BRCM_CPU_PART_BRAHMA_B53)
 #define MIDR_BRCM_VULCAN MIDR_CPU_MODEL(ARM_CPU_IMP_BRCM, BRCM_CPU_PART_VULCAN)
 #define MIDR_QCOM_FALKOR_V1 MIDR_CPU_MODEL(ARM_CPU_IMP_QCOM, QCOM_CPU_PART_FALKOR_V1)
diff --git a/arch/arm64/kernel/cpu_errata.c b/arch/arm64/kernel/cpu_errata.c
index 6a87270f55d8..37ed2a89a221 100644
--- a/arch/arm64/kernel/cpu_errata.c
+++ b/arch/arm64/kernel/cpu_errata.c
@@ -787,6 +787,23 @@ static const struct arm64_cpu_capabilities erratum_843419_list[] = {
 	{},
 };
 #endif
+#ifdef CONFIG_MARVELL_ERRATUM_38627
+static const struct midr_range marvell_erratum_38627_cpus[] = {
+	/* Marvell OcteonTX 2, 95xx all passes */
+	MIDR_ALL_VERSIONS(MIDR_MRVL_OCTEONTX2_95XX),
+	/* Marvell OcteonTX 2, 95MM all passes */
+	MIDR_ALL_VERSIONS(MIDR_MRVL_OCTEONTX2_95MM),
+	/* Marvell OcteonTX 2, LOKI all passes */
+	MIDR_ALL_VERSIONS(MIDR_MRVL_OCTEONTX2_LOKI),
+	/* Marvell OcteonTX 2, 96xx all passes */
+	MIDR_ALL_VERSIONS(MIDR_MRVL_OCTEONTX2_96XX),
+	/* Marvell OcteonTX 2, 98xx pass 1.0 */
+	MIDR_REV(MIDR_MRVL_OCTEONTX2_98XX, 0, 0),
+	/* Marvell OcteonTX 2, 95O pass 1.0 */
+	MIDR_REV(MIDR_MRVL_OCTEONTX2_95O, 0, 0),
+	{},
+};
+#endif
 
 static void __maybe_unused
 cpu_enable_trap_zva_access(const struct arm64_cpu_capabilities *__unused)
@@ -934,6 +951,13 @@ const struct arm64_cpu_capabilities arm64_errata[] = {
 		.capability = ARM64_WORKAROUND_858921,
 		ERRATA_MIDR_ALL_VERSIONS(MIDR_CORTEX_A73),
 	},
+#endif
+#ifdef CONFIG_MARVELL_ERRATUM_38627
+	{
+		.desc = "MARVELL erratum 38627",
+		.capability = ARM64_WORKAROUND_MRVL_38627,
+		ERRATA_MIDR_RANGE_LIST(marvell_erratum_38627_cpus),
+	},
 #endif
 	{
 		.desc = "Branch predictor hardening",
diff --git a/drivers/clocksource/Kconfig b/drivers/clocksource/Kconfig
index 3300739edce4..9968a563d771 100644
--- a/drivers/clocksource/Kconfig
+++ b/drivers/clocksource/Kconfig
@@ -338,6 +338,15 @@ config ARM_ARCH_TIMER_EVTSTREAM
 config ARM_ARCH_TIMER_OOL_WORKAROUND
 	bool
 
+config MARVELL_ERRATUM_38627
+	bool "Workaround for Marvell Erratum 38627"
+	default y
+	depends on ARM_ARCH_TIMER && ARM64
+	select ARM_ARCH_TIMER_OOL_WORKAROUND
+	help
+	  This option enables a workaround for Marvell Erratum
+	  38627.
+
 config FSL_ERRATUM_A008585
 	bool "Workaround for Freescale/NXP Erratum A-008585"
 	default y
diff --git a/drivers/clocksource/arm_arch_timer.c b/drivers/clocksource/arm_arch_timer.c
index 07e57a49d1e8..59269f82fb99 100644
--- a/drivers/clocksource/arm_arch_timer.c
+++ b/drivers/clocksource/arm_arch_timer.c
@@ -24,6 +24,7 @@
 #include <linux/sched/clock.h>
 #include <linux/sched_clock.h>
 #include <linux/acpi.h>
+#include <linux/delay.h>
 
 #include <asm/arch_timer.h>
 #include <asm/virt.h>
@@ -73,6 +74,8 @@ static bool vdso_default = true;
 
 static cpumask_t evtstrm_available = CPU_MASK_NONE;
 static bool evtstrm_enable = IS_ENABLED(CONFIG_ARM_ARCH_TIMER_EVTSTREAM);
+static __always_inline void set_next_event(const int access, unsigned long evt,
+					   struct clock_event_device *clk);
 
 static int __init early_evtstrm_cfg(char *buf)
 {
@@ -416,6 +419,48 @@ static __maybe_unused int erratum_set_next_event_tval_phys(unsigned long evt,
 	return 0;
 }
 
+#ifdef CONFIG_MARVELL_ERRATUM_38627
+/* Workaround is to ensure maximum 2us of time gap between timer expiry
+ * and timer programming which can de-assert timer interrupt.
+ * Time calculation below is based on 100MHz as timer frequency is fixed
+ * to 100MHz on all affected parts.
+ */
+static __always_inline
+void erratum_38627_set_next_event(const int access, unsigned long evt,
+				  struct clock_event_device *clk)
+{
+	int32_t tval;
+
+	tval = arch_timer_reg_read(access, ARCH_TIMER_REG_TVAL, clk);
+
+	/* Timer already expired, wait for (2 - expired time)us */
+	if ((tval > -200) && (tval < 0))
+		udelay(2 + tval/100);
+
+	/* Timer is about to expire, wait for 2us + time to expire */
+	if (tval >= 0 && tval < 200)
+		udelay(3 + tval/100);
+
+	set_next_event(access, evt, clk);
+}
+
+static __maybe_unused
+int erratum_38627_set_next_event_tval_virt(unsigned long evt,
+					   struct clock_event_device *clk)
+{
+	erratum_38627_set_next_event(ARCH_TIMER_VIRT_ACCESS, evt, clk);
+	return 0;
+}
+
+static __maybe_unused
+int erratum_38627_set_next_event_tval_phys(unsigned long evt,
+					   struct clock_event_device *clk)
+{
+	erratum_38627_set_next_event(ARCH_TIMER_PHYS_ACCESS, evt, clk);
+	return 0;
+}
+#endif
+
 static const struct arch_timer_erratum_workaround ool_workarounds[] = {
 #ifdef CONFIG_FSL_ERRATUM_A008585
 	{
@@ -463,6 +508,15 @@ static const struct arch_timer_erratum_workaround ool_workarounds[] = {
 		.read_cntvct_el0 = arm64_858921_read_cntvct_el0,
 	},
 #endif
+#ifdef CONFIG_MARVELL_ERRATUM_38627
+	{
+		.match_type = ate_match_local_cap_id,
+		.id = (void *)ARM64_WORKAROUND_MRVL_38627,
+		.desc = "Marvell erratum 38627",
+		.set_next_event_phys = erratum_38627_set_next_event_tval_phys,
+		.set_next_event_virt = erratum_38627_set_next_event_tval_virt,
+	},
+#endif
 #ifdef CONFIG_SUN50I_ERRATUM_UNKNOWN1
 	{
 		.match_type = ate_match_dt,
-- 
2.31.1

