From 8a2971a1ffacaa292218946e9171014f11cd076c Mon Sep 17 00:00:00 2001
From: Subbaraya Sundeep <sbhatta@marvell.com>
Date: Fri, 5 Apr 2019 00:04:30 +0530
Subject: [PATCH 0138/1921] octeontx2-af: Use default unicast RSS action when
 installing a flow

Currently one can choose to either Drop or Direct to queue actions
when installing a flow in mcam. There should be support for adding
RSS action also. To acheive this, RSS action set in default unicast
entry is used for a flow when NIX_RX_ACTION_DEFAULT is specified in
its request.
Along with RSS this patch
 - stores vtag_action for future use.
 - Adds support for displaying flow action in debugfs.

Example:
~ # ethtool -K eth0 ntuple on
~ # ethtool -U eth0 flow-type udp4 src-port 23 action 0 user-def 0x1
Added rule with ID 35
~ # cat /sys/kernel/debug/octeontx2/npc/mcam_rules

        PF1
        mcam entry: 192
        outer vlan id  0 mask 0x0
        action: Direct to queue 0

        PF1
        mcam entry: 228
        udp source port  23 mask 0xffff
        action: RSS
        counter: 0
        hits: 0

        PF1
        mcam entry: 1890
        dmac  72:da:79:d8:3e:1d mask ff:ff:ff:ff:ff:ff
        action: RSS
~ #

Change-Id: I8dcc54f4f4857c2f7690ff3d9208cd113d5e3ba5
Signed-off-by: Subbaraya Sundeep <sbhatta@marvell.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 .../net/ethernet/marvell/octeontx2/af/npc.h   |  1 +
 .../marvell/octeontx2/af/rvu_debugfs.c        | 35 ++++++++++++++++---
 .../ethernet/marvell/octeontx2/af/rvu_npc.c   |  6 ++++
 .../marvell/octeontx2/af/rvu_npc_fs.c         |  4 +++
 4 files changed, 42 insertions(+), 4 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/af/npc.h b/drivers/net/ethernet/marvell/octeontx2/af/npc.h
index 301152db04fb..c61acba70d42 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/npc.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/npc.h
@@ -299,6 +299,7 @@ struct rvu_npc_mcam_rule {
 	struct flow_msg packet;
 	struct flow_msg mask;
 	struct nix_rx_action action;
+	u64 vtag_action;
 	struct list_head list;
 	u64 features;
 	u16 pcifunc;
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_debugfs.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_debugfs.c
index 324f58218575..4babbd7bd198 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_debugfs.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_debugfs.c
@@ -1386,11 +1386,12 @@ static void rvu_dbg_npc_mcam_show_flows(struct seq_file *s,
 			break;
 		case NPC_OUTER_VID:
 			seq_printf(s, "%d ", ntohs(rule->packet.vlan_tci));
-			seq_printf(s, "%d\n", ntohs(rule->mask.vlan_tci));
+			seq_printf(s, "mask 0x%x\n",
+				   ntohs(rule->mask.vlan_tci));
 			break;
 		case NPC_TOS:
 			seq_printf(s, "%d ", rule->packet.tos);
-			seq_printf(s, "%d\n", rule->mask.tos);
+			seq_printf(s, "mask 0x%x\n", rule->mask.tos);
 			break;
 		case NPC_SIP_IPV4:
 			seq_printf(s, "%pI4 ", &rule->packet.ip4src);
@@ -1411,12 +1412,12 @@ static void rvu_dbg_npc_mcam_show_flows(struct seq_file *s,
 		case NPC_SPORT_TCP:
 		case NPC_SPORT_UDP:
 			seq_printf(s, "%d ", ntohs(rule->packet.sport));
-			seq_printf(s, "%d\n", ntohs(rule->mask.sport));
+			seq_printf(s, "mask 0x%x\n", ntohs(rule->mask.sport));
 			break;
 		case NPC_DPORT_TCP:
 		case NPC_DPORT_UDP:
 			seq_printf(s, "%d ", ntohs(rule->packet.dport));
-			seq_printf(s, "%d\n", ntohs(rule->mask.dport));
+			seq_printf(s, "mask 0x%x\n", ntohs(rule->mask.dport));
 			break;
 		default:
 			break;
@@ -1424,6 +1425,31 @@ static void rvu_dbg_npc_mcam_show_flows(struct seq_file *s,
 	}
 }
 
+static void rvu_dbg_npc_mcam_show_action(struct seq_file *s,
+					 struct rvu_npc_mcam_rule *rule)
+{
+	switch (rule->action.op) {
+	case NIX_RX_ACTIONOP_DROP:
+		seq_puts(s, "\taction: Drop\n");
+		break;
+	case NIX_RX_ACTIONOP_UCAST:
+		seq_printf(s, "\taction: Direct to queue %d\n",
+			   rule->action.index);
+		break;
+	case NIX_RX_ACTIONOP_RSS:
+		seq_puts(s, "\taction: RSS\n");
+		break;
+	case NIX_RX_ACTIONOP_UCAST_IPSEC:
+		seq_puts(s, "\taction: Unicast ipsec\n");
+		break;
+	case NIX_RX_ACTIONOP_MCAST:
+		seq_puts(s, "\taction: Multicast\n");
+		break;
+	default:
+		break;
+	};
+}
+
 static int rvu_dbg_npc_mcam_show_rules(struct seq_file *s, void *unused)
 {
 	struct rvu_npc_mcam_rule *iter;
@@ -1450,6 +1476,7 @@ static int rvu_dbg_npc_mcam_show_rules(struct seq_file *s, void *unused)
 
 		seq_printf(s, "\tmcam entry: %d\n", iter->entry);
 		rvu_dbg_npc_mcam_show_flows(s, iter);
+		rvu_dbg_npc_mcam_show_action(s, iter);
 
 		if (!iter->has_cntr)
 			continue;
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc.c
index a6774cfe900f..7536d646298d 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc.c
@@ -588,6 +588,7 @@ void rvu_npc_update_flowkey_alg_idx(struct rvu *rvu, u16 pcifunc, int nixlf,
 	struct npc_mcam *mcam = &rvu->hw->mcam;
 	struct nix_rx_action action;
 	int blkaddr, index, bank;
+	struct rvu_pfvf *pfvf;
 
 	blkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);
 	if (blkaddr < 0)
@@ -624,6 +625,11 @@ void rvu_npc_update_flowkey_alg_idx(struct rvu *rvu, u16 pcifunc, int nixlf,
 	rvu_write64(rvu, blkaddr,
 		    NPC_AF_MCAMEX_BANKX_ACTION(index, bank), *(u64 *)&action);
 
+	/* update the action change in default rule */
+	pfvf = rvu_get_pfvf(rvu, pcifunc);
+	if (pfvf->def_rule)
+		pfvf->def_rule->action = action;
+
 	index = npc_get_nixlf_mcam_index(mcam, pcifunc,
 					 nixlf, NIXLF_PROMISC_ENTRY);
 
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc_fs.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc_fs.c
index 688bae2d9a1d..1ffc28448502 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc_fs.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc_fs.c
@@ -785,6 +785,9 @@ static int npc_install_flow(struct rvu *rvu, int blkaddr, u16 target,
 	action.match_id = req->match_id;
 	action.flow_key_alg = req->flow_key_alg;
 
+	if (req->op == NIX_RX_ACTION_DEFAULT && pfvf->def_rule)
+		action = pfvf->def_rule->action;
+
 	entry->action = *(u64 *)&action;
 	/* VTAG0 starts at 12th byte of LID_A.
 	 * VTAG1 starts at 2nd byte of LID_B.
@@ -874,6 +877,7 @@ static int npc_install_flow(struct rvu *rvu, int blkaddr, u16 target,
 	memcpy(&rule->mask, &dummy.mask, sizeof(rule->mask));
 	rule->entry = entry_index;
 	rule->action = action;
+	rule->vtag_action = entry->vtag_action;
 	rule->features = installed_features;
 	rule->default_rule = req->default_rule;
 	rule->pcifunc = requester;
-- 
2.31.1

