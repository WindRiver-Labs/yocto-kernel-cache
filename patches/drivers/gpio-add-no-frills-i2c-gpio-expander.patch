From 132a6c204f2f8df1f326061cfbfb5a1e0a11983e Mon Sep 17 00:00:00 2001
From: Peter Swain <pswain@cavium.com>
Date: Mon, 4 Jun 2018 17:48:08 -0700
Subject: [PATCH 353/767] gpio: add no-frills i2c->gpio expander

commit e54f30f5c9b6f56d979e7659b168505133deaf96 from
git@git.assembla.com:cavium/WindRiver.linux.git

Simple i2c->gpio expander driven by device tree or platform data.
No interrupts, no frills, just set/get 8 pins per byte.

Added for GPIO pins integrated into i2c-accessed CPLDs
on custom embedded boards. Typically one would use
a more specialized driver if one exists, but this fallback
option is kept general to model a whole class of embedded devices.

Change-Id: Ic6e2d8a6b8843771892eaee28df97e30b8d15560
Signed-off-by: Peter Swain <pswain@cavium.com>
Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
Reviewed-on: https://sj1git1.cavium.com/16108
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Tested-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[Kevin: Just some minor context mods in order to port to linux-yocto]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../devicetree/bindings/gpio/gpio-i2c.txt     |  32 +++
 MAINTAINERS                                   |   5 +
 drivers/gpio/Kconfig                          |  12 +
 drivers/gpio/Makefile                         |   1 +
 drivers/gpio/gpio-i2c.c                       | 206 ++++++++++++++++++
 5 files changed, 256 insertions(+)
 create mode 100644 Documentation/devicetree/bindings/gpio/gpio-i2c.txt
 create mode 100644 drivers/gpio/gpio-i2c.c

diff --git a/Documentation/devicetree/bindings/gpio/gpio-i2c.txt b/Documentation/devicetree/bindings/gpio/gpio-i2c.txt
new file mode 100644
index 000000000000..ad2743bc65ed
--- /dev/null
+++ b/Documentation/devicetree/bindings/gpio/gpio-i2c.txt
@@ -0,0 +1,32 @@
+Device-Tree bindings for gpio i2c driver
+
+A simple parameterized no-irq of_driven i2c->gpio expander,
+cut down from gpio-pcf857x.c to be totally device-tree driven.
+
+Suitable for any "memory-like" device, where a 1-byte i2c read yields data
+which can safely be written back, possibly with a bit changed, with the
+effect of changing only the output level of that bit's GPIO pin.
+
+Required properties:
+	- compatible = "gpio-i2c"
+	- reg = i2c-address
+	- gpio-controller
+	- #gpio-cells = <1>;
+	- ngpios = number of pins modeled
+
+Example nodes:
+
+&i2c_bus {
+        gpio1: cpld@6c {
+                compatible = "gpio-i2c";
+		gpio-controller;
+                reg = <0x6c>;
+		#gpio-cells = <1>;
+                ngpios = <160>; // 8bits for each reg 0..0x13
+        };
+};
+
+_some_device_ {
+	// pin controlled by bitmask 0x2 of byte 0x4 of gpio1
+	enable-gpios = <&gpio1 33>;
+}
diff --git a/MAINTAINERS b/MAINTAINERS
index 863ce2ead1db..609ec66e2ce0 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -6643,6 +6643,11 @@ F:	drivers/net/wan/pc300too.c
 F:	drivers/net/wan/pci200syn.c
 F:	drivers/net/wan/wanxl*
 
+GENERIC I2C GPIO DRIVER
+M:	Peter Swain <pswain@marvell.com>
+S:	Maintained
+F:	drivers/gpio/gpio-i2c.c
+
 GENERIC INCLUDE/ASM HEADER FILES
 M:	Arnd Bergmann <arnd@arndb.de>
 L:	linux-arch@vger.kernel.org
diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index acd40eb51c46..d05dd2bf538e 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -847,6 +847,18 @@ config GPIO_GW_PLD
 	  Say yes here to provide access to the Gateworks I2C PLD GPIO
 	  Expander. This is used at least on the Cambria GW2358-4.
 
+config GPIO_I2C
+	tristate "Generic I2C->GPIO no-irq expander"
+	depends on OF
+	default n
+	help
+	  Select this option to enable GPIO for simple I2C devices,
+	  parameterized by device-tree, and having no interrupts.
+	  Developed to model a custom board's CPLD, but may be useful
+	  for various hardware where i2c-poking flips external pins.
+
+	  If unsure, say N.
+
 config GPIO_MAX7300
 	tristate "Maxim MAX7300 GPIO expander"
 	select GPIO_MAX730X
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index 6700eee860b7..07a30dbf0930 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -59,6 +59,7 @@ obj-$(CONFIG_GPIO_GRGPIO)	+= gpio-grgpio.o
 obj-$(CONFIG_GPIO_GW_PLD)	+= gpio-gw-pld.o
 obj-$(CONFIG_GPIO_HLWD)		+= gpio-hlwd.o
 obj-$(CONFIG_HTC_EGPIO)		+= gpio-htc-egpio.o
+obj-$(CONFIG_GPIO_I2C)		+= gpio-i2c.o
 obj-$(CONFIG_GPIO_ICH)		+= gpio-ich.o
 obj-$(CONFIG_GPIO_IOP)		+= gpio-iop.o
 obj-$(CONFIG_GPIO_IXP4XX)	+= gpio-ixp4xx.o
diff --git a/drivers/gpio/gpio-i2c.c b/drivers/gpio/gpio-i2c.c
new file mode 100644
index 000000000000..f24b7df4c69d
--- /dev/null
+++ b/drivers/gpio/gpio-i2c.c
@@ -0,0 +1,206 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * simple parameterized no-irq of_driven i2c->gpio expander,
+ * cut down from gpio-pcf857x.c to be totally device-tree driven.
+ *
+ * Suitable for any "memory-like" device, where a 1-byte i2c read yields data
+ * which can safely be written back, possibly with a bit changed, with the
+ * effect of changing only the output level of that bit's GPIO pin.
+ *
+ * Copyright (C) 2016 Cavium Inc.
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+
+struct gpio_i2c_platform_data {
+	unsigned int	i2c_addr;
+	unsigned int	pins;
+};
+
+
+static const struct of_device_id gpio_i2c_of_table[] = {
+	{ .compatible = "gpio-i2c" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, gpio_i2c_of_table);
+
+struct gpio_i2c {
+	unsigned int	i2c_addr;
+	struct gpio_chip	chip;
+	struct i2c_client	*client;
+	struct mutex		lock;		/* protect 'out' */
+	u8			out[];		/* software latch */
+};
+
+/*-------------------------------------------------------------------------*/
+
+static int gpio_i2c_get(struct gpio_chip *chip, unsigned int offset)
+{
+	struct gpio_i2c	*gpio = container_of(chip, struct gpio_i2c, chip);
+	int		value;
+	unsigned int	byte = (offset >> 3);
+	unsigned int	bit = (offset & 7);
+
+	mutex_lock(&gpio->lock);
+	value = i2c_smbus_read_byte_data(gpio->client, byte);
+	mutex_unlock(&gpio->lock);
+	return (value < 0) ? 0 : ((value >> bit) & 1);
+}
+
+static int gpio_i2c_output(struct gpio_chip *chip,
+		unsigned int offset, int value)
+{
+	struct gpio_i2c	*gpio = container_of(chip, struct gpio_i2c, chip);
+	unsigned int	byte = (offset >> 3);
+	unsigned int	bit = (offset & 7);
+	unsigned int	mask = (1 << bit);
+	int		status;
+	u8		was;
+
+	mutex_lock(&gpio->lock);
+	was = i2c_smbus_read_byte_data(gpio->client, byte);
+	if (value)
+		was |= mask;
+	else
+		was &= ~mask;
+	status = i2c_smbus_write_byte_data(gpio->client, byte, was);
+	gpio->out[byte] = was;
+	mutex_unlock(&gpio->lock);
+
+	return status;
+}
+
+static void gpio_i2c_set(struct gpio_chip *chip, unsigned int offset, int value)
+{
+	gpio_i2c_output(chip, offset, value);
+}
+
+/* for open-drain: set as input by letting output go high */
+static int gpio_i2c_input(struct gpio_chip *chip, unsigned int offset)
+{
+	return gpio_i2c_output(chip, offset, 1);
+}
+
+/*-------------------------------------------------------------------------*/
+
+static int gpio_i2c_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id)
+{
+	struct gpio_i2c_platform_data	*pdata = dev_get_platdata(&client->dev);
+	struct device_node		*np = client->dev.of_node;
+	struct gpio_i2c			*gpio;
+	u32				pins;
+	u32				i2c_addr;
+	int				status;
+
+	if (np) {
+		status = of_property_read_u32(np, "reg", &i2c_addr);
+		if (status < 0) {
+			dev_dbg(&client->dev, "missing reg property\n");
+			return status;
+		}
+		status = of_property_read_u32(np, "ngpios", &pins);
+		if (status < 0) {
+			dev_dbg(&client->dev, "missing ngpios property\n");
+			return status;
+		}
+	} else if (pdata) {
+		i2c_addr = pdata->i2c_addr;
+		pins = pdata->pins;
+	} else {
+		dev_dbg(&client->dev, "no platform data\n");
+		return -EPROBE_DEFER;
+	}
+
+	/* Allocate, initialize, and register this gpio_chip. */
+	gpio = devm_kzalloc(&client->dev,
+		sizeof(*gpio) + (pins + 7) / 8, GFP_KERNEL);
+	if (!gpio)
+		return -ENOMEM;
+
+	mutex_init(&gpio->lock);
+
+	gpio->i2c_addr			= i2c_addr;
+	gpio->chip.base			= -1;
+	gpio->chip.can_sleep		= true;
+	gpio->chip.parent		= &client->dev;
+	gpio->chip.owner		= THIS_MODULE;
+	gpio->chip.get			= gpio_i2c_get;
+	gpio->chip.set			= gpio_i2c_set;
+	gpio->chip.direction_input	= gpio_i2c_input;
+	gpio->chip.direction_output	= gpio_i2c_output;
+	gpio->chip.ngpio		= pins;
+	gpio->chip.label		= client->name;
+	gpio->client			= client;
+	gpio->client->addr		= i2c_addr;
+	i2c_set_clientdata(client, gpio);
+
+	status = gpiochip_add(&gpio->chip);
+	if (status < 0)
+		goto fail;
+
+	dev_info(&client->dev, "probed\n");
+
+	return 0;
+
+fail:
+	dev_dbg(&client->dev, "probe error %d for '%s'\n", status,
+		client->name);
+
+	return status;
+}
+
+static int gpio_i2c_remove(struct i2c_client *client)
+{
+	struct gpio_i2c			*gpio = i2c_get_clientdata(client);
+	int				status = 0;
+
+	gpiochip_remove(&gpio->chip);
+	return status;
+}
+
+/* this must _exist_ for i2c_device_probe() to call our probe, may be empty */
+static struct i2c_device_id empty_id_table[] = {
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, empty_id_table);
+
+static struct i2c_driver gpio_i2c_driver = {
+	.driver = {
+		.name	= "gpio-i2c",
+		.of_match_table = of_match_ptr(gpio_i2c_of_table),
+	},
+	.probe	= gpio_i2c_probe,
+	.remove	= gpio_i2c_remove,
+	.id_table = empty_id_table,
+};
+
+module_i2c_driver(gpio_i2c_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("David Brownell");
+MODULE_AUTHOR("Peter Swain <pswain@cavium.com>");
+/*
+ * arguably this name defies convention, but correct(?) alias has been
+ * taken by the inverse function in
+ *	drivers/i2c/busses/i2c-gpio.c:MODULE_ALIAS("platform:i2c-gpio");
+ */
+MODULE_ALIAS("platform:gpio-i2c");
-- 
2.31.1

