From c5a367d6f2b69cc30c9eb92a295947569b0c1ec2 Mon Sep 17 00:00:00 2001
From: Vishal Sagar <vishal.sagar@xilinx.com>
Date: Wed, 19 Dec 2018 15:51:44 +0530
Subject: [PATCH 0493/1851] v4l: xilinx: vpss-scaler: Fix clock framework
 support

commit 91b935cab659a6c94d9cbfa31db0118daf317227 from
https://github.com/Xilinx/linux-xlnx.git

This patch fixes the clock framework support for VPSS Scaler by adding
support for axi lite interface clock along with the video clock. Since
two clocks are now required, the older xvip_init_resources is dropped as
it supports only one video clock. The compatible string is also updated.

Signed-off-by: Vishal Sagar <vishal.sagar@xilinx.com>
Reviewed-by: Hyun Kwon <hyun.kwon@xilinx.com>
State: pending
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 .../platform/xilinx/xilinx-vpss-scaler.c      | 107 ++++++++++++++++--
 1 file changed, 98 insertions(+), 9 deletions(-)

diff --git a/drivers/media/platform/xilinx/xilinx-vpss-scaler.c b/drivers/media/platform/xilinx/xilinx-vpss-scaler.c
index a5270580c72a..1d6f0b094ff8 100644
--- a/drivers/media/platform/xilinx/xilinx-vpss-scaler.c
+++ b/drivers/media/platform/xilinx/xilinx-vpss-scaler.c
@@ -13,6 +13,7 @@
  * GNU General Public License for more details.
  */
 
+#include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/device.h>
 #include <linux/gpio/consumer.h>
@@ -715,6 +716,16 @@ xvsc_coeff_taps12[XV_VSCALER_MAX_V_PHASES][XV_VSCALER_TAPS_12] = {
 #define XV_VSCALER_CTRL_WIDTH_HWREG_VFLTCOEFF		(16)
 #define XV_VSCALER_CTRL_DEPTH_HWREG_VFLTCOEFF		(384)
 
+#define XSCALER_CLK_PROP	BIT(0)
+
+/**
+ * struct xscaler_feature - dt or IP property structure
+ * @flags: Bitmask of properties enabled in IP or dt
+ */
+struct xscaler_feature {
+	u32 flags;
+};
+
 /**
  * struct xscaler_device - Xilinx Scaler device structure
  * @xvip: Xilinx Video IP device
@@ -733,6 +744,9 @@ xvsc_coeff_taps12[XV_VSCALER_MAX_V_PHASES][XV_VSCALER_TAPS_12] = {
  * @vscaler_coeff: The complete array of V-scaler coefficients
  * @is_polyphase: Track if scaling algorithm is polyphase or not
  * @rst_gpio: GPIO reset line to bring VPSS Scaler out of reset
+ * @cfg: Pointer to scaler config structure
+ * @aclk_axis: AXI4-Stream video interface clock
+ * @aclk_ctrl: AXI4-Lite control interface clock
  */
 struct xscaler_device {
 	struct xvip_device xvip;
@@ -754,7 +768,27 @@ struct xscaler_device {
 	bool is_polyphase;
 
 	struct gpio_desc *rst_gpio;
+	const struct xscaler_feature *cfg;
+	struct clk *aclk_axis;
+	struct clk *aclk_ctrl;
+};
+
+static const struct xscaler_feature xlnx_scaler_v1_0 = {
+	.flags = XSCALER_CLK_PROP,
+};
+
+static const struct xscaler_feature xlnx_scaler = {
+	.flags = 0,
+};
+
+static const struct of_device_id xscaler_of_id_table[] = {
+	{ .compatible = "xlnx,v-vpss-scaler",
+		.data = &xlnx_scaler},
+	{ .compatible = "xlnx,v-vpss-scaler-1.0",
+		.data = &xlnx_scaler_v1_0},
+	{ /* end of table */ }
 };
+MODULE_DEVICE_TABLE(of, xscaler_of_id_table);
 
 static inline struct xscaler_device *to_scaler(struct v4l2_subdev *subdev)
 {
@@ -1542,6 +1576,23 @@ static int xscaler_parse_of(struct xscaler_device *xscaler)
 	int ret;
 	u32 port_id, dt_ppc;
 
+	if (xscaler->cfg->flags & XSCALER_CLK_PROP) {
+		xscaler->aclk_axis = devm_clk_get(dev, "aclk_axis");
+		if (IS_ERR(xscaler->aclk_axis)) {
+			ret = PTR_ERR(xscaler->aclk_axis);
+			dev_err(dev, "failed to get aclk_axis (%d)\n", ret);
+			return ret;
+		}
+		xscaler->aclk_ctrl = devm_clk_get(dev, "aclk_ctrl");
+		if (IS_ERR(xscaler->aclk_ctrl)) {
+			ret = PTR_ERR(xscaler->aclk_ctrl);
+			dev_err(dev, "failed to get aclk_ctrl (%d)\n", ret);
+			return ret;
+		}
+	} else {
+		dev_info(dev, "assuming all required clocks are enabled!\n");
+	}
+
 	ret = of_property_read_u32(node, "xlnx,max-height",
 				   &xscaler->max_lines);
 	if (ret < 0) {
@@ -1672,6 +1723,9 @@ static int xscaler_probe(struct platform_device *pdev)
 	struct v4l2_subdev *subdev;
 	struct v4l2_mbus_framefmt *default_format;
 	int ret;
+	const struct of_device_id *match;
+	struct device_node *node = pdev->dev.of_node;
+	struct resource *res;
 
 	xscaler = devm_kzalloc(&pdev->dev, sizeof(*xscaler), GFP_KERNEL);
 	if (!xscaler)
@@ -1679,6 +1733,19 @@ static int xscaler_probe(struct platform_device *pdev)
 
 	xscaler->xvip.dev = &pdev->dev;
 
+	match = of_match_node(xscaler_of_id_table, node);
+	if (!match)
+		return -ENODEV;
+
+	if (!strncmp(match->compatible, xscaler_of_id_table[0].compatible,
+		     strlen(xscaler_of_id_table[0].compatible))) {
+		dev_warn(&pdev->dev,
+			 "%s - compatible string is getting deprecated!\n",
+			 match->compatible);
+	}
+
+	xscaler->cfg = match->data;
+
 	ret = xscaler_parse_of(xscaler);
 	if (ret < 0)
 		return ret;
@@ -1686,9 +1753,31 @@ static int xscaler_probe(struct platform_device *pdev)
 	/* Initialize coefficient parameters */
 	xscaler->max_num_phases = XSCALER_MAX_PHASES;
 
-	ret = xvip_init_resources(&xscaler->xvip);
-	if (ret < 0)
-		return ret;
+	if (xscaler->cfg->flags & XSCALER_CLK_PROP) {
+		res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+		xscaler->xvip.iomem = devm_ioremap_resource(xscaler->xvip.dev,
+							    res);
+		if (IS_ERR(xscaler->xvip.iomem))
+			return PTR_ERR(xscaler->xvip.iomem);
+
+		ret = clk_prepare_enable(xscaler->aclk_axis);
+		if (ret) {
+			dev_err(&pdev->dev, "failed to enable aclk_axis (%d)\n",
+				ret);
+			goto res_cleanup;
+		}
+
+		ret = clk_prepare_enable(xscaler->aclk_ctrl);
+		if (ret) {
+			dev_err(&pdev->dev, "failed to enable aclk_ctrl (%d)\n",
+				ret);
+			goto axis_clk_cleanup;
+		}
+	} else {
+		ret = xvip_init_resources(&xscaler->xvip);
+		if (ret < 0)
+			return ret;
+	}
 
 	/* Reset the Global IP Reset through a PS GPIO */
 	gpiod_set_value_cansleep(xscaler->rst_gpio, XSCALER_RESET_DEASSERT);
@@ -1744,6 +1833,10 @@ static int xscaler_probe(struct platform_device *pdev)
 
 error:
 	media_entity_cleanup(&subdev->entity);
+	clk_disable_unprepare(xscaler->aclk_ctrl);
+axis_clk_cleanup:
+	clk_disable_unprepare(xscaler->aclk_axis);
+res_cleanup:
 	xvip_cleanup_resources(&xscaler->xvip);
 	return ret;
 }
@@ -1755,17 +1848,13 @@ static int xscaler_remove(struct platform_device *pdev)
 
 	v4l2_async_unregister_subdev(subdev);
 	media_entity_cleanup(&subdev->entity);
+	clk_disable_unprepare(xscaler->aclk_ctrl);
+	clk_disable_unprepare(xscaler->aclk_axis);
 	xvip_cleanup_resources(&xscaler->xvip);
 
 	return 0;
 }
 
-static const struct of_device_id xscaler_of_id_table[] = {
-	{ .compatible = "xlnx,v-vpss-scaler" },
-	{ /* end of table */ }
-};
-MODULE_DEVICE_TABLE(of, xscaler_of_id_table);
-
 static struct platform_driver xscaler_driver = {
 	.driver			= {
 		.name		= "xilinx-vpss-scaler",
-- 
2.31.1

