From c8170590b935501208c3c5b857a329c6b9c009ea Mon Sep 17 00:00:00 2001
From: Venkateshwar Rao Gannavarapu <venkateshwar.rao.gannavarapu@xilinx.com>
Date: Fri, 14 Feb 2020 17:36:40 +0530
Subject: [PATCH 1217/1852] staging: xlnx_tsmux: Add stream table update logic

commit ada721ceb14ec3e96410bc003b312cf1ff52bae2 from
https://github.com/Xilinx/linux-xlnx.git

This patch adds the internal stream table update logic to achieve
the bit exactness with software mpegmux encoder.

Signed-off-by: Venkateshwar Rao Gannavarapu <venkateshwar.rao.gannavarapu@xilinx.com>
State: pending
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 drivers/staging/xlnx_tsmux/xlnx_mpg2tsmux.c | 94 +++++++++++++++++----
 1 file changed, 76 insertions(+), 18 deletions(-)

diff --git a/drivers/staging/xlnx_tsmux/xlnx_mpg2tsmux.c b/drivers/staging/xlnx_tsmux/xlnx_mpg2tsmux.c
index adefc930b603..5b2f4f8f8ee8 100644
--- a/drivers/staging/xlnx_tsmux/xlnx_mpg2tsmux.c
+++ b/drivers/staging/xlnx_tsmux/xlnx_mpg2tsmux.c
@@ -576,6 +576,66 @@ static int xlnx_tsmux_ioctl_strmtbl_alloc(struct xlnx_tsmux *mpgmuxts,
 	return -ENOMEM;
 }
 
+/**
+ * xlnx_tsmux_update_intstrm_tbl - updates stream id table
+ * @mpgmuxts: pointer to the device structure
+ *
+ * This function updates the stream id table
+ *
+ * Return: 0 on success and error value on failure.
+ *
+ */
+static int xlnx_tsmux_update_intstrm_tbl(struct xlnx_tsmux *mpgmuxts)
+{
+	struct stream_info *cptr, *intn_cptr;
+	int i, j;
+
+	cptr = (struct stream_info *)mpgmuxts->strmtbl_kaddrs;
+
+	if (!cptr->usageflag)
+		return 0;
+
+	for (i = 0; i < mpgmuxts->num_strmnodes && cptr->usageflag;
+	     i++, cptr++) {
+		intn_cptr = (struct stream_info *)mpgmuxts->intn_strmtbl_kaddrs;
+		/* Adding to table */
+		if (cptr->strmtbl_update == ADD_TO_TBL) {
+			for (j = 0; j < mpgmuxts->num_strmnodes;
+			     j++, intn_cptr++) {
+				if (!intn_cptr->usageflag) {
+					intn_cptr->pid = cptr->pid;
+					intn_cptr->continuity_counter = 0;
+					intn_cptr->usageflag = 1;
+					cptr->usageflag = 0;
+					break;
+				}
+			}
+			if (j == mpgmuxts->num_strmnodes)
+				return -EIO;
+		} else if (cptr->strmtbl_update == DEL_FR_TBL) {
+			/* deleting from table */
+			for (j = 0; j < mpgmuxts->num_strmnodes; j++,
+			     intn_cptr++) {
+				if (intn_cptr->usageflag) {
+					if (intn_cptr->pid == cptr->pid) {
+						intn_cptr->pid = 0;
+						intn_cptr->continuity_counter = 0;
+						intn_cptr->usageflag = 0;
+						cptr->usageflag = 0;
+						break;
+					}
+				}
+			}
+			if (j == mpgmuxts->num_strmnodes)
+				return -EIO;
+		} else {
+			return -EIO;
+		}
+	}
+
+	return 0;
+}
+
 static int xlnx_tsmux_update_strminfo_table(struct xlnx_tsmux *mpgmuxts,
 					    struct strc_strminfo new_strm_info)
 {
@@ -584,25 +644,16 @@ static int xlnx_tsmux_update_strminfo_table(struct xlnx_tsmux *mpgmuxts,
 
 	cptr = (struct stream_info *)mpgmuxts->strmtbl_kaddrs;
 
-	if (new_strm_info.strmtbl_ctxt == ADD_TO_TBL) {
 	/* Finding free memory block and writing input data into the block*/
-		for (i = 0; i < mpgmuxts->num_strmnodes; i++, cptr++) {
-			if (!cptr->usageflag) {
-				cptr->pid = new_strm_info.pid;
-				cptr->continuity_counter = 0;
-				cptr->usageflag = XTSMUX_STRMBL_BUSY;
-				break;
-			}
-		}
-	} else if (new_strm_info.strmtbl_ctxt == DEL_FR_TBL) {
-		for (i = 0; i < mpgmuxts->num_strmnodes; i++, cptr++) {
-			if (cptr->pid == new_strm_info.pid) {
-				cptr->usageflag = XTSMUX_STRMBL_FREE;
-				break;
-			}
+	for (i = 0; i < mpgmuxts->num_strmnodes; i++, cptr++) {
+		if (!cptr->usageflag) {
+			cptr->pid = new_strm_info.pid;
+			cptr->continuity_counter = 0;
+			cptr->usageflag = XTSMUX_STRMBL_BUSY;
+			cptr->strmtbl_update = new_strm_info.strmtbl_ctxt;
+			break;
 		}
 	}
-
 	if (i == mpgmuxts->num_strmnodes)
 		return -EIO;
 
@@ -769,7 +820,7 @@ static enum xlnx_tsmux_status xlnx_tsmux_get_device_status(struct xlnx_tsmux *
 static int xlnx_tsmux_ioctl_start(struct xlnx_tsmux *mpgmuxts)
 {
 	enum xlnx_tsmux_status ip_stat;
-	int cnt;
+	int cnt, ret;
 
 	/* get IP status */
 	ip_stat = xlnx_tsmux_get_device_status(mpgmuxts);
@@ -787,6 +838,13 @@ static int xlnx_tsmux_ioctl_start(struct xlnx_tsmux *mpgmuxts)
 	cnt = atomic_read(&mpgmuxts->stream_count);
 	atomic_set(&mpgmuxts->intn_stream_count, cnt);
 
+	/* update streamid table */
+	ret = xlnx_tsmux_update_intstrm_tbl(mpgmuxts);
+
+	if (ret < 0) {
+		dev_err(mpgmuxts->dev, "Update streamid intn table failed\n");
+		return ret;
+	}
 	return xlnx_tsmux_start_muxer(mpgmuxts);
 }
 
@@ -1208,7 +1266,7 @@ static __poll_t xlnx_tsmux_poll(struct file *fptr, poll_table *wait)
 	poll_wait(fptr, &mpgmuxts->waitq, wait);
 
 	if (xlnx_tsmux_read(mpgmuxts, XTSMUX_LAST_NODE_PROCESSED))
-		return EPOLLIN | EPOLLPRI;
+		return POLLIN | POLLPRI;
 
 	return 0;
 }
-- 
2.31.1

