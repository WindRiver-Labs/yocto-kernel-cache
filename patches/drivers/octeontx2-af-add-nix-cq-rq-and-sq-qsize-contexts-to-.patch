From 69678313a9e38cc24a926ae745f2e42822e7c131 Mon Sep 17 00:00:00 2001
From: Prakash Brahmajyosyula <bprakash@marvell.com>
Date: Tue, 26 Mar 2019 19:15:35 +0530
Subject: [PATCH 104/767] octeontx2-af: add nix {cq,rq and sq} qsize contexts
 to debugfs.

commit 8a87e327f18714849557faacc4c32f747734f381 from
git@git.assembla.com:cavium/WindRiver.linux.git

added functions to dump the qsize context for nix queues, i,e cq, rq
and sq. As "qsize" write and display patterns are common for npa
and nix, generalized code by creating new apis.

"qsize" new file added to debugfs at 'sys/kernel/debug/octeontx2/nix/'
and it dump's the nix{cq,rq &sq} bitmaps and qsize values.

Usage:
echo <nixlf> > /sys/ernel/debug/octeontx2/nix/qsize
cat /sys/kernel/debug/octeontx2/nix/qsize

Change-Id: I90460de3d7dc6bd3b7a588f6d8e709186ba91d32
Signed-off-by: Prakash Brahmajyosyula <bprakash@marvell.com>
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../net/ethernet/marvell/octeontx2/af/rvu.h   |   1 +
 .../marvell/octeontx2/af/rvu_debugfs.c        | 157 ++++++++++++++----
 2 files changed, 129 insertions(+), 29 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu.h b/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
index bd4cdd459431..c29fd5f78a4b 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
@@ -67,6 +67,7 @@ struct rvu_debugfs {
 	struct dump_ctx nix_sq_ctx;
 	struct cpt_dump_ctx cpt_ctx;
 	int npa_qsize_id;
+	int nix_qsize_id;
 };
 #endif /* CONFIG_DEBUG_FS */
 
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_debugfs.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_debugfs.c
index 536d91b7dc3f..82edffd41552 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_debugfs.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_debugfs.c
@@ -108,6 +108,8 @@ static const struct file_operations rvu_dbg_##name##_fops = { \
 	.write = rvu_dbg_##write_op \
 }
 
+static void print_nix_qsize(struct seq_file *filp, struct rvu_pfvf *pfvf);
+
 /* Dumps current provisioning status of all RVU block LFs */
 static ssize_t rvu_dbg_rsrc_attach_status(struct file *filp,
 					  char __user *buffer,
@@ -226,26 +228,13 @@ static bool rvu_dbg_is_valid_lf(struct rvu *rvu, int blktype, int lf,
 	return true;
 }
 
-/* The 'qsize' entry dumps current Aura/Pool context Qsize
- * and each context's current enable/disable status in a bitmap.
- */
-static int rvu_dbg_npa_qsize_display(struct seq_file *m, void *unsused)
+static void print_npa_qsize(struct seq_file *m, struct rvu_pfvf *pfvf)
 {
-	struct rvu_pfvf *pfvf;
-	struct rvu *rvu;
-	u16 pcifunc;
 	char *buf;
 
-	rvu = m->private;
-
-	if (!rvu_dbg_is_valid_lf(rvu, BLKTYPE_NPA, rvu->rvu_dbg.npa_qsize_id,
-				 &pcifunc))
-		return -EINVAL;
-
-	pfvf = rvu_get_pfvf(rvu, pcifunc);
 	buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
 	if (!buf)
-		return PTR_ERR(buf);
+		return;
 
 	if (!pfvf->aura_ctx) {
 		seq_puts(m, "Aura context is not initialized\n");
@@ -265,19 +254,56 @@ static int rvu_dbg_npa_qsize_display(struct seq_file *m, void *unsused)
 		seq_printf(m, "Pool context ena/dis bitmap : %s\n", buf);
 	}
 	kfree(buf);
+}
+
+/* The 'qsize' entry dumps current Aura/Pool context Qsize
+ * and each context's current enable/disable status in a bitmap.
+ */
+static int rvu_dbg_qsize_display(struct seq_file *filp, void *unsused,
+				 int blktype)
+{
+	void (*print_qsize)(struct seq_file *filp,
+			    struct rvu_pfvf *pfvf) = NULL;
+	struct rvu_pfvf *pfvf;
+	struct rvu *rvu;
+	int qsize_id;
+	u16 pcifunc;
+
+	rvu = filp->private;
+	switch (blktype) {
+	case BLKTYPE_NPA:
+		qsize_id = rvu->rvu_dbg.npa_qsize_id;
+		print_qsize = print_npa_qsize;
+		break;
+
+	case BLKTYPE_NIX:
+		qsize_id = rvu->rvu_dbg.nix_qsize_id;
+		print_qsize = print_nix_qsize;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	if (!rvu_dbg_is_valid_lf(rvu, blktype, qsize_id, &pcifunc))
+		return -EINVAL;
+
+	pfvf = rvu_get_pfvf(rvu, pcifunc);
+	print_qsize(filp, pfvf);
+
 	return 0;
 }
 
-static ssize_t rvu_dbg_npa_qsize_write(struct file *filp,
-				       const char __user *buffer,
-				       size_t count, loff_t *ppos)
+static ssize_t rvu_dbg_qsize_write(struct file *filp,
+				   const char __user *buffer, size_t count,
+				   loff_t *ppos, int blktype)
 {
+	char *blk_string = (blktype == BLKTYPE_NPA) ? "npa" : "nix";
 	struct seq_file *seqfile = filp->private_data;
 	char *cmd_buf, *cmd_buf_tmp, *subtoken;
 	struct rvu *rvu = seqfile->private;
 	u16 pcifunc;
-	int npalf;
-	int ret;
+	int ret, lf;
 
 	cmd_buf = memdup_user(buffer, count);
 	if (IS_ERR(cmd_buf))
@@ -293,26 +319,44 @@ static ssize_t rvu_dbg_npa_qsize_write(struct file *filp,
 
 	cmd_buf_tmp = cmd_buf;
 	subtoken = strsep(&cmd_buf, " ");
-	ret = subtoken ? kstrtoint(subtoken, 10, &npalf) : -EINVAL;
+	ret = subtoken ? kstrtoint(subtoken, 10, &lf) : -EINVAL;
 	if (cmd_buf)
 		ret = -EINVAL;
 
 	if (!strncmp(subtoken, "help", 4) || ret < 0) {
-		dev_info(rvu->dev, "Use echo <npalf > qsize\n");
-		goto npa_qsize_write_done;
+		dev_info(rvu->dev, "Use echo <%s-lf > qsize\n", blk_string);
+		goto qsize_write_done;
 	}
 
-	if (!rvu_dbg_is_valid_lf(rvu, BLKTYPE_NPA, npalf, &pcifunc)) {
+	if (!rvu_dbg_is_valid_lf(rvu, blktype, lf, &pcifunc)) {
 		ret = -EINVAL;
-		goto npa_qsize_write_done;
+		goto qsize_write_done;
 	}
-	rvu->rvu_dbg.npa_qsize_id = npalf;
+	if (blktype  == BLKTYPE_NPA)
+		rvu->rvu_dbg.npa_qsize_id = lf;
+	else
+		rvu->rvu_dbg.nix_qsize_id = lf;
 
-npa_qsize_write_done:
+qsize_write_done:
 	kfree(cmd_buf_tmp);
 	return ret ? ret : count;
 }
 
+static ssize_t rvu_dbg_npa_qsize_write(struct file *filp,
+				       const char __user *buffer,
+				       size_t count, loff_t *ppos)
+{
+	return rvu_dbg_qsize_write(filp, buffer, count, ppos,
+					    BLKTYPE_NPA);
+}
+
+static int rvu_dbg_npa_qsize_display(struct seq_file *filp, void *unused)
+{
+	return rvu_dbg_qsize_display(filp, unused, BLKTYPE_NPA);
+}
+
+RVU_DEBUG_SEQ_FOPS(npa_qsize, npa_qsize_display, npa_qsize_write);
+
 /* Dumps given NPA Aura's context */
 static void print_npa_aura_ctx(struct seq_file *m, struct npa_aq_enq_rsp *rsp)
 {
@@ -599,8 +643,6 @@ static ssize_t rvu_dbg_npa_ctx_write(struct file *filp,
 	return ret ? ret : count;
 }
 
-RVU_DEBUG_SEQ_FOPS(npa_qsize, npa_qsize_display, npa_qsize_write);
-
 static ssize_t rvu_dbg_npa_aura_ctx_write(struct file *filp,
 					  const char __user *buffer,
 					  size_t count, loff_t *ppos)
@@ -1456,6 +1498,58 @@ static void rvu_dbg_npc_init(struct rvu *rvu)
 	debugfs_remove_recursive(rvu->rvu_dbg.npc);
 }
 
+static void print_nix_qctx_qsize(struct seq_file *filp, int qsize,
+				 unsigned long *bmap, char *qtype)
+{
+	char *buf;
+
+	buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	if (!buf)
+		return;
+
+	bitmap_print_to_pagebuf(false, buf, bmap, qsize);
+	seq_printf(filp, "%s context count : %d\n", qtype, qsize);
+	seq_printf(filp, "%s context ena/dis bitmap : %s\n",
+		   qtype, buf);
+	kfree(buf);
+}
+
+static void print_nix_qsize(struct seq_file *filp, struct rvu_pfvf *pfvf)
+{
+	if (!pfvf->cq_ctx)
+		seq_puts(filp, "cq context is not initialized\n");
+	else
+		print_nix_qctx_qsize(filp, pfvf->cq_ctx->qsize, pfvf->cq_bmap,
+				     "cq");
+
+	if (!pfvf->rq_ctx)
+		seq_puts(filp, "rq context is not initialized\n");
+	else
+		print_nix_qctx_qsize(filp, pfvf->rq_ctx->qsize, pfvf->rq_bmap,
+				     "rq");
+
+	if (!pfvf->sq_ctx)
+		seq_puts(filp, "sq context is not initialized\n");
+	else
+		print_nix_qctx_qsize(filp, pfvf->sq_ctx->qsize, pfvf->sq_bmap,
+				     "sq");
+}
+
+static ssize_t rvu_dbg_nix_qsize_write(struct file *filp,
+				       const char __user *buffer,
+				       size_t count, loff_t *ppos)
+{
+	return rvu_dbg_qsize_write(filp, buffer, count, ppos,
+				   BLKTYPE_NIX);
+}
+
+static int rvu_dbg_nix_qsize_display(struct seq_file *filp, void *unused)
+{
+	return rvu_dbg_qsize_display(filp, unused, BLKTYPE_NIX);
+}
+
+RVU_DEBUG_SEQ_FOPS(nix_qsize, nix_qsize_display, nix_qsize_write);
+
 static void rvu_dbg_nix_init(struct rvu *rvu)
 {
 	const struct device *dev = &rvu->pdev->dev;
@@ -1502,6 +1596,11 @@ static void rvu_dbg_nix_init(struct rvu *rvu)
 	if (!pfile)
 		goto create_failed;
 
+	pfile = debugfs_create_file("qsize", 0600, rvu->rvu_dbg.nix, rvu,
+				    &rvu_dbg_nix_qsize_fops);
+	if (!pfile)
+		goto create_failed;
+
 	return;
 create_failed:
 	dev_err(dev, "Failed to create debugfs dir/file for NIX\n");
-- 
2.31.1

