From 9d826f15cf6913af1f8f86446f42c173ac0ce65a Mon Sep 17 00:00:00 2001
From: Ben Levinsky <ben.levinsky@xilinx.com>
Date: Mon, 6 Apr 2020 07:20:07 -0700
Subject: [PATCH 1321/1851] remoteproc: zynq: Add explicit nodes for vrings

commit 2c7618605b13e7ef928c610178ccd5c6edc601f9 from
https://github.com/Xilinx/linux-xlnx.git

This patch changes zynq driver to specify the firmware memory that
is required explicitly. Without this, the driver will not work, as the CMA
allocated memory will instead be used.

In conjunction this patch also enables user to specify the vring and
shared buffer location to ensure that only this aforementioned
memory space is used.

Signed-off-by: Ben Levinsky <ben.levinsky@xilinx.com>
Acked-by: Wendy Liang <wendy.liang@xilinx.com>
State: not-upstreamable
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 drivers/remoteproc/zynq_remoteproc.c | 175 ++++++++++++---------------
 1 file changed, 78 insertions(+), 97 deletions(-)

diff --git a/drivers/remoteproc/zynq_remoteproc.c b/drivers/remoteproc/zynq_remoteproc.c
index 503a4aeb0bdf..a110de99907a 100644
--- a/drivers/remoteproc/zynq_remoteproc.c
+++ b/drivers/remoteproc/zynq_remoteproc.c
@@ -177,53 +177,92 @@ static int zynq_rproc_stop(struct rproc *rproc)
 	return 0;
 }
 
-static void *zynq_rproc_da_to_va(struct rproc *rproc, u64 da, int len)
+static int zynq_parse_fw(struct rproc *rproc, const struct firmware *fw)
 {
-	struct zynq_rproc_pdata *local = rproc->priv;
-	struct zynq_mem_res *mem_res;
-	struct device *dev;
-
-	dev = rproc->dev.parent;
-	list_for_each_entry(mem_res, &local->fw_mems, node) {
-		/* This function will only get called if
-		 * the reserved firmware memory is not yet
-		 * added to the carved out list.
-		 */
-		struct rproc_mem_entry *mem;
-		struct resource *res = &mem_res->res;
-		u64 res_da = (u64)res->start;
-		resource_size_t size;
-		int offset;
-		void *va;
-		dma_addr_t dma;
-
-		size = resource_size(res);
-		offset = (int)(da - res_da);
-		if (offset < 0)
-			continue;
-		if (da > (res_da + size))
-			continue;
-		va = devm_ioremap_wc(dev, res->start, size);
-		dma = (dma_addr_t)res->start;
-		mem = rproc_mem_entry_init(dev, va, dma, (int)size,
-					   (u32)res->start,
-					   NULL, NULL, res->name);
-		if (!mem)
-			return NULL;
-		dev_dbg(dev, "%s: %s, va = %p, da = 0x%x dma = 0x%x\n",
-			__func__, mem->name, mem->va,
-			mem->da, mem->dma);
-		rproc_add_carveout(rproc, mem);
-		return (char *)va + offset;
+	int num_mems, i, ret;
+	struct device *dev = rproc->dev.parent;
+	struct device_node *np = dev->of_node;
+	struct rproc_mem_entry *mem;
+
+	num_mems = of_count_phandle_with_args(np, "memory-region", NULL);
+	if (num_mems <= 0)
+		return 0;
+	for (i = 0; i < num_mems; i++) {
+		struct device_node *node;
+		struct reserved_mem *rmem;
+
+		node = of_parse_phandle(np, "memory-region", i);
+		rmem = of_reserved_mem_lookup(node);
+		if (!rmem) {
+			dev_err(dev, "unable to acquire memory-region\n");
+			return -EINVAL;
+		}
+		if (strstr(node->name, "vdev") &&
+			strstr(node->name, "buffer")) {
+			/* Register DMA region */
+			mem = rproc_mem_entry_init(dev, NULL,
+						   (dma_addr_t)rmem->base,
+						   rmem->size, rmem->base,
+						   NULL, NULL,
+						   node->name);
+			if (!mem) {
+				dev_err(dev,
+					"unable to initialize memory-region %s \n",
+					node->name);
+				return -ENOMEM;
+			}
+			rproc_add_carveout(rproc, mem);
+		} else if (strstr(node->name, "vdev") &&
+			   strstr(node->name, "vring")) {
+			/* Register vring */
+			mem = rproc_mem_entry_init(dev, NULL,
+						   (dma_addr_t)rmem->base,
+						   rmem->size, rmem->base,
+						   NULL, NULL,
+						   node->name);
+			mem->va = devm_ioremap_wc(dev, rmem->base, rmem->size);
+			if (!mem->va)
+				return -ENOMEM;
+			if (!mem) {
+				dev_err(dev,
+					"unable to initialize memory-region %s\n",
+					node->name);
+				return -ENOMEM;
+			}
+			rproc_add_carveout(rproc, mem);
+		} else {
+			mem = rproc_of_resm_mem_entry_init(dev, i,
+							rmem->size,
+							rmem->base,
+							node->name);
+			if (!mem) {
+				dev_err(dev,
+					"unable to initialize memory-region %s \n",
+					node->name);
+				return -ENOMEM;
+			}
+			mem->va = devm_ioremap_wc(dev, rmem->base, rmem->size);
+			if (!mem->va)
+				return -ENOMEM;
+
+			rproc_add_carveout(rproc, mem);
+		}
 	}
-	return NULL;
+
+	ret = rproc_elf_load_rsc_table(rproc, fw);
+	if (ret == -EINVAL)
+		ret = 0;
+	return ret;
 }
 
 static struct rproc_ops zynq_rproc_ops = {
 	.start		= zynq_rproc_start,
 	.stop		= zynq_rproc_stop,
+	.load		= rproc_elf_load_segments,
+	.parse_fw	= zynq_parse_fw,
+	.find_loaded_rsc_table = rproc_elf_find_loaded_rsc_table,
+	.get_boot_addr	= rproc_elf_get_boot_addr,
 	.kick		= zynq_rproc_kick,
-	.da_to_va	= zynq_rproc_da_to_va,
 };
 
 /* Just to detect bug if interrupt forwarding is broken */
@@ -266,57 +305,6 @@ static void clear_irq(struct rproc *rproc)
 	}
 }
 
-static int zynq_rproc_add_mems(struct zynq_rproc_pdata *pdata)
-{
-	int num_mems, i;
-	struct device *dev = pdata->rproc->dev.parent;
-	struct device_node *np = dev->of_node;
-
-	INIT_LIST_HEAD(&pdata->fw_mems);
-	num_mems = of_count_phandle_with_args(np, "memory-region", NULL);
-	if (num_mems <= 0)
-		return 0;
-	for (i = 0; i < num_mems; i++) {
-		struct device_node *node;
-		struct zynq_mem_res *mem_res;
-		int ret;
-
-		node = of_parse_phandle(np, "memory-region", i);
-		ret = of_device_is_compatible(node, "shared-dma-pool");
-		if (ret) {
-			/* it is DMA memory. */
-			ret = of_reserved_mem_device_init_by_idx(dev, np, i);
-			if (ret) {
-				dev_err(dev, "unable to reserve DMA mem.\n");
-				return ret;
-			}
-			dev_dbg(dev, "%s, dma memory %s.\n",
-				__func__, of_node_full_name(node));
-			continue;
-		}
-		/*
-		 * It is non-DMA memory, used for firmware loading.
-		 * It will be added to the remoteproc carveouts later while
-		 * loading the firmware.
-		 * It needs to keep track of the memory resource here and
-		 * add it to carveouts when loading firmware because
-		 * the carveouts will be removed when rproc stops the processor.
-		 */
-		mem_res = devm_kzalloc(dev, sizeof(*mem_res), GFP_KERNEL);
-		if (!mem_res)
-			return -ENOMEM;
-		ret = of_address_to_resource(node, 0, &mem_res->res);
-		if (ret) {
-			dev_err(dev, "unable to resolve memory region.\n");
-			return ret;
-		}
-		list_add_tail(&mem_res->node, &pdata->fw_mems);
-		dev_dbg(dev, "%s, non-dma mem %s\n",
-			__func__, of_node_full_name(node));
-	}
-	return 0;
-}
-
 static int zynq_remoteproc_probe(struct platform_device *pdev)
 {
 	int ret = 0;
@@ -409,13 +397,6 @@ static int zynq_remoteproc_probe(struct platform_device *pdev)
 		goto ipi_fault;
 	}
 
-	/* Find on-chip memory */
-	ret = zynq_rproc_add_mems(local);
-	if (ret) {
-		dev_err(&pdev->dev, "rproc failed to add mems\n");
-		goto ipi_fault;
-	}
-
 	rproc->auto_boot = autoboot;
 
 	ret = rproc_add(local->rproc);
-- 
2.31.1

