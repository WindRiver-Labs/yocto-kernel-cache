From 3a0476e0c88638263a2bae47451d1bc12abc133b Mon Sep 17 00:00:00 2001
From: Michal Simek <michal.simek@xilinx.com>
Date: Mon, 16 Mar 2020 13:37:55 +0100
Subject: [PATCH 0995/1851] usb: dwc3: of-simple: Enable CCI support in dwc3
 driver

commit 8110b9b0dcabf1f2fcfcf8279e4aeec1f03bafcc from
https://github.com/Xilinx/linux-xlnx.git

This patch adds CCI support in DWC3 driver when CCI is enabled in the
design. There are couple of registers which need to be modified for
making CCI enabled transfers in USB. This patch add the support for the
same.

Signed-off-by: Piyush Mehta <piyush.mehta@xilinx.com>
Signed-off-by: Manish Narani <manish.narani@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
State: pending
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 drivers/usb/dwc3/core.c           | 44 +++++++++++++++++++++++++++++++
 drivers/usb/dwc3/core.h           |  9 +++++++
 drivers/usb/dwc3/dwc3-of-simple.c | 30 +++++++++++++++++++++
 3 files changed, 83 insertions(+)

diff --git a/drivers/usb/dwc3/core.c b/drivers/usb/dwc3/core.c
index 0de2ded3a4e4..5f6decc9aa86 100644
--- a/drivers/usb/dwc3/core.c
+++ b/drivers/usb/dwc3/core.c
@@ -25,6 +25,7 @@
 #include <linux/of.h>
 #include <linux/acpi.h>
 #include <linux/pinctrl/consumer.h>
+#include <linux/of_address.h>
 #include <linux/reset.h>
 
 #include <linux/usb/ch9.h>
@@ -528,6 +529,45 @@ static void dwc3_cache_hwparams(struct dwc3 *dwc)
 	parms->hwparams8 = dwc3_readl(dwc->regs, DWC3_GHWPARAMS8);
 }
 
+static int dwc3_config_soc_bus(struct dwc3 *dwc)
+{
+	int ret;
+
+	/*
+	 * Check if CCI is enabled for USB. Returns true
+	 * if the node has property 'dma-coherent'. Otherwise
+	 * returns false.
+	 */
+	if (of_dma_is_coherent(dwc->dev->of_node)) {
+		u32 reg;
+
+		reg = dwc3_readl(dwc->regs, DWC3_GSBUSCFG0);
+		reg |= DWC3_GSBUSCFG0_DATRDREQINFO |
+			DWC3_GSBUSCFG0_DESRDREQINFO |
+			DWC3_GSBUSCFG0_DATWRREQINFO |
+			DWC3_GSBUSCFG0_DESWRREQINFO;
+		dwc3_writel(dwc->regs, DWC3_GSBUSCFG0, reg);
+	}
+
+	/*
+	 * This routes the usb dma traffic to go through CCI path instead
+	 * of reaching DDR directly. This traffic routing is needed to
+	 * to make SMMU and CCI work with USB dma.
+	 */
+	if (of_dma_is_coherent(dwc->dev->of_node) || dwc->dev->iommu_group) {
+		ret = dwc3_enable_hw_coherency(dwc->dev);
+		if (ret)
+			return ret;
+	}
+
+	/* Send struct dwc3 to dwc3-of-simple for configuring VBUS
+	 * during suspend/resume
+	 */
+	dwc3_set_simple_data(dwc);
+
+	return 0;
+}
+
 static int dwc3_core_ulpi_init(struct dwc3 *dwc)
 {
 	int intf;
@@ -953,6 +993,10 @@ static int dwc3_core_init(struct dwc3 *dwc)
 
 	dwc3_set_incr_burst_type(dwc);
 
+	ret = dwc3_config_soc_bus(dwc);
+	if (ret)
+		goto err1;
+
 	usb_phy_set_suspend(dwc->usb2_phy, 0);
 	usb_phy_set_suspend(dwc->usb3_phy, 0);
 	ret = phy_power_on(dwc->usb2_generic_phy);
diff --git a/drivers/usb/dwc3/core.h b/drivers/usb/dwc3/core.h
index dddbb2dd217f..ff627ca1e213 100644
--- a/drivers/usb/dwc3/core.h
+++ b/drivers/usb/dwc3/core.h
@@ -199,6 +199,12 @@
 #define DWC3_EVENTQ		7
 #define DWC3_AUXEVENTQ		8
 
+/* Global SoC Bus Configuration Register */
+#define DWC3_GSBUSCFG0_DATRDREQINFO	(0xf << 28)
+#define DWC3_GSBUSCFG0_DESRDREQINFO	(0xf << 24)
+#define DWC3_GSBUSCFG0_DATWRREQINFO	(0xf << 20)
+#define DWC3_GSBUSCFG0_DESWRREQINFO	(0xf << 16)
+
 /* Global RX Threshold Configuration Register */
 #define DWC3_GRXTHRCFG_MAXRXBURSTSIZE(n) (((n) & 0x1f) << 19)
 #define DWC3_GRXTHRCFG_RXPKTCNT(n) (((n) & 0xf) << 24)
@@ -1419,9 +1425,12 @@ static inline bool dwc3_is_usb31(struct dwc3 *dwc)
 }
 
 #if IS_ENABLED(CONFIG_USB_DWC3_OF_SIMPLE)
+int dwc3_enable_hw_coherency(struct device *dev);
 void dwc3_simple_wakeup_capable(struct device *dev, bool wakeup);
 void dwc3_set_simple_data(struct dwc3 *dwc);
 #else
+static inline int dwc3_enable_hw_coherency(struct device *dev)
+{ return 1; }
 void dwc3_simple_wakeup_capable(struct device *dev, bool wakeup)
 { ; }
 void dwc3_set_simple_data(struct dwc3 *dwc)
diff --git a/drivers/usb/dwc3/dwc3-of-simple.c b/drivers/usb/dwc3/dwc3-of-simple.c
index c45630bcf959..5ba8fd87b556 100644
--- a/drivers/usb/dwc3/dwc3-of-simple.c
+++ b/drivers/usb/dwc3/dwc3-of-simple.c
@@ -21,12 +21,19 @@
 #include <linux/of_platform.h>
 #include <linux/pm_runtime.h>
 #include <linux/reset.h>
+#include <linux/soc/xilinx/zynqmp/fw.h>
+#include <linux/slab.h>
 
 #include <linux/phy/phy-zynqmp.h>
+#include <linux/of_address.h>
 
 #include "core.h"
 #include "io.h"
 
+/* Xilinx USB 3.0 IP Register */
+#define XLNX_USB_COHERENCY		0x005C
+#define XLNX_USB_COHERENCY_ENABLE	0x1
+
 /* ULPI control registers */
 #define ULPI_OTG_CTRL_SET		0xB
 #define ULPI_OTG_CTRL_CLEAR		0XC
@@ -48,6 +55,29 @@ struct dwc3_of_simple {
 	bool			need_reset;
 };
 
+int dwc3_enable_hw_coherency(struct device *dev)
+{
+	struct device_node *node = of_get_parent(dev->of_node);
+
+	if (of_device_is_compatible(node, "xlnx,zynqmp-dwc3")) {
+		struct platform_device *pdev_parent;
+		struct dwc3_of_simple *simple;
+		void __iomem *regs;
+		u32 reg;
+
+		pdev_parent = of_find_device_by_node(node);
+		simple = platform_get_drvdata(pdev_parent);
+		regs = simple->regs;
+
+		reg = readl(regs + XLNX_USB_COHERENCY);
+		reg |= XLNX_USB_COHERENCY_ENABLE;
+		writel(reg, regs + XLNX_USB_COHERENCY);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(dwc3_enable_hw_coherency);
+
 void dwc3_set_simple_data(struct dwc3 *dwc)
 {
 	struct device_node *node = of_get_parent(dwc->dev->of_node);
-- 
2.31.1

