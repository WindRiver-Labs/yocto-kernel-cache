From 48ecdf4edb167e432a4251fde33a59df75f43d3e Mon Sep 17 00:00:00 2001
From: Laurent Pinchart <[laurent.pinchart@ideasonboard.com]>
Date: Wed, 25 Jun 2014 15:18:13 -0700
Subject: [PATCH 0198/1851] media: xilinx: Add HLS core driver

commit d494b0c170eb437dae159ecaaac7d45e4defa96c from
https://github.com/Xilinx/linux-xlnx.git

Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
State: pending
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 .../bindings/media/xilinx/xlnx,v-hls.txt      |  64 +++
 drivers/media/platform/xilinx/Kconfig         |   6 +
 drivers/media/platform/xilinx/Makefile        |   1 +
 .../media/platform/xilinx/xilinx-hls-common.h |  36 ++
 drivers/media/platform/xilinx/xilinx-hls.c    | 481 ++++++++++++++++++
 include/uapi/linux/xilinx-hls.h               |  21 +
 include/uapi/linux/xilinx-v4l2-controls.h     |   9 +
 7 files changed, 618 insertions(+)
 create mode 100644 Documentation/devicetree/bindings/media/xilinx/xlnx,v-hls.txt
 create mode 100644 drivers/media/platform/xilinx/xilinx-hls-common.h
 create mode 100644 drivers/media/platform/xilinx/xilinx-hls.c
 create mode 100644 include/uapi/linux/xilinx-hls.h

diff --git a/Documentation/devicetree/bindings/media/xilinx/xlnx,v-hls.txt b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-hls.txt
new file mode 100644
index 000000000000..a6db3040565a
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-hls.txt
@@ -0,0 +1,64 @@
+Xilinx High-Level Synthesis Core (HLS)
+--------------------------------------
+
+High-Level Synthesis cores are synthesized from a high-level function
+description developed by the user. As such their functions vary widely, but
+they all share a set of common characteristics that allow them to be described
+by common bindings.
+
+
+Required properties:
+
+- compatible: This property must contain "xlnx,v-hls" to indicate that the
+  core is compatible with the generic Xilinx HLS DT bindings. It can also
+  contain a more specific string to identify the HLS core implementation. The
+  value of those implementation-specific strings is out of scope for these DT
+  bindings.
+
+- reg: Physical base address and length of the registers sets for the device.
+  The HLS core has two registers sets, the first one contains the core
+  standard registers and the second one contains the custom user registers.
+
+- clocks: Reference to the video core clock.
+
+- ports: Video ports, using the DT bindings defined in ../video-interfaces.txt.
+  The HLS core has one input port (0) and one output port (1).
+
+Required port properties:
+
+- xlnx,video-format: Video format as defined in video.txt.
+- xlnx,video-width: Video width as defined in video.txt.
+
+Example:
+
+	hls_0: hls@43c00000 {
+		compatible = "xlnx,v-hls-sobel", "xlnx,v-hls";
+		reg = <0x43c00000 0x24>, <0x43c00024 0xa0>;
+		clocks = <&clkc 15>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+
+				xlnx,video-format = <XVIP_VF_YUV_422>;
+				xlnx,video-width = <8>;
+
+				hls0_in: endpoint {
+					remote-endpoint = <&vdma_out>;
+				};
+			};
+			port@1 {
+				reg = <1>;
+
+				xlnx,video-format = <XVIP_VF_YUV_422>;
+				xlnx,video-width = <8>;
+
+				hls0_out: endpoint {
+					remote-endpoint = <&vdma_in>;
+				};
+			};
+		};
+	};
diff --git a/drivers/media/platform/xilinx/Kconfig b/drivers/media/platform/xilinx/Kconfig
index a1b31e51d678..728f9ad77ce3 100644
--- a/drivers/media/platform/xilinx/Kconfig
+++ b/drivers/media/platform/xilinx/Kconfig
@@ -24,6 +24,12 @@ config VIDEO_XILINX_CRESAMPLE
 	---help---
 	   Driver for the Xilinx Chroma Resampler
 
+config VIDEO_XILINX_HLS
+	tristate "Xilinx Video HLS Core"
+	depends on VIDEO_XILINX
+	---help---
+	   Driver for the Xilinx Video HLS Cores
+
 config VIDEO_XILINX_REMAPPER
 	tristate "Xilinx Video Remapper"
 	depends on VIDEO_XILINX
diff --git a/drivers/media/platform/xilinx/Makefile b/drivers/media/platform/xilinx/Makefile
index 7e17ed9d127d..9fb4d60b335c 100644
--- a/drivers/media/platform/xilinx/Makefile
+++ b/drivers/media/platform/xilinx/Makefile
@@ -5,6 +5,7 @@ xilinx-video-objs += xilinx-dma.o xilinx-vip.o xilinx-vipp.o
 obj-$(CONFIG_VIDEO_XILINX) += xilinx-video.o
 obj-$(CONFIG_VIDEO_XILINX_CFA) += xilinx-cfa.o
 obj-$(CONFIG_VIDEO_XILINX_CRESAMPLE) += xilinx-cresample.o
+obj-$(CONFIG_VIDEO_XILINX_HLS) += xilinx-hls.o
 obj-$(CONFIG_VIDEO_XILINX_RGB2YUV) += xilinx-rgb2yuv.o
 obj-$(CONFIG_VIDEO_XILINX_SCALER) += xilinx-scaler.o
 obj-$(CONFIG_VIDEO_XILINX_REMAPPER) += xilinx-remapper.o
diff --git a/drivers/media/platform/xilinx/xilinx-hls-common.h b/drivers/media/platform/xilinx/xilinx-hls-common.h
new file mode 100644
index 000000000000..8ecc3cfb8a83
--- /dev/null
+++ b/drivers/media/platform/xilinx/xilinx-hls-common.h
@@ -0,0 +1,36 @@
+/*
+ * Xilinx HLS common header
+ *
+ * Copyright (C) 2013-2015 Xilinx, Inc.
+ *
+ * Contacts: Radhey Shyam Pandey <radheys@xilinx.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __XILINX_HLS_COMMON_H__
+#define __XILINX_HLS_COMMON_H__
+
+#include <linux/bitops.h>
+
+#define XHLS_DEF_WIDTH                          1920
+#define XHLS_DEF_HEIGHT                         1080
+
+#define XHLS_REG_CTRL_DONE                      BIT(1)
+#define XHLS_REG_CTRL_IDLE                      BIT(2)
+#define XHLS_REG_CTRL_READY                     BIT(3)
+#define XHLS_REG_CTRL_AUTO_RESTART              BIT(7)
+#define XHLS_REG_GIE                            0x04
+#define XHLS_REG_GIE_GIE                        BIT(0)
+#define XHLS_REG_IER                            0x08
+#define XHLS_REG_IER_DONE                       BIT(0)
+#define XHLS_REG_IER_READY                      BIT(1)
+#define XHLS_REG_ISR                            0x0c
+#define XHLS_REG_ISR_DONE                       BIT(0)
+#define XHLS_REG_ISR_READY                      BIT(1)
+#define XHLS_REG_ROWS                           0x10
+#define XHLS_REG_COLS                           0x18
+
+#endif /* __XILINX_HLS_COMMON_H__ */
diff --git a/drivers/media/platform/xilinx/xilinx-hls.c b/drivers/media/platform/xilinx/xilinx-hls.c
new file mode 100644
index 000000000000..fc42977440a9
--- /dev/null
+++ b/drivers/media/platform/xilinx/xilinx-hls.c
@@ -0,0 +1,481 @@
+/*
+ * Xilinx HLS Core
+ *
+ * Copyright (C) 2013-2015 Ideas on Board
+ * Copyright (C) 2013-2015 Xilinx, Inc.
+ *
+ * Contacts: Hyun Kwon <hyun.kwon@xilinx.com>
+ *           Laurent Pinchart <laurent.pinchart@ideasonboard.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/xilinx-hls.h>
+#include <linux/xilinx-v4l2-controls.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-subdev.h>
+
+#include "xilinx-hls-common.h"
+#include "xilinx-vip.h"
+
+/**
+ * struct xhls_device - Xilinx HLS Core device structure
+ * @xvip: Xilinx Video IP device
+ * @pads: media pads
+ * @compatible: first DT compatible string for the device
+ * @formats: active V4L2 media bus formats at the sink and source pads
+ * @default_formats: default V4L2 media bus formats
+ * @vip_formats: format information corresponding to the pads active formats
+ * @model: additional description of IP implementation if available
+ * @ctrl_handler: control handler
+ * @user_mem: user portion of the register space
+ * @user_mem_size: size of the user portion of the register space
+ */
+struct xhls_device {
+	struct xvip_device xvip;
+	struct media_pad pads[2];
+
+	const char *compatible;
+
+	struct v4l2_mbus_framefmt formats[2];
+	struct v4l2_mbus_framefmt default_formats[2];
+	const struct xvip_video_format *vip_formats[2];
+
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct v4l2_ctrl *model;
+
+	void __iomem *user_mem;
+	size_t user_mem_size;
+};
+
+static inline struct xhls_device *to_hls(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct xhls_device, xvip.subdev);
+}
+
+/* -----------------------------------------------------------------------------
+ * Controls
+ */
+
+static const struct v4l2_ctrl_config xhls_model_ctrl = {
+	.id	= V4L2_CID_XILINX_HLS_MODEL,
+	.name	= "HLS Model",
+	.type	= V4L2_CTRL_TYPE_STRING,
+	.step	= 1,
+	.flags	= V4L2_CTRL_FLAG_READ_ONLY,
+};
+
+static int xhls_create_controls(struct xhls_device *xhls)
+{
+	struct v4l2_ctrl_config model = xhls_model_ctrl;
+	struct v4l2_ctrl *ctrl;
+
+	model.max = strlen(xhls->compatible);
+	model.min = model.max;
+
+	v4l2_ctrl_handler_init(&xhls->ctrl_handler, 1);
+
+	ctrl = v4l2_ctrl_new_custom(&xhls->ctrl_handler, &model, NULL);
+
+	if (xhls->ctrl_handler.error) {
+		dev_err(xhls->xvip.dev, "failed to add controls\n");
+		return xhls->ctrl_handler.error;
+	}
+
+	v4l2_ctrl_s_ctrl_string(ctrl, xhls->compatible);
+
+	xhls->xvip.subdev.ctrl_handler = &xhls->ctrl_handler;
+
+	return 0;
+}
+
+/* -----------------------------------------------------------------------------
+ * V4L2 Subdevice Core Operations
+ */
+
+static int xhls_user_read(struct xhls_device *xhls,
+			  struct xilinx_axi_hls_registers *regs)
+{
+	unsigned int i;
+	u32 offset;
+	u32 value;
+
+	if (regs->num_regs >= xhls->user_mem_size / 4)
+		return -EINVAL;
+
+	for (i = 0; i < regs->num_regs; ++i) {
+		if (copy_from_user(&offset, &regs->regs[i].offset,
+				   sizeof(offset)))
+			return -EFAULT;
+
+		if (offset >= xhls->user_mem_size || offset & 3)
+			return -EINVAL;
+
+		value = ioread32(xhls->user_mem + offset);
+
+		if (copy_to_user(&regs->regs[i].value, &value, sizeof(value)))
+			return -EFAULT;
+	}
+
+	return 0;
+}
+
+static int xhls_user_write(struct xhls_device *xhls,
+			   struct xilinx_axi_hls_registers *regs)
+{
+	struct xilinx_axi_hls_register reg;
+	unsigned int i;
+
+	if (regs->num_regs >= xhls->user_mem_size / 4)
+		return -EINVAL;
+
+	for (i = 0; i < regs->num_regs; ++i) {
+		if (copy_from_user(&reg, &regs->regs[i], sizeof(reg)))
+			return -EFAULT;
+
+		if (reg.offset >= xhls->user_mem_size || reg.offset & 3)
+			return -EINVAL;
+
+		iowrite32(reg.value, xhls->user_mem + reg.offset);
+	}
+
+	return 0;
+}
+
+static long xhls_ioctl(struct v4l2_subdev *subdev, unsigned int cmd, void *arg)
+{
+	struct xhls_device *xhls = to_hls(subdev);
+
+	switch (cmd) {
+	case XILINX_AXI_HLS_READ:
+		return xhls_user_read(xhls, arg);
+	case XILINX_AXI_HLS_WRITE:
+		return xhls_user_write(xhls, arg);
+	}
+
+	return -ENOTTY;
+}
+
+/* -----------------------------------------------------------------------------
+ * V4L2 Subdevice Video Operations
+ */
+
+static int xhls_s_stream(struct v4l2_subdev *subdev, int enable)
+{
+	struct xhls_device *xhls = to_hls(subdev);
+	struct v4l2_mbus_framefmt *format = &xhls->formats[XVIP_PAD_SINK];
+
+	if (!enable) {
+		xvip_write(&xhls->xvip, XVIP_CTRL_CONTROL, 0);
+		return 0;
+	}
+
+	xvip_write(&xhls->xvip, XHLS_REG_COLS, format->width);
+	xvip_write(&xhls->xvip, XHLS_REG_ROWS, format->height);
+
+	xvip_write(&xhls->xvip, XVIP_CTRL_CONTROL,
+		   XHLS_REG_CTRL_AUTO_RESTART | XVIP_CTRL_CONTROL_SW_ENABLE);
+
+	return 0;
+}
+
+/* -----------------------------------------------------------------------------
+ * V4L2 Subdevice Pad Operations
+ */
+
+static struct v4l2_mbus_framefmt *
+__xhls_get_pad_format(struct xhls_device *xhls,
+		      struct v4l2_subdev_pad_config *cfg,
+		      unsigned int pad, u32 which)
+{
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_format(&xhls->xvip.subdev, cfg, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		return &xhls->formats[pad];
+	default:
+		return NULL;
+	}
+}
+
+static int xhls_get_format(struct v4l2_subdev *subdev,
+			   struct v4l2_subdev_pad_config *cfg,
+			   struct v4l2_subdev_format *fmt)
+{
+	struct xhls_device *xhls = to_hls(subdev);
+
+	fmt->format = *__xhls_get_pad_format(xhls, cfg, fmt->pad, fmt->which);
+
+	return 0;
+}
+
+static int xhls_set_format(struct v4l2_subdev *subdev,
+			   struct v4l2_subdev_pad_config *cfg,
+			   struct v4l2_subdev_format *fmt)
+{
+	struct xhls_device *xhls = to_hls(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	format = __xhls_get_pad_format(xhls, cfg, fmt->pad, fmt->which);
+
+	if (fmt->pad == XVIP_PAD_SOURCE) {
+		fmt->format = *format;
+		return 0;
+	}
+
+	xvip_set_format_size(format, fmt);
+
+	fmt->format = *format;
+
+	/* Propagate the format to the source pad. */
+	format = __xhls_get_pad_format(xhls, cfg, XVIP_PAD_SOURCE,
+					 fmt->which);
+
+	xvip_set_format_size(format, fmt);
+
+	return 0;
+}
+
+/* -----------------------------------------------------------------------------
+ * V4L2 Subdevice Operations
+ */
+
+static int xhls_open(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
+{
+	struct xhls_device *xhls = to_hls(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	/* Initialize with default formats */
+	format = v4l2_subdev_get_try_format(subdev, fh->pad, XVIP_PAD_SINK);
+	*format = xhls->default_formats[XVIP_PAD_SINK];
+
+	format = v4l2_subdev_get_try_format(subdev, fh->pad, XVIP_PAD_SOURCE);
+	*format = xhls->default_formats[XVIP_PAD_SOURCE];
+
+	return 0;
+}
+
+static int xhls_close(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
+{
+	return 0;
+}
+
+static struct v4l2_subdev_core_ops xhls_core_ops = {
+	.ioctl = xhls_ioctl,
+};
+
+static struct v4l2_subdev_video_ops xhls_video_ops = {
+	.s_stream = xhls_s_stream,
+};
+
+static struct v4l2_subdev_pad_ops xhls_pad_ops = {
+	.enum_mbus_code = xvip_enum_mbus_code,
+	.enum_frame_size = xvip_enum_frame_size,
+	.get_fmt = xhls_get_format,
+	.set_fmt = xhls_set_format,
+};
+
+static struct v4l2_subdev_ops xhls_ops = {
+	.core   = &xhls_core_ops,
+	.video  = &xhls_video_ops,
+	.pad    = &xhls_pad_ops,
+};
+
+static const struct v4l2_subdev_internal_ops xhls_internal_ops = {
+	.open = xhls_open,
+	.close = xhls_close,
+};
+
+/* -----------------------------------------------------------------------------
+ * Media Operations
+ */
+
+static const struct media_entity_operations xhls_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+/* -----------------------------------------------------------------------------
+ * Platform Device Driver
+ */
+
+static void xhls_init_formats(struct xhls_device *xhls)
+{
+	struct v4l2_mbus_framefmt *format;
+
+	/* Initialize default and active formats */
+	format = &xhls->default_formats[XVIP_PAD_SINK];
+	format->code = xhls->vip_formats[XVIP_PAD_SINK]->code;
+	format->field = V4L2_FIELD_NONE;
+	format->colorspace = V4L2_COLORSPACE_SRGB;
+
+	format->width = xvip_read(&xhls->xvip, XHLS_REG_COLS);
+	format->height = xvip_read(&xhls->xvip, XHLS_REG_ROWS);
+
+	xhls->formats[XVIP_PAD_SINK] = *format;
+
+	format = &xhls->default_formats[XVIP_PAD_SOURCE];
+	*format = xhls->default_formats[XVIP_PAD_SINK];
+	format->code = xhls->vip_formats[XVIP_PAD_SOURCE]->code;
+
+	xhls->formats[XVIP_PAD_SOURCE] = *format;
+}
+
+static int xhls_parse_of(struct xhls_device *xhls)
+{
+	struct device *dev = xhls->xvip.dev;
+	struct device_node *node = xhls->xvip.dev->of_node;
+	struct device_node *ports;
+	struct device_node *port;
+	u32 port_id;
+	int ret;
+
+	ret = of_property_read_string(node, "compatible", &xhls->compatible);
+	if (ret < 0)
+		return -EINVAL;
+
+	ports = of_get_child_by_name(node, "ports");
+	if (ports == NULL)
+		ports = node;
+
+	/* Get the format description for each pad */
+	for_each_child_of_node(ports, port) {
+		if (port->name && (of_node_cmp(port->name, "port") == 0)) {
+			const struct xvip_video_format *vip_format;
+
+			vip_format = xvip_of_get_format(port);
+			if (IS_ERR(vip_format)) {
+				dev_err(dev, "invalid format in DT");
+				return PTR_ERR(vip_format);
+			}
+
+			ret = of_property_read_u32(port, "reg", &port_id);
+			if (ret < 0) {
+				dev_err(dev, "no reg in DT");
+				return ret;
+			}
+
+			if (port_id != 0 && port_id != 1) {
+				dev_err(dev, "invalid reg in DT");
+				return -EINVAL;
+			}
+
+			xhls->vip_formats[port_id] = vip_format;
+		}
+	}
+
+	return 0;
+}
+
+static int xhls_probe(struct platform_device *pdev)
+{
+	struct v4l2_subdev *subdev;
+	struct xhls_device *xhls;
+	struct resource *mem;
+	int ret;
+
+	xhls = devm_kzalloc(&pdev->dev, sizeof(*xhls), GFP_KERNEL);
+	if (!xhls)
+		return -ENOMEM;
+
+	xhls->xvip.dev = &pdev->dev;
+
+	ret = xhls_parse_of(xhls);
+	if (ret < 0)
+		return ret;
+
+	ret = xvip_init_resources(&xhls->xvip);
+	if (ret < 0)
+		return ret;
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	xhls->user_mem = devm_ioremap_resource(&pdev->dev, mem);
+	if (IS_ERR(xhls->user_mem))
+		return PTR_ERR(xhls->user_mem);
+	xhls->user_mem_size = resource_size(mem);
+
+	/* Reset and initialize the core */
+	xvip_reset(&xhls->xvip);
+
+	/* Initialize V4L2 subdevice and media entity */
+	subdev = &xhls->xvip.subdev;
+	v4l2_subdev_init(subdev, &xhls_ops);
+	subdev->dev = &pdev->dev;
+	subdev->internal_ops = &xhls_internal_ops;
+	strlcpy(subdev->name, dev_name(&pdev->dev), sizeof(subdev->name));
+	v4l2_set_subdevdata(subdev, xhls);
+	subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	xhls_init_formats(xhls);
+
+	xhls->pads[XVIP_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	xhls->pads[XVIP_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	subdev->entity.ops = &xhls_media_ops;
+	ret = media_entity_pads_init(&subdev->entity, 2, xhls->pads);
+	if (ret < 0)
+		goto error;
+
+	ret = xhls_create_controls(xhls);
+	if (ret < 0)
+		goto error;
+
+	platform_set_drvdata(pdev, xhls);
+
+	ret = v4l2_async_register_subdev(subdev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to register subdev\n");
+		goto error;
+	}
+
+	dev_info(xhls->xvip.dev, "device %s found\n", xhls->compatible);
+
+	return 0;
+
+error:
+	v4l2_ctrl_handler_free(&xhls->ctrl_handler);
+	media_entity_cleanup(&subdev->entity);
+	xvip_cleanup_resources(&xhls->xvip);
+	return ret;
+}
+
+static int xhls_remove(struct platform_device *pdev)
+{
+	struct xhls_device *xhls = platform_get_drvdata(pdev);
+	struct v4l2_subdev *subdev = &xhls->xvip.subdev;
+
+	v4l2_async_unregister_subdev(subdev);
+	v4l2_ctrl_handler_free(&xhls->ctrl_handler);
+	media_entity_cleanup(&subdev->entity);
+
+	xvip_cleanup_resources(&xhls->xvip);
+
+	return 0;
+}
+
+static const struct of_device_id xhls_of_id_table[] = {
+	{ .compatible = "xlnx,v-hls" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, xhls_of_id_table);
+
+static struct platform_driver xhls_driver = {
+	.driver = {
+		.name = "xilinx-hls",
+		.of_match_table = xhls_of_id_table,
+	},
+	.probe = xhls_probe,
+	.remove = xhls_remove,
+};
+
+module_platform_driver(xhls_driver);
+
+MODULE_AUTHOR("Laurent Pinchart <laurent.pinchart@ideasonboard.com>");
+MODULE_DESCRIPTION("Xilinx HLS Core Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/include/uapi/linux/xilinx-hls.h b/include/uapi/linux/xilinx-hls.h
new file mode 100644
index 000000000000..a7f6447927e0
--- /dev/null
+++ b/include/uapi/linux/xilinx-hls.h
@@ -0,0 +1,21 @@
+#ifndef __UAPI_XILINX_HLS_H__
+#define __UAPI_XILINX_HLS_H__
+
+#include <linux/ioctl.h>
+#include <linux/types.h>
+#include <linux/videodev2.h>
+
+struct xilinx_axi_hls_register {
+	__u32 offset;
+	__u32 value;
+};
+
+struct xilinx_axi_hls_registers {
+	__u32 num_regs;
+	struct xilinx_axi_hls_register __user *regs;
+};
+
+#define XILINX_AXI_HLS_READ	_IOWR('V', BASE_VIDIOC_PRIVATE+0, struct xilinx_axi_hls_registers)
+#define XILINX_AXI_HLS_WRITE	_IOW('V', BASE_VIDIOC_PRIVATE+1, struct xilinx_axi_hls_registers)
+
+#endif /* __UAPI_XILINX_HLS_H__ */
diff --git a/include/uapi/linux/xilinx-v4l2-controls.h b/include/uapi/linux/xilinx-v4l2-controls.h
index 5ca553872176..e3029c18b33d 100644
--- a/include/uapi/linux/xilinx-v4l2-controls.h
+++ b/include/uapi/linux/xilinx-v4l2-controls.h
@@ -118,4 +118,13 @@
 /* CD coefficient */
 #define V4L2_CID_XILINX_RGB2YUV_DCOEF		(V4L2_CID_XILINX_RGB2YUV + 13)
 
+/*
+ * Xilinx HLS Video IP
+ */
+
+#define V4L2_CID_XILINX_HLS			(V4L2_CID_USER_BASE + 0xc060)
+
+/* The IP model */
+#define V4L2_CID_XILINX_HLS_MODEL		(V4L2_CID_XILINX_HLS + 1)
+
 #endif /* __UAPI_XILINX_V4L2_CONTROLS_H__ */
-- 
2.31.1

