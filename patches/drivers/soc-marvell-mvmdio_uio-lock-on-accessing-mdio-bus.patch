From 7310a08c8199f7239a074b613fe74fadd4fbacfe Mon Sep 17 00:00:00 2001
From: Damian Eppel <deppel@marvell.com>
Date: Sat, 7 Aug 2021 15:11:02 -0700
Subject: [PATCH 1898/1921] soc: marvell: mvmdio_uio: lock on accessing mdio
 bus

mvmdio_uio driver should take the mdio_lock before accessing
the MDIO bus, hence switched to using mdiobus_read/write helper
functions, that do the proper locking.

Signed-off-by: Damian Eppel <deppel@marvell.com>
Change-Id: I972894e801d4682f8774c5640b2ebe6b9ac9d0ff
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/58491
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Chandrakala Chavva <cchavva@marvell.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 drivers/soc/marvell/mvmdio_uio.c | 24 +++++++++++++++---------
 1 file changed, 15 insertions(+), 9 deletions(-)

diff --git a/drivers/soc/marvell/mvmdio_uio.c b/drivers/soc/marvell/mvmdio_uio.c
index ef32418e0a81..6781679f9f64 100644
--- a/drivers/soc/marvell/mvmdio_uio.c
+++ b/drivers/soc/marvell/mvmdio_uio.c
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0
 /* Marvell's MDIO bus uio driver
  *
- * Copyright (C) 2021 Marvell International Ltd.
+ * Copyright (C) 2021 Marvell
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -43,20 +43,23 @@ static ssize_t mv_mdio_device_read(struct file *file,
 {
 	int ret;
 	struct mii_data mii;
+	struct mii_bus *bus;
 
 	if (copy_from_user(&mii, (struct mii_data *)buf, sizeof(struct mii_data))) {
 		pr_err("copy_from_user failed\n");
 		return -EFAULT;
 	}
 
-	if (mv_mii_buses[mii.bus_id] == NULL) {
+	if (mii.bus_id < 0 || mii.bus_id >= MAX_MDIO_BUS)
+		return -EINVAL;
+
+	bus = mv_mii_buses[mii.bus_id];
+	if (!bus) {
 		pr_err("invalid bus_id\n");
 		return -EINVAL;
 	}
 
-	ret = mv_mii_buses[mii.bus_id]->read(mv_mii_buses[mii.bus_id],
-		mii.phy_id, mii.reg);
-
+	ret = mdiobus_read(bus, mii.phy_id, mii.reg);
 	if (ret < 0) {
 		pr_err("smi read failed at Bus: %X, devAddr: %X, regAddr: %X\n",
 			mii.bus_id, mii.phy_id, mii.reg);
@@ -77,20 +80,23 @@ static ssize_t mv_mdio_device_write(struct file *file,
 {
 	int ret;
 	struct mii_data mii;
+	struct mii_bus *bus;
 
 	if (copy_from_user(&mii, (struct mii_data *)buf, sizeof(struct mii_data))) {
 		pr_err("copy_from_user failed\n");
 		return -EFAULT;
 	}
 
-	if (mv_mii_buses[mii.bus_id] == NULL) {
+	if (mii.bus_id < 0 || mii.bus_id >= MAX_MDIO_BUS)
+		return -EINVAL;
+
+	bus = mv_mii_buses[mii.bus_id];
+	if (!bus) {
 		pr_err("invalid bus_id\n");
 		return -EINVAL;
 	}
 
-	ret = mv_mii_buses[mii.bus_id]->write(mv_mii_buses[mii.bus_id],
-		mii.phy_id, mii.reg, mii.data);
-
+	ret = mdiobus_write(bus, mii.phy_id, mii.reg, mii.data);
 	if (ret < 0) {
 		pr_err("smi write failed at bus: %X, devAddr: %X, regAddr: %X\n",
 			mii.bus_id, mii.phy_id, mii.reg);
-- 
2.31.1

