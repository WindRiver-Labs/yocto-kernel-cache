From 2591b4e498d022db5ddb94f81738695a149d01e3 Mon Sep 17 00:00:00 2001
From: Sujeet Baranwal <sbaranwal@marvell.com>
Date: Wed, 1 May 2019 15:34:07 -0700
Subject: [PATCH 0405/1921] mmc: octeontx2: interrupt addition for ncb fault

Hardware issues DMA requests using NCB. If one of these requests
receives a fault, the NCB_FLT interrupt bit is set. This typically
indicates a bad pointer in one of the structures, or SMMU
misconfiguration. The interrupt handling is on par with DMA
errors.

Change-Id: I98e5c409c4fc886103d9c47f76c4fbc25a60ac35
Signed-off-by: Sujeet Baranwal <sbaranwal@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/8534
Tested-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Reviewed-by: Chandrakala Chavva <cchavva@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/26900
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 drivers/mmc/host/cavium.c | 16 +++++++++++++---
 drivers/mmc/host/cavium.h |  1 +
 2 files changed, 14 insertions(+), 3 deletions(-)

diff --git a/drivers/mmc/host/cavium.c b/drivers/mmc/host/cavium.c
index 04b46a595697..f7311bc3149f 100644
--- a/drivers/mmc/host/cavium.c
+++ b/drivers/mmc/host/cavium.c
@@ -485,6 +485,10 @@ irqreturn_t cvm_mmc_interrupt(int irq, void *dev_id)
 		    emm_int & MIO_EMM_INT_CMD_ERR  ||
 		    emm_int & MIO_EMM_INT_DMA_ERR;
 
+	/* Add NCB_FLT interrupt for octtx2 */
+	if (is_mmc_otx2(host))
+		host_done = host_done || emm_int & MIO_EMM_INT_NCB_FLT;
+
 	if (!(host_done && req->done))
 		goto no_req_done;
 
@@ -658,7 +662,7 @@ static void cvm_mmc_dma_request(struct mmc_host *mmc,
 	struct cvm_mmc_slot *slot = mmc_priv(mmc);
 	struct cvm_mmc_host *host = slot->host;
 	struct mmc_data *data;
-	u64 emm_dma, addr;
+	u64 emm_dma, addr, int_enable_mask = 0;
 
 	if (!mrq->data || !mrq->data->sg || !mrq->data->sg_len ||
 	    !mrq->stop || mrq->stop->opcode != MMC_STOP_TRANSMISSION) {
@@ -686,8 +690,14 @@ static void cvm_mmc_dma_request(struct mmc_host *mmc,
 	}
 
 	host->dma_active = true;
-	host->int_enable(host, MIO_EMM_INT_CMD_ERR | MIO_EMM_INT_DMA_DONE |
-			 MIO_EMM_INT_DMA_ERR);
+	int_enable_mask = MIO_EMM_INT_CMD_ERR | MIO_EMM_INT_DMA_DONE |
+			MIO_EMM_INT_DMA_ERR;
+
+	/* Add NCB_FLT interrupt for octtx2 */
+	if (is_mmc_otx2(host))
+		int_enable_mask |= MIO_EMM_INT_NCB_FLT;
+
+	host->int_enable(host, int_enable_mask);
 
 	if (host->dmar_fixup)
 		host->dmar_fixup(host, mrq->cmd, data, addr);
diff --git a/drivers/mmc/host/cavium.h b/drivers/mmc/host/cavium.h
index 172edad3a65f..b1155dbab7cf 100644
--- a/drivers/mmc/host/cavium.h
+++ b/drivers/mmc/host/cavium.h
@@ -174,6 +174,7 @@ struct cvm_mmc_cr_mods {
 #define MIO_EMM_DMA_CFG_SIZE		GENMASK_ULL(55, 36)
 #define MIO_EMM_DMA_CFG_ADR		GENMASK_ULL(35, 0)
 
+#define MIO_EMM_INT_NCB_FLT		BIT_ULL(7)
 #define MIO_EMM_INT_SWITCH_ERR		BIT_ULL(6)
 #define MIO_EMM_INT_SWITCH_DONE		BIT_ULL(5)
 #define MIO_EMM_INT_DMA_ERR		BIT_ULL(4)
-- 
2.31.1

