From fc5fc57a5501cc438e4c83774d387390a268ddef Mon Sep 17 00:00:00 2001
From: Witold Sadowski <wsadowski@marvell.com>
Date: Tue, 16 Mar 2021 02:43:04 -0700
Subject: [PATCH 1331/1921] spi: Split Cadence xSPI driver

Split xSPI driver to multiple files.
It will be possible to change interface
from platform to pci driver for example.

Change-Id: I8a203b39bdba374edb2c53e099c547087c0ec6ce
Signed-off-by: Witold Sadowski <wsadowski@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/47823
Tested-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Reviewed-by: Chandrakala Chavva <cchavva@marvell.com>
Reviewed-by: Suneel Garapati <sgarapati@caviumnetworks.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/48120
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 drivers/spi/Kconfig                     |   4 +-
 drivers/spi/Makefile                    |   3 +-
 drivers/spi/spi-cadence-xspi-platform.c | 137 ++++++++
 drivers/spi/spi-cadence-xspi.c          | 431 ++----------------------
 drivers/spi/spi-cadence-xspi.h          | 256 ++++++++++++++
 5 files changed, 434 insertions(+), 397 deletions(-)
 create mode 100644 drivers/spi/spi-cadence-xspi-platform.c
 create mode 100644 drivers/spi/spi-cadence-xspi.h

diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 9a6d6a1ba454..5f07cb9b2880 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -872,7 +872,7 @@ config SPI_ZYNQMP_GQSPI
 	help
 	  Enables Xilinx GQSPI controller driver for Zynq UltraScale+ MPSoC.
 
-config SPI_CADENCE_XSPI
+config SPI_CADENCE_XSPI_PLATFORM
 	tristate "Cadence XSPI controller"
 	depends on (OF || COMPILE_TEST) && HAS_IOMEM
 	help
@@ -881,7 +881,7 @@ config SPI_CADENCE_XSPI
 	  Cadence XSPI is a specialized controller for connecting an SPI
 	  Flash over upto 8bit wide bus. Enable this option if you have a
 	  device with a Cadence XSPI controller and want to access the
-	  Flash as an MTD device.
+	  Flash as an MTD device. Register as platform device.
 
 #
 # Add new SPI master controllers in alphabetical order above this line
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index 51352b4bd3d2..ca6936a115ed 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -122,7 +122,8 @@ obj-$(CONFIG_SPI_XLP)			+= spi-xlp.o
 obj-$(CONFIG_SPI_XTENSA_XTFPGA)		+= spi-xtensa-xtfpga.o
 obj-$(CONFIG_SPI_ZYNQ_QSPI)		+= spi-zynq-qspi.o
 obj-$(CONFIG_SPI_ZYNQMP_GQSPI)		+= spi-zynqmp-gqspi.o
-obj-$(CONFIG_SPI_CADENCE_XSPI)      += spi-cadence-xspi.o
+spi-cdns-xspi-plat-objs              	:= spi-cadence-xspi.o spi-cadence-xspi-platform.o
+obj-$(CONFIG_SPI_CADENCE_XSPI_PLATFORM) += spi-cdns-xspi-plat.o
 
 # SPI slave protocol handlers
 obj-$(CONFIG_SPI_SLAVE_TIME)		+= spi-slave-time.o
diff --git a/drivers/spi/spi-cadence-xspi-platform.c b/drivers/spi/spi-cadence-xspi-platform.c
new file mode 100644
index 000000000000..e4e82d647913
--- /dev/null
+++ b/drivers/spi/spi-cadence-xspi-platform.c
@@ -0,0 +1,137 @@
+// SPDX-License-Identifier: GPL-2.0+
+#include "spi-cadence-xspi.h"
+
+static int cdns_xspi_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct spi_master *master = NULL;
+	struct resource *res = NULL;
+	struct cdns_xspi_dev *cdns_xspi = NULL;
+	struct cdns_xspi_platform_data *plat_data = NULL;
+	int ret;
+
+	master = cdns_xspi_prepare_master(dev);
+	if (!master) {
+		ret = -ENOMEM;
+		dev_err(dev, "Failed to allocate memory for spi_master\n");
+		goto err_no_mem;
+	}
+
+	platform_set_drvdata(pdev, master);
+
+	plat_data = devm_kmalloc(dev, sizeof(*plat_data), GFP_KERNEL);
+	if (!plat_data) {
+		ret = -ENOMEM;
+		dev_err(dev, "Failed to allocate memory for platform_data\n");
+		goto err_spi_master;
+	}
+	pdev->dev.platform_data = plat_data;
+
+	cdns_xspi = spi_master_get_devdata(master);
+	cdns_xspi->pdev = pdev;
+	cdns_xspi->dev = &pdev->dev;
+	cdns_xspi->current_cs = 0;
+	cdns_xspi->plat_data = plat_data;
+
+	init_completion(&cdns_xspi->cmd_complete);
+	init_completion(&cdns_xspi->sdma_complete);
+
+	ret = cdns_xspi_of_get_plat_data(dev);
+	if (ret) {
+		ret = -ENODEV;
+		dev_err(dev, "Failed to get platform data\n");
+		goto err_spi_master;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	cdns_xspi->iobase = devm_ioremap_resource(cdns_xspi->dev, res);
+	if (IS_ERR(cdns_xspi->iobase)) {
+		ret = PTR_ERR(cdns_xspi->iobase);
+		dev_err(dev, "Failed to remap controller base address\n");
+		goto err_spi_master;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	cdns_xspi->sdmabase = devm_ioremap_resource(cdns_xspi->dev, res);
+	if (IS_ERR(cdns_xspi->sdmabase)) {
+		ret = PTR_ERR(cdns_xspi->sdmabase);
+		dev_err(dev, "Failed to remap SDMA address\n");
+		goto err_spi_master;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 2);
+	cdns_xspi->auxbase = devm_ioremap_resource(cdns_xspi->dev, res);
+	if (IS_ERR(cdns_xspi->auxbase)) {
+		ret = PTR_ERR(cdns_xspi->auxbase);
+		dev_err(dev, "Failed to remap AUX address\n");
+		goto err_spi_master;
+	}
+
+	cdns_xspi->irq = platform_get_irq(pdev, 0);
+	if (cdns_xspi->irq < 0) {
+		ret = -ENXIO;
+		dev_err(dev, "Failed to get IRQ\n");
+		goto err_spi_master;
+	}
+
+	ret = devm_request_irq(dev, cdns_xspi->irq, cdns_xspi_irq_handler,
+		IRQF_SHARED, pdev->name, cdns_xspi);
+	if (ret) {
+		dev_err(dev, "Failed to request IRQ: %d\n", cdns_xspi->irq);
+		goto err_spi_master;
+	}
+
+	ret = cdns_xspi_configure(cdns_xspi);
+	if (ret) {
+		dev_err(dev, "Failed to prepare xSPI");
+		goto err_spi_master;
+	}
+
+	master->num_chipselect = 1 << cdns_xspi->hw_num_banks;
+
+	ret = devm_spi_register_master(dev, master);
+	if (ret) {
+		dev_err(dev, "Failed to register SPI master\n");
+		goto err_spi_master;
+	}
+
+	dev_info(dev, "Successfully registered SPI master\n");
+
+	return 0;
+
+err_spi_master:
+	spi_master_put(master);
+
+err_no_mem:
+	dev_err(dev, "Failed to probe Cadence XSPI controller driver\n");
+
+	return ret;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id cdns_xspi_of_match[] = {
+	{
+		.compatible = "cdns,xspi-nor-fpga",
+	},
+	{ /* end of table */}
+};
+MODULE_DEVICE_TABLE(of, cdns_xspi_of_match);
+#else
+#define cdns_xspi_of_match NULL
+#endif /* CONFIG_OF */
+
+static struct platform_driver cdns_xspi_platform_driver = {
+	.probe          = cdns_xspi_probe,
+	.remove         = NULL,
+	.driver = {
+		.name = CDNS_XSPI_NAME,
+		.of_match_table = cdns_xspi_of_match,
+	},
+};
+
+module_platform_driver(cdns_xspi_platform_driver);
+
+MODULE_DESCRIPTION("Cadence XSPI Controller Driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" CDNS_XSPI_NAME);
+MODULE_AUTHOR("Konrad Kociolek <konrad@cadence.com>");
diff --git a/drivers/spi/spi-cadence-xspi.c b/drivers/spi/spi-cadence-xspi.c
index d5958469ec99..061ba8270638 100644
--- a/drivers/spi/spi-cadence-xspi.c
+++ b/drivers/spi/spi-cadence-xspi.c
@@ -6,256 +6,7 @@
  *
  * Author: Konrad Kociolek <konrad@cadence.com>
  */
-#include <linux/completion.h>
-#include <linux/delay.h>
-#include <linux/err.h>
-#include <linux/errno.h>
-#include <linux/interrupt.h>
-#include <linux/io.h>
-#include <linux/iopoll.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/of_device.h>
-#include <linux/of.h>
-#include <linux/platform_device.h>
-#include <linux/pm_runtime.h>
-#include <linux/spi/spi.h>
-#include <linux/mtd/spi-nor.h>
-#include <linux/bitfield.h>
-#include <linux/limits.h>
-#include <linux/log2.h>
-
-#define CDNS_XSPI_MAGIC_NUM_VALUE               0x6522
-#define CDNS_XSPI_MAX_BANKS                     8
-#define CDNS_XSPI_NAME                          "cadence-xspi"
-
-/*
- * Note: below are additional auxiliary registers to
- * configure XSPI controller pin-strap settings
- */
-
-/* PHY DQ timing register */
-#define CDNS_XSPI_CCP_PHY_DQ_TIMING           0x0000
-#define CDNS_XSPI_CCP_DATA_SELECT_OE_START    GENMASK(6, 4)
-#define CDNS_XSPI_CCP_DATA_SELECT_OE_END      GENMASK(2, 0)
-#define CDNS_XSPI_CCP_PHY_DQ_TIMING_INIT_VAL  0x80000000
-
-/* PHY DQS timing register */
-#define CDNS_XSPI_CCP_PHY_DQS_TIMING          0x0004
-#define CDNS_XSPI_CCP_USE_EXT_LPBCK_DQS       BIT(22)
-#define CDNS_XSPI_CCP_USE_LPBCK_DQS           BIT(21)
-#define CDNS_XSPI_CCP_USE_PHONY               BIT(20)
-#define CDNS_XSPI_CCP_DQS_SELECT_OE_START     GENMASK(7, 4)
-#define CDNS_XSPI_CCP_DQS_SELECT_OE_END       GENMASK(3, 0)
-
-/* PHY gate loopback control register */
-#define CDNS_XSPI_CCP_PHY_GATE_LPBCK_CTRL     0x0008
-#define CDNS_XSPI_CCP_READ_DATA_DELAY_SEL     GENMASK(24, 19)
-#define CDNS_XSPI_CCP_GATE_CFG_CLOSE          GENMASK(5, 4)
-#define CDNS_XSPI_CCP_GATE_CFG                GENMASK(3, 0)
-
-/* PHY DLL slave control register */
-#define CDNS_XSPI_CCP_PHY_DLL_SLAVE_CTRL      0x0010
-#define CDNS_XSPI_CCP_CLK_WR_DELAY            GENMASK(15, 8)
-#define CDNS_XSPI_CCP_READ_DQS_DELAY          GENMASK(7, 0)
-
-#define CDNS_XSPI_AUX_PHY_ADDONS_REG          0x0040
-#define CDNS_XSPI_AUX_PHY_ADDONS_VALUE        0xE0012000
-#define CDNS_XSPI_AUX_DEV_DISC_CONFIG_REG     0x0048
-#define CDNS_XSPI_AUX_DEV_DISC_CONFIG_VALUE   0x00000000
-#define CDNS_XSPI_AUX_DRIVING_REG             0x0050
-#define CDNS_XSPI_AUX_CTRL_RESET              BIT(0)
-
-/* DLL PHY control register */
-#define CDNS_XSPI_DLL_PHY_CTRL                0x1034
-#define CDNS_XSPI_CCP_DQS_LAST_DATA_DROP_EN   BIT(20)
-
-/* Command registers */
-#define CDNS_XSPI_CMD_REG_0                   0x0000
-#define CDNS_XSPI_CMD_REG_1                   0x0004
-#define CDNS_XSPI_CMD_REG_2                   0x0008
-#define CDNS_XSPI_CMD_REG_3                   0x000C
-#define CDNS_XSPI_CMD_REG_4                   0x0010
-#define CDNS_XSPI_CMD_REG_5                   0x0014
-
-/* Command status registers */
-#define CDNS_XSPI_CMD_STATUS_REG              0x0044
-#define CDNS_XSPI_CMD_COMPLETED               BIT(15)
-#define CDNS_XSPI_CMD_FAILED                  BIT(14)
-
-/* Controller status register */
-#define CDNS_XSPI_CTRL_STATUS_REG             0x0100
-#define CDNS_XSPI_INIT_COMPLETED              BIT(16)
-#define CDNS_XSPI_INIT_LEGACY                 BIT(9)
-#define CDNS_XSPI_INIT_FAIL                   BIT(8)
-#define CDNS_XSPI_CTRL_BUSY                   BIT(7)
-
-/* Controller interrupt status register */
-#define CDNS_XSPI_INTR_STATUS_REG             0x0110
-#define CDNS_XSPI_STIG_DONE                   BIT(23)
-#define CDNS_XSPI_SDMA_ERROR                  BIT(22)
-#define CDNS_XSPI_SDMA_TRIGGER                BIT(21)
-
-/* Controller interrupt enable register */
-#define CDNS_XSPI_INTR_ENABLE_REG             0x0114
-#define CDNS_XSPI_INTR_EN                     BIT(31)
-#define CDNS_XSPI_STIG_DONE_EN                BIT(23)
-#define CDNS_XSPI_SDMA_ERROR_EN               BIT(22)
-#define CDNS_XSPI_SDMA_TRIGGER_EN             BIT(21)
-
-#define CDNS_XSPI_INTR_MASK (CDNS_XSPI_INTR_EN | \
-	CDNS_XSPI_STIG_DONE_EN  | \
-	CDNS_XSPI_SDMA_ERROR_EN | \
-	CDNS_XSPI_SDMA_TRIGGER_EN)
-
-/* Controller config register */
-#define CDNS_XSPI_CTRL_CONFIG_REG             0x0230
-#define CDNS_XSPI_CTRL_WORK_MODE              GENMASK(6, 5)
-
-/* SDMA trigger transaction registers */
-#define CDNS_XSPI_SDMA_SIZE_REG               0x0240
-#define CDNS_XSPI_SDMA_TRD_INFO_REG           0x0244
-#define CDNS_XSPI_SDMA_DIR                    BIT(8)
-
-/* Controller features register */
-#define CDNS_XSPI_CTRL_FEATURES_REG           0x0F04
-#define CDNS_XSPI_NUM_BANKS                   GENMASK(25, 24)
-#define CDNS_XSPI_DMA_DATA_WIDTH              BIT(21)
-#define CDNS_XSPI_NUM_THREADS                 GENMASK(3, 0)
-
-/* Controller version register */
-#define CDNS_XSPI_CTRL_VERSION_REG            0x0F00
-#define CDNS_XSPI_MAGIC_NUM                   GENMASK(31, 16)
-#define CDNS_XSPI_CTRL_REV                    GENMASK(7, 0)
-
-/* STIG Profile 1.0 instruction fields (split into registers) */
-#define CDNS_XSPI_CMD_INSTR_TYPE              GENMASK(6, 0)
-#define CDNS_XSPI_CMD_P1_R1_ADDR0             GENMASK(31, 24)
-#define CDNS_XSPI_CMD_P1_R2_ADDR1             GENMASK(7, 0)
-#define CDNS_XSPI_CMD_P1_R2_ADDR2             GENMASK(15, 8)
-#define CDNS_XSPI_CMD_P1_R2_ADDR3             GENMASK(23, 16)
-#define CDNS_XSPI_CMD_P1_R2_ADDR4             GENMASK(31, 24)
-#define CDNS_XSPI_CMD_P1_R3_ADDR5             GENMASK(7, 0)
-#define CDNS_XSPI_CMD_P1_R3_CMD               GENMASK(23, 16)
-#define CDNS_XSPI_CMD_P1_R3_NUM_ADDR_BYTES    GENMASK(30, 28)
-#define CDNS_XSPI_CMD_P1_R4_ADDR_IOS          GENMASK(1, 0)
-#define CDNS_XSPI_CMD_P1_R4_CMD_IOS           GENMASK(9, 8)
-#define CDNS_XSPI_CMD_P1_R4_BANK              GENMASK(14, 12)
-
-/* STIG data sequence instruction fields (split into registers) */
-#define CDNS_XSPI_CMD_DSEQ_R2_DCNT_L          GENMASK(31, 16)
-#define CDNS_XSPI_CMD_DSEQ_R3_DCNT_H          GENMASK(15, 0)
-#define CDNS_XSPI_CMD_DSEQ_R3_NUM_OF_DUMMY    GENMASK(25, 20)
-#define CDNS_XSPI_CMD_DSEQ_R4_BANK            GENMASK(14, 12)
-#define CDNS_XSPI_CMD_DSEQ_R4_DATA_IOS        GENMASK(9, 8)
-#define CDNS_XSPI_CMD_DSEQ_R4_DIR             BIT(4)
-
-/* STIG command status fields */
-#define CDNS_XSPI_CMD_STATUS_COMPLETED        BIT(15)
-#define CDNS_XSPI_CMD_STATUS_FAILED           BIT(14)
-#define CDNS_XSPI_CMD_STATUS_DQS_ERROR        BIT(3)
-#define CDNS_XSPI_CMD_STATUS_CRC_ERROR        BIT(2)
-#define CDNS_XSPI_CMD_STATUS_BUS_ERROR        BIT(1)
-#define CDNS_XSPI_CMD_STATUS_INV_SEQ_ERROR    BIT(0)
-
-#define CDNS_XSPI_CTRL_WORK_MODE_STIG         0x01
-
-#define CDNS_XSPI_STIG_DONE_FLAG              BIT(0)
-
-/* Helper macros for filling command registers */
-#define CDNS_XSPI_CMD_FLD_P1_INSTR_CMD_1(op, data_phase) ( \
-	FIELD_PREP(CDNS_XSPI_CMD_INSTR_TYPE, (data_phase) ? \
-		CDNS_XSPI_STIG_INSTR_TYPE_1 : CDNS_XSPI_STIG_INSTR_TYPE_0) | \
-	FIELD_PREP(CDNS_XSPI_CMD_P1_R1_ADDR0, op->addr.val & 0xff))
-
-#define CDNS_XSPI_CMD_FLD_P1_INSTR_CMD_2(op) ( \
-	FIELD_PREP(CDNS_XSPI_CMD_P1_R2_ADDR1, (op->addr.val >> 8)  & 0xFF) | \
-	FIELD_PREP(CDNS_XSPI_CMD_P1_R2_ADDR2, (op->addr.val >> 16) & 0xFF) | \
-	FIELD_PREP(CDNS_XSPI_CMD_P1_R2_ADDR3, (op->addr.val >> 24) & 0xFF) | \
-	FIELD_PREP(CDNS_XSPI_CMD_P1_R2_ADDR4, (op->addr.val >> 32) & 0xFF))
-
-#define CDNS_XSPI_CMD_FLD_P1_INSTR_CMD_3(op) ( \
-	FIELD_PREP(CDNS_XSPI_CMD_P1_R3_ADDR5, (op->addr.val >> 40) & 0xFF) | \
-	FIELD_PREP(CDNS_XSPI_CMD_P1_R3_CMD, op->cmd.opcode) | \
-	FIELD_PREP(CDNS_XSPI_CMD_P1_R3_NUM_ADDR_BYTES, op->addr.nbytes))
-
-#define CDNS_XSPI_CMD_FLD_P1_INSTR_CMD_4(op, chipsel) ( \
-	FIELD_PREP(CDNS_XSPI_CMD_P1_R4_ADDR_IOS, ilog2(op->addr.buswidth)) | \
-	FIELD_PREP(CDNS_XSPI_CMD_P1_R4_CMD_IOS, ilog2(op->cmd.buswidth)) | \
-	FIELD_PREP(CDNS_XSPI_CMD_P1_R4_BANK, chipsel))
-
-#define CDNS_XSPI_CMD_FLD_DSEQ_CMD_1(op) \
-	FIELD_PREP(CDNS_XSPI_CMD_INSTR_TYPE, CDNS_XSPI_STIG_INSTR_TYPE_DATA_SEQ)
-
-#define CDNS_XSPI_CMD_FLD_DSEQ_CMD_2(op) \
-	FIELD_PREP(CDNS_XSPI_CMD_DSEQ_R2_DCNT_L, op->data.nbytes & 0xFFFF)
-
-#define CDNS_XSPI_CMD_FLD_DSEQ_CMD_3(op) ( \
-	FIELD_PREP(CDNS_XSPI_CMD_DSEQ_R3_DCNT_H, \
-		(op->data.nbytes >> 16) & 0xffff) | \
-	FIELD_PREP(CDNS_XSPI_CMD_DSEQ_R3_NUM_OF_DUMMY, op->dummy.nbytes * 8))
-
-#define CDNS_XSPI_CMD_FLD_DSEQ_CMD_4(op, chipsel) ( \
-	FIELD_PREP(CDNS_XSPI_CMD_DSEQ_R4_BANK, chipsel) | \
-	FIELD_PREP(CDNS_XSPI_CMD_DSEQ_R4_DATA_IOS, ilog2(op->data.buswidth)) | \
-	FIELD_PREP(CDNS_XSPI_CMD_DSEQ_R4_DIR, \
-		(op->data.dir == SPI_MEM_DATA_IN) ? \
-		CDNS_XSPI_STIG_CMD_DIR_READ : CDNS_XSPI_STIG_CMD_DIR_WRITE))
-
-enum cdns_xspi_stig_instr_type {
-	CDNS_XSPI_STIG_INSTR_TYPE_0,
-	CDNS_XSPI_STIG_INSTR_TYPE_1,
-	CDNS_XSPI_STIG_INSTR_TYPE_DATA_SEQ = 127,
-};
-
-enum cdns_xspi_sdma_dir {
-	CDNS_XSPI_SDMA_DIR_READ,
-	CDNS_XSPI_SDMA_DIR_WRITE,
-};
-
-enum cdns_xspi_stig_cmd_dir {
-	CDNS_XSPI_STIG_CMD_DIR_READ,
-	CDNS_XSPI_STIG_CMD_DIR_WRITE,
-};
-
-struct cdns_xspi_platform_data {
-	u32 phy_data_sel_oe_start;
-	u32 phy_data_sel_oe_end;
-	u32 phy_dqs_sel_oe_start;
-	u32 phy_dqs_sel_oe_end;
-	u32 phy_gate_cfg_close;
-	u32 phy_gate_cfg;
-	u32 phy_rd_del_sel;
-	u32 clk_wr_delay;
-	bool dqs_last_data_drop;
-	bool use_lpbk_dqs;
-	bool use_ext_lpbk_dqs;
-};
-
-struct cdns_xspi_dev {
-	struct platform_device *pdev;
-	struct device *dev;
-
-	void __iomem *iobase;
-	void __iomem *auxbase;
-	void __iomem *sdmabase;
-
-	int irq;
-	int current_cs;
-
-	struct mutex lock;
-
-	struct completion cmd_complete;
-	struct completion sdma_complete;
-	bool sdma_error;
-
-	void *in_buffer;
-	const void *out_buffer;
-
-	u8 hw_num_banks;
-
-	struct cdns_xspi_platform_data *plat_data;
-};
+#include "spi-cadence-xspi.h"
 
 static void cdns_xspi_controller_reset(struct cdns_xspi_dev *cdns_xspi)
 {
@@ -609,7 +360,7 @@ static int cdns_xspi_setup(struct spi_device *spi_dev)
 	return 0;
 }
 
-static irqreturn_t cdns_xspi_irq_handler(int this_irq, void *dev)
+irqreturn_t cdns_xspi_irq_handler(int this_irq, void *dev)
 {
 	struct cdns_xspi_dev *cdns_xspi = dev;
 	u32 irq_status;
@@ -638,66 +389,66 @@ static irqreturn_t cdns_xspi_irq_handler(int this_irq, void *dev)
 	return result;
 }
 
-static int cdns_xspi_of_get_plat_data(struct platform_device *pdev)
+int cdns_xspi_of_get_plat_data(struct device *dev)
 {
-	struct device_node *node_prop = pdev->dev.of_node;
+	struct device_node *node_prop = dev->of_node;
 	struct device_node *node_child;
-	struct cdns_xspi_platform_data *plat_data = pdev->dev.platform_data;
+	struct cdns_xspi_platform_data *plat_data = dev->platform_data;
 	unsigned int property;
 	unsigned int cs;
 
 	if (of_property_read_u32(node_prop,
 		"cdns,phy-data-select-oe-start", &property)) {
-		dev_err(&pdev->dev, "Couldn't determine data select oe start\n");
+		dev_err(dev, "Couldn't determine data select oe start\n");
 		return -ENXIO;
 	}
 	plat_data->phy_data_sel_oe_start = property;
 
 	if (of_property_read_u32(node_prop,
 		"cdns,phy-data-select-oe-end", &property)) {
-		dev_err(&pdev->dev, "Couldn't determine data select oe end\n");
+		dev_err(dev, "Couldn't determine data select oe end\n");
 		return -ENXIO;
 	}
 	plat_data->phy_data_sel_oe_end = property;
 
 	if (of_property_read_u32(node_prop,
 		"cdns,phy-dqs-select-oe-start", &property)) {
-		dev_err(&pdev->dev, "Couldn't determine DQS select oe start\n");
+		dev_err(dev, "Couldn't determine DQS select oe start\n");
 		return -ENXIO;
 	}
 	plat_data->phy_dqs_sel_oe_start = property;
 
 	if (of_property_read_u32(node_prop,
 		"cdns,phy-dqs-select-oe-end", &property)) {
-		dev_err(&pdev->dev, "Couldn't determine DQS select oe end\n");
+		dev_err(dev, "Couldn't determine DQS select oe end\n");
 		return -ENXIO;
 	}
 	plat_data->phy_dqs_sel_oe_end = property;
 
 	if (of_property_read_u32(node_prop,
 		"cdns,phy-gate-cfg-close", &property)) {
-		dev_err(&pdev->dev, "Couldn't determine gate config close\n");
+		dev_err(dev, "Couldn't determine gate config close\n");
 		return -ENXIO;
 	}
 	plat_data->phy_gate_cfg_close = property;
 
 	if (of_property_read_u32(node_prop,
 		"cdns,phy-gate-cfg", &property)) {
-		dev_err(&pdev->dev, "Couldn't determine gate config\n");
+		dev_err(dev, "Couldn't determine gate config\n");
 		return -ENXIO;
 	}
 	plat_data->phy_gate_cfg = property;
 
 	if (of_property_read_u32(node_prop,
 		"cdns,phy-rd-del-select", &property)) {
-		dev_err(&pdev->dev, "Couldn't determine read delay select\n");
+		dev_err(dev, "Couldn't determine read delay select\n");
 		return -ENXIO;
 	}
 	plat_data->phy_rd_del_sel = property;
 
 	if (of_property_read_u32(node_prop,
 		"cdns,phy-clk-wr-delay", &property)) {
-		dev_err(&pdev->dev, "Couldn't determine clock write delay\n");
+		dev_err(dev, "Couldn't determine clock write delay\n");
 		return -ENXIO;
 	}
 	plat_data->clk_wr_delay = property;
@@ -714,10 +465,10 @@ static int cdns_xspi_of_get_plat_data(struct platform_device *pdev)
 			continue;
 
 		if (of_property_read_u32(node_child, "reg", &cs)) {
-			dev_err(&pdev->dev, "Couldn't get memory chip select\n");
+			dev_err(dev, "Couldn't get memory chip select\n");
 			return -ENXIO;
 		} else if (cs >= CDNS_XSPI_MAX_BANKS) {
-			dev_err(&pdev->dev, "reg (cs) parameter value too large\n");
+			dev_err(dev, "reg (cs) parameter value too large\n");
 			return -ENXIO;
 		}
 	}
@@ -742,99 +493,15 @@ static void cdns_xspi_print_phy_config(struct cdns_xspi_dev *cdns_xspi)
 		readl(cdns_xspi->auxbase + CDNS_XSPI_CCP_PHY_DLL_SLAVE_CTRL));
 }
 
-static int cdns_xspi_probe(struct platform_device *pdev)
+int cdns_xspi_configure(struct cdns_xspi_dev *cdns_xspi)
 {
-	struct device *dev = &pdev->dev;
-	struct spi_master *master = NULL;
-	struct resource *res = NULL;
-	struct cdns_xspi_dev *cdns_xspi = NULL;
-	struct cdns_xspi_platform_data *plat_data = NULL;
 	int ret;
-
-	master = spi_alloc_master(dev, sizeof(*cdns_xspi));
-	if (!master) {
-		ret = -ENOMEM;
-		dev_err(dev, "Failed to allocate memory for spi_master\n");
-		goto err_no_mem;
-	}
-
-	master->mode_bits = SPI_3WIRE | SPI_TX_DUAL  | SPI_TX_QUAD  |
-		SPI_RX_DUAL | SPI_RX_QUAD | SPI_TX_OCTAL | SPI_RX_OCTAL |
-		SPI_MODE_0  | SPI_MODE_3;
-
-	master->mem_ops = &cadence_xspi_mem_ops;
-	master->setup = cdns_xspi_setup;
-	master->dev.of_node = pdev->dev.of_node;
-	master->bus_num = -1;
-
-	platform_set_drvdata(pdev, master);
-
-	plat_data = devm_kmalloc(dev, sizeof(*plat_data), GFP_KERNEL);
-	if (!plat_data) {
-		ret = -ENOMEM;
-		dev_err(dev, "Failed to allocate memory for platform_data\n");
-		goto err_spi_master;
-	}
-	pdev->dev.platform_data = plat_data;
-
-	cdns_xspi = spi_master_get_devdata(master);
-	cdns_xspi->pdev = pdev;
-	cdns_xspi->dev = &pdev->dev;
-	cdns_xspi->current_cs = 0;
-	cdns_xspi->plat_data = plat_data;
-
-	init_completion(&cdns_xspi->cmd_complete);
-	init_completion(&cdns_xspi->sdma_complete);
-
-	ret = cdns_xspi_of_get_plat_data(pdev);
-	if (ret) {
-		ret = -ENODEV;
-		dev_err(dev, "Failed to get platform data\n");
-		goto err_spi_master;
-	}
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	cdns_xspi->iobase = devm_ioremap_resource(cdns_xspi->dev, res);
-	if (IS_ERR(cdns_xspi->iobase)) {
-		ret = PTR_ERR(cdns_xspi->iobase);
-		dev_err(dev, "Failed to remap controller base address\n");
-		goto err_spi_master;
-	}
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
-	cdns_xspi->sdmabase = devm_ioremap_resource(cdns_xspi->dev, res);
-	if (IS_ERR(cdns_xspi->sdmabase)) {
-		ret = PTR_ERR(cdns_xspi->sdmabase);
-		dev_err(dev, "Failed to remap SDMA address\n");
-		goto err_spi_master;
-	}
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 2);
-	cdns_xspi->auxbase = devm_ioremap_resource(cdns_xspi->dev, res);
-	if (IS_ERR(cdns_xspi->auxbase)) {
-		ret = PTR_ERR(cdns_xspi->auxbase);
-		dev_err(dev, "Failed to remap AUX address\n");
-		goto err_spi_master;
-	}
-
-	cdns_xspi->irq = platform_get_irq(pdev, 0);
-	if (cdns_xspi->irq < 0) {
-		ret = -ENXIO;
-		dev_err(dev, "Failed to get IRQ\n");
-		goto err_spi_master;
-	}
-
-	ret = devm_request_irq(dev, cdns_xspi->irq, cdns_xspi_irq_handler,
-		IRQF_SHARED, pdev->name, cdns_xspi);
-	if (ret) {
-		dev_err(dev, "Failed to request IRQ: %d\n", cdns_xspi->irq);
-		goto err_spi_master;
-	}
+	struct device *dev = cdns_xspi->dev;
 
 	ret = cdns_xspi_phy_init(cdns_xspi);
 	if (ret) {
 		dev_err(dev, "Failed to initialize PHY\n");
-		goto err_spi_master;
+		return ret;
 	}
 
 	cdns_xspi_print_phy_config(cdns_xspi);
@@ -842,54 +509,30 @@ static int cdns_xspi_probe(struct platform_device *pdev)
 	ret = cdns_xspi_controller_init(cdns_xspi);
 	if (ret) {
 		dev_err(dev, "Failed to initialize controller\n");
-		goto err_spi_master;
+		return ret;
 	}
 
-	master->num_chipselect = 1 << cdns_xspi->hw_num_banks;
-
-	ret = devm_spi_register_master(dev, master);
-	if (ret) {
-		dev_err(dev, "Failed to register SPI master\n");
-		goto err_spi_master;
-	}
+	return ret;
+}
 
-	dev_info(dev, "Successfully registered SPI master\n");
+struct spi_master *cdns_xspi_prepare_master(struct device *dev)
+{
+	struct spi_master *master = NULL;
 
-	return 0;
+	master = spi_alloc_master(dev, sizeof(struct cdns_xspi_dev));
+	if (!master) {
+		dev_err(dev, "Failed to allocate memory for spi_master\n");
+		return NULL;
+	}
 
-err_spi_master:
-	spi_master_put(master);
+	master->mode_bits = SPI_3WIRE | SPI_TX_DUAL  | SPI_TX_QUAD  |
+		SPI_RX_DUAL | SPI_RX_QUAD | SPI_TX_OCTAL | SPI_RX_OCTAL |
+		SPI_MODE_0  | SPI_MODE_3;
 
-err_no_mem:
-	dev_err(dev, "Failed to probe Cadence XSPI controller driver\n");
+	master->mem_ops = &cadence_xspi_mem_ops;
+	master->setup = cdns_xspi_setup;
+	master->dev.of_node = dev->of_node;
+	master->bus_num = -1;
 
-	return ret;
+	return master;
 }
-
-#ifdef CONFIG_OF
-static const struct of_device_id cdns_xspi_of_match[] = {
-	{
-		.compatible = "cdns,xspi-nor-fpga",
-	},
-	{ /* end of table */}
-};
-MODULE_DEVICE_TABLE(of, cdns_xspi_of_match);
-#else
-#define cdns_xspi_of_match NULL
-#endif /* CONFIG_OF */
-
-static struct platform_driver cdns_xspi_platform_driver = {
-	.probe          = cdns_xspi_probe,
-	.remove         = NULL,
-	.driver = {
-		.name = CDNS_XSPI_NAME,
-		.of_match_table = cdns_xspi_of_match,
-	},
-};
-
-module_platform_driver(cdns_xspi_platform_driver);
-
-MODULE_DESCRIPTION("Cadence XSPI Controller Driver");
-MODULE_LICENSE("GPL v2");
-MODULE_ALIAS("platform:" CDNS_XSPI_NAME);
-MODULE_AUTHOR("Konrad Kociolek <konrad@cadence.com>");
diff --git a/drivers/spi/spi-cadence-xspi.h b/drivers/spi/spi-cadence-xspi.h
new file mode 100644
index 000000000000..9e506ef1b039
--- /dev/null
+++ b/drivers/spi/spi-cadence-xspi.h
@@ -0,0 +1,256 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+#include <linux/completion.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/iopoll.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/spi/spi.h>
+#include <linux/mtd/spi-nor.h>
+#include <linux/bitfield.h>
+#include <linux/limits.h>
+#include <linux/log2.h>
+
+#define CDNS_XSPI_MAGIC_NUM_VALUE               0x6522
+#define CDNS_XSPI_MAX_BANKS                     8
+#define CDNS_XSPI_NAME                          "cadence-xspi"
+
+/*
+ * Note: below are additional auxiliary registers to
+ * configure XSPI controller pin-strap settings
+ */
+
+/* PHY DQ timing register */
+#define CDNS_XSPI_CCP_PHY_DQ_TIMING           0x0000
+#define CDNS_XSPI_CCP_DATA_SELECT_OE_START    GENMASK(6, 4)
+#define CDNS_XSPI_CCP_DATA_SELECT_OE_END      GENMASK(2, 0)
+#define CDNS_XSPI_CCP_PHY_DQ_TIMING_INIT_VAL  0x80000000
+
+/* PHY DQS timing register */
+#define CDNS_XSPI_CCP_PHY_DQS_TIMING          0x0004
+#define CDNS_XSPI_CCP_USE_EXT_LPBCK_DQS       BIT(22)
+#define CDNS_XSPI_CCP_USE_LPBCK_DQS           BIT(21)
+#define CDNS_XSPI_CCP_USE_PHONY               BIT(20)
+#define CDNS_XSPI_CCP_DQS_SELECT_OE_START     GENMASK(7, 4)
+#define CDNS_XSPI_CCP_DQS_SELECT_OE_END       GENMASK(3, 0)
+
+/* PHY gate loopback control register */
+#define CDNS_XSPI_CCP_PHY_GATE_LPBCK_CTRL     0x0008
+#define CDNS_XSPI_CCP_READ_DATA_DELAY_SEL     GENMASK(24, 19)
+#define CDNS_XSPI_CCP_GATE_CFG_CLOSE          GENMASK(5, 4)
+#define CDNS_XSPI_CCP_GATE_CFG                GENMASK(3, 0)
+
+/* PHY DLL slave control register */
+#define CDNS_XSPI_CCP_PHY_DLL_SLAVE_CTRL      0x0010
+#define CDNS_XSPI_CCP_CLK_WR_DELAY            GENMASK(15, 8)
+#define CDNS_XSPI_CCP_READ_DQS_DELAY          GENMASK(7, 0)
+
+#define CDNS_XSPI_AUX_PHY_ADDONS_REG          0x0040
+#define CDNS_XSPI_AUX_PHY_ADDONS_VALUE        0xE0012000
+#define CDNS_XSPI_AUX_DEV_DISC_CONFIG_REG     0x0048
+#define CDNS_XSPI_AUX_DEV_DISC_CONFIG_VALUE   0x00000000
+#define CDNS_XSPI_AUX_DRIVING_REG             0x0050
+#define CDNS_XSPI_AUX_CTRL_RESET              BIT(0)
+
+/* DLL PHY control register */
+#define CDNS_XSPI_DLL_PHY_CTRL                0x1034
+#define CDNS_XSPI_CCP_DQS_LAST_DATA_DROP_EN   BIT(20)
+
+/* Command registers */
+#define CDNS_XSPI_CMD_REG_0                   0x0000
+#define CDNS_XSPI_CMD_REG_1                   0x0004
+#define CDNS_XSPI_CMD_REG_2                   0x0008
+#define CDNS_XSPI_CMD_REG_3                   0x000C
+#define CDNS_XSPI_CMD_REG_4                   0x0010
+#define CDNS_XSPI_CMD_REG_5                   0x0014
+
+/* Command status registers */
+#define CDNS_XSPI_CMD_STATUS_REG              0x0044
+#define CDNS_XSPI_CMD_COMPLETED               BIT(15)
+#define CDNS_XSPI_CMD_FAILED                  BIT(14)
+
+/* Controller status register */
+#define CDNS_XSPI_CTRL_STATUS_REG             0x0100
+#define CDNS_XSPI_INIT_COMPLETED              BIT(16)
+#define CDNS_XSPI_INIT_LEGACY                 BIT(9)
+#define CDNS_XSPI_INIT_FAIL                   BIT(8)
+#define CDNS_XSPI_CTRL_BUSY                   BIT(7)
+
+/* Controller interrupt status register */
+#define CDNS_XSPI_INTR_STATUS_REG             0x0110
+#define CDNS_XSPI_STIG_DONE                   BIT(23)
+#define CDNS_XSPI_SDMA_ERROR                  BIT(22)
+#define CDNS_XSPI_SDMA_TRIGGER                BIT(21)
+
+/* Controller interrupt enable register */
+#define CDNS_XSPI_INTR_ENABLE_REG             0x0114
+#define CDNS_XSPI_INTR_EN                     BIT(31)
+#define CDNS_XSPI_STIG_DONE_EN                BIT(23)
+#define CDNS_XSPI_SDMA_ERROR_EN               BIT(22)
+#define CDNS_XSPI_SDMA_TRIGGER_EN             BIT(21)
+
+#define CDNS_XSPI_INTR_MASK (CDNS_XSPI_INTR_EN | \
+	CDNS_XSPI_STIG_DONE_EN  | \
+	CDNS_XSPI_SDMA_ERROR_EN | \
+	CDNS_XSPI_SDMA_TRIGGER_EN)
+
+/* Controller config register */
+#define CDNS_XSPI_CTRL_CONFIG_REG             0x0230
+#define CDNS_XSPI_CTRL_WORK_MODE              GENMASK(6, 5)
+
+/* SDMA trigger transaction registers */
+#define CDNS_XSPI_SDMA_SIZE_REG               0x0240
+#define CDNS_XSPI_SDMA_TRD_INFO_REG           0x0244
+#define CDNS_XSPI_SDMA_DIR                    BIT(8)
+
+/* Controller features register */
+#define CDNS_XSPI_CTRL_FEATURES_REG           0x0F04
+#define CDNS_XSPI_NUM_BANKS                   GENMASK(25, 24)
+#define CDNS_XSPI_DMA_DATA_WIDTH              BIT(21)
+#define CDNS_XSPI_NUM_THREADS                 GENMASK(3, 0)
+
+/* Controller version register */
+#define CDNS_XSPI_CTRL_VERSION_REG            0x0F00
+#define CDNS_XSPI_MAGIC_NUM                   GENMASK(31, 16)
+#define CDNS_XSPI_CTRL_REV                    GENMASK(7, 0)
+
+/* STIG Profile 1.0 instruction fields (split into registers) */
+#define CDNS_XSPI_CMD_INSTR_TYPE              GENMASK(6, 0)
+#define CDNS_XSPI_CMD_P1_R1_ADDR0             GENMASK(31, 24)
+#define CDNS_XSPI_CMD_P1_R2_ADDR1             GENMASK(7, 0)
+#define CDNS_XSPI_CMD_P1_R2_ADDR2             GENMASK(15, 8)
+#define CDNS_XSPI_CMD_P1_R2_ADDR3             GENMASK(23, 16)
+#define CDNS_XSPI_CMD_P1_R2_ADDR4             GENMASK(31, 24)
+#define CDNS_XSPI_CMD_P1_R3_ADDR5             GENMASK(7, 0)
+#define CDNS_XSPI_CMD_P1_R3_CMD               GENMASK(23, 16)
+#define CDNS_XSPI_CMD_P1_R3_NUM_ADDR_BYTES    GENMASK(30, 28)
+#define CDNS_XSPI_CMD_P1_R4_ADDR_IOS          GENMASK(1, 0)
+#define CDNS_XSPI_CMD_P1_R4_CMD_IOS           GENMASK(9, 8)
+#define CDNS_XSPI_CMD_P1_R4_BANK              GENMASK(14, 12)
+
+/* STIG data sequence instruction fields (split into registers) */
+#define CDNS_XSPI_CMD_DSEQ_R2_DCNT_L          GENMASK(31, 16)
+#define CDNS_XSPI_CMD_DSEQ_R3_DCNT_H          GENMASK(15, 0)
+#define CDNS_XSPI_CMD_DSEQ_R3_NUM_OF_DUMMY    GENMASK(25, 20)
+#define CDNS_XSPI_CMD_DSEQ_R4_BANK            GENMASK(14, 12)
+#define CDNS_XSPI_CMD_DSEQ_R4_DATA_IOS        GENMASK(9, 8)
+#define CDNS_XSPI_CMD_DSEQ_R4_DIR             BIT(4)
+
+/* STIG command status fields */
+#define CDNS_XSPI_CMD_STATUS_COMPLETED        BIT(15)
+#define CDNS_XSPI_CMD_STATUS_FAILED           BIT(14)
+#define CDNS_XSPI_CMD_STATUS_DQS_ERROR        BIT(3)
+#define CDNS_XSPI_CMD_STATUS_CRC_ERROR        BIT(2)
+#define CDNS_XSPI_CMD_STATUS_BUS_ERROR        BIT(1)
+#define CDNS_XSPI_CMD_STATUS_INV_SEQ_ERROR    BIT(0)
+
+#define CDNS_XSPI_CTRL_WORK_MODE_STIG         0x01
+
+#define CDNS_XSPI_STIG_DONE_FLAG              BIT(0)
+
+/* Helper macros for filling command registers */
+#define CDNS_XSPI_CMD_FLD_P1_INSTR_CMD_1(op, data_phase) ( \
+	FIELD_PREP(CDNS_XSPI_CMD_INSTR_TYPE, (data_phase) ? \
+		CDNS_XSPI_STIG_INSTR_TYPE_1 : CDNS_XSPI_STIG_INSTR_TYPE_0) | \
+	FIELD_PREP(CDNS_XSPI_CMD_P1_R1_ADDR0, op->addr.val & 0xff))
+
+#define CDNS_XSPI_CMD_FLD_P1_INSTR_CMD_2(op) ( \
+	FIELD_PREP(CDNS_XSPI_CMD_P1_R2_ADDR1, (op->addr.val >> 8)  & 0xFF) | \
+	FIELD_PREP(CDNS_XSPI_CMD_P1_R2_ADDR2, (op->addr.val >> 16) & 0xFF) | \
+	FIELD_PREP(CDNS_XSPI_CMD_P1_R2_ADDR3, (op->addr.val >> 24) & 0xFF) | \
+	FIELD_PREP(CDNS_XSPI_CMD_P1_R2_ADDR4, (op->addr.val >> 32) & 0xFF))
+
+#define CDNS_XSPI_CMD_FLD_P1_INSTR_CMD_3(op) ( \
+	FIELD_PREP(CDNS_XSPI_CMD_P1_R3_ADDR5, (op->addr.val >> 40) & 0xFF) | \
+	FIELD_PREP(CDNS_XSPI_CMD_P1_R3_CMD, op->cmd.opcode) | \
+	FIELD_PREP(CDNS_XSPI_CMD_P1_R3_NUM_ADDR_BYTES, op->addr.nbytes))
+
+#define CDNS_XSPI_CMD_FLD_P1_INSTR_CMD_4(op, chipsel) ( \
+	FIELD_PREP(CDNS_XSPI_CMD_P1_R4_ADDR_IOS, ilog2(op->addr.buswidth)) | \
+	FIELD_PREP(CDNS_XSPI_CMD_P1_R4_CMD_IOS, ilog2(op->cmd.buswidth)) | \
+	FIELD_PREP(CDNS_XSPI_CMD_P1_R4_BANK, chipsel))
+
+#define CDNS_XSPI_CMD_FLD_DSEQ_CMD_1(op) \
+	FIELD_PREP(CDNS_XSPI_CMD_INSTR_TYPE, CDNS_XSPI_STIG_INSTR_TYPE_DATA_SEQ)
+
+#define CDNS_XSPI_CMD_FLD_DSEQ_CMD_2(op) \
+	FIELD_PREP(CDNS_XSPI_CMD_DSEQ_R2_DCNT_L, op->data.nbytes & 0xFFFF)
+
+#define CDNS_XSPI_CMD_FLD_DSEQ_CMD_3(op) ( \
+	FIELD_PREP(CDNS_XSPI_CMD_DSEQ_R3_DCNT_H, \
+		(op->data.nbytes >> 16) & 0xffff) | \
+	FIELD_PREP(CDNS_XSPI_CMD_DSEQ_R3_NUM_OF_DUMMY, op->dummy.nbytes * 8))
+
+#define CDNS_XSPI_CMD_FLD_DSEQ_CMD_4(op, chipsel) ( \
+	FIELD_PREP(CDNS_XSPI_CMD_DSEQ_R4_BANK, chipsel) | \
+	FIELD_PREP(CDNS_XSPI_CMD_DSEQ_R4_DATA_IOS, ilog2(op->data.buswidth)) | \
+	FIELD_PREP(CDNS_XSPI_CMD_DSEQ_R4_DIR, \
+		(op->data.dir == SPI_MEM_DATA_IN) ? \
+		CDNS_XSPI_STIG_CMD_DIR_READ : CDNS_XSPI_STIG_CMD_DIR_WRITE))
+
+enum cdns_xspi_stig_instr_type {
+	CDNS_XSPI_STIG_INSTR_TYPE_0,
+	CDNS_XSPI_STIG_INSTR_TYPE_1,
+	CDNS_XSPI_STIG_INSTR_TYPE_DATA_SEQ = 127,
+};
+
+enum cdns_xspi_sdma_dir {
+	CDNS_XSPI_SDMA_DIR_READ,
+	CDNS_XSPI_SDMA_DIR_WRITE,
+};
+
+enum cdns_xspi_stig_cmd_dir {
+	CDNS_XSPI_STIG_CMD_DIR_READ,
+	CDNS_XSPI_STIG_CMD_DIR_WRITE,
+};
+
+struct cdns_xspi_platform_data {
+	u32 phy_data_sel_oe_start;
+	u32 phy_data_sel_oe_end;
+	u32 phy_dqs_sel_oe_start;
+	u32 phy_dqs_sel_oe_end;
+	u32 phy_gate_cfg_close;
+	u32 phy_gate_cfg;
+	u32 phy_rd_del_sel;
+	u32 clk_wr_delay;
+	bool dqs_last_data_drop;
+	bool use_lpbk_dqs;
+	bool use_ext_lpbk_dqs;
+};
+
+struct cdns_xspi_dev {
+	struct platform_device *pdev;
+	struct device *dev;
+
+	void __iomem *iobase;
+	void __iomem *auxbase;
+	void __iomem *sdmabase;
+
+	int irq;
+	int current_cs;
+
+	struct mutex lock;
+
+	struct completion cmd_complete;
+	struct completion sdma_complete;
+	bool sdma_error;
+
+	void *in_buffer;
+	const void *out_buffer;
+
+	u8 hw_num_banks;
+
+	struct cdns_xspi_platform_data *plat_data;
+};
+
+struct spi_master *cdns_xspi_prepare_master(struct device *dev);
+int cdns_xspi_configure(struct cdns_xspi_dev *cdns_xspi);
+int cdns_xspi_of_get_plat_data(struct device *dev);
+irqreturn_t cdns_xspi_irq_handler(int this_irq, void *dev);
-- 
2.31.1

