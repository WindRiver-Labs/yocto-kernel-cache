From 9c320cb186dc953deb487ffd15ee8ee1c6281fe4 Mon Sep 17 00:00:00 2001
From: Linu Cherian <lcherian@marvell.com>
Date: Thu, 12 Sep 2019 06:45:54 +0530
Subject: [PATCH 364/767] coresight: Fix assumptions on coresight topology

commit 923c488e675803a3aa6982a1105e46a4a1780341 from
git@git.assembla.com:cavium/WindRiver.linux.git

Remove the assumption that there is common sink
for all the trace sources.
Note: This is fixed only for the sysfs interface.

Change-Id: Iefc073a2410d211b5e6b743f5bea404dbd9ea995
Signed-off-by: Linu Cherian <lcherian@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/16637
[Kevin: Just some minor context mods in order to port to linux-yocto]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../hwtracing/coresight/coresight-etm-perf.c  |  2 +-
 drivers/hwtracing/coresight/coresight-priv.h  |  3 ++-
 drivers/hwtracing/coresight/coresight.c       | 25 +++++++++++++++++--
 3 files changed, 26 insertions(+), 4 deletions(-)

diff --git a/drivers/hwtracing/coresight/coresight-etm-perf.c b/drivers/hwtracing/coresight/coresight-etm-perf.c
index 1ef098ff27c3..6558dd7652a5 100644
--- a/drivers/hwtracing/coresight/coresight-etm-perf.c
+++ b/drivers/hwtracing/coresight/coresight-etm-perf.c
@@ -223,7 +223,7 @@ static void *etm_setup_aux(struct perf_event *event, void **pages,
 		id = (u32)event->attr.config2;
 		sink = coresight_get_sink_by_id(id);
 	} else {
-		sink = coresight_get_enabled_sink(true);
+		sink = coresight_get_enabled_sink(NULL, true);
 	}
 
 	if (!sink)
diff --git a/drivers/hwtracing/coresight/coresight-priv.h b/drivers/hwtracing/coresight/coresight-priv.h
index e0684d06e9ee..83325b0f86f0 100644
--- a/drivers/hwtracing/coresight/coresight-priv.h
+++ b/drivers/hwtracing/coresight/coresight-priv.h
@@ -147,7 +147,8 @@ static inline void coresight_write_reg_pair(void __iomem *addr, u64 val,
 void coresight_disable_path(struct list_head *path);
 int coresight_enable_path(struct list_head *path, u32 mode, void *sink_data);
 struct coresight_device *coresight_get_sink(struct list_head *path);
-struct coresight_device *coresight_get_enabled_sink(bool reset);
+struct coresight_device *coresight_get_enabled_sink(struct coresight_device *cs,
+						    bool reset);
 struct coresight_device *coresight_get_sink_by_id(u32 id);
 struct list_head *coresight_build_path(struct coresight_device *csdev,
 				       struct coresight_device *sink);
diff --git a/drivers/hwtracing/coresight/coresight.c b/drivers/hwtracing/coresight/coresight.c
index 4b130281236a..1fbf7e125b23 100644
--- a/drivers/hwtracing/coresight/coresight.c
+++ b/drivers/hwtracing/coresight/coresight.c
@@ -524,6 +524,7 @@ static int coresight_enabled_sink(struct device *dev, void *data)
 
 /**
  * coresight_get_enabled_sink - returns the first enabled sink found on the bus
+ * In case the child port is a single source ETR, returns the child port as sink
  * @deactivate:	Whether the 'enable_sink' flag should be reset
  *
  * When operated from perf the deactivate parameter should be set to 'true'.
@@ -534,10 +535,30 @@ static int coresight_enabled_sink(struct device *dev, void *data)
  * parameter should be set to 'false', hence mandating users to explicitly
  * clear the flag.
  */
-struct coresight_device *coresight_get_enabled_sink(bool deactivate)
+struct coresight_device *coresight_get_enabled_sink(struct coresight_device *s,
+						    bool deactivate)
 {
+	struct coresight_device *child;
 	struct device *dev = NULL;
 
+	if (s == NULL)
+		goto skip_single_source;
+
+	/* If the connected port is an ETR with single trace source,
+	 * nothing to search further.
+	 */
+	child = s->conns[0].child_dev;
+	if (s->nr_outport == 1 &&
+	    child->type == CORESIGHT_DEV_TYPE_SINK &&
+	    child->subtype.sink_subtype == CORESIGHT_DEV_SUBTYPE_SINK_BUFFER &&
+	    child->nr_inport == 1 &&
+	    child->activated) {
+		if (deactivate)
+			child->activated = false;
+		return child;
+	}
+
+skip_single_source:
 	dev = bus_find_device(&coresight_bustype, NULL, &deactivate,
 			      coresight_enabled_sink);
 
@@ -782,7 +803,7 @@ int coresight_enable(struct coresight_device *csdev)
 	 * Search for a valid sink for this session but don't reset the
 	 * "enable_sink" flag in sysFS.  Users get to do that explicitly.
 	 */
-	sink = coresight_get_enabled_sink(false);
+	sink = coresight_get_enabled_sink(csdev, false);
 	if (!sink) {
 		ret = -EINVAL;
 		goto out;
-- 
2.31.1

