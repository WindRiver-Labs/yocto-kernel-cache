From e185d1f27aa7e9b8d402dfa813c5d29b62019805 Mon Sep 17 00:00:00 2001
From: Linu Cherian <lcherian@marvell.com>
Date: Wed, 19 Dec 2018 17:01:43 +0530
Subject: [PATCH 058/767] octeontx2-pf: Register and handle CGX link
 notifications

commit 05058520ddc4418f91dc1b3b7782af617ebcbdde from
git@git.assembla.com:cavium/WindRiver.linux.git

RVU PF and AF (admin function) shares 64KB of reserved memory
region for communication. This region is shared for
 - Messages sent by PF and responses sent by AF.
 - Notifications sent by AF and ACKs sent by PF.

This patch adds infrastructure to handle notifications sent
by AF and adds handlers to process them.

One of the main usecase of notifications from AF is physical
link changes. So this patch adds registration of PF with AF
to receive CGX link status change notifications and also adds
the handler for that notification.

This patch also adds __weak function symbols for mbox handlers to
enable us to add mbox IDs for mbox handlers which are outside the
kernel.

Change-Id: Ide7be9b0d2049807c517138462cf45fdb8a86118
Signed-off-by: Linu Cherian <lcherian@marvell.com>
Signed-off-by: Aleksey Makarov <amakarov@marvell.com>
Signed-off-by: Sunil Goutham <sgoutham@marvell.com>
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../marvell/octeontx2/nic/otx2_common.c       |  13 ++
 .../marvell/octeontx2/nic/otx2_common.h       |  12 ++
 .../ethernet/marvell/octeontx2/nic/otx2_pf.c  | 129 +++++++++++++++++-
 3 files changed, 152 insertions(+), 2 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.c
index 8a2b8a258f5d..642496d317b6 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.c
@@ -974,3 +974,16 @@ void otx2_set_cints_affinity(struct otx2_nic *pfvf)
 			cpu = 0;
 	}
 }
+
+#define M(_name, _id, _fn_name, _req_type, _rsp_type)			\
+int __weak								\
+otx2_mbox_up_handler_ ## _fn_name(struct otx2_nic *pfvf,		\
+				struct _req_type *req,			\
+				struct _rsp_type *rsp)			\
+{									\
+	/* Nothing to do here */					\
+	return 0;							\
+}
+
+MBOX_UP_CGX_MESSAGES
+#undef M
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h
index 48678cb8f2fe..c0cc799c9252 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h
@@ -134,6 +134,9 @@ static inline int otx2_mbox_bbuf_init(struct mbox *mbox, struct pci_dev *pdev)
 	mdev = &otx2_mbox->dev[0];
 	mdev->mbase = mbox->bbuf_base;
 
+	otx2_mbox = &mbox->mbox_up;
+	mdev = &otx2_mbox->dev[0];
+	mdev->mbase = mbox->bbuf_base;
 	return 0;
 }
 
@@ -290,6 +293,15 @@ static struct _req_type __maybe_unused					\
 MBOX_MESSAGES
 #undef M
 
+#define M(_name, _id, _fn_name, _req_type, _rsp_type)			\
+int									\
+otx2_mbox_up_handler_ ## _fn_name(struct otx2_nic *pfvf,		\
+				struct _req_type *req,			\
+				struct _rsp_type *rsp);			\
+
+MBOX_UP_CGX_MESSAGES
+#undef M
+
 #define	RVU_PFVF_PF_SHIFT	10
 #define	RVU_PFVF_PF_MASK	0x3F
 #define	RVU_PFVF_FUNC_SHIFT	0
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c
index 7ef6328e4f0b..8d258804d090 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c
@@ -110,6 +110,96 @@ static void otx2_pfaf_mbox_handler(struct work_struct *work)
 	otx2_write64(af_mbox->pfvf, RVU_PF_INT, BIT_ULL(0));
 }
 
+int otx2_mbox_up_handler_cgx_link_event(struct otx2_nic *pf,
+					struct cgx_link_info_msg *msg,
+					struct msg_rsp *rsp)
+{
+	struct cgx_link_user_info *linfo = &msg->link_info;
+	struct net_device *netdev = pf->netdev;
+
+	pr_info("%s NIC Link is %s\n",
+		netdev->name, linfo->link_up ? "UP" : "DOWN");
+	if (linfo->link_up) {
+		netif_carrier_on(netdev);
+		netif_tx_start_all_queues(netdev);
+	} else {
+		netif_tx_stop_all_queues(netdev);
+		netif_carrier_off(netdev);
+	}
+	return 0;
+}
+
+static int otx2_process_mbox_msg_up(struct otx2_nic *pf,
+				    struct mbox_msghdr *req)
+{
+	/* Check if valid, if not reply with a invalid msg */
+	if (req->sig != OTX2_MBOX_REQ_SIG) {
+		otx2_reply_invalid_msg(&pf->mbox.mbox_up, 0, 0, req->id);
+		return -ENODEV;
+	}
+
+	switch (req->id) {
+#define M(_name, _id, _fn_name, _req_type, _rsp_type)			\
+	case _id: {							\
+		struct _rsp_type *rsp;					\
+		int err;						\
+									\
+		rsp = (struct _rsp_type *)otx2_mbox_alloc_msg(		\
+			&pf->mbox.mbox_up, 0,				\
+			sizeof(struct _rsp_type));			\
+		if (!rsp)						\
+			return -ENOMEM;					\
+									\
+		rsp->hdr.id = _id;					\
+		rsp->hdr.sig = OTX2_MBOX_RSP_SIG;			\
+		rsp->hdr.pcifunc = 0;					\
+		rsp->hdr.rc = 0;					\
+									\
+		err = otx2_mbox_up_handler_ ## _fn_name(		\
+			pf, (struct _req_type *)req, rsp);		\
+		return err;						\
+	}
+MBOX_UP_CGX_MESSAGES
+#undef M
+		break;
+	default:
+		otx2_reply_invalid_msg(&pf->mbox.mbox_up, 0, 0, req->id);
+		return -ENODEV;
+	}
+	return 0;
+}
+
+static void otx2_pfaf_mbox_up_handler(struct work_struct *work)
+{
+	struct mbox *af_mbox = container_of(work, struct mbox, mbox_up_wrk);
+	struct otx2_mbox *mbox = &af_mbox->mbox_up;
+	struct otx2_nic *pf = af_mbox->pfvf;
+	struct otx2_mbox_dev *mdev = &mbox->dev[0];
+	struct mbox_hdr *rsp_hdr;
+	struct mbox_msghdr *msg;
+	int offset, id;
+	int err;
+
+	rsp_hdr = (struct mbox_hdr *)(mdev->mbase + mbox->rx_start);
+	if (rsp_hdr->num_msgs == 0)
+		return;
+
+	offset = mbox->rx_start + ALIGN(sizeof(*rsp_hdr), MBOX_MSG_ALIGN);
+
+	for (id = 0; id < rsp_hdr->num_msgs; id++) {
+		msg = (struct mbox_msghdr *)(mdev->mbase + offset);
+
+		err = otx2_process_mbox_msg_up(pf, msg);
+		if (err) {
+			dev_warn(pf->dev, "Error %d when processing message %s from AF\n",
+				 err, otx2_mbox_id2name(msg->id));
+		}
+		offset = mbox->rx_start + msg->next_msgoff;
+	}
+
+	otx2_mbox_msg_send(mbox, 0);
+}
+
 static irqreturn_t otx2_pfaf_mbox_intr_handler(int irq, void *pf_irq)
 {
 	struct otx2_nic *pf = (struct otx2_nic *)pf_irq;
@@ -129,6 +219,15 @@ static irqreturn_t otx2_pfaf_mbox_intr_handler(int irq, void *pf_irq)
 	if (hdr->num_msgs)
 		queue_work(pf->mbox_wq, &pf->mbox.mbox_wrk);
 
+	/* Check for AF => PF notification messages */
+	mbox = &pf->mbox.mbox_up;
+	mdev = &mbox->dev[0];
+	otx2_sync_mbox_bbuf(mbox, 0);
+
+	hdr = (struct mbox_hdr *)(mdev->mbase + mbox->rx_start);
+	if (hdr->num_msgs)
+		queue_work(pf->mbox_wq, &pf->mbox.mbox_up_wrk);
+
 	/* Clear the IRQ */
 	otx2_write64(pf, RVU_PF_INT, BIT_ULL(0));
 
@@ -199,6 +298,7 @@ static void otx2_pfaf_mbox_destroy(struct otx2_nic *pf)
 		iounmap((void __iomem *)mbox->mbox.hwbase);
 
 	otx2_mbox_destroy(&mbox->mbox);
+	otx2_mbox_destroy(&mbox->mbox_up);
 }
 
 static int otx2_pfaf_mbox_init(struct otx2_nic *pf)
@@ -231,11 +331,18 @@ static int otx2_pfaf_mbox_init(struct otx2_nic *pf)
 	if (err)
 		goto exit;
 
+	err = otx2_mbox_init(&mbox->mbox_up, hwbase, pf->pdev, pf->reg_base,
+			     MBOX_DIR_PFAF_UP, 1);
+	if (err)
+		goto exit;
+
 	err = otx2_mbox_bbuf_init(mbox, pf->pdev);
 	if (err)
 		goto exit;
 
+
 	INIT_WORK(&mbox->mbox_wrk, otx2_pfaf_mbox_handler);
+	INIT_WORK(&mbox->mbox_up_wrk, otx2_pfaf_mbox_up_handler);
 
 	return 0;
 exit:
@@ -243,6 +350,21 @@ static int otx2_pfaf_mbox_init(struct otx2_nic *pf)
 	return err;
 }
 
+static int otx2_cgx_config_linkevents(struct otx2_nic *pf, bool enable)
+{
+	struct msg_req *msg;
+
+	if (enable)
+		msg = otx2_mbox_alloc_msg_cgx_start_linkevents(&pf->mbox);
+	else
+		msg = otx2_mbox_alloc_msg_cgx_stop_linkevents(&pf->mbox);
+
+	if (!msg)
+		return -ENOMEM;
+
+	return otx2_sync_mbox_msg(&pf->mbox);
+}
+
 static int otx2_cgx_config_loopback(struct otx2_nic *pf, bool enable)
 {
 	struct msg_req *msg;
@@ -569,9 +691,9 @@ static int otx2_open(struct net_device *netdev)
 		goto err_free_cints;
 
 	pf->intf_down = false;
-	netif_carrier_on(netdev);
-	netif_tx_start_all_queues(netdev);
 
+	/* Enable link notifications */
+	otx2_cgx_config_linkevents(pf, true);
 	return 0;
 
 err_free_cints:
@@ -596,6 +718,9 @@ static int otx2_stop(struct net_device *netdev)
 	/* First stop packet Rx/Tx */
 	otx2_rxtx_enable(pf, false);
 
+	/* Disable link notifications */
+	otx2_cgx_config_linkevents(pf, false);
+
 	pf->intf_down = true;
 	/* 'intf_down' may be checked on any cpu */
 	smp_wmb();
-- 
2.31.1

