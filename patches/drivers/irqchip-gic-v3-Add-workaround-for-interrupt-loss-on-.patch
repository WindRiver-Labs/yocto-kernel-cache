From 584509b8ba2a1226389fc921513f2ede29d5a153 Mon Sep 17 00:00:00 2001
From: Linu Cherian <lcherian@marvell.com>
Date: Wed, 15 Jul 2020 21:12:17 +0530
Subject: [PATCH 600/767] irqchip/gic-v3: Add workaround for interrupt loss on
 IPI

commit 6d8e7e989063996a13cf8190d4d23bef8ca9a89e from
git@git.assembla.com:cavium/WindRiver.linux.git

RCU stalls has been observed during stress-ng tests on
OcteonTx2 silicon and the reason being an interrupt loss on an IPI.

As a workaround, added provision to ensure that every IPI has been
received on the destination core and if an IPI interrupt loss is
encountered, do resend the IPI.

Identifying a lost interrupt:
Once an interrupt is raised on an IPI line, it would be either in
one of the below states.
   A. pending
   B. active
   C. deactivated

Pending/active states can be verified from the corresponding redist
registers. An interrupt would be in deactivated state either because its
already processed or its been lost. So to identify the reason for case C,
per core tx and rx counters has been introduced for each IPI line.

Change-Id: I5ff5886a498d4b4ef6c783f52a9590feecf314b2
Signed-off-by: Linu Cherian <lcherian@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/32026
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
[Kevin: Change the lock to raw_spinlock_t for rt]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/irqchip/irq-gic-v3-fixes.c       | 147 ++++++++++++++++++++++-
 drivers/irqchip/irq-gic-v3.c             |  58 ++++++++-
 include/linux/irqchip/irq-gic-v3-fixes.h |  12 +-
 3 files changed, 211 insertions(+), 6 deletions(-)

diff --git a/drivers/irqchip/irq-gic-v3-fixes.c b/drivers/irqchip/irq-gic-v3-fixes.c
index a3fee8e48ba8..ee89ac63c70d 100644
--- a/drivers/irqchip/irq-gic-v3-fixes.c
+++ b/drivers/irqchip/irq-gic-v3-fixes.c
@@ -1,5 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0
-/* Marvell Silicon gicv3 definitions
+/* Marvell Silicon GICv3/ITS hardware quirks
  *
  * Copyright (C) 2020 Marvell International Ltd.
  *
@@ -9,14 +9,159 @@
  */
 
 #include <linux/percpu.h>
+#include <linux/io.h>
 #include <linux/arm-smccc.h>
 #include <linux/irqchip.h>
 #include <linux/irqchip/arm-gic-v3.h>
+#include <linux/irqchip/arm-gic-common.h>
 #include <linux/irqchip/irq-gic-v3-fixes.h>
 
+#include "irq-gic-common.h"
+
 #define OCTEONTX_LPI_PROP_TBL_BASE      0xc2000c0c
 #define gic_data_rdist()		(raw_cpu_ptr(gic_rdists->rdist))
 
+enum ipi_msg_type {
+	IPI_RESCHEDULE,
+	IPI_CALL_FUNC,
+	IPI_CPU_STOP,
+	IPI_CPU_CRASH_STOP,
+	IPI_TIMER,
+	IPI_IRQ_WORK,
+	IPI_WAKEUP,
+	NR_IPIS
+};
+
+struct gic_ipi_track {
+	atomic_t tx_count;
+	atomic_t rx_count;
+	raw_spinlock_t lock;
+};
+
+static struct gic_ipi_track gic_ipitrack[NR_CPUS][NR_IPIS];
+
+static inline void gic_ipi_txcount_inc(int cpu, int irq)
+{
+	atomic_inc(&gic_ipitrack[cpu][irq].tx_count);
+}
+
+void gic_ipi_rxcount_inc(int cpu, int irq)
+{
+	atomic_inc(&gic_ipitrack[cpu][irq].rx_count);
+}
+
+static inline void gic_ipi_count_reset(int cpu, int irq)
+{
+	atomic_set(&gic_ipitrack[cpu][irq].tx_count, 0x0);
+	atomic_set(&gic_ipitrack[cpu][irq].rx_count, 0x0);
+}
+
+static inline bool is_gic_ipi_received(int dest_cpu, int irq)
+{
+	int retry_count = 0xf;
+
+retry:
+	if (gic_rdist_pend_reg(dest_cpu, 0x0) & (1 << irq))
+		return true;
+
+	if (gic_rdist_active_reg(dest_cpu, 0x0) & (1 << irq))
+		return true;
+	smp_rmb(); /* Ensure pend/active reg read happens first */
+
+	if (atomic_read(&gic_ipitrack[dest_cpu][irq].tx_count) ==
+		atomic_read(&gic_ipitrack[dest_cpu][irq].rx_count))
+		return true;
+
+	if (!retry_count)
+		return false;
+
+	retry_count--;
+	goto retry;
+}
+
+void gic_write_sgi1r_retry(int dest_cpu, int irq, u64 val)
+{
+	unsigned long flags;
+
+	raw_spin_lock_irqsave(&gic_ipitrack[dest_cpu][irq].lock, flags);
+	wmb(); /* Ensure lock is acquired before we generate an IPI */
+retry:
+	gic_write_sgi1r(val);
+	isb(); /* Ensure sgi write is completed before pending/active read */
+	gic_ipi_txcount_inc(dest_cpu, irq);
+	if (is_gic_ipi_received(dest_cpu, irq))
+		goto out;
+
+	/* Seems we have lost an interrupt
+	 * Reset and start again
+	 */
+	gic_ipi_count_reset(dest_cpu, irq);
+	wmb(); /* Ensure the write is completed before we start again */
+	goto retry;
+out:
+	raw_spin_unlock_irqrestore(&gic_ipitrack[dest_cpu][irq].lock, flags);
+}
+
+static bool __maybe_unused gicv3_enable_quirk_otx2(void *data)
+{
+	int cpu, ipi;
+
+	gic_v3_enable_ipimiss_quirk();
+
+	/* Initialize necessary lock */
+	for_each_possible_cpu(cpu)
+		for (ipi = 0; ipi < NR_IPIS; ipi++)
+			raw_spin_lock_init(&gic_ipitrack[cpu][ipi].lock);
+
+	return true;
+}
+
+static const struct gic_quirk gicv3_quirks[] = {
+	{
+		.desc	= "GIC V3: IPI Miss",
+		.iidr	= 0xb100034c,
+		.mask	= 0xff000fff,
+		.init	= gicv3_enable_quirk_otx2,
+	},
+	{
+		.desc	= "GIC V3: IPI Miss",
+		.iidr	= 0xb200034c,
+		.mask	= 0xff000fff,
+		.init	= gicv3_enable_quirk_otx2,
+	},
+	{
+		.desc	= "GIC V3: IPI Miss",
+		.iidr	= 0xb300034c,
+		.mask	= 0xff000fff,
+		.init	= gicv3_enable_quirk_otx2,
+	},
+	{
+		.desc	= "GIC V3: IPI Miss",
+		.iidr	= 0xb400034c,
+		.mask	= 0xff000fff,
+		.init	= gicv3_enable_quirk_otx2,
+	},
+	{
+		.desc	= "GIC V3: IPI Miss",
+		.iidr	= 0xb500034c,
+		.mask	= 0xff000fff,
+		.init	= gicv3_enable_quirk_otx2,
+	},
+	{ /* NULL entry */
+		0,
+		0,
+		0,
+		0,
+	}
+};
+
+void gic_v3_enable_quirks(void __iomem *base)
+{
+	u32 iidr = readl_relaxed(base + GICD_IIDR);
+
+	gic_enable_quirks(iidr, gicv3_quirks, NULL);
+}
+
 struct page *its_prop_alloc_pages(struct rdists *gic_rdists,
 				size_t prop_tbl_sz,  gfp_t gfp_flags)
 {
diff --git a/drivers/irqchip/irq-gic-v3.c b/drivers/irqchip/irq-gic-v3.c
index c09c1eea3319..8ccfce258b32 100644
--- a/drivers/irqchip/irq-gic-v3.c
+++ b/drivers/irqchip/irq-gic-v3.c
@@ -23,6 +23,7 @@
 #include <linux/irqchip/arm-gic-common.h>
 #include <linux/irqchip/arm-gic-v3.h>
 #include <linux/irqchip/irq-partition-percpu.h>
+#include <linux/irqchip/irq-gic-v3-fixes.h>
 
 #include <asm/cputype.h>
 #include <asm/exception.h>
@@ -57,6 +58,7 @@ struct gic_chip_data {
 
 static struct gic_chip_data gic_data __read_mostly;
 static DEFINE_STATIC_KEY_TRUE(supports_deactivate_key);
+static DEFINE_STATIC_KEY_FALSE(gic_ipimiss_quirk);
 
 /*
  * The behaviours of RPR and PMR registers differ depending on the value of
@@ -94,9 +96,39 @@ static DEFINE_PER_CPU(bool, has_rss);
 #define gic_data_rdist_rd_base()	(gic_data_rdist()->rd_base)
 #define gic_data_rdist_sgi_base()	(gic_data_rdist_rd_base() + SZ_64K)
 
+#define gic_data_rdist_cpu(cpu)		\
+				(per_cpu_ptr(gic_data.rdists.rdist, cpu))
+#define gic_data_rdist_rd_base_cpu(cpu)	\
+				(gic_data_rdist_cpu(cpu)->rd_base)
+#define gic_data_rdist_sgi_base_cpu(cpu)\
+				(gic_data_rdist_rd_base_cpu(cpu) + SZ_64K)
+
 /* Our default, arbitrary priority value. Linux only uses one anyway. */
 #define DEFAULT_PMR_VALUE	0xf0
 
+void gic_v3_enable_ipimiss_quirk(void)
+{
+	static_branch_enable(&gic_ipimiss_quirk);
+}
+
+u32 gic_rdist_pend_reg(int cpu, int offset)
+{
+	void __iomem *base;
+
+	base = gic_data_rdist_sgi_base_cpu(cpu);
+
+	return readl_relaxed(base + GICR_ISPENDR0 + offset);
+}
+
+u32 gic_rdist_active_reg(int cpu, int offset)
+{
+	void __iomem *base;
+
+	base = gic_data_rdist_sgi_base_cpu(cpu);
+
+	return readl_relaxed(base + GICR_ISACTIVER0 + offset);
+}
+
 static inline unsigned int gic_irq(struct irq_data *d)
 {
 	return d->hwirq;
@@ -516,6 +548,12 @@ static asmlinkage void __exception_irq_entry gic_handle_irq(struct pt_regs *regs
 		return;
 	}
 	if (irqnr < 16) {
+		if (static_branch_likely(&gic_ipimiss_quirk)) {
+			gic_ipi_rxcount_inc(smp_processor_id(), irqnr);
+			/* Force increment is done before deactivate */
+			wmb();
+		}
+
 		gic_write_eoir(irqnr);
 		if (static_branch_likely(&supports_deactivate_key))
 			gic_write_dir(irqnr);
@@ -578,6 +616,8 @@ static void __init gic_dist_init(void)
 	u64 affinity;
 	void __iomem *base = gic_data.dist_base;
 
+	gic_v3_enable_quirks(base);
+
 	/* Disable the distributor */
 	writel_relaxed(0, base + GICD_CTLR);
 	gic_dist_wait_for_rwp();
@@ -884,6 +924,10 @@ static u16 gic_compute_target_list(int *base_cpu, const struct cpumask *mask,
 	while (cpu < nr_cpu_ids) {
 		tlist |= 1 << (mpidr & 0xf);
 
+		if (static_branch_likely(&gic_ipimiss_quirk))
+			/* Force only one target at a time */
+			goto out;
+
 		next_cpu = cpumask_next(cpu, mask);
 		if (next_cpu >= nr_cpu_ids)
 			goto out;
@@ -904,8 +948,8 @@ static u16 gic_compute_target_list(int *base_cpu, const struct cpumask *mask,
 #define MPIDR_TO_SGI_AFFINITY(cluster_id, level) \
 	(MPIDR_AFFINITY_LEVEL(cluster_id, level) \
 		<< ICC_SGI1R_AFFINITY_## level ##_SHIFT)
-
-static void gic_send_sgi(u64 cluster_id, u16 tlist, unsigned int irq)
+static void gic_send_sgi(int dest_cpu, u64 cluster_id, u16 tlist,
+			 unsigned int irq)
 {
 	u64 val;
 
@@ -917,7 +961,10 @@ static void gic_send_sgi(u64 cluster_id, u16 tlist, unsigned int irq)
 	       tlist << ICC_SGI1R_TARGET_LIST_SHIFT);
 
 	pr_devel("CPU%d: ICC_SGI1R_EL1 %llx\n", smp_processor_id(), val);
-	gic_write_sgi1r(val);
+	if (static_branch_likely(&gic_ipimiss_quirk))
+		gic_write_sgi1r_retry(dest_cpu, irq, val);
+	else
+		gic_write_sgi1r(val);
 }
 
 static void gic_raise_softirq(const struct cpumask *mask, unsigned int irq)
@@ -938,9 +985,12 @@ static void gic_raise_softirq(const struct cpumask *mask, unsigned int irq)
 		u16 tlist;
 
 		tlist = gic_compute_target_list(&cpu, mask, cluster_id);
-		gic_send_sgi(cluster_id, tlist, irq);
+		gic_send_sgi(cpu, cluster_id, tlist, irq);
 	}
 
+	if (static_branch_likely(&gic_ipimiss_quirk))
+		return;
+
 	/* Force the above writes to ICC_SGI1R_EL1 to be executed */
 	isb();
 }
diff --git a/include/linux/irqchip/irq-gic-v3-fixes.h b/include/linux/irqchip/irq-gic-v3-fixes.h
index 3b03be60650c..0729b49007ec 100644
--- a/include/linux/irqchip/irq-gic-v3-fixes.h
+++ b/include/linux/irqchip/irq-gic-v3-fixes.h
@@ -1,5 +1,5 @@
 /* SPDX-License-Identifier: GPL-2.0
- * Marvell Silicon gicv3 definitions
+ * Marvell Silicon GICv3/ITS hardware quirks
  *
  * Copyright (C) 2020 Marvell International Ltd.
  *
@@ -11,6 +11,16 @@
 #ifndef __LINUX_IRQCHIP_MARVELL_GIC_V3_H
 #define __LINUX_IRQCHIP_MARVELL_GIC_V3_H
 
+#define GICV3_QUIRK_IPI_MISS	(1 << 0)
+
+u32 gic_rdist_pend_reg(int cpu, int offset);
+u32 gic_rdist_active_reg(int cpu, int offset);
+
+void gic_ipi_rxcount_inc(int cpu, int irq);
+void gic_write_sgi1r_retry(int dest_cpu, int irq, u64 val);
+void gic_v3_enable_quirks(void __iomem *base);
+void gic_v3_enable_ipimiss_quirk(void);
+
 struct page *its_prop_alloc_pages(struct rdists *gic_rdists,
 				size_t prop_tbl_sz,  gfp_t gfp_flags);
 struct page *its_pend_alloc_pages(struct rdists *gic_rdists,
-- 
2.31.1

