From cf460e424bab63e77b03e64595cbc5bd38f162ee Mon Sep 17 00:00:00 2001
From: Srujana Challa <schalla@marvell.com>
Date: Mon, 29 Jun 2020 17:35:27 +0530
Subject: [PATCH 0522/1921] octeontx2-af: Add support for CPT1 in debugfs

If CPT1 block is also implemented then add a new
directory for CPT1 in debugfs root. Stats of
CPT1 block can be read/writen from/to the files
in directory "/sys/kernel/debug/octeontx2/cpt1/"

Change-Id: Id05bfdceeba61dbe2c6041cbb2c74dab103237c4
Signed-off-by: Srujana Challa <schalla@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/31173
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Mahipal Challa <mchalla@marvell.com>
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 .../marvell/octeontx2/af/rvu_debugfs.c        | 60 ++++++++++++-------
 1 file changed, 39 insertions(+), 21 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_debugfs.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_debugfs.c
index 91ab4b5e42ac..33fb31918c49 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_debugfs.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_debugfs.c
@@ -2785,13 +2785,14 @@ static int rvu_dbg_cpt_engines_sts_display(struct seq_file *filp, void *unused)
 	struct rvu *rvu = filp->private;
 	u16  max_ses, max_ies, max_aes;
 	u32  e_min = 0, e_max = 0, e;
+	struct dentry *current_dir;
 	int  blkaddr;
 	char *e_type;
 	u64  reg;
 
-	blkaddr = rvu_get_blkaddr(rvu, BLKTYPE_CPT, 0);
-	if (blkaddr < 0)
-		return -ENODEV;
+	current_dir = filp->file->f_path.dentry->d_parent;
+	blkaddr = (!strcmp(current_dir->d_name.name, "cpt1") ?
+		   BLKADDR_CPT1 : BLKADDR_CPT0);
 
 	reg = rvu_read64(rvu, blkaddr, CPT_AF_CONSTANTS1);
 	max_ses = reg & 0xffff;
@@ -2853,14 +2854,15 @@ static int rvu_dbg_cpt_engines_info_display(struct seq_file *filp, void *unused)
 {
 	struct rvu *rvu = filp->private;
 	u16  max_ses, max_ies, max_aes;
+	struct dentry *current_dir;
 	u32  e_min, e_max, e;
 	int  blkaddr;
 	char *e_type;
 	u64  reg;
 
-	blkaddr = rvu_get_blkaddr(rvu, BLKTYPE_CPT, 0);
-	if (blkaddr < 0)
-		return -ENODEV;
+	current_dir = filp->file->f_path.dentry->d_parent;
+	blkaddr = (!strcmp(current_dir->d_name.name, "cpt1") ?
+		   BLKADDR_CPT1 : BLKADDR_CPT0);
 
 	reg = rvu_read64(rvu, blkaddr, CPT_AF_CONSTANTS1);
 	max_ses = reg & 0xffff;
@@ -2908,14 +2910,15 @@ static int rvu_dbg_cpt_lfs_info_display(struct seq_file *filp, void *unused)
 {
 	struct rvu *rvu = filp->private;
 	struct rvu_hwinfo *hw = rvu->hw;
+	struct dentry *current_dir;
 	struct rvu_block *block;
 	int blkaddr;
 	u64 reg;
 	u32 lf;
 
-	blkaddr = rvu_get_blkaddr(rvu, BLKTYPE_CPT, 0);
-	if (blkaddr < 0)
-		return -ENODEV;
+	current_dir = filp->file->f_path.dentry->d_parent;
+	blkaddr = (!strcmp(current_dir->d_name.name, "cpt1") ?
+		   BLKADDR_CPT1 : BLKADDR_CPT0);
 
 	block = &hw->block[blkaddr];
 	if (!block->lf.bmap)
@@ -2942,12 +2945,13 @@ RVU_DEBUG_SEQ_FOPS(cpt_lfs_info, cpt_lfs_info_display, NULL);
 static int rvu_dbg_cpt_err_info_display(struct seq_file *filp, void *unused)
 {
 	struct rvu *rvu = filp->private;
+	struct dentry *current_dir;
 	u64 reg0, reg1;
 	int blkaddr;
 
-	blkaddr = rvu_get_blkaddr(rvu, BLKTYPE_CPT, 0);
-	if (blkaddr < 0)
-		return -ENODEV;
+	current_dir = filp->file->f_path.dentry->d_parent;
+	blkaddr = (!strcmp(current_dir->d_name.name, "cpt1") ?
+		   BLKADDR_CPT1 : BLKADDR_CPT0);
 
 	reg0 = rvu_read64(rvu, blkaddr, CPT_AF_FLTX_INT(0));
 	reg1 = rvu_read64(rvu, blkaddr, CPT_AF_FLTX_INT(1));
@@ -2971,14 +2975,16 @@ RVU_DEBUG_SEQ_FOPS(cpt_err_info, cpt_err_info_display, NULL);
 
 static int rvu_dbg_cpt_pc_display(struct seq_file *filp, void *unused)
 {
+	struct dentry *current_dir;
 	struct rvu *rvu;
 	int blkaddr;
 	u64 reg;
 
 	rvu = filp->private;
-	blkaddr = rvu_get_blkaddr(rvu, BLKTYPE_CPT, 0);
-	if (blkaddr < 0)
-		return -ENODEV;
+
+	current_dir = filp->file->f_path.dentry->d_parent;
+	blkaddr = (!strcmp(current_dir->d_name.name, "cpt1") ?
+		   BLKADDR_CPT1 : BLKADDR_CPT0);
 
 	reg = rvu_read64(rvu, blkaddr, CPT_AF_INST_REQ_PC);
 	seq_printf(filp, "CPT instruction requests   %llu\n", reg);
@@ -3000,15 +3006,28 @@ static int rvu_dbg_cpt_pc_display(struct seq_file *filp, void *unused)
 
 RVU_DEBUG_SEQ_FOPS(cpt_pc, cpt_pc_display, NULL);
 
-static void rvu_dbg_cpt_init(struct rvu *rvu)
+static void rvu_dbg_cpt_init(struct rvu *rvu, int blkaddr)
 {
 	const struct device *dev = &rvu->pdev->dev;
 	struct dentry *pfile;
 
-	rvu->rvu_dbg.cpt = debugfs_create_dir("cpt", rvu->rvu_dbg.root);
-	if (!rvu->rvu_dbg.cpt)
+	if (!is_block_implemented(rvu->hw, blkaddr))
 		return;
 
+	if (blkaddr == BLKADDR_CPT0) {
+		rvu->rvu_dbg.cpt = debugfs_create_dir("cpt", rvu->rvu_dbg.root);
+		if (!rvu->rvu_dbg.cpt) {
+			dev_err(rvu->dev, "create debugfs dir failed for cpt\n");
+			return;
+		}
+	} else {
+		rvu->rvu_dbg.cpt = debugfs_create_dir("cpt1",
+						      rvu->rvu_dbg.root);
+		if (!rvu->rvu_dbg.cpt) {
+			dev_err(rvu->dev, "create debugfs dir failed for cpt1\n");
+			return;
+		}
+	}
 	pfile = debugfs_create_file("cpt_pc", 0600,
 				    rvu->rvu_dbg.cpt, rvu,
 				    &rvu_dbg_cpt_pc_fops);
@@ -3072,9 +3091,8 @@ void rvu_dbg_init(struct rvu *rvu)
 	rvu_dbg_nix_init(rvu, BLKADDR_NIX1);
 	rvu_dbg_npc_init(rvu);
 	rvu_dbg_sso_init(rvu);
-
-	if (is_block_implemented(rvu->hw, BLKADDR_CPT0))
-		rvu_dbg_cpt_init(rvu);
+	rvu_dbg_cpt_init(rvu, BLKADDR_CPT0);
+	rvu_dbg_cpt_init(rvu, BLKADDR_CPT1);
 
 	return;
 
-- 
2.31.1

