From fc9d54217fc9d47db8db7e55ac803263e3226f8a Mon Sep 17 00:00:00 2001
From: Sunil Goutham <sgoutham@marvell.com>
Date: Sat, 27 Jul 2019 13:34:47 +0530
Subject: [PATCH 0238/1921] octeontx2-af: Apply relevant HW issue workarounds
 for 96xx B0 silicon

Made changes to apply relevant workarounds for HW issues which
are present in 96xx B0 silicon. Also moved some silicon checks to
a common place to reduce clutter.

Change-Id: I09b7d3812c9a14c0a574ed4bb4bbbdf133323e2a
Signed-off-by: Sunil Goutham <sgoutham@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/13140
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Tested-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 .../net/ethernet/marvell/octeontx2/af/rvu.c   |  6 +-
 .../net/ethernet/marvell/octeontx2/af/rvu.h   | 17 ++++-
 .../ethernet/marvell/octeontx2/af/rvu_fixes.c | 73 ++++++++++++++++++-
 .../ethernet/marvell/octeontx2/af/rvu_npc.c   | 19 ++---
 .../ethernet/marvell/octeontx2/af/rvu_sso.c   |  2 +-
 .../ethernet/marvell/octeontx2/af/rvu_tim.c   | 21 ------
 6 files changed, 93 insertions(+), 45 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu.c
index 4d51f20a91c7..caf57b6cdd41 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu.c
@@ -67,7 +67,7 @@ static void rvu_setup_hw_capabilities(struct rvu *rvu)
 	hw->cap.nix_shaping = true;
 	hw->cap.nix_tx_link_bp = true;
 
-	if (is_rvu_96xx_A0(rvu) || is_rvu_95xx_A0(rvu)) {
+	if (is_rvu_96xx_B0(rvu) || is_rvu_95xx_A0(rvu)) {
 		hw->cap.nix_fixed_txschq_mapping = true;
 		hw->cap.nix_txsch_per_cgx_lmac = 4;
 		hw->cap.nix_txsch_per_lbk_lmac = 132;
@@ -1049,8 +1049,8 @@ static int rvu_lookup_rsrc(struct rvu *rvu, struct rvu_block *block,
 {
 	u64 val;
 
-	if (block->type == BLKTYPE_TIM && is_rvu_96xx_A0(rvu))
-		return rvu_lf_lookup_tim_errata(rvu, block, pcifunc, slot);
+	if (block->type == BLKTYPE_TIM)
+		return rvu_tim_lookup_rsrc(rvu, block, pcifunc, slot);
 
 	val = ((u64)pcifunc << 24) | (slot << 16) | (1ULL << 13);
 	rvu_write64(rvu, block->addr, block->lookup_reg, val);
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu.h b/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
index e15f8bb311f9..ad0093e0a90f 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
@@ -474,6 +474,7 @@ static inline u64 rvupf_read64(struct rvu *rvu, u64 offset)
 	return readq(rvu->pfreg_base + offset);
 }
 
+/* Silicon revisions */
 static inline bool is_rvu_96xx_A0(struct rvu *rvu)
 {
 	struct pci_dev *pdev = rvu->pdev;
@@ -482,6 +483,14 @@ static inline bool is_rvu_96xx_A0(struct rvu *rvu)
 		(pdev->subsystem_device == PCI_SUBSYS_DEVID_96XX);
 }
 
+static inline bool is_rvu_96xx_B0(struct rvu *rvu)
+{
+	struct pci_dev *pdev = rvu->pdev;
+
+	return ((pdev->revision == 0x00) || (pdev->revision == 0x01)) &&
+		(pdev->subsystem_device == PCI_SUBSYS_DEVID_96XX);
+}
+
 static inline bool is_rvu_95xx_A0(struct rvu *rvu)
 {
 	struct pci_dev *pdev = rvu->pdev;
@@ -636,8 +645,6 @@ void rvu_cpt_unregister_interrupts(struct rvu *rvu);
 /* TIM APIs */
 int rvu_tim_init(struct rvu *rvu);
 int rvu_tim_lf_teardown(struct rvu *rvu, u16 pcifunc, int lf, int slot);
-int rvu_lf_lookup_tim_errata(struct rvu *rvu, struct rvu_block *block,
-		u16 pcifunc, int slot);
 
 /* CONFIG_DEBUG_FS*/
 #ifdef CONFIG_DEBUG_FS
@@ -649,6 +656,7 @@ static inline void rvu_dbg_exit(struct rvu *rvu) {}
 #endif /* CONFIG_DEBUG_FS*/
 
 /* HW workarounds/fixes */
+#include "npc.h"
 void rvu_nix_txsch_lock(struct nix_hw *nix_hw);
 void rvu_nix_txsch_unlock(struct nix_hw *nix_hw);
 void rvu_nix_update_link_credits(struct rvu *rvu, int blkaddr,
@@ -661,4 +669,9 @@ ssize_t rvu_nix_get_tx_stall_counters(struct rvu *rvu,
 				      char __user *buffer, loff_t *ppos);
 int rvu_nix_fixes_init(struct rvu *rvu, struct nix_hw *nix_hw, int blkaddr);
 void rvu_nix_fixes_exit(struct rvu *rvu, struct nix_hw *nix_hw);
+int rvu_tim_lookup_rsrc(struct rvu *rvu, struct rvu_block *block,
+			u16 pcifunc, int slot);
+int rvu_npc_get_tx_nibble_cfg(struct rvu *rvu, u64 nibble_ena);
+bool is_parse_nibble_config_valid(struct rvu *rvu,
+				  struct npc_mcam_kex *mcam_kex);
 #endif /* RVU_H */
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_fixes.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_fixes.c
index 36c747a45682..a27d7e5de5a0 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_fixes.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_fixes.c
@@ -898,19 +898,19 @@ int rvu_nix_fixes_init(struct rvu *rvu, struct nix_hw *nix_hw, int blkaddr)
 	int err;
 	u64 cfg;
 
-	if (!is_rvu_96xx_A0(rvu) && !is_rvu_95xx_A0(rvu))
+	if (!is_rvu_96xx_B0(rvu) && !is_rvu_95xx_A0(rvu))
 		return 0;
 
 	/* As per a HW errata in 96xx A0 silicon, NIX may corrupt
 	 * internal state when conditional clocks are turned off.
 	 * Hence enable them.
 	 */
-	if (is_rvu_95xx_A0(rvu))
+	if (is_rvu_96xx_A0(rvu))
 		rvu_write64(rvu, blkaddr, NIX_AF_CFG,
-			    rvu_read64(rvu, blkaddr, NIX_AF_CFG) | 0x40ULL);
+			    rvu_read64(rvu, blkaddr, NIX_AF_CFG) | 0x5EULL);
 	else
 		rvu_write64(rvu, blkaddr, NIX_AF_CFG,
-			    rvu_read64(rvu, blkaddr, NIX_AF_CFG) | 0x5EULL);
+			    rvu_read64(rvu, blkaddr, NIX_AF_CFG) | 0x40ULL);
 
 	/* Set chan/link to backpressure TL3 instead of TL2 */
 	rvu_write64(rvu, blkaddr, NIX_AF_PSE_CHANNEL_LEVEL, 0x01);
@@ -942,3 +942,68 @@ void rvu_nix_fixes_exit(struct rvu *rvu, struct nix_hw *nix_hw)
 
 	rvu_nix_tx_stall_workaround_exit(rvu, nix_hw);
 }
+
+int rvu_tim_lookup_rsrc(struct rvu *rvu, struct rvu_block *block,
+			u16 pcifunc, int slot)
+{
+	int lf, blkaddr;
+	u64 val;
+
+	/* Due to a HW issue LF_CFG_DEBUG register cannot be used to
+	 * find PF_FUNC <=> LF mapping, hence scan through LFX_CFG
+	 * registers to find mapped LF for a given PF_FUNC.
+	 */
+	if (is_rvu_96xx_B0(rvu)) {
+		blkaddr = rvu_get_blkaddr(rvu, BLKTYPE_TIM, pcifunc);
+		if (blkaddr < 0)
+			return TIM_AF_LF_INVALID;
+
+		for (lf = 0; lf < block->lf.max; lf++) {
+			val = rvu_read64(rvu, block->addr, block->lfcfg_reg |
+					 (lf << block->lfshift));
+			if ((((val >> 8) & 0xffff) == pcifunc) &&
+			    (val & 0xff) == slot)
+				return lf;
+		}
+		return -1;
+	}
+
+	val = ((u64)pcifunc << 24) | (slot << 16) | (1ULL << 13);
+	rvu_write64(rvu, block->addr, block->lookup_reg, val);
+
+	/* Wait for the lookup to finish */
+	while (rvu_read64(rvu, block->addr, block->lookup_reg) & (1ULL << 13))
+		;
+
+	val = rvu_read64(rvu, block->addr, block->lookup_reg);
+
+	/* Check LF valid bit */
+	if (!(val & (1ULL << 12)))
+		return -1;
+
+	return (val & 0xFFF);
+}
+
+int rvu_npc_get_tx_nibble_cfg(struct rvu *rvu, u64 nibble_ena)
+{
+	/* Due to a HW issue in these silicon versions, parse nibble enable
+	 * configuration has to be identical for both Rx and Tx interfaces.
+	 */
+	if (is_rvu_96xx_B0(rvu))
+		return nibble_ena;
+	return 0;
+}
+
+bool is_parse_nibble_config_valid(struct rvu *rvu,
+				  struct npc_mcam_kex *mcam_kex)
+{
+	if (!is_rvu_96xx_B0(rvu))
+		return true;
+
+	/* Due to a HW issue in above silicon versions, parse nibble enable
+	 * configuration has to be identical for both Rx and Tx interfaces.
+	 */
+	if (mcam_kex->keyx_cfg[NIX_INTF_RX] != mcam_kex->keyx_cfg[NIX_INTF_TX])
+		return false;
+	return true;
+}
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc.c
index adbb64286d41..2230f4a716fa 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc.c
@@ -1113,13 +1113,7 @@ static void npc_load_mkex_profile(struct rvu *rvu, int blkaddr)
 		/* Compare with mkex mod_param name string */
 		if (mcam_kex->mkex_sign == MKEX_SIGN &&
 		    !strncmp(mcam_kex->name, mkex_profile, MKEX_NAME_LEN)) {
-			/* Due to an errata (35786) in A0 pass silicon,
-			 * parse nibble enable configuration has to be
-			 * identical for both Rx and Tx interfaces.
-			 */
-			if (is_rvu_96xx_A0(rvu) &&
-			    mcam_kex->keyx_cfg[NIX_INTF_RX] !=
-			    mcam_kex->keyx_cfg[NIX_INTF_TX])
+			if (!is_parse_nibble_config_valid(rvu, mcam_kex))
 				goto load_default;
 
 			/* Program selected mkex profile */
@@ -1478,13 +1472,10 @@ int rvu_npc_init(struct rvu *rvu)
 	nibble_ena = 0x249207;
 	rvu_write64(rvu, blkaddr, NPC_AF_INTFX_KEX_CFG(NIX_INTF_RX),
 			((keyz & 0x3) << 32) | nibble_ena);
-	/* Due to an errata (35786) in A0 pass silicon, parse nibble enable
-	 * configuration has to be identical for both Rx and Tx interfaces.
-	 */
-	/* For A1 silicon onwards, no need to match the channel number for
-	 * Tx side, so match only Ltypes from LA...LE
-	 */
-	if (!is_rvu_96xx_A0(rvu))
+
+	/* Extract Ltypes LID_LA to LID_LE */
+	nibble_ena = rvu_npc_get_tx_nibble_cfg(rvu, nibble_ena);
+	if (!nibble_ena)
 		nibble_ena = 0x249200;
 	rvu_write64(rvu, blkaddr, NPC_AF_INTFX_KEX_CFG(NIX_INTF_TX),
 			((keyz & 0x3) << 32) | nibble_ena);
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_sso.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_sso.c
index b68137f015b2..663fb2ce2865 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_sso.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_sso.c
@@ -377,7 +377,7 @@ int rvu_sso_lf_teardown(struct rvu *rvu, u16 pcifunc, int lf, int slot)
 	 * TAQ buffer used by HWGRP when HWGRP is reset. Use SW routine to
 	 * drain it manually.
 	 */
-	if (is_rvu_96xx_A0(rvu))
+	if (is_rvu_96xx_B0(rvu))
 		rvu_sso_ggrp_taq_flush(rvu, pcifunc, lf, slot, ssow_lf, blkaddr,
 				       ssow_blkaddr);
 
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_tim.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_tim.c
index 3f07334c49b2..5c7e219c6656 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_tim.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_tim.c
@@ -58,27 +58,6 @@ static int rvu_tim_disable_lf(struct rvu *rvu, int lf, int blkaddr)
 	return 0;
 }
 
-int rvu_lf_lookup_tim_errata(struct rvu *rvu, struct rvu_block *block,
-		u16 pcifunc, int slot)
-{
-	int i, blkaddr;
-	u64 val;
-
-	blkaddr = rvu_get_blkaddr(rvu, BLKTYPE_TIM, pcifunc);
-	if (blkaddr < 0)
-		return TIM_AF_LF_INVALID;
-
-	for (i = 0; i < block->lf.max; i++) {
-		val = rvu_read64(rvu, block->addr, block->lfcfg_reg |
-				 (i << block->lfshift));
-		if ((((val >> 8) & 0xffff) == pcifunc) &&
-				(val & 0xff) == slot)
-			return i;
-	}
-
-	return -1;
-}
-
 int rvu_mbox_handler_tim_lf_alloc(struct rvu *rvu,
 				  struct tim_lf_alloc_req *req,
 				  struct tim_lf_alloc_rsp *rsp)
-- 
2.31.1

