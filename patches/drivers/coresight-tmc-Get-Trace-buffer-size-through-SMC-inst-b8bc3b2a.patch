From 11e24a5254eb6762adaaf2bb526e6235d5ff1ad6 Mon Sep 17 00:00:00 2001
From: Linu Cherian <lcherian@marvell.com>
Date: Wed, 22 Jan 2020 11:55:57 +0530
Subject: [PATCH 0674/1921] coresight: tmc: Get Trace buffer size through SMC
 instead of dts

With firmware now supporting, larger and configurable trace buffer
size, its easier and cleaner to keep all secure tracebuffer management
hooks through SMC calls.

- Trace buffer size is now obtained through newly introduced SMC call
  instead of dts node attribute.
- With possibility of larger trace buffer, cache locking is disabled by
  default.
- Trace buffer size for each ETR can be read using,
 /sys/bus/coresight/devices/XXX.etrX/tracebuffer_size

Change-Id: I7dfd5c7a4ff2fda73c616ac086220f22e9defdc6
Signed-off-by: Linu Cherian <lcherian@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/22252
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/32249
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 drivers/hwtracing/coresight/coresight-tmc.c | 33 ++++++++++++++++++++-
 drivers/hwtracing/coresight/coresight-tmc.h | 18 +++++++++++
 2 files changed, 50 insertions(+), 1 deletion(-)

diff --git a/drivers/hwtracing/coresight/coresight-tmc.c b/drivers/hwtracing/coresight/coresight-tmc.c
index 99e622321d19..acd45df61dcb 100644
--- a/drivers/hwtracing/coresight/coresight-tmc.c
+++ b/drivers/hwtracing/coresight/coresight-tmc.c
@@ -360,9 +360,27 @@ static ssize_t buffer_size_store(struct device *dev,
 
 static DEVICE_ATTR_RW(buffer_size);
 
+static ssize_t tracebuffer_size_store(struct device *dev,
+			     struct device_attribute *attr,
+			     const char *buf, size_t size)
+{
+	return -EINVAL;
+}
+
+static ssize_t tracebuffer_size_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct tmc_drvdata *drvdata = dev_get_drvdata(dev->parent);
+	unsigned long val = drvdata->size;
+
+	return sprintf(buf, "%#lx\n", val);
+}
+static DEVICE_ATTR_RW(tracebuffer_size);
+
 static struct attribute *coresight_tmc_attrs[] = {
 	&dev_attr_trigger_cntr.attr,
 	&dev_attr_buffer_size.attr,
+	&dev_attr_tracebuffer_size.attr,
 	NULL,
 };
 
@@ -496,11 +514,24 @@ static int tmc_probe(struct amba_device *adev, const struct amba_id *id)
 	drvdata->pid = -1;
 
 	if (drvdata->config_type == TMC_CONFIG_TYPE_ETR) {
-		drvdata->size = tmc_etr_get_default_buffer_size(dev);
+		if (drvdata->etr_options & CSETR_QUIRK_SECURE_BUFF) {
+			if (tmc_get_cpu_tracebufsize(drvdata, &drvdata->size) ||
+			    !drvdata->size) {
+				dev_info(&drvdata->csdev->dev,
+					 "Secure tracebuffer not available\n");
+				ret = -ENOMEM;
+				goto out;
+			}
+		} else  {
+			drvdata->size = tmc_etr_get_default_buffer_size(dev);
+		}
+
 		if (dev->fwnode)
 			drvdata->cache_lock_en =
 				fwnode_property_read_bool(dev->fwnode,
 							       "cache-lock");
+		/* Keep cache lock disabled by default */
+		drvdata->cache_lock_en = false;
 	} else
 		drvdata->size = readl_relaxed(drvdata->base + TMC_RSZ) * 4;
 
diff --git a/drivers/hwtracing/coresight/coresight-tmc.h b/drivers/hwtracing/coresight/coresight-tmc.h
index faeaffd0e946..a8b5f6337504 100644
--- a/drivers/hwtracing/coresight/coresight-tmc.h
+++ b/drivers/hwtracing/coresight/coresight-tmc.h
@@ -152,6 +152,10 @@ enum tmc_mem_intf_width {
 #define OCTEONTX_TRC_FREE_SBUF		0xc2000c08
 /* Args: x1 - non secure buffer address, x2 - size */
 #define OCTEONTX_TRC_UNREGISTER_DRVBUF	0xc2000c09
+/* Args: Nil
+ * Returns: cpu trace buffer size
+ */
+#define OCTEONTX_TRC_GET_CPU_BUFSIZE    0xc2000c0a
 
 enum etr_mode {
 	ETR_MODE_FLAT,		/* Uses contiguous flat buffer */
@@ -366,6 +370,20 @@ static inline bool tmc_etr_has_cap(struct tmc_drvdata *drvdata, u32 cap)
 	return !!(drvdata->etr_caps & cap);
 }
 
+static inline int tmc_get_cpu_tracebufsize(struct tmc_drvdata *drvdata,
+					  u32 *len)
+{
+	struct arm_smccc_res res;
+
+	arm_smccc_smc(OCTEONTX_TRC_GET_CPU_BUFSIZE, 0, 0, 0,
+		      0, 0, 0, 0, &res);
+	if (res.a0 != SMCCC_RET_SUCCESS)
+		return -EFAULT;
+
+	*len = (u32)res.a1;
+	return 0;
+}
+
 struct tmc_sg_table *tmc_alloc_sg_table(struct device *dev,
 					int node,
 					int nr_tpages,
-- 
2.31.1

