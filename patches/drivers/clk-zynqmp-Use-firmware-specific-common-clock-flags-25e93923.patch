From 44d16dfd6fbb98e00d315716efa78d0d5bc2adc4 Mon Sep 17 00:00:00 2001
From: Rajan Vaja <rajan.vaja@xilinx.com>
Date: Mon, 15 Jun 2020 06:25:34 -0700
Subject: [PATCH 1386/1851] clk: zynqmp: Use firmware specific common clock
 flags

commit 65f5ad695338eaab0567492ccd436e7e0124f061 from
https://github.com/Xilinx/linux-xlnx.git

Currently firmware passes CCF specific flags to ZynqMP clock driver.
So firmware needs to be updated if CCF flags are changed. The firmware
should have its own 'flag number space' that is distinct from the
common clk framework's 'flag number space'. So define and use ZynqMP
specific common clock flags instead of using CCF flags.

Signed-off-by: Rajan Vaja <rajan.vaja@xilinx.com>
Reviewed-by: Jolly Shah <jolly.shah@xilinx.com>
State: pending
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 drivers/clk/zynqmp/clk-zynqmp.h | 22 ++++++++++++++++++++++
 drivers/clk/zynqmp/clkc.c       | 23 +++++++++++++++++++++--
 2 files changed, 43 insertions(+), 2 deletions(-)

diff --git a/drivers/clk/zynqmp/clk-zynqmp.h b/drivers/clk/zynqmp/clk-zynqmp.h
index 143d73d6badc..a5d183bdec0e 100644
--- a/drivers/clk/zynqmp/clk-zynqmp.h
+++ b/drivers/clk/zynqmp/clk-zynqmp.h
@@ -10,6 +10,28 @@
 
 #include <linux/firmware/xlnx-zynqmp.h>
 
+/* Common Flags */
+/* must be gated across rate change */
+#define ZYNQMP_CLK_SET_RATE_GATE	BIT(0)
+/* must be gated across re-parent */
+#define ZYNQMP_CLK_SET_PARENT_GATE	BIT(1)
+/* propagate rate change up one level */
+#define ZYNQMP_CLK_SET_RATE_PARENT	BIT(2)
+/* do not gate even if unused */
+#define ZYNQMP_CLK_IGNORE_UNUSED	BIT(3)
+/* do not use the cached clk rate */
+#define ZYNQMP_CLK_GET_RATE_NOCACHE	BIT(6)
+/* don't re-parent on rate change */
+#define ZYNQMP_CLK_SET_RATE_NO_REPARENT	BIT(7)
+/* do not use the cached clk accuracy */
+#define ZYNQMP_CLK_GET_ACCURACY_NOCACHE	BIT(8)
+/* recalc rates after notifications */
+#define ZYNQMP_CLK_RECALC_NEW_RATES	BIT(9)
+/* clock needs to run to set rate */
+#define ZYNQMP_CLK_SET_RATE_UNGATE	BIT(10)
+/* do not gate, ever */
+#define ZYNQMP_CLK_IS_CRITICAL		BIT(11)
+
 enum topology_type {
 	TYPE_INVALID,
 	TYPE_MUX,
diff --git a/drivers/clk/zynqmp/clkc.c b/drivers/clk/zynqmp/clkc.c
index 51b830225860..aa6d1a29a42e 100644
--- a/drivers/clk/zynqmp/clkc.c
+++ b/drivers/clk/zynqmp/clkc.c
@@ -386,14 +386,33 @@ static int __zynqmp_clock_get_topology(struct clock_topology *topology,
 {
 	int i;
 	u32 type;
+	u32 flag;
 
 	for (i = 0; i < ARRAY_SIZE(response->topology); i++) {
 		type = FIELD_GET(CLK_TOPOLOGY_TYPE, response->topology[i]);
 		if (type == TYPE_INVALID)
 			return END_OF_TOPOLOGY_NODE;
 		topology[*nnodes].type = type;
-		topology[*nnodes].flag = FIELD_GET(CLK_TOPOLOGY_FLAGS,
-						   response->topology[i]);
+		flag = FIELD_GET(CLK_TOPOLOGY_FLAGS, response->topology[i]);
+		topology[*nnodes].flag = 0;
+		topology[*nnodes].flag |= (flag & ZYNQMP_CLK_SET_RATE_PARENT) ?
+					   CLK_SET_RATE_PARENT : 0;
+		topology[*nnodes].flag |= (flag & ZYNQMP_CLK_IGNORE_UNUSED) ?
+					  CLK_IGNORE_UNUSED : 0;
+		topology[*nnodes].flag |= (flag & ZYNQMP_CLK_GET_RATE_NOCACHE) ?
+					  CLK_GET_RATE_NOCACHE : 0;
+		topology[*nnodes].flag |= (flag &
+					   ZYNQMP_CLK_SET_RATE_NO_REPARENT) ?
+					   CLK_SET_RATE_NO_REPARENT : 0;
+		topology[*nnodes].flag |= (flag &
+					   ZYNQMP_CLK_GET_ACCURACY_NOCACHE) ?
+					   CLK_GET_ACCURACY_NOCACHE : 0;
+		topology[*nnodes].flag |= (flag & ZYNQMP_CLK_RECALC_NEW_RATES) ?
+					  CLK_RECALC_NEW_RATES : 0;
+		topology[*nnodes].flag |= (flag & ZYNQMP_CLK_SET_RATE_UNGATE) ?
+					  CLK_SET_RATE_UNGATE : 0;
+		topology[*nnodes].flag |= (flag & ZYNQMP_CLK_IS_CRITICAL) ?
+					  CLK_IS_CRITICAL : 0;
 		topology[*nnodes].type_flag =
 				FIELD_GET(CLK_TOPOLOGY_TYPE_FLAGS,
 					  response->topology[i]);
-- 
2.31.1

