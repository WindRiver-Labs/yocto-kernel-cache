From a94e38ff887a615f717f59ebff89f8bf572c533d Mon Sep 17 00:00:00 2001
From: Bharat Kumar Gogada <bharat.kumar.gogada@xilinx.com>
Date: Mon, 13 Jan 2020 15:26:36 +0530
Subject: [PATCH 0840/1851] pci: xdma: pl: Fix Multi MSI data

commit 4b6d1658115370f877013569b6d25f1449b9843f from
https://github.com/Xilinx/linux-xlnx.git

The current XDMA MSI allocation code allows a bitmap allocation
that is not a power of two boundaries, resulting in a broken
Multi MSI implementation.

Update the code to allocate MSI bitmap ranges with a power of two
alignment.

Signed-off-by: Bharat Kumar Gogada <bharat.kumar.gogada@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
State: not-upstreamable
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 drivers/pci/controller/pcie-xdma-pl.c | 19 +++++--------------
 1 file changed, 5 insertions(+), 14 deletions(-)

diff --git a/drivers/pci/controller/pcie-xdma-pl.c b/drivers/pci/controller/pcie-xdma-pl.c
index 8ef3c3ae2702..1005df802fd3 100644
--- a/drivers/pci/controller/pcie-xdma-pl.c
+++ b/drivers/pci/controller/pcie-xdma-pl.c
@@ -480,23 +480,13 @@ static int xilinx_irq_domain_alloc(struct irq_domain *domain, unsigned int virq,
 	int i;
 
 	mutex_lock(&msi->lock);
-	bit = bitmap_find_next_zero_area(msi->bitmap, XILINX_NUM_MSI_IRQS, 0,
-					 nr_irqs, 0);
-	if (bit >= XILINX_NUM_MSI_IRQS) {
+	bit = bitmap_find_free_region(msi->bitmap, XILINX_NUM_MSI_IRQS,
+				      get_count_order(nr_irqs));
+	if (bit < 0) {
 		mutex_unlock(&msi->lock);
 		return -ENOSPC;
 	}
 
-	if ((bit % nr_irqs) == 0) {
-		bit = bit;
-	} else if (nr_irqs > 1) {
-		tst_bit = bit & ((1 << ilog2(nr_irqs)) - 1);
-		bit = bit - tst_bit;
-		bit = bit + nr_irqs;
-	}
-
-	bitmap_set(msi->bitmap, bit, nr_irqs);
-
 	for (i = 0; i < nr_irqs; i++) {
 		irq_domain_set_info(domain, virq + i, bit + i, &xilinx_irq_chip,
 				    domain->host_data, handle_simple_irq,
@@ -514,7 +504,8 @@ static void xilinx_irq_domain_free(struct irq_domain *domain, unsigned int virq,
 	struct xilinx_msi *msi = &pcie->msi;
 
 	mutex_lock(&msi->lock);
-	bitmap_clear(msi->bitmap, data->hwirq, nr_irqs);
+	bitmap_release_region(msi->bitmap, data->hwirq,
+			      get_count_order(nr_irqs));
 	mutex_unlock(&msi->lock);
 }
 
-- 
2.31.1

