From 15c1672a1ad3bea85fb2a19f38e6cb075cbcfd91 Mon Sep 17 00:00:00 2001
From: Subbaraya Sundeep <sbhatta@marvell.com>
Date: Fri, 11 Dec 2020 14:12:53 +0530
Subject: [PATCH 0952/1921] octeontx2-af: Check for no CGX devices

It is possible that there are no CGX devices
in the system. This patch ensures that code
is checked for no CGX devices wherever required.

Change-Id: I5ac7d0a4cb6077c29c3aef1c83fb175601a08f08
Signed-off-by: Subbaraya Sundeep <sbhatta@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/42226
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 drivers/net/ethernet/marvell/octeontx2/af/cgx.c        |  3 +++
 drivers/net/ethernet/marvell/octeontx2/af/rvu_cgx.c    |  5 ++++-
 .../net/ethernet/marvell/octeontx2/af/rvu_debugfs.c    | 10 ++++++++++
 3 files changed, 17 insertions(+), 1 deletion(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/af/cgx.c b/drivers/net/ethernet/marvell/octeontx2/af/cgx.c
index 9f46fd8b68e3..e3188956bf4a 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/cgx.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/cgx.c
@@ -117,6 +117,9 @@ static int get_sequence_id_of_lmac(struct cgx *cgx, int lmac_id)
 
 struct cgx_mac_ops *cgx_get_mac_ops(void *cgxd)
 {
+	if (!cgxd)
+		return cgxd;
+
 	return ((struct cgx *)cgxd)->mac_ops;
 }
 
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_cgx.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_cgx.c
index 937167a3b8d8..da7983316edc 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_cgx.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_cgx.c
@@ -1181,9 +1181,12 @@ u32 rvu_cgx_get_fifolen(struct rvu *rvu)
 {
 	struct cgx_mac_ops *mac_ops;
 	int rvu_def_cgx_id = 0;
+	u32 fifo_len;
 
 	mac_ops = cgx_get_mac_ops(rvu_cgx_pdata(rvu_def_cgx_id, rvu));
-	return mac_ops->fifo_len;
+	fifo_len = mac_ops ? mac_ops->fifo_len : 0;
+
+	return fifo_len;
 }
 
 int rvu_mbox_handler_cgx_stats(struct rvu *rvu, struct msg_req *req,
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_debugfs.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_debugfs.c
index c22c0f069cf5..e0c5992dada0 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_debugfs.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_debugfs.c
@@ -1038,6 +1038,9 @@ static int cgx_print_stats(struct seq_file *s, int lmac_id)
 		return -ENODEV;
 
 	mac_ops = cgx_get_mac_ops(cgxd);
+	/* There can be no CGX devices at all */
+	if (!mac_ops)
+		return 0;
 
 	/* Link status */
 	seq_puts(s, "\n=======Link Status======\n\n");
@@ -2209,6 +2212,9 @@ static void rvu_dbg_cgx_init(struct rvu *rvu)
 		return;
 
 	mac_ops = cgx_get_mac_ops(rvu_cgx_pdata(rvu_def_cgx_id, rvu));
+	/* There can be no CGX devices at all */
+	if (!mac_ops)
+		return;
 	rvu->rvu_dbg.cgx_root = debugfs_create_dir(mac_ops->name,
 						   rvu->rvu_dbg.root);
 
@@ -3363,6 +3369,9 @@ void rvu_dbg_init(struct rvu *rvu)
 	if (!pfile)
 		goto create_failed;
 
+	if (!cgx_get_cgxcnt_max())
+		goto create;
+
 	if (is_rvu_otx2(rvu))
 		pfile = debugfs_create_file("rvu_pf_cgx_map", 0444, rvu->rvu_dbg.root,
 					    rvu, &rvu_dbg_rvu_pf_cgx_map_fops);
@@ -3372,6 +3381,7 @@ void rvu_dbg_init(struct rvu *rvu)
 	if (!pfile)
 		goto create_failed;
 
+create:
 	rvu_dbg_npa_init(rvu);
 	rvu_dbg_cgx_init(rvu);
 	rvu_dbg_nix_init(rvu, BLKADDR_NIX0);
-- 
2.31.1

