From be86dc685813823f81bb0526e22dcd480cd74caa Mon Sep 17 00:00:00 2001
From: Felix Manlunas <fmanlunas@marvell.com>
Date: Sat, 16 Nov 2019 14:03:50 -0800
Subject: [PATCH 410/767] octeontx2-af: Add new CGX_CMD to get PHY FEC
 statistics

commit b1b525868f846e2599dd96ac881d8e483d162c0d from
git@git.assembla.com:cavium/WindRiver.linux.git

The stats are put in the shared data struct fwdata.  A PHY driver indicates
that it has FEC stats by setting the flag fwdata.phy.misc.has_fec_stats
(for now, only the LIO3 card's 6141 PHY does this; all other PHYs clear
that flag).

On LIO3, FEC can be enabled at the PHY line-side only, never at the PHY
host-side.  So for LIO3, the ethtool FEC stats come from the PHY (not from
CGX).

Besides CGX_CMD_GET_PHY_FEC_STATS, also add CGX_CMD_PRBS and
CGX_CMD_DISPLAY_EYE to enum cgx_cmd_id so that Linux's enum list is in sync
with ATF's enum list.

Change-Id: Ib0cb8e9315b88e3c3f1ddd16cae709f8837d4f1d
Signed-off-by: Felix Manlunas <fmanlunas@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/18814
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Tested-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../net/ethernet/marvell/octeontx2/af/cgx.c   | 12 ++++
 .../net/ethernet/marvell/octeontx2/af/cgx.h   |  1 +
 .../ethernet/marvell/octeontx2/af/cgx_fw_if.h |  3 +
 .../net/ethernet/marvell/octeontx2/af/mbox.h  | 16 ++++-
 .../ethernet/marvell/octeontx2/af/rvu_cgx.c   | 10 ++++
 .../marvell/octeontx2/nic/otx2_ethtool.c      | 60 ++++++++++++++++---
 6 files changed, 92 insertions(+), 10 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/af/cgx.c b/drivers/net/ethernet/marvell/octeontx2/af/cgx.c
index 5518e81a91e8..0a1f54de40ce 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/cgx.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/cgx.c
@@ -1161,6 +1161,18 @@ int cgx_get_phy_mod_type(void *cgxd, int lmac_id)
 	return err;
 }
 
+int cgx_get_phy_fec_stats(void *cgxd, int lmac_id)
+{
+	struct cgx *cgx = cgxd;
+	u64 req = 0, resp;
+
+	if (!cgx)
+		return -ENODEV;
+
+	req = FIELD_SET(CMDREG_ID, CGX_CMD_GET_PHY_FEC_STATS, req);
+	return cgx_fwi_cmd_generic(req, &resp, cgx, lmac_id);
+}
+
 int cgx_set_link_mode(void *cgxd, struct cgx_set_link_mode_args args,
 		      int cgx_id, int lmac_id)
 {
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/cgx.h b/drivers/net/ethernet/marvell/octeontx2/af/cgx.h
index e9b6102bfef7..4daba85f836a 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/cgx.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/cgx.h
@@ -162,4 +162,5 @@ void cgx_lmac_ptp_config(void *cgxd, int lmac_id, bool enable);
 int cgx_set_link_state(void *cgxd, int lmac_id, bool enable);
 int cgx_set_phy_mod_type(int mod, void *cgxd, int lmac_id);
 int cgx_get_phy_mod_type(void *cgxd, int lmac_id);
+int cgx_get_phy_fec_stats(void *cgxd, int lmac_id);
 #endif /* CGX_H */
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/cgx_fw_if.h b/drivers/net/ethernet/marvell/octeontx2/af/cgx_fw_if.h
index 1dc3059c9e0d..37a20d66246b 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/cgx_fw_if.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/cgx_fw_if.h
@@ -129,6 +129,9 @@ enum cgx_cmd_id {
 	CGX_CMD_GET_ADV_FEC,
 	CGX_CMD_GET_PHY_MOD_TYPE, /* line-side modulation type: NRZ or PAM4 */
 	CGX_CMD_SET_PHY_MOD_TYPE,
+	CGX_CMD_PRBS,
+	CGX_CMD_DISPLAY_EYE,
+	CGX_CMD_GET_PHY_FEC_STATS,
 };
 
 /* async event ids */
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/mbox.h b/drivers/net/ethernet/marvell/octeontx2/af/mbox.h
index 950ba1774ba7..8354572fa132 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/mbox.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/mbox.h
@@ -167,6 +167,7 @@ M(CGX_SET_PHY_MOD_TYPE, 0x216, cgx_set_phy_mod_type, cgx_phy_mod_type,	\
 M(CGX_FEC_STATS,	0x217, cgx_fec_stats, msg_req, cgx_fec_stats_rsp) \
 M(CGX_SET_LINK_MODE,	0x218, cgx_set_link_mode, cgx_set_link_mode_req,\
 			       cgx_set_link_mode_rsp)	\
+M(CGX_GET_PHY_FEC_STATS, 0x219, cgx_get_phy_fec_stats, msg_req, msg_rsp) \
 /* NPA mbox IDs (range 0x400 - 0x5FF) */				\
 M(NPA_LF_ALLOC,		0x400, npa_lf_alloc,				\
 				npa_lf_alloc_req, npa_lf_alloc_rsp)	\
@@ -498,8 +499,17 @@ enum fec_type {
 };
 
 struct phy_s {
-	u64 can_change_mod_type : 1;
-	u64 mod_type            : 1;
+	struct {
+		u64 can_change_mod_type : 1;
+		u64 mod_type            : 1;
+		u64 has_fec_stats       : 1;
+	} misc;
+	struct fec_stats_s {
+		u32 rsfec_corr_cws;
+		u32 rsfec_uncorr_cws;
+		u32 brfec_corr_blks;
+		u32 brfec_uncorr_blks;
+	} fec_stats;
 };
 
 struct cgx_lmac_fwdata_s {
@@ -513,7 +523,7 @@ struct cgx_lmac_fwdata_s {
 	/* Only applicable if SFP/QSFP slot is present */
 	struct sfp_eeprom_s sfp_eeprom;
 	struct phy_s phy;
-#define LMAC_FWDATA_RESERVED_MEM 1023
+#define LMAC_FWDATA_RESERVED_MEM 1021
 	u64 reserved[LMAC_FWDATA_RESERVED_MEM];
 };
 
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_cgx.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_cgx.c
index e7f2a5678d57..145329cf5eaf 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_cgx.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_cgx.c
@@ -906,6 +906,16 @@ int rvu_mbox_handler_cgx_get_phy_mod_type(struct rvu *rvu, struct msg_req *req,
 	return 0;
 }
 
+int rvu_mbox_handler_cgx_get_phy_fec_stats(struct rvu *rvu, struct msg_req *req,
+					   struct msg_rsp *rsp)
+{
+	int pf = rvu_get_pf(req->hdr.pcifunc);
+	u8 cgx_id, lmac_id;
+
+	rvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_id, &lmac_id);
+	return cgx_get_phy_fec_stats(rvu_cgx_pdata(cgx_id, rvu), lmac_id);
+}
+
 /* Finds cumulative status of NIX rx/tx counters from LF of a PF and those
  * from its VFs as well. ie. NIX rx/tx counters at the CGX port level
  */
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_ethtool.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_ethtool.c
index 8f804effb352..e2cb70a79dbe 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_ethtool.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_ethtool.c
@@ -25,6 +25,8 @@
 
 #define OTX2_DEFAULT_ACTION	0x1
 
+static struct cgx_fw_data *otx2_get_fwdata(struct otx2_nic *pfvf);
+
 static const char otx2_priv_flags_strings[][ETH_GSTRING_LEN] = {
 	"pam4",
 	"edsa",
@@ -222,11 +224,30 @@ static void otx2_get_qset_stats(struct otx2_nic *pfvf,
 	}
 }
 
+static int otx2_get_phy_fec_stats(struct otx2_nic *pfvf)
+{
+	struct msg_req *req;
+	int rc = -EAGAIN;
+
+	otx2_mbox_lock(&pfvf->mbox);
+	req = otx2_mbox_alloc_msg_cgx_get_phy_fec_stats(&pfvf->mbox);
+	if (!req)
+		goto end;
+
+	if (!otx2_sync_mbox_msg(&pfvf->mbox))
+		rc = 0;
+end:
+	otx2_mbox_unlock(&pfvf->mbox);
+	return rc;
+}
+
 /* Get device and per queue statistics */
 static void otx2_get_ethtool_stats(struct net_device *netdev,
 				   struct ethtool_stats *stats, u64 *data)
 {
 	struct otx2_nic *pfvf = netdev_priv(netdev);
+	u64 fec_corr_blks, fec_uncorr_blks;
+	struct cgx_fw_data *rsp;
 	int stat;
 
 	otx2_get_dev_stats(pfvf);
@@ -245,10 +266,35 @@ static void otx2_get_ethtool_stats(struct net_device *netdev,
 	for (stat = 0; stat < CGX_TX_STATS_COUNT; stat++)
 		*(data++) = pfvf->hw.cgx_tx_stats[stat];
 	*(data++) = pfvf->reset_count;
-	if (pfvf->linfo.fec) {
-		*(data++) = pfvf->hw.cgx_fec_corr_blks;
-		*(data++) = pfvf->hw.cgx_fec_uncorr_blks;
+
+	if (pfvf->linfo.fec == OTX2_FEC_NONE)
+		return;
+
+	fec_corr_blks = pfvf->hw.cgx_fec_corr_blks;
+	fec_uncorr_blks = pfvf->hw.cgx_fec_uncorr_blks;
+
+	rsp = otx2_get_fwdata(pfvf);
+	if (!IS_ERR(rsp) && rsp->fwdata.phy.misc.has_fec_stats &&
+	    !otx2_get_phy_fec_stats(pfvf)) {
+		/* Fetch fwdata again because it's been recently populated with
+		 * latest PHY FEC stats.
+		 */
+		rsp = otx2_get_fwdata(pfvf);
+		if (!IS_ERR(rsp)) {
+			struct fec_stats_s *p = &rsp->fwdata.phy.fec_stats;
+
+			if (pfvf->linfo.fec == OTX2_FEC_BASER) {
+				fec_corr_blks   = p->brfec_corr_blks;
+				fec_uncorr_blks = p->brfec_uncorr_blks;
+			} else {
+				fec_corr_blks   = p->rsfec_corr_cws;
+				fec_uncorr_blks = p->rsfec_uncorr_cws;
+			}
+		}
 	}
+
+	*(data++) = fec_corr_blks;
+	*(data++) = fec_uncorr_blks;
 }
 
 static int otx2_get_sset_count(struct net_device *netdev, int sset)
@@ -267,12 +313,12 @@ static int otx2_get_sset_count(struct net_device *netdev, int sset)
 		       (pfvf->hw.rx_queues + pfvf->hw.tx_queues);
 
 	if (!if_up || !pfvf->linfo.fec) {
-		return otx2_n_dev_stats + qstats_count +
+		return otx2_n_dev_stats + otx2_n_drv_stats + qstats_count +
 			CGX_RX_STATS_COUNT + CGX_TX_STATS_COUNT + 1;
 	}
 	fec_stats_count = 2;
 	otx2_update_lmac_fec_stats(pfvf);
-	return otx2_n_dev_stats + qstats_count +
+	return otx2_n_dev_stats + otx2_n_drv_stats + qstats_count +
 		CGX_RX_STATS_COUNT + CGX_TX_STATS_COUNT + 1 +
 		fec_stats_count;
 }
@@ -1227,7 +1273,7 @@ static u32 otx2_get_priv_flags(struct net_device *netdev)
 	if (IS_ERR(rsp)) {
 		pfvf->ethtool_flags &= ~OTX2_PRIV_FLAG_PAM4;
 	} else {
-		if (rsp->fwdata.phy.mod_type)
+		if (rsp->fwdata.phy.misc.mod_type)
 			pfvf->ethtool_flags |= OTX2_PRIV_FLAG_PAM4;
 		else
 			pfvf->ethtool_flags &= ~OTX2_PRIV_FLAG_PAM4;
@@ -1248,7 +1294,7 @@ static int otx2_set_phy_mod_type(struct net_device *netdev, bool enable)
 		return -EAGAIN;
 
 	/* ret here if phy does not support this feature */
-	if (!fwd->fwdata.phy.can_change_mod_type)
+	if (!fwd->fwdata.phy.misc.can_change_mod_type)
 		return -EOPNOTSUPP;
 
 	otx2_mbox_lock(&pfvf->mbox);
-- 
2.31.1

