From c35b2ef31e0e2fe0aacee6cde4351a978abc3e42 Mon Sep 17 00:00:00 2001
From: Vishal Sagar <vishal.sagar@xilinx.com>
Date: Fri, 21 Sep 2018 15:53:52 +0530
Subject: [PATCH 0426/1852] v4l: xilinx-vpss-csc: Add check for max width and
 height

commit 3cb23f7a129c0a30cf4f9552d4cb5ccb447b56a8 from
https://github.com/Xilinx/linux-xlnx.git

Patch adds support to get maximum width and height from dt property.
If the parameters are not present then the IP sets the max size of
8192x4320. It then uses this value to clamp width and height instead
of fixed default value while setting format.

It also corrects the minimum width and height parameters.

Signed-off-by: Vishal Sagar <vishal.sagar@xilinx.com>
Reviewed-by: Hyun Kwon <hyun.kwon@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
State: pending
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 .../media/platform/xilinx/xilinx-vpss-csc.c   | 32 +++++++++++++++++++
 1 file changed, 32 insertions(+)

diff --git a/drivers/media/platform/xilinx/xilinx-vpss-csc.c b/drivers/media/platform/xilinx/xilinx-vpss-csc.c
index b8a18f429f19..fd0eedad53ee 100644
--- a/drivers/media/platform/xilinx/xilinx-vpss-csc.c
+++ b/drivers/media/platform/xilinx/xilinx-vpss-csc.c
@@ -49,6 +49,11 @@
 #define XV_CSC_DEFAULT_WIDTH	(1280)
 #define XV_CSC_K_MAX_ROWS	(3)
 #define XV_CSC_K_MAX_COLUMNS	(3)
+#define XV_CSC_MIN_WIDTH	(64)
+#define XV_CSC_MAX_WIDTH	(8192)
+#define XV_CSC_MIN_HEIGHT	(64)
+#define XV_CSC_MAX_HEIGHT	(4320)
+
 /* GPIO Reset Assert/De-assert */
 #define XCSC_RESET_ASSERT	(1)
 #define XCSC_RESET_DEASSERT	(0)
@@ -157,6 +162,8 @@ rgb_to_ycrcb_unity[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1] = {
  * @shadow_coeff: Coefficients to track RGB equivalents for color controls
  * @clip_max: Maximum value to clip output color range
  * @rst_gpio: Handle to PS GPIO specifier to assert/de-assert the reset line
+ * @max_width: Maximum width supported by IP.
+ * @max_height: Maximum height supported by IP.
  */
 struct xcsc_dev {
 	struct xvip_device xvip;
@@ -185,6 +192,8 @@ struct xcsc_dev {
 	s32 shadow_coeff[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1];
 	s32 clip_max;
 	struct gpio_desc *rst_gpio;
+	u32 max_width;
+	u32 max_height;
 };
 
 #ifdef DEBUG
@@ -762,6 +771,11 @@ static int xcsc_set_format(struct v4l2_subdev *subdev,
 					    XVIP_PAD_SOURCE, fmt->which);
 	*__format = fmt->format;
 
+	__format->width = clamp_t(unsigned int, fmt->format.width,
+				  XV_CSC_MIN_WIDTH, xcsc->max_width);
+	__format->height = clamp_t(unsigned int, fmt->format.height,
+				   XV_CSC_MIN_HEIGHT, xcsc->max_height);
+
 	switch (__format->code) {
 	case MEDIA_BUS_FMT_VUY8_1X24:
 	case MEDIA_BUS_FMT_RBG888_1X24:
@@ -941,6 +955,24 @@ static int xcsc_parse_of(struct xcsc_dev *xcsc)
 	u32 port_id = 0;
 	u32 video_width[2];
 
+	rval = of_property_read_u32(node, "xlnx,max-height", &xcsc->max_height);
+	if (rval < 0) {
+		xcsc->max_height = XV_CSC_MAX_HEIGHT;
+	} else if (xcsc->max_height > XV_CSC_MAX_HEIGHT ||
+		   xcsc->max_height < XV_CSC_MIN_HEIGHT) {
+		dev_err(dev, "Invalid height in dt");
+		return -EINVAL;
+	}
+
+	rval = of_property_read_u32(node, "xlnx,max-width", &xcsc->max_width);
+	if (rval < 0) {
+		xcsc->max_width = XV_CSC_MAX_WIDTH;
+	} else if (xcsc->max_width > XV_CSC_MAX_WIDTH ||
+		   xcsc->max_width < XV_CSC_MIN_WIDTH) {
+		dev_err(dev, "Invalid width in dt");
+		return -EINVAL;
+	}
+
 	ports = of_get_child_by_name(node, "ports");
 	if (!ports)
 		ports = node;
-- 
2.31.1

