From 49a8020911d286d8f51752608c95b9991fbd4af6 Mon Sep 17 00:00:00 2001
From: Paul Thomas <pthomas8589@gmail.com>
Date: Tue, 23 Jun 2020 14:49:37 -0400
Subject: [PATCH 1419/1852] clk: clock-wizard: Refactor internal clocks

commit ef5cc7cc6f105a2cb8a1aee510594f417f91971c from
https://github.com/Xilinx/linux-xlnx.git

Within the clock-wizard block there are 2 knobs to get to the VCO
frequency, a divide and a fractional multiply:
INPUT-->DIVIDE[1]-->MULTIPLY[2]-->VCO Frequency

Before this was represented as two internal clocks, now it is two
'struct clk_hw's. This allows the rates to be dynamically
changed.

[1] The divide is controlled with DIVCLK_DIVIDE
[2] The multiply is controlled with
     CLKFBOUT_MULT & CLKFBOUT_FRAC

Signed-off-by: Paul Thomas <pthomas8589@gmail.com>
Reviewed-by: Shubhrajyoti Datta <shubhrajyoti.datta@xilinx.com>
State: pending
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 drivers/clk/clk-xlnx-clock-wizard.c | 363 +++++++++++++++++++++++-----
 1 file changed, 304 insertions(+), 59 deletions(-)

diff --git a/drivers/clk/clk-xlnx-clock-wizard.c b/drivers/clk/clk-xlnx-clock-wizard.c
index d8e4acd1fd07..6a8a591a2192 100644
--- a/drivers/clk/clk-xlnx-clock-wizard.c
+++ b/drivers/clk/clk-xlnx-clock-wizard.c
@@ -44,19 +44,20 @@
 #define WZRD_DR_DIV_TO_PHASE_OFFSET	4
 #define WZRD_DR_BEGIN_DYNA_RECONF	0x03
 
+/* Multiplier limits, from UG572 Table 3-4 for Ultrascale+ */
+#define CLKFBOUT_MULT_F_MIN		2000U
+#define CLKFBOUT_MULT_F_MAX		128000U
+
+/* Divider limits, from UG572 Table 3-4 for Ultrascale+ */
+#define DIVCLK_DIVIDE_MIN		1U
+#define DIVCLK_DIVIDE_MAX		106U
+
 /* Get the mask from width */
 #define div_mask(width)			((1 << (width)) - 1)
 
 /* Extract divider instance from clock hardware instance */
 #define to_clk_wzrd_divider(_hw) container_of(_hw, struct clk_wzrd_divider, hw)
 
-enum clk_wzrd_int_clks {
-	wzrd_clk_mul,
-	wzrd_clk_mul_div,
-	wzrd_clk_mul_frac,
-	wzrd_clk_int_max
-};
-
 /**
  * struct clk_wzrd - Clock wizard private data structure
  *
@@ -65,10 +66,11 @@ enum clk_wzrd_int_clks {
  * @base:		Memory base
  * @clk_in1:		Handle to input clock 'clk_in1'
  * @axi_clk:		Handle to input clock 's_axi_aclk'
- * @clks_internal:	Internal clocks
  * @clkout:		Output clocks
  * @speed_grade:	Speed grade of the device
  * @suspended:		Flag indicating power state of the device
+ * @lock		lock pointer
+ * @vco_clk:		hw Voltage Controlled Oscilator clock
  */
 struct clk_wzrd {
 	struct clk_onecell_data clk_data;
@@ -76,10 +78,12 @@ struct clk_wzrd {
 	void __iomem *base;
 	struct clk *clk_in1;
 	struct clk *axi_clk;
-	struct clk *clks_internal[wzrd_clk_int_max];
 	struct clk *clkout[WZRD_NUM_OUTPUTS];
 	unsigned int speed_grade;
 	bool suspended;
+	spinlock_t *lock;
+	struct clk_hw vco_clk_div_hw;
+	struct clk_hw vco_clk_mul_hw;
 };
 
 /**
@@ -311,6 +315,229 @@ static const struct clk_ops clk_wzrd_clk_divider_ops_f = {
 	.recalc_rate = clk_wzrd_recalc_ratef,
 };
 
+static unsigned long clk_wzrd_vco_mul_recalc_rate_f(struct clk_hw *hw,
+					       unsigned long parent_rate)
+{
+	u32 clk_cfg_reg0;
+	u32 clkfbout_mult, clkfbout_frac;
+	u64 rate;
+
+	struct clk_wzrd *clk_wzrd = container_of(hw,
+						 struct clk_wzrd,
+						 vco_clk_mul_hw);
+
+	clk_cfg_reg0 = readl(clk_wzrd->base + WZRD_CLK_CFG_REG(0));
+	clkfbout_mult = (clk_cfg_reg0 & WZRD_CLKFBOUT_MULT_MASK) >>
+			 WZRD_CLKFBOUT_MULT_SHIFT;
+	clkfbout_frac = (clk_cfg_reg0 & WZRD_CLKFBOUT_FRAC_MASK) >>
+			 WZRD_CLKFBOUT_FRAC_SHIFT;
+
+	rate = parent_rate *
+	       (clkfbout_mult * 1000 + clkfbout_frac) / /* multiplier x1000 */
+	       1000;
+
+	return (unsigned long)rate;
+}
+
+static int clk_wzrd_vco_mul_dynamic_reconfig_f(struct clk_hw *hw,
+					   unsigned long rate,
+					   unsigned long parent_rate)
+{
+	int err = 0;
+	u16 retries;
+	unsigned long flags = 0;
+	u32 clk_cfg_reg0, value;
+	u32 divclk_divide, clkfbout_mult, clkfbout_frac;
+	unsigned int new_mult;
+
+	struct clk_wzrd *clk_wzrd = container_of(hw,
+						 struct clk_wzrd,
+						 vco_clk_mul_hw);
+
+	/* The 8*125 give the x1000 that is needed */
+	new_mult = (rate * 8 / parent_rate) * 125;
+	new_mult = clamp(new_mult, CLKFBOUT_MULT_F_MIN, CLKFBOUT_MULT_F_MAX);
+
+	clkfbout_mult = new_mult / 1000;
+	clkfbout_frac = new_mult % 1000;
+
+	/* Read divclk_divide so it can be left unchanged */
+	clk_cfg_reg0 = readl(clk_wzrd->base + WZRD_CLK_CFG_REG(0));
+	divclk_divide = (clk_cfg_reg0 & WZRD_DIVCLK_DIVIDE_MASK) >>
+			 WZRD_DIVCLK_DIVIDE_SHIFT;
+
+	value = clkfbout_frac << WZRD_CLKFBOUT_FRAC_SHIFT |
+		 clkfbout_mult << WZRD_CLKFBOUT_MULT_SHIFT |
+		 divclk_divide << WZRD_DIVCLK_DIVIDE_SHIFT;
+
+	if (clk_wzrd->lock)
+		spin_lock_irqsave(clk_wzrd->lock, flags);
+	else
+		__acquire(clk_wzrd->lock);
+
+	/* Write the configuration out */
+	writel(value, clk_wzrd->base + WZRD_CLK_CFG_REG(0));
+
+	/* Check status register */
+	retries = WZRD_DR_NUM_RETRIES;
+	while (retries--) {
+		if (readl(clk_wzrd->base + WZRD_DR_STATUS_REG_OFFSET) &
+							WZRD_DR_LOCK_BIT_MASK)
+			break;
+	}
+
+	if (!retries) {
+		err = -ETIMEDOUT;
+		goto err_reconfig;
+	}
+
+	/* Initiate reconfiguration */
+	writel(WZRD_DR_BEGIN_DYNA_RECONF,
+	       clk_wzrd->base + WZRD_DR_INIT_REG_OFFSET);
+
+	/* Check status register */
+	retries = WZRD_DR_NUM_RETRIES;
+	while (retries--) {
+		if (readl(clk_wzrd->base + WZRD_DR_STATUS_REG_OFFSET) &
+							WZRD_DR_LOCK_BIT_MASK)
+			break;
+	}
+
+	if (!retries)
+		err = -ETIMEDOUT;
+
+err_reconfig:
+	if (clk_wzrd->lock)
+		spin_unlock_irqrestore(clk_wzrd->lock, flags);
+	else
+		__release(clk_wzrd->lock);
+
+	return err;
+}
+
+static long clk_wzrd_vco_mul_round_rate_f(struct clk_hw *hw, unsigned long rate,
+				      unsigned long *prate)
+{
+	return rate;
+}
+
+static const struct clk_ops clk_wzrd_vco_mul_ops_f = {
+	.round_rate = clk_wzrd_vco_mul_round_rate_f,
+	.set_rate = clk_wzrd_vco_mul_dynamic_reconfig_f,
+	.recalc_rate = clk_wzrd_vco_mul_recalc_rate_f,
+};
+
+static unsigned long clk_wzrd_vco_div_recalc_rate(struct clk_hw *hw,
+					       unsigned long parent_rate)
+{
+	u32 clk_cfg_reg0;
+	u32 divclk_divide;
+	u64 rate;
+
+	struct clk_wzrd *clk_wzrd = container_of(hw,
+						 struct clk_wzrd,
+						 vco_clk_div_hw);
+
+	clk_cfg_reg0 = readl(clk_wzrd->base + WZRD_CLK_CFG_REG(0));
+	divclk_divide = (clk_cfg_reg0 & WZRD_DIVCLK_DIVIDE_MASK) >>
+			 WZRD_DIVCLK_DIVIDE_SHIFT;
+
+	rate = parent_rate / divclk_divide;
+
+	return (unsigned long)rate;
+}
+
+static int clk_wzrd_vco_div_dynamic_reconfig(struct clk_hw *hw,
+					   unsigned long rate,
+					   unsigned long parent_rate)
+{
+	int err = 0;
+	u16 retries;
+	unsigned long flags = 0;
+	u32 clk_cfg_reg0, value;
+	u32 divclk_divide, clkfbout_mult, clkfbout_frac;
+
+	struct clk_wzrd *clk_wzrd = container_of(hw,
+						 struct clk_wzrd,
+						 vco_clk_div_hw);
+
+	divclk_divide = DIV_ROUND_CLOSEST(parent_rate, rate);
+
+	divclk_divide = clamp(divclk_divide,
+			      DIVCLK_DIVIDE_MIN,
+			      DIVCLK_DIVIDE_MAX);
+
+	/*
+	 * Read clkfbout_mult and clkfbout_frac
+	 * so they can be left unchanged
+	 */
+	clk_cfg_reg0 = readl(clk_wzrd->base + WZRD_CLK_CFG_REG(0));
+	clkfbout_mult = (clk_cfg_reg0 & WZRD_CLKFBOUT_MULT_MASK) >>
+			 WZRD_CLKFBOUT_MULT_SHIFT;
+	clkfbout_frac = (clk_cfg_reg0 & WZRD_CLKFBOUT_FRAC_MASK) >>
+			 WZRD_CLKFBOUT_FRAC_SHIFT;
+
+	value = clkfbout_frac << WZRD_CLKFBOUT_FRAC_SHIFT |
+		 clkfbout_mult << WZRD_CLKFBOUT_MULT_SHIFT |
+		 divclk_divide << WZRD_DIVCLK_DIVIDE_SHIFT;
+
+	if (clk_wzrd->lock)
+		spin_lock_irqsave(clk_wzrd->lock, flags);
+	else
+		__acquire(clk_wzrd->lock);
+
+	/* Write the configuration out */
+	writel(value, clk_wzrd->base + WZRD_CLK_CFG_REG(0));
+
+	/* Check status register */
+	retries = WZRD_DR_NUM_RETRIES;
+	while (retries--) {
+		if (readl(clk_wzrd->base + WZRD_DR_STATUS_REG_OFFSET) &
+							WZRD_DR_LOCK_BIT_MASK)
+			break;
+	}
+
+	if (!retries) {
+		err = -ETIMEDOUT;
+		goto err_reconfig;
+	}
+
+	/* Initiate reconfiguration */
+	writel(WZRD_DR_BEGIN_DYNA_RECONF,
+	       clk_wzrd->base + WZRD_DR_INIT_REG_OFFSET);
+
+	/* Check status register */
+	retries = WZRD_DR_NUM_RETRIES;
+	while (retries--) {
+		if (readl(clk_wzrd->base + WZRD_DR_STATUS_REG_OFFSET) &
+							WZRD_DR_LOCK_BIT_MASK)
+			break;
+	}
+
+	if (!retries)
+		err = -ETIMEDOUT;
+
+err_reconfig:
+	if (clk_wzrd->lock)
+		spin_unlock_irqrestore(clk_wzrd->lock, flags);
+	else
+		__release(clk_wzrd->lock);
+
+	return err;
+}
+
+static long clk_wzrd_vco_div_round_rate(struct clk_hw *hw, unsigned long rate,
+				      unsigned long *prate)
+{
+	return rate;
+}
+
+static const struct clk_ops clk_wzrd_vco_div_ops = {
+	.round_rate = clk_wzrd_vco_div_round_rate,
+	.set_rate = clk_wzrd_vco_div_dynamic_reconfig,
+	.recalc_rate = clk_wzrd_vco_div_recalc_rate,
+};
+
 static struct clk *clk_wzrd_register_divf(struct device *dev,
 					  const char *name,
 					  const char *parent_name,
@@ -488,16 +715,17 @@ static SIMPLE_DEV_PM_OPS(clk_wzrd_dev_pm_ops, clk_wzrd_suspend,
 static int clk_wzrd_probe(struct platform_device *pdev)
 {
 	int i, ret;
-	u32 reg, reg_f, mult;
 	unsigned long rate;
-	const char *clk_name;
-	void __iomem *ctrl_reg;
 	struct clk_wzrd *clk_wzrd;
 	struct resource *mem;
 	int outputs;
 	unsigned long flags = 0;
 	struct device_node *np = pdev->dev.of_node;
 
+	const char *clk_in_name = NULL;
+	const char *clk_vco_div_name = NULL, *clk_vco_mul_name = NULL;
+	struct clk_init_data init;
+
 	clk_wzrd = devm_kzalloc(&pdev->dev, sizeof(*clk_wzrd), GFP_KERNEL);
 	if (!clk_wzrd)
 		return -ENOMEM;
@@ -508,6 +736,8 @@ static int clk_wzrd_probe(struct platform_device *pdev)
 	if (IS_ERR(clk_wzrd->base))
 		return PTR_ERR(clk_wzrd->base);
 
+	clk_wzrd->lock = &clkwzrd_lock;
+
 	ret = of_property_read_u32(np, "speed-grade", &clk_wzrd->speed_grade);
 	if (!ret) {
 		if (clk_wzrd->speed_grade < 1 || clk_wzrd->speed_grade > 3) {
@@ -543,51 +773,62 @@ static int clk_wzrd_probe(struct platform_device *pdev)
 		goto err_disable_clk;
 	}
 
-	/* register multiplier */
-	reg = (readl(clk_wzrd->base + WZRD_CLK_CFG_REG(0)) &
-		     WZRD_CLKFBOUT_MULT_MASK) >> WZRD_CLKFBOUT_MULT_SHIFT;
-	reg_f = (readl(clk_wzrd->base + WZRD_CLK_CFG_REG(0)) &
-		     WZRD_CLKFBOUT_FRAC_MASK) >> WZRD_CLKFBOUT_FRAC_SHIFT;
-
-	mult = ((reg * 1000) + reg_f);
-	clk_name = kasprintf(GFP_KERNEL, "%s_mul", dev_name(&pdev->dev));
-	if (!clk_name) {
-		ret = -ENOMEM;
-		goto err_disable_clk;
-	}
-	clk_wzrd->clks_internal[wzrd_clk_mul] = clk_register_fixed_factor
-			(&pdev->dev, clk_name,
-			 __clk_get_name(clk_wzrd->clk_in1),
-			0, mult, 1000);
-	kfree(clk_name);
-	if (IS_ERR(clk_wzrd->clks_internal[wzrd_clk_mul])) {
-		dev_err(&pdev->dev, "unable to register fixed-factor clock\n");
-		ret = PTR_ERR(clk_wzrd->clks_internal[wzrd_clk_mul]);
-		goto err_disable_clk;
+	ret = clk_prepare_enable(clk_wzrd->clk_in1);
+	if (ret) {
+		dev_err(&pdev->dev, "enabling clk_in1 failed\n");
+		return ret;
 	}
 
+	/* Only allow the parent rate to be set if there is a single output */
 	outputs = of_property_count_strings(np, "clock-output-names");
 	if (outputs == 1)
 		flags = CLK_SET_RATE_PARENT;
-	clk_name = kasprintf(GFP_KERNEL, "%s_mul_div", dev_name(&pdev->dev));
-	if (!clk_name) {
+
+	/* Write the divider clock name */
+	clk_vco_div_name = kasprintf(GFP_KERNEL, "%s_div",
+				     dev_name(&pdev->dev));
+
+	if (!clk_vco_div_name) {
 		ret = -ENOMEM;
-		goto err_rm_int_clk;
+		goto err_disable_clk;
 	}
 
-	ctrl_reg = clk_wzrd->base + WZRD_CLK_CFG_REG(0);
-	/* register div */
-	clk_wzrd->clks_internal[wzrd_clk_mul_div] = clk_register_divider
-			(&pdev->dev, clk_name,
-			 __clk_get_name(clk_wzrd->clks_internal[wzrd_clk_mul]),
-			flags, ctrl_reg, 0, 8, CLK_DIVIDER_ONE_BASED |
-			CLK_DIVIDER_ALLOW_ZERO, &clkwzrd_lock);
-	if (IS_ERR(clk_wzrd->clks_internal[wzrd_clk_mul_div])) {
-		dev_err(&pdev->dev, "unable to register divider clock\n");
-		ret = PTR_ERR(clk_wzrd->clks_internal[wzrd_clk_mul_div]);
-		goto err_rm_int_clk;
+	/* Write the multiplier clock name */
+	clk_vco_mul_name = kasprintf(GFP_KERNEL, "%s_mul",
+				     dev_name(&pdev->dev));
+	if (!clk_vco_mul_name) {
+		ret = -ENOMEM;
+		kfree(clk_vco_div_name);
+		goto err_disable_clk;
 	}
 
+	/* setup and register the VCO divider clock */
+	init.name = clk_vco_div_name;
+	init.ops = &clk_wzrd_vco_div_ops;
+	clk_in_name = __clk_get_name(clk_wzrd->clk_in1);
+	dev_info(&pdev->dev, "clk_in_name: %s\n", clk_in_name);
+	init.parent_names = &clk_in_name;
+	init.num_parents = 1;
+	init.flags = 0;
+
+	clk_wzrd->vco_clk_div_hw.init = &init;
+	ret = clk_hw_register(&pdev->dev, &clk_wzrd->vco_clk_div_hw);
+	if (ret)
+		goto err_disable_clk_free_names;
+
+	/* setup and register the VCO multiplier clock */
+	init.name = clk_vco_mul_name;
+	init.ops = &clk_wzrd_vco_mul_ops_f;
+	init.parent_names = &clk_vco_div_name;
+	init.num_parents = 1;
+	/* needs CLK_SET_RATE_PARENT if set above */
+	init.flags = flags;
+
+	clk_wzrd->vco_clk_mul_hw.init = &init;
+	ret = clk_hw_register(&pdev->dev, &clk_wzrd->vco_clk_mul_hw);
+	if (ret)
+		goto err_rm_hw_div_clk;
+
 	/* register div per output */
 	for (i = outputs - 1; i >= 0 ; i--) {
 		const char *clkout_name;
@@ -597,12 +838,12 @@ static int clk_wzrd_probe(struct platform_device *pdev)
 			dev_err(&pdev->dev,
 				"clock output name not specified\n");
 			ret = -EINVAL;
-			goto err_rm_int_clks;
+			goto err_rm_hw_clks;
 		}
 		if (!i)
 			clk_wzrd->clkout[i] = clk_wzrd_register_divf
 				(&pdev->dev, clkout_name,
-				clk_name, flags,
+				clk_vco_mul_name, flags,
 				clk_wzrd->base, (WZRD_CLK_CFG_REG(2) + i * 12),
 				WZRD_CLKOUT_DIVIDE_SHIFT,
 				WZRD_CLKOUT_DIVIDE_WIDTH,
@@ -611,7 +852,7 @@ static int clk_wzrd_probe(struct platform_device *pdev)
 		else
 			clk_wzrd->clkout[i] = clk_wzrd_register_divider
 				(&pdev->dev, clkout_name,
-				clk_name, 0,
+				clk_vco_mul_name, 0,
 				clk_wzrd->base, (WZRD_CLK_CFG_REG(2) + i * 12),
 				WZRD_CLKOUT_DIVIDE_SHIFT,
 				WZRD_CLKOUT_DIVIDE_WIDTH,
@@ -625,11 +866,12 @@ static int clk_wzrd_probe(struct platform_device *pdev)
 			dev_err(&pdev->dev,
 				"unable to register divider clock\n");
 			ret = PTR_ERR(clk_wzrd->clkout[i]);
-			goto err_rm_int_clks;
+			goto err_rm_hw_clks;
 		}
 	}
 
-	kfree(clk_name);
+	kfree(clk_vco_div_name);
+	kfree(clk_vco_mul_name);
 
 	clk_wzrd->clk_data.clks = clk_wzrd->clkout;
 	clk_wzrd->clk_data.clk_num = ARRAY_SIZE(clk_wzrd->clkout);
@@ -652,11 +894,13 @@ static int clk_wzrd_probe(struct platform_device *pdev)
 
 	return 0;
 
-err_rm_int_clks:
-	clk_unregister(clk_wzrd->clks_internal[1]);
-err_rm_int_clk:
-	kfree(clk_name);
-	clk_unregister(clk_wzrd->clks_internal[0]);
+err_rm_hw_clks:
+	clk_unregister(clk_wzrd->vco_clk_mul_hw.clk);
+err_rm_hw_div_clk:
+	clk_unregister(clk_wzrd->vco_clk_div_hw.clk);
+err_disable_clk_free_names:
+	kfree(clk_vco_div_name);
+	kfree(clk_vco_mul_name);
 err_disable_clk:
 	clk_disable_unprepare(clk_wzrd->axi_clk);
 
@@ -672,8 +916,9 @@ static int clk_wzrd_remove(struct platform_device *pdev)
 
 	for (i = 0; i < WZRD_NUM_OUTPUTS; i++)
 		clk_unregister(clk_wzrd->clkout[i]);
-	for (i = 0; i < wzrd_clk_int_max; i++)
-		clk_unregister(clk_wzrd->clks_internal[i]);
+
+	clk_unregister(clk_wzrd->vco_clk_div_hw.clk);
+	clk_unregister(clk_wzrd->vco_clk_mul_hw.clk);
 
 	if (clk_wzrd->speed_grade) {
 		clk_notifier_unregister(clk_wzrd->axi_clk, &clk_wzrd->nb);
-- 
2.31.1

