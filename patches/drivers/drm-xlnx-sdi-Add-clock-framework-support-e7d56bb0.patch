From a7cb630473068f6e10d5a5aac99a3603fc731a4c Mon Sep 17 00:00:00 2001
From: Vishal Sagar <vishal.sagar@xilinx.com>
Date: Wed, 27 Feb 2019 10:15:40 -0800
Subject: [PATCH 0516/1851] drm: xlnx: sdi: Add clock framework support

commit 1da3f20aa12c0f21a50bfe3e6568fb27d0e96843 from
https://github.com/Xilinx/linux-xlnx.git

This patch adds clock framework support by adding clock and clock-name
dt property for AXI Lite, video in and SDI Tx clock.

This breaks backward compatibility as the compatible string isn't changed
but new required properties are added.

Signed-off-by: Vishal Sagar <vishal.sagar@xilinx.com>
Reviewed-by: Hyun Kwon <hyun.kwon@xilinx.com>
State: pending
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 drivers/gpu/drm/xlnx/xlnx_sdi.c | 85 +++++++++++++++++++++++++++++----
 1 file changed, 77 insertions(+), 8 deletions(-)

diff --git a/drivers/gpu/drm/xlnx/xlnx_sdi.c b/drivers/gpu/drm/xlnx/xlnx_sdi.c
index 25412dda5293..3b26e9287d2b 100644
--- a/drivers/gpu/drm/xlnx/xlnx_sdi.c
+++ b/drivers/gpu/drm/xlnx/xlnx_sdi.c
@@ -11,6 +11,7 @@
 #include <drm/drm_crtc_helper.h>
 #include <drm/drmP.h>
 #include <drm/drm_probe_helper.h>
+#include <linux/clk.h>
 #include <linux/component.h>
 #include <linux/device.h>
 #include <linux/of_device.h>
@@ -170,6 +171,9 @@ enum payload_line_2 {
  * @use_ds2_3ga_prop: Use DS2 instead of DS3 in 3GA mode parameter
  * @use_ds2_3ga_val: Use DS2 instead of DS3 in 3GA mode parameter value
  * @video_mode: current display mode
+ * @axi_clk: AXI Lite interface clock
+ * @sditx_clk: SDI Tx Clock
+ * @vidin_clk: Video Clock
  */
 struct xlnx_sdi {
 	struct drm_encoder encoder;
@@ -205,6 +209,9 @@ struct xlnx_sdi {
 	struct drm_property *use_ds2_3ga_prop;
 	bool use_ds2_3ga_val;
 	struct drm_display_mode video_mode;
+	struct clk *axi_clk;
+	struct clk *sditx_clk;
+	struct clk *vidin_clk;
 };
 
 #define connector_to_sdi(c) container_of(c, struct xlnx_sdi, connector)
@@ -1044,6 +1051,45 @@ static int xlnx_sdi_probe(struct platform_device *pdev)
 	}
 	platform_set_drvdata(pdev, sdi);
 
+	sdi->axi_clk = devm_clk_get(dev, "s_axi_aclk");
+	if (IS_ERR(sdi->axi_clk)) {
+		ret = PTR_ERR(sdi->axi_clk);
+		dev_err(dev, "failed to get s_axi_aclk %d\n", ret);
+		return ret;
+	}
+
+	sdi->sditx_clk = devm_clk_get(dev, "sdi_tx_clk");
+	if (IS_ERR(sdi->sditx_clk)) {
+		ret = PTR_ERR(sdi->sditx_clk);
+		dev_err(dev, "failed to get sdi_tx_clk %d\n", ret);
+		return ret;
+	}
+
+	sdi->vidin_clk = devm_clk_get(dev, "video_in_clk");
+	if (IS_ERR(sdi->vidin_clk)) {
+		ret = PTR_ERR(sdi->vidin_clk);
+		dev_err(dev, "failed to get video_in_clk %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(sdi->axi_clk);
+	if (ret) {
+		dev_err(dev, "failed to enable axi_clk %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(sdi->sditx_clk);
+	if (ret) {
+		dev_err(dev, "failed to enable sditx_clk %d\n", ret);
+		goto err_disable_axi_clk;
+	}
+
+	ret = clk_prepare_enable(sdi->vidin_clk);
+	if (ret) {
+		dev_err(dev, "failed to enable vidin_clk %d\n", ret);
+		goto err_disable_sditx_clk;
+	}
+
 	/* in case all "port" nodes are grouped under a "ports" node */
 	ports = of_get_child_by_name(sdi->dev->of_node, "ports");
 	if (!ports) {
@@ -1064,7 +1110,8 @@ static int xlnx_sdi_probe(struct platform_device *pdev)
 		if (!endpoint) {
 			dev_err(dev, "No remote port at %s\n", port->name);
 			of_node_put(endpoint);
-			return -EINVAL;
+			ret = -EINVAL;
+			goto err_disable_vidin_clk;
 		}
 
 		of_node_put(endpoint);
@@ -1072,7 +1119,7 @@ static int xlnx_sdi_probe(struct platform_device *pdev)
 		ret = of_property_read_u32(port, "reg", &index);
 		if (ret) {
 			dev_err(dev, "reg property not present - %d\n", ret);
-			return ret;
+			goto err_disable_vidin_clk;
 		}
 
 		portmask |= (1 << index);
@@ -1088,7 +1135,8 @@ static int xlnx_sdi_probe(struct platform_device *pdev)
 		sdi->enable_anc_data = false;
 	} else {
 		dev_err(dev, "Incorrect dt node!\n");
-		return -EINVAL;
+		ret = -EINVAL;
+		goto err_disable_vidin_clk;
 	}
 
 	sdi->enable_st352_chroma = of_property_read_bool(sdi->dev->of_node,
@@ -1097,14 +1145,16 @@ static int xlnx_sdi_probe(struct platform_device *pdev)
 	/* disable interrupt */
 	xlnx_sdi_writel(sdi->base, XSDI_TX_GLBL_IER, 0);
 	irq = platform_get_irq(pdev, 0);
-	if (irq < 0)
-		return irq;
+	if (irq < 0) {
+		ret = irq;
+		goto err_disable_vidin_clk;
+	}
 
 	ret = devm_request_threaded_irq(sdi->dev, irq, NULL,
 					xlnx_sdi_irq_handler, IRQF_ONESHOT,
 					dev_name(sdi->dev), sdi);
 	if (ret < 0)
-		return ret;
+		goto err_disable_vidin_clk;
 
 	/* initialize the wait queue for GT reset event */
 	init_waitqueue_head(&sdi->wait_event);
@@ -1115,7 +1165,8 @@ static int xlnx_sdi_probe(struct platform_device *pdev)
 		sdi->bridge = of_xlnx_bridge_get(vpss_node);
 		if (!sdi->bridge) {
 			dev_info(sdi->dev, "Didn't get bridge instance\n");
-			return -EPROBE_DEFER;
+			ret = -EPROBE_DEFER;
+			goto err_disable_vidin_clk;
 		}
 	}
 
@@ -1126,12 +1177,30 @@ static int xlnx_sdi_probe(struct platform_device *pdev)
 	 */
 	pdev->dev.platform_data = &sdi->video_mode;
 
-	return component_add(dev, &xlnx_sdi_component_ops);
+	ret = component_add(dev, &xlnx_sdi_component_ops);
+	if (ret < 0)
+		goto err_disable_vidin_clk;
+
+	return ret;
+
+err_disable_vidin_clk:
+	clk_disable_unprepare(sdi->vidin_clk);
+err_disable_sditx_clk:
+	clk_disable_unprepare(sdi->sditx_clk);
+err_disable_axi_clk:
+	clk_disable_unprepare(sdi->axi_clk);
+
+	return ret;
 }
 
 static int xlnx_sdi_remove(struct platform_device *pdev)
 {
+	struct xlnx_sdi *sdi = platform_get_drvdata(pdev);
+
 	component_del(&pdev->dev, &xlnx_sdi_component_ops);
+	clk_disable_unprepare(sdi->vidin_clk);
+	clk_disable_unprepare(sdi->sditx_clk);
+	clk_disable_unprepare(sdi->axi_clk);
 
 	return 0;
 }
-- 
2.31.1

