From 3ec5bf5de84b4f8c6ba3fbc436af9f637853db44 Mon Sep 17 00:00:00 2001
From: Hyun Kwon <hyun.kwon@xilinx.com>
Date: Wed, 21 Feb 2018 10:21:27 -0800
Subject: [PATCH 0286/1851] drm: xlnx: drv: Allow multiple masters on a drm
 device

commit d41f656e889ecb5b11d46a8c19ab8515f2f33521 from
https://github.com/Xilinx/linux-xlnx.git

This may not be the ideal solution, but is to allow multiple
masters running on a single drm device, when the application
has the admin priviliege. This enables access to master
only resources such as setting drm planes and etc.

Signed-off-by: Hyun Kwon <hyun.kwon@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
State: pending
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 drivers/gpu/drm/xlnx/xlnx_drv.c | 34 ++++++++++++++++++++++++++++++++-
 1 file changed, 33 insertions(+), 1 deletion(-)

diff --git a/drivers/gpu/drm/xlnx/xlnx_drv.c b/drivers/gpu/drm/xlnx/xlnx_drv.c
index 83b97aa38f08..de9bfcaba6fd 100644
--- a/drivers/gpu/drm/xlnx/xlnx_drv.c
+++ b/drivers/gpu/drm/xlnx/xlnx_drv.c
@@ -57,6 +57,7 @@ MODULE_PARM_DESC(fbdev_vres,
  * @fb: DRM fb helper
  * @master: logical master device for pipeline
  * @suspend_state: atomic state for suspend / resume
+ * @is_master: A flag to indicate if this instance is fake master
  */
 struct xlnx_drm {
 	struct drm_device *drm;
@@ -64,6 +65,7 @@ struct xlnx_drm {
 	struct drm_fb_helper *fb;
 	struct platform_device *master;
 	struct drm_atomic_state *suspend_state;
+	bool is_master;
 };
 
 /**
@@ -135,6 +137,35 @@ static void xlnx_mode_config_init(struct drm_device *drm)
 		xlnx_crtc_helper_get_cursor_height(crtc);
 }
 
+static int xlnx_drm_open(struct drm_device *dev, struct drm_file *file)
+{
+	struct xlnx_drm *xlnx_drm = dev->dev_private;
+
+	/* This is a hacky way to allow the root user to run as a master */
+	if (!(drm_is_primary_client(file) && !dev->master) &&
+	    !file->is_master && capable(CAP_SYS_ADMIN)) {
+		file->is_master = 1;
+		xlnx_drm->is_master = true;
+	}
+
+	return 0;
+}
+
+static int xlnx_drm_release(struct inode *inode, struct file *filp)
+{
+	struct drm_file *file = filp->private_data;
+	struct drm_minor *minor = file->minor;
+	struct drm_device *drm = minor->dev;
+	struct xlnx_drm *xlnx_drm = drm->dev_private;
+
+	if (xlnx_drm->is_master) {
+		xlnx_drm->is_master = false;
+		file->is_master = 0;
+	}
+
+	return drm_release(inode, filp);
+}
+
 static void xlnx_lastclose(struct drm_device *drm)
 {
 	struct xlnx_drm *xlnx_drm = drm->dev_private;
@@ -146,7 +177,7 @@ static void xlnx_lastclose(struct drm_device *drm)
 static const struct file_operations xlnx_fops = {
 	.owner		= THIS_MODULE,
 	.open		= drm_open,
-	.release	= drm_release,
+	.release	= xlnx_drm_release,
 	.unlocked_ioctl	= drm_ioctl,
 	.mmap		= drm_gem_cma_mmap,
 	.poll		= drm_poll,
@@ -160,6 +191,7 @@ static const struct file_operations xlnx_fops = {
 static struct drm_driver xlnx_drm_driver = {
 	.driver_features		= DRIVER_MODESET | DRIVER_GEM |
 					  DRIVER_ATOMIC,
+	.open				= xlnx_drm_open,
 	.lastclose			= xlnx_lastclose,
 
 	.prime_handle_to_fd		= drm_gem_prime_handle_to_fd,
-- 
2.31.1

