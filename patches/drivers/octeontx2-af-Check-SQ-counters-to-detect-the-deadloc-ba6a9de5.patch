From 641fe505342bc45b30b94625a4d583b491a05f5a Mon Sep 17 00:00:00 2001
From: Geetha sowjanya <gakula@marvell.com>
Date: Thu, 4 Apr 2019 14:45:36 +0530
Subject: [PATCH 0134/1921] octeontx2-af: Check SQ counters to detect the
 deadlock

This patch creates mapping between SQs and SMQs.
Checks TX stats of every SQ mapped to SMQs to detect the deadlock.
If atleast one SQ tx counters get updated then that SMQ is not stalled.

Change-Id: Id54dc3c6793b2d0f0ced0bbaa6dab3cfefe52977
Signed-off-by: Geetha sowjanya <gakula@marvell.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 .../net/ethernet/marvell/octeontx2/af/rvu.h   |   2 +
 .../ethernet/marvell/octeontx2/af/rvu_fixes.c | 102 +++++++++++++++++-
 .../ethernet/marvell/octeontx2/af/rvu_nix.c   |   2 +
 3 files changed, 101 insertions(+), 5 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu.h b/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
index 7dc50d8ea736..7de753d007dd 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
@@ -610,6 +610,8 @@ void rvu_nix_txsch_unlock(struct nix_hw *nix_hw);
 void rvu_nix_update_link_credits(struct rvu *rvu, int blkaddr,
 				 int link, u64 ncredits);
 
+void rvu_nix_update_sq_smq_mapping(struct rvu *rvu, int blkaddr, int nixlf,
+				   u16 sq, u16 smq);
 void rvu_nix_txsch_config_changed(struct nix_hw *nix_hw);
 ssize_t rvu_nix_get_tx_stall_counters(struct rvu *rvu,
 				      char __user *buffer, loff_t *ppos);
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_fixes.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_fixes.c
index 0ad15356fb86..982f20d01ea6 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_fixes.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_fixes.c
@@ -20,6 +20,8 @@
 #include "rvu.h"
 #include "cgx.h"
 
+#define OTX2_MAX_CQ_CNT 64
+
 struct nix_tx_stall {
 	struct rvu *rvu;
 	int blkaddr;
@@ -27,10 +29,12 @@ struct nix_tx_stall {
 	int tl4_count;
 	int tl3_count;
 	int tl2_count;
+	int sq_count;
 	u16 *smq_tl2_map;
 	u16 *tl4_tl2_map;
 	u16 *tl3_tl2_map;
 	u16 *tl2_tl1_map;
+	u16 *sq_smq_map;
 #define LINK_TYPE_SHIFT	7
 #define EXPR_LINK(map)	(map & (1 << LINK_TYPE_SHIFT))
 #define LINK_CHAN_SHIFT	8
@@ -130,6 +134,28 @@ void rvu_nix_update_link_credits(struct rvu *rvu, int blkaddr,
 	rvu_nix_txsch_unlock(nix_hw);
 }
 
+void rvu_nix_update_sq_smq_mapping(struct rvu *rvu, int blkaddr, int nixlf,
+				   u16 sq, u16 smq)
+{
+	struct nix_tx_stall *tx_stall;
+	struct nix_hw *nix_hw;
+	int sq_count;
+
+	nix_hw = get_nix_hw(rvu->hw, blkaddr);
+	if (!nix_hw)
+		return;
+
+	tx_stall = nix_hw->tx_stall;
+	if (!tx_stall)
+		return;
+
+	sq_count = tx_stall->sq_count;
+
+	rvu_nix_txsch_lock(nix_hw);
+	tx_stall->sq_smq_map[nixlf * sq_count + sq] = smq;
+	rvu_nix_txsch_unlock(nix_hw);
+}
+
 static void rvu_nix_scan_link_credits(struct rvu *rvu, int blkaddr,
 				      struct nix_tx_stall *tx_stall)
 {
@@ -175,6 +201,24 @@ static void rvu_nix_scan_tl2_link_mapping(struct rvu *rvu,
 	}
 }
 
+static bool is_sq_allocated(struct rvu *rvu, struct rvu_pfvf *pfvf,
+			    int blkaddr, int sq)
+{
+	struct rvu_hwinfo *hw = rvu->hw;
+	struct rvu_block *block;
+	struct admin_queue *aq;
+
+	block = &hw->block[blkaddr];
+	aq = block->aq;
+	spin_lock(&aq->lock);
+	if (test_bit(sq, pfvf->sq_bmap)) {
+		spin_unlock(&aq->lock);
+		return true;
+	}
+	spin_unlock(&aq->lock);
+	return false;
+}
+
 static bool is_schq_allocated(struct rvu *rvu, struct nix_hw *nix_hw,
 			      int lvl, int schq)
 {
@@ -303,16 +347,22 @@ static void rvu_nix_scan_txsch_hierarchy(struct rvu *rvu,
 }
 
 #define TX_OCTS 4
+#define RVU_AF_BAR2_SEL			(0x9000000ull)
+#define RVU_AF_BAR2_ALIASX(a, b)	(0x9100000ull | (a) << 12 | (b))
+#define	NIX_LF_SQ_OP_OCTS		(0xa10)
 
 static bool is_sq_stalled(struct rvu *rvu, struct nix_hw *nix_hw, int smq)
 {
 	struct nix_tx_stall *tx_stall = nix_hw->tx_stall;
+	u64 btx_octs, atx_octs, cfg, incr;
+	int sq_count = tx_stall->sq_count;
 	struct rvu_hwinfo *hw = rvu->hw;
 	int blkaddr = tx_stall->blkaddr;
 	struct nix_txsch *smq_txsch;
-	u64 btx_octs, atx_octs;
+	struct rvu_pfvf *pfvf;
+	atomic64_t *ptr;
+	int nixlf, sq;
 	u16 pcifunc;
-	int nixlf;
 
 	smq_txsch = &nix_hw->txsch[NIX_TXSCH_LVL_SMQ];
 	pcifunc = TXSCH_MAP_FUNC(smq_txsch->pfvf_map[smq]);
@@ -340,8 +390,39 @@ static bool is_sq_stalled(struct rvu *rvu, struct nix_hw *nix_hw, int smq)
 	if (!tx_stall->nixlf_tl2_count[nixlf])
 		return false;
 
-	/* TODO: SQ stats checking */
-	return false;
+	pfvf = rvu_get_pfvf(rvu, pcifunc);
+
+	/* Enable BAR2 register access from AF BAR2 alias registers*/
+	cfg = BIT_ULL(16) | pcifunc;
+	rvu_wr64(rvu, blkaddr, RVU_AF_BAR2_SEL, cfg);
+
+	for (sq = 0; sq < pfvf->sq_ctx->qsize; sq++) {
+		if (!is_sq_allocated(rvu, pfvf, blkaddr, sq))
+			continue;
+
+		rvu_nix_txsch_lock(nix_hw);
+		if (tx_stall->sq_smq_map[nixlf * sq_count + sq] != smq) {
+			rvu_nix_txsch_unlock(nix_hw);
+			continue;
+		}
+		rvu_nix_txsch_unlock(nix_hw);
+
+		incr = (u64)sq << 32;
+		ptr = (__force atomic64_t *)(rvu->afreg_base + ((blkaddr << 28)
+			| RVU_AF_BAR2_ALIASX(nixlf, NIX_LF_SQ_OP_OCTS)));
+
+		btx_octs = atomic64_fetch_add_relaxed(incr, ptr);
+		usleep_range(50, 60);
+		atx_octs = atomic64_fetch_add_relaxed(incr, ptr);
+		/* If atleast one SQ is transmitting pkts then SMQ is
+		 * not stalled.
+		 */
+		if (btx_octs != atx_octs)
+			return false;
+	}
+	tx_stall->nixlf_stall_count[nixlf]++;
+
+	return true;
 }
 
 static bool rvu_nix_check_smq_stall(struct rvu *rvu, struct nix_hw *nix_hw,
@@ -670,6 +751,18 @@ static int rvu_nix_tx_stall_workaround_init(struct rvu *rvu,
 	if (err)
 		return err;
 
+	block = &hw->block[blkaddr];
+	tx_stall->sq_count = min_t(int, num_online_cpus(), OTX2_MAX_CQ_CNT);
+
+	/* SMQs to nixlf SQ mapping info */
+	tx_stall->sq_smq_map = devm_kcalloc(rvu->dev,
+					    block->lf.max * tx_stall->sq_count,
+					    sizeof(u16), GFP_KERNEL);
+	if (!tx_stall->sq_smq_map)
+		return -ENOMEM;
+	memset(tx_stall->sq_smq_map, U16_MAX,
+	       block->lf.max * tx_stall->sq_count * sizeof(u16));
+
 	/* TL2 to transmit link mapping info */
 	tx_stall->tl2_link_map = devm_kcalloc(rvu->dev, tx_stall->tl2_count,
 					      sizeof(u16), GFP_KERNEL);
@@ -679,7 +772,6 @@ static int rvu_nix_tx_stall_workaround_init(struct rvu *rvu,
 	       tx_stall->tl2_count * sizeof(u16));
 
 	/* Number of Tl2s attached to NIXLF */
-	block = &hw->block[blkaddr];
 	tx_stall->nixlf_tl2_count = devm_kcalloc(rvu->dev, block->lf.max,
 						 sizeof(u8), GFP_KERNEL);
 	if (!tx_stall->nixlf_tl2_count)
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c
index 454578bdbcf8..bba1a58a496c 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c
@@ -670,6 +670,8 @@ static int rvu_nix_aq_enq_inst(struct rvu *rvu, struct nix_aq_enq_req *req,
 		if (!is_valid_txschq(rvu, blkaddr, NIX_TXSCH_LVL_SMQ,
 				     pcifunc, req->sq.smq))
 			return NIX_AF_ERR_AQ_ENQUEUE;
+		rvu_nix_update_sq_smq_mapping(rvu, blkaddr, nixlf, req->qidx,
+					      req->sq.smq);
 	}
 
 	memset(&inst, 0, sizeof(struct nix_aq_inst_s));
-- 
2.31.1

