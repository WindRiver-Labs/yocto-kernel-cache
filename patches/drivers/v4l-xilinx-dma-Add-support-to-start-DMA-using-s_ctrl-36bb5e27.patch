From 6dbac673f0e33c408f658a5ef24e9414342958d5 Mon Sep 17 00:00:00 2001
From: Devarsh Thakkar <devarsh.thakkar@xilinx.com>
Date: Wed, 7 Aug 2019 11:44:36 -0700
Subject: [PATCH 0657/1851] v4l: xilinx: dma: Add support to start DMA using
 s_ctrl

commit ad6368516938e72fb65467c1896cede0127827ad from
https://github.com/Xilinx/linux-xlnx.git

This patch adds new control value under existing control id
V4L2_CID_XILINX_START_DMA, which can be used by application
to start DMA engine.

For low latency capture we are targeting below flow:
1) Application queues buffer to v4l2 client using VIDIOC_QBUF
2) Applications issues streamon using VIDIOC_STREAMON
  - At this point, we need to defer starting the dma when application
    calls the streamon, as here we need to send an empty buffer to
    consumer so that it can read the stride and initialize itself.
    So we don't issue pending transactions on streamon.
  - But the application is still able to dequeue the queued empty
    buffers as we are marking them as done in videobuf2 list
    straightaway when they are queued and we are in streaming state.

3) Applications signals to start dma once consumer is ready
   - At this point, we need to start the actual dma transfer by
     issueing the pending transactions.

This helps the application to follow the same order of qbuf, streamon,
poll, dqbuf as in normal scenario and signal the readiness of consumer
explicitly using this mechanism.

Signed-off-by: Devarsh Thakkar <devarsh.thakkar@xilinx.com>
Signed-off-by: Satish Kumar Nagireddy <satish.nagireddy.nagireddy@xilinx.com>
Reviewed-by: Hyun Kwon <hyun.kwon@xilinx.com>
State: pending
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 drivers/media/platform/xilinx/xilinx-dma.c | 29 ++++++++++++++++------
 include/uapi/linux/xilinx-v4l2-controls.h  |  3 +++
 2 files changed, 25 insertions(+), 7 deletions(-)

diff --git a/drivers/media/platform/xilinx/xilinx-dma.c b/drivers/media/platform/xilinx/xilinx-dma.c
index 1a8533a927ba..c16dbcc53072 100644
--- a/drivers/media/platform/xilinx/xilinx-dma.c
+++ b/drivers/media/platform/xilinx/xilinx-dma.c
@@ -1131,19 +1131,34 @@ xvip_dma_set_ctrl(struct file *file, void *fh, struct v4l2_control *ctl)
 	struct xvip_dma *dma = to_xvip_dma(vfh->vdev);
 	int ret = 0;
 
-	if (vb2_is_busy(&dma->queue))
-		return -EBUSY;
-
 	switch (ctl->id)  {
 	case V4L2_CID_XILINX_LOW_LATENCY:
-		if (ctl->value == XVIP_LOW_LATENCY_ENABLE)
+		if (ctl->value == XVIP_LOW_LATENCY_ENABLE) {
+			if (vb2_is_busy(&dma->queue))
+				return -EBUSY;
+
 			dma->low_latency_cap = true;
-		else if (ctl->value == XVIP_LOW_LATENCY_DISABLE)
+		} else if (ctl->value == XVIP_LOW_LATENCY_DISABLE) {
+			if (vb2_is_busy(&dma->queue))
+				return -EBUSY;
+
 			dma->low_latency_cap = false;
-		else
+		} else if (ctl->value == XVIP_START_DMA) {
+			/*
+			 * In low latency capture, the driver allows application
+			 * to start dma when queue has buffers. That's why we
+			 * don't check for vb2_is_busy().
+			 */
+			if (dma->low_latency_cap &&
+			    vb2_is_streaming(&dma->queue))
+				dma_async_issue_pending(dma->dma);
+			else
+				ret = -EINVAL;
+		} else {
 			ret = -EINVAL;
+		}
 
-	break;
+		break;
 	default:
 		ret = -EINVAL;
 	}
diff --git a/include/uapi/linux/xilinx-v4l2-controls.h b/include/uapi/linux/xilinx-v4l2-controls.h
index 3c7eafcb7e1e..974c1100f6ef 100644
--- a/include/uapi/linux/xilinx-v4l2-controls.h
+++ b/include/uapi/linux/xilinx-v4l2-controls.h
@@ -216,4 +216,7 @@
 /* Control values to enable/disable low latency capture mode */
 #define XVIP_LOW_LATENCY_ENABLE		BIT(1)
 #define XVIP_LOW_LATENCY_DISABLE	BIT(2)
+
+/* Control value to start DMA */
+#define XVIP_START_DMA			BIT(3)
 #endif /* __UAPI_XILINX_V4L2_CONTROLS_H__ */
-- 
2.31.1

