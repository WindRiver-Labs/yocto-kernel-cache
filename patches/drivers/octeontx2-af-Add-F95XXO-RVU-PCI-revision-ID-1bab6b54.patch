From b00c9a55bc4abace50f1631de3ff31ac5e64dc06 Mon Sep 17 00:00:00 2001
From: Geetha sowjanya <gakula@marvell.com>
Date: Mon, 15 Feb 2021 11:16:29 +0530
Subject: [PATCH 1257/1921] octeontx2-af: Add F95XXO RVU PCI revision ID

This patch adds F95O PCI revision id to the platform check
and PTP subsystem id to the PCI device table.

Change-Id: Ia5653cc9c46d51c17fe33c30a6ba08abb872fe6e
Signed-off-by: Geetha sowjanya <gakula@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/45974
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 .../net/ethernet/marvell/octeontx2/af/ptp.c   |  8 ++++++++
 .../net/ethernet/marvell/octeontx2/af/rvu.c   |  5 ++---
 .../net/ethernet/marvell/octeontx2/af/rvu.h   | 20 +++++++------------
 .../ethernet/marvell/octeontx2/af/rvu_fixes.c |  2 +-
 .../marvell/octeontx2/nic/otx2_common.h       | 11 +++++-----
 .../marvell/octeontx2/nic/otx2_txrx.c         | 14 ++++++-------
 6 files changed, 29 insertions(+), 31 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/af/ptp.c b/drivers/net/ethernet/marvell/octeontx2/af/ptp.c
index fd9ed8c0960b..9564bd660724 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/ptp.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/ptp.c
@@ -21,6 +21,8 @@
 #define PCI_SUBSYS_DEVID_OCTX2_96XX_PTP		0xB200
 #define PCI_SUBSYS_DEVID_OCTX2_95XX_PTP		0xB300
 #define PCI_SUBSYS_DEVID_OCTX2_LOKI_PTP		0xB400
+#define PCI_SUBSYS_DEVID_OCTX2_95MM_PTP		0xB500
+#define PCI_SUBSYS_DEVID_OCTX2_95XXO_PTP	0xB600
 #define PCI_SUBSYS_DEVID_CN10K_A_PTP		0xB900
 #define PCI_SUBSYS_DEVID_CNF10K_A_PTP		0xBA00
 #define PCI_SUBSYS_DEVID_CNF10K_B_PTP		0xBC00
@@ -237,6 +239,12 @@ static const struct pci_device_id ptp_id_table[] = {
 	{ PCI_DEVICE_SUB(PCI_VENDOR_ID_CAVIUM, PCI_DEVID_OCTEONTX2_PTP,
 			 PCI_VENDOR_ID_CAVIUM,
 			 PCI_SUBSYS_DEVID_OCTX2_LOKI_PTP) },
+	{ PCI_DEVICE_SUB(PCI_VENDOR_ID_CAVIUM, PCI_DEVID_OCTEONTX2_PTP,
+			 PCI_VENDOR_ID_CAVIUM,
+			 PCI_SUBSYS_DEVID_OCTX2_95MM_PTP) },
+	{ PCI_DEVICE_SUB(PCI_VENDOR_ID_CAVIUM, PCI_DEVID_OCTEONTX2_PTP,
+			 PCI_VENDOR_ID_CAVIUM,
+			 PCI_SUBSYS_DEVID_OCTX2_95XXO_PTP) },
 	{ PCI_DEVICE_SUB(PCI_VENDOR_ID_CAVIUM, PCI_DEVID_OCTEONTX2_PTP,
 			 PCI_VENDOR_ID_CAVIUM,
 			 PCI_SUBSYS_DEVID_CN10K_A_PTP) },
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu.c
index 0e9127496647..ba16b053e9a2 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu.c
@@ -73,8 +73,7 @@ static void rvu_setup_hw_capabilities(struct rvu *rvu)
 	hw->cap.nix_shaper_toggle_wait = false;
 	hw->rvu = rvu;
 
-	if (is_rvu_96xx_B0(rvu) || is_rvu_95xx_A0(rvu) ||
-	    is_rvu_95xx_B0(rvu)) {
+	if (is_rvu_pre_96xx_C0(rvu)) {
 		hw->cap.nix_fixed_txschq_mapping = true;
 		hw->cap.nix_txsch_per_cgx_lmac = 4;
 		hw->cap.nix_txsch_per_lbk_lmac = 132;
@@ -84,7 +83,7 @@ static void rvu_setup_hw_capabilities(struct rvu *rvu)
 		if (is_rvu_96xx_A0(rvu) || is_rvu_95xx_A0(rvu))
 			hw->cap.nix_rx_multicast = false;
 	}
-	if (is_rvu_post_96xx_C0(rvu))
+	if (!is_rvu_pre_96xx_C0(rvu))
 		hw->cap.nix_shaper_toggle_wait = true;
 
 	if (!is_rvu_otx2(rvu))
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu.h b/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
index 005b75662b9a..f805fa1ea8d2 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
@@ -530,13 +530,13 @@ static inline u64 rvupf_read64(struct rvu *rvu, u64 offset)
 }
 
 /* Silicon revisions */
-
-static inline bool is_rvu_post_96xx_C0(struct rvu *rvu)
+static inline bool is_rvu_pre_96xx_C0(struct rvu *rvu)
 {
 	struct pci_dev *pdev = rvu->pdev;
-
-	return (pdev->revision == 0x08) || (pdev->revision == 0x30) ||
-		(pdev->revision == 0x20);
+	/* 96XX A0/B0, 95XX A0/A1/B0 chips */
+	return ((pdev->revision == 0x00) || (pdev->revision == 0x01) ||
+		(pdev->revision == 0x10) || (pdev->revision == 0x11) ||
+		(pdev->revision == 0x14));
 }
 
 static inline bool is_rvu_96xx_A0(struct rvu *rvu)
@@ -553,13 +553,6 @@ static inline bool is_rvu_96xx_B0(struct rvu *rvu)
 	return (pdev->revision == 0x00) || (pdev->revision == 0x01);
 }
 
-static inline bool is_rvu_95xx_B0(struct rvu *rvu)
-{
-	struct pci_dev *pdev = rvu->pdev;
-
-	return (pdev->revision == 0x14);
-}
-
 static inline bool is_rvu_95xx_A0(struct rvu *rvu)
 {
 	struct pci_dev *pdev = rvu->pdev;
@@ -576,6 +569,7 @@ static inline bool is_rvu_95xx_A0(struct rvu *rvu)
 #define PCI_REVISION_ID_LOKI		0x20
 #define PCI_REVISION_ID_98XX		0x30
 #define PCI_REVISION_ID_95XXMM		0x40
+#define PCI_REVISION_ID_95XXO		0xE0
 
 static inline bool is_rvu_otx2(struct rvu *rvu)
 {
@@ -585,7 +579,7 @@ static inline bool is_rvu_otx2(struct rvu *rvu)
 
 	return (midr == PCI_REVISION_ID_96XX || midr == PCI_REVISION_ID_95XX ||
 		midr == PCI_REVISION_ID_LOKI || midr == PCI_REVISION_ID_98XX ||
-		midr == PCI_REVISION_ID_95XXMM);
+		midr == PCI_REVISION_ID_95XXMM || midr == PCI_REVISION_ID_95XXO);
 }
 
 static inline bool is_cgx_mapped_to_nix(unsigned short id, u8 cgx_id)
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_fixes.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_fixes.c
index a6c7baca4e7a..05f1bdc0555b 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_fixes.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_fixes.c
@@ -884,7 +884,7 @@ int rvu_nix_fixes_init(struct rvu *rvu, struct nix_hw *nix_hw, int blkaddr)
 	if (is_rvu_96xx_A0(rvu))
 		rvu_write64(rvu, blkaddr, NIX_AF_CFG,
 			    rvu_read64(rvu, blkaddr, NIX_AF_CFG) | 0x5EULL);
-	if (!is_rvu_post_96xx_C0(rvu))
+	if (is_rvu_pre_96xx_C0(rvu))
 		rvu_write64(rvu, blkaddr, NIX_AF_CFG,
 			    rvu_read64(rvu, blkaddr, NIX_AF_CFG) | 0x40ULL);
 
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h
index 0ba5b5fa1517..96df92e18c65 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h
@@ -388,11 +388,6 @@ static inline bool is_otx2_lbkvf(struct pci_dev *pdev)
 	return pdev->device == PCI_DEVID_OCTEONTX2_RVU_AFVF;
 }
 
-static inline bool is_dev_post_96xx_C0(struct pci_dev *pdev)
-{
-	return (pdev->revision == 0x08) || (pdev->revision == 0x30);
-}
-
 static inline bool is_96xx_A0(struct pci_dev *pdev)
 {
 	return (pdev->revision == 0x00);
@@ -418,6 +413,7 @@ static inline bool is_95xx_A0(struct pci_dev *pdev)
 #define PCI_REVISION_ID_LOKI		0x20
 #define PCI_REVISION_ID_98XX		0x30
 #define PCI_REVISION_ID_95XXMM		0x40
+#define PCI_REVISION_ID_95XXO		0xE0
 
 static inline bool is_dev_otx2(struct pci_dev *pdev)
 {
@@ -425,7 +421,7 @@ static inline bool is_dev_otx2(struct pci_dev *pdev)
 
 	return (midr == PCI_REVISION_ID_96XX || midr == PCI_REVISION_ID_95XX ||
 		midr == PCI_REVISION_ID_LOKI || midr == PCI_REVISION_ID_98XX ||
-		midr == PCI_REVISION_ID_95XXMM);
+		midr == PCI_REVISION_ID_95XXMM || midr == PCI_REVISION_ID_95XXO);
 }
 
 static inline void otx2_setup_dev_hw_settings(struct otx2_nic *pfvf)
@@ -455,6 +451,9 @@ static inline void otx2_setup_dev_hw_settings(struct otx2_nic *pfvf)
 		 */
 		pfvf->netdev->watchdog_timeo = 10000 * HZ;
 	}
+	if (is_96xx_B0(pfvf->pdev))
+		__clear_bit(HW_TSO, &hw->cap_flag);
+
 	if (!is_dev_otx2(pfvf->pdev)) {
 		__set_bit(CN10K_MBOX, &hw->cap_flag);
 		__set_bit(CN10K_LMTST, &hw->cap_flag);
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_txrx.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_txrx.c
index 602209d85ed6..07e4d9262ff6 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_txrx.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_txrx.c
@@ -897,24 +897,22 @@ static bool is_hw_tso_supported(struct otx2_nic *pfvf,
 {
 	int payload_len, last_seg_size;
 
-
-	if (is_dev_post_96xx_C0(pfvf->pdev))
+	if (test_bit(HW_TSO, &pfvf->hw.cap_flag))
 		return true;
+
+	/* On 96xx A0, HW TSO not supported */
+	if (!is_96xx_B0(pfvf->pdev))
+		return false;
+
 	/* HW has an issue due to which when the payload of the last LSO
 	 * segment is shorter than 16 bytes, some header fields may not
 	 * be correctly modified, hence don't offload such TSO segments.
 	 */
-	if (!is_96xx_B0(pfvf->pdev))
-		return true;
-
 	payload_len = skb->len - (skb_transport_offset(skb) + tcp_hdrlen(skb));
 	last_seg_size = payload_len % skb_shinfo(skb)->gso_size;
 	if (last_seg_size && last_seg_size < 16)
 		return false;
 
-	if (test_bit(HW_TSO, &pfvf->hw.cap_flag))
-		return true;
-
 	return true;
 }
 
-- 
2.31.1

