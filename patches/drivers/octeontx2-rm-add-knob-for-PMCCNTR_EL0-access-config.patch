From 9fbe0d8b3217ed98836a6ea6efd40775edbc76fe Mon Sep 17 00:00:00 2001
From: Stanislaw Kardach <skardach@marvell.com>
Date: Wed, 24 Jul 2019 16:58:23 +0200
Subject: [PATCH 297/767] octeontx2-rm: add knob for PMCCNTR_EL0 access config

commit 1a627a67e2666cea8ac2003ea74b69f83291c855 from
git@git.assembla.com:cavium/WindRiver.linux.git

Add a sysfs file to configure the PMCCNTR access in EL0.
Writing 1 to /sys/bus/pci/drivers/octeontx2-rm/0*/pmccntr_el0 will
enable access to userspace, while 0 will disable it.
Reading this file will print a compined enable status for all cores.
Value read will be 1 if counter is enabled on all cores.
Access is enabled with as little PMU register modifications as possible.

Change-Id: Ib48328e16d4ed62319c39d4d896891ae9eec4130
Signed-off-by: Stanislaw Kardach <skardach@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/13261
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
(cherry picked from commit 350ae2c8e8cf6cac7eece31b78a8aaacbebd2498)
Reviewed-on: https://sj1git1.cavium.com/13536
Tested-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../soc/marvell/octeontx2-rm/domain_sysfs.c   | 100 ++++++++++++++++++
 1 file changed, 100 insertions(+)

diff --git a/drivers/soc/marvell/octeontx2-rm/domain_sysfs.c b/drivers/soc/marvell/octeontx2-rm/domain_sysfs.c
index 7e2193f3222d..9101edea8118 100644
--- a/drivers/soc/marvell/octeontx2-rm/domain_sysfs.c
+++ b/drivers/soc/marvell/octeontx2-rm/domain_sysfs.c
@@ -74,6 +74,7 @@ struct domain_sysfs {
 	struct list_head	list;
 	struct kobj_attribute	create_domain;
 	struct kobj_attribute	destroy_domain;
+	struct kobj_attribute	pmccntr_el0;
 	/* List of all ports added to all domains. Used for validating if new
 	 * domain creation doesn't want to take an already taken port.
 	 */
@@ -635,6 +636,93 @@ static void dpivf_sysfs_destroy(struct domain_sysfs *lsfs)
 	dpi_info->dpi_vf = NULL;
 }
 
+
+static void enable_pmccntr_el0(void *data)
+{
+	u64 val;
+	/* Disable cycle counter overflow interrupt */
+	asm volatile("mrs %0, pmintenset_el1" : "=r" (val));
+	val &= ~BIT_ULL(31);
+	asm volatile("msr pmintenset_el1, %0" : : "r" (val));
+	/* Enable cycle counter */
+	asm volatile("mrs %0, pmcntenset_el0" : "=r" (val));
+	val |= BIT_ULL(31);
+	asm volatile("msr pmcntenset_el0, %0" :: "r" (val));
+	/* Enable user-mode access to cycle counters. */
+	asm volatile("mrs %0, pmuserenr_el0" : "=r" (val));
+	val |= BIT(2) | BIT(0);
+	asm volatile("msr pmuserenr_el0, %0" : : "r"(val));
+	/* Start cycle counter */
+	asm volatile("mrs %0, pmcr_el0" : "=r" (val));
+	val |= BIT(0);
+	isb();
+	asm volatile("msr pmcr_el0, %0" : : "r" (val));
+	asm volatile("mrs %0, pmccfiltr_el0" : "=r" (val));
+	val |= BIT(27);
+	asm volatile("msr pmccfiltr_el0, %0" : : "r" (val));
+}
+
+static void disable_pmccntr_el0(void *data)
+{
+	u64 val;
+	/* Disable cycle counter */
+	asm volatile("mrs %0, pmcntenset_el0" : "=r" (val));
+	val &= ~BIT_ULL(31);
+	asm volatile("msr pmcntenset_el0, %0" :: "r" (val));
+	/* Disable user-mode access to counters. */
+	asm volatile("mrs %0, pmuserenr_el0" : "=r" (val));
+	val &= ~(BIT(2) | BIT(0));
+	asm volatile("msr pmuserenr_el0, %0" : : "r"(val));
+}
+
+static ssize_t
+enadis_pmccntr_el0_store(struct kobject *kobj, struct kobj_attribute *attr,
+			 const char *buf, size_t count)
+{
+	struct domain_sysfs *lsfs = container_of(attr, struct domain_sysfs,
+						 pmccntr_el0);
+	struct device *dev = &lsfs->rdev->pdev->dev;
+	char tmp_buf[64];
+	long enable = 0;
+	char *tmp_ptr;
+	ssize_t used;
+
+	strlcpy(tmp_buf, buf, 64);
+	used = strlen(tmp_buf);
+	tmp_ptr = strim(tmp_buf);
+	if (kstrtol(tmp_ptr, 0, &enable)) {
+		dev_err(dev, "Invalid value, expected 1/0\n");
+		return -EIO;
+	}
+
+	if (enable)
+		on_each_cpu(enable_pmccntr_el0, NULL, 1);
+	else
+		on_each_cpu(disable_pmccntr_el0, NULL, 1);
+
+	return count;
+}
+
+static void check_pmccntr_el0(void *data)
+{
+	int *out = data;
+	u64 val;
+
+	asm volatile("mrs %0, pmuserenr_el0" : "=r" (val));
+	*out = *out & !!(val & (BIT(2) | BIT(0)));
+}
+
+static ssize_t
+enadis_pmccntr_el0_show(struct kobject *kobj, struct kobj_attribute *attr,
+			char *buf)
+{
+	int out = 1;
+
+	on_each_cpu(check_pmccntr_el0, &out, 1);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", out);
+}
+
 int domain_sysfs_create(struct rm_dev *rm)
 {
 	struct domain_sysfs *lsfs;
@@ -674,6 +762,14 @@ int domain_sysfs_create(struct rm_dev *rm)
 	if (res)
 		goto err_destroy_domain;
 
+	lsfs->pmccntr_el0.attr.name = "pmccntr_el0";
+	lsfs->pmccntr_el0.attr.mode = 0644;
+	lsfs->pmccntr_el0.show = enadis_pmccntr_el0_show;
+	lsfs->pmccntr_el0.store = enadis_pmccntr_el0_store;
+	res = sysfs_create_file(&rm->pdev->dev.kobj, &lsfs->pmccntr_el0.attr);
+	if (res)
+		goto err_pmccntr_el0;
+
 	lsfs->parent = &rm->pdev->dev.kobj;
 
 	res = dpivf_sysfs_create(lsfs);
@@ -687,6 +783,8 @@ int domain_sysfs_create(struct rm_dev *rm)
 	return 0;
 
 err_dpivf_sysfs_create:
+	sysfs_remove_file(&rm->pdev->dev.kobj, &lsfs->pmccntr_el0.attr);
+err_pmccntr_el0:
 	sysfs_remove_file(&rm->pdev->dev.kobj, &lsfs->destroy_domain.attr);
 err_destroy_domain:
 	sysfs_remove_file(&rm->pdev->dev.kobj, &lsfs->create_domain.attr);
@@ -722,6 +820,8 @@ void domain_sysfs_destroy(struct rm_dev *rm)
 
 	dpivf_sysfs_destroy(lsfs);
 
+	if (lsfs->pmccntr_el0.attr.mode != 0)
+		sysfs_remove_file(lsfs->parent, &lsfs->pmccntr_el0.attr);
 	if (lsfs->destroy_domain.attr.mode != 0)
 		sysfs_remove_file(lsfs->parent, &lsfs->destroy_domain.attr);
 	if (lsfs->create_domain.attr.mode != 0)
-- 
2.31.1

