From 6d89ec92773420ef9f99bb621c400e3a861b0ac9 Mon Sep 17 00:00:00 2001
From: Christina Jacob <cjacob@marvell.com>
Date: Fri, 9 Aug 2019 11:25:05 +0530
Subject: [PATCH 336/767] net: thunderx: Do a PCS reset upon SGMII link toggle

commit 0f603cd4405febd9b9839383fca796471d223498 from
git@git.assembla.com:cavium/WindRiver.linux.git

When physical link toggles with BGX mode being SGMII, BGX to Serdes
link needs to be reset for it to function normally otherwise packet
IO won't work.

This patch does the PCS reset to get IO functioning again when the
traffic is running, otherwise if we unplug the ethernet cable from
SGMII port and plug it again, it may malfunction.

Change-Id: I99bd80f3fbdc765c2c4209c9210d5e5028cf65d9
Signed-off-by: Christina Jacob <cjacob@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/15266
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Tested-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../net/ethernet/cavium/thunder/thunder_bgx.c | 35 ++++++-------------
 1 file changed, 11 insertions(+), 24 deletions(-)

diff --git a/drivers/net/ethernet/cavium/thunder/thunder_bgx.c b/drivers/net/ethernet/cavium/thunder/thunder_bgx.c
index a0681a0f0077..431234a2a390 100644
--- a/drivers/net/ethernet/cavium/thunder/thunder_bgx.c
+++ b/drivers/net/ethernet/cavium/thunder/thunder_bgx.c
@@ -571,12 +571,13 @@ static void bgx_sgmii_change_link_state(struct lmac *lmac)
 	}
 	bgx_reg_write(bgx, lmac->lmacid, BGX_GMP_PCS_MISCX_CTL, misc_ctl);
 	bgx_reg_write(bgx, lmac->lmacid, BGX_GMP_GMI_PRTX_CFG, port_cfg);
-
-	bgx_reg_modify(bgx, lmac->lmacid, BGX_GMP_PCS_MRX_CTL,
-		       PCS_MRX_CTL_RESET);
-	if (bgx_poll_reg(bgx, lmac->lmacid, BGX_GMP_PCS_MRX_CTL,
-			 PCS_MRX_CTL_RESET, true)) {
-		dev_err(&bgx->pdev->dev, "BGX PCS reset not completed\n");
+	if (!bgx->is_rgx) {
+		bgx_reg_modify(bgx, lmac->lmacid, BGX_GMP_PCS_MRX_CTL,
+			       PCS_MRX_CTL_RESET);
+		if (bgx_poll_reg(bgx, lmac->lmacid, BGX_GMP_PCS_MRX_CTL,
+				 PCS_MRX_CTL_RESET, true)) {
+			dev_err(&bgx->pdev->dev, "BGX PCS reset not completed\n");
+		}
 	}
 
 	/* Restore CMR config settings */
@@ -591,35 +592,21 @@ static void bgx_lmac_handler(struct net_device *netdev)
 {
 	struct lmac *lmac = container_of(netdev, struct lmac, netdev);
 	struct phy_device *phydev;
-	int link_changed = 0;
 
 	if (!lmac)
 		return;
 
 	phydev = lmac->phydev;
 
-	if (!phydev->link && lmac->last_link)
-		link_changed = -1;
-
-	if (phydev->link &&
-	    (lmac->last_duplex != phydev->duplex ||
-	     lmac->last_link != phydev->link ||
-	     lmac->last_speed != phydev->speed)) {
-			link_changed = 1;
-	}
+	if (phydev->link == 1)
+		lmac->link_up = true;
+	else
+		lmac->link_up = false;
 
 	lmac->last_link = phydev->link;
 	lmac->last_speed = phydev->speed;
 	lmac->last_duplex = phydev->duplex;
 
-	if (!link_changed)
-		return;
-
-	if (link_changed > 0)
-		lmac->link_up = true;
-	else
-		lmac->link_up = false;
-
 	if (lmac->is_sgmii)
 		bgx_sgmii_change_link_state(lmac);
 	else
-- 
2.31.1

