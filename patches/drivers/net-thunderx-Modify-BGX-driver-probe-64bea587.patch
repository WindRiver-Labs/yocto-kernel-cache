From 8d93d2bfecd8c480473f6a7bdd350af2d2db7aac Mon Sep 17 00:00:00 2001
From: Hariprasad Kelam <hkelam@marvell.com>
Date: Fri, 12 Feb 2021 10:50:54 +0530
Subject: [PATCH 1289/1921] net: thunderx: Modify BGX driver probe

current design is that, BGX driver probe fails in case
of failure in finding of phy device associated with
any one of lmac. Which results in all lmacs connected that
BGX wont be available to NIC driver.

This patch changes the probe of BGX device such that only
lmacs failed in discovering phy device will be released and
other lmacs will be available to NIC driver usage.

With this changes
	- Lmacs which are not associated with phy device wont be
	  enabled and bgx lmac count is updated accordingly

Change-Id: I2ba8c421c4f6d5b462dbd42ad9902b8d09294f61
Signed-off-by: Hariprasad Kelam <hkelam@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/47224
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 .../net/ethernet/cavium/thunder/nic_main.c    |  5 +-
 .../net/ethernet/cavium/thunder/thunder_bgx.c | 51 ++++++++++---------
 .../net/ethernet/cavium/thunder/thunder_bgx.h |  1 +
 3 files changed, 33 insertions(+), 24 deletions(-)

diff --git a/drivers/net/ethernet/cavium/thunder/nic_main.c b/drivers/net/ethernet/cavium/thunder/nic_main.c
index 9361f964bb9b..bc8c84b19587 100644
--- a/drivers/net/ethernet/cavium/thunder/nic_main.c
+++ b/drivers/net/ethernet/cavium/thunder/nic_main.c
@@ -318,6 +318,7 @@ static void nic_set_lmac_vf_mapping(struct nicpf *nic)
 {
 	unsigned bgx_map = bgx_get_map(nic->node);
 	int bgx, next_bgx_lmac = 0;
+	unsigned long lmac_bmap;
 	int lmac, lmac_cnt = 0;
 	u64 lmac_credit;
 
@@ -327,7 +328,9 @@ static void nic_set_lmac_vf_mapping(struct nicpf *nic)
 		if (!(bgx_map & (1 << bgx)))
 			continue;
 		lmac_cnt = bgx_get_lmac_count(nic->node, bgx);
-		for (lmac = 0; lmac < lmac_cnt; lmac++)
+		lmac_bmap = bgx_get_lmac_bmap(nic->node, bgx);
+
+		for_each_set_bit(lmac, &lmac_bmap, MAX_LMAC_PER_BGX)
 			nic->vf_lmac_map[next_bgx_lmac++] =
 						NIC_SET_VF_LMAC_MAP(bgx, lmac);
 		nic->num_vf_en += lmac_cnt;
diff --git a/drivers/net/ethernet/cavium/thunder/thunder_bgx.c b/drivers/net/ethernet/cavium/thunder/thunder_bgx.c
index 27632c3b3b3a..4033401041cc 100644
--- a/drivers/net/ethernet/cavium/thunder/thunder_bgx.c
+++ b/drivers/net/ethernet/cavium/thunder/thunder_bgx.c
@@ -74,6 +74,7 @@ struct bgx {
 	struct pci_dev		*pdev;
 	bool                    is_dlm;
 	bool                    is_rgx;
+	unsigned long		lmac_bmap; /* bitmap of enabled lmacs */
 };
 
 static struct bgx *bgx_vnic[MAX_BGX_THUNDER];
@@ -196,12 +197,24 @@ int bgx_get_lmac_count(int node, int bgx_idx)
 
 	bgx = get_bgx(node, bgx_idx);
 	if (bgx)
-		return bgx->lmac_count;
+		return hweight64(bgx->lmac_bmap);
 
 	return 0;
 }
 EXPORT_SYMBOL(bgx_get_lmac_count);
 
+unsigned long bgx_get_lmac_bmap(int node, int bgx_idx)
+{
+	struct bgx *bgx;
+
+	bgx = get_bgx(node, bgx_idx);
+	if (bgx)
+		return bgx->lmac_bmap;
+
+	return 0;
+}
+EXPORT_SYMBOL(bgx_get_lmac_bmap);
+
 /* Returns the current link status of LMAC */
 void bgx_get_lmac_link_state(int node, int bgx_idx, int lmacid, void *status)
 {
@@ -1192,7 +1205,7 @@ static void bgx_init_hw(struct bgx *bgx)
 		dev_err(&bgx->pdev->dev, "BGX%d BIST failed\n", bgx->bgx_id);
 
 	/* Set lmac type and lane2serdes mapping */
-	for (i = 0; i < bgx->lmac_count; i++) {
+	for_each_set_bit(i, &bgx->lmac_bmap, MAX_LMAC_PER_BGX) {
 		lmac = &bgx->lmac[i];
 		bgx_reg_write(bgx, i, BGX_CMRX_CFG,
 			      (lmac->lmac_type << 8) | lmac->lane_to_sds);
@@ -1204,7 +1217,7 @@ static void bgx_init_hw(struct bgx *bgx)
 	bgx_reg_write(bgx, 0, BGX_CMR_RX_LMACS, bgx->lmac_count);
 
 	/* Set the backpressure AND mask */
-	for (i = 0; i < bgx->lmac_count; i++)
+	for_each_set_bit(i, &bgx->lmac_bmap, MAX_LMAC_PER_BGX)
 		bgx_reg_modify(bgx, 0, BGX_CMR_CHAN_MSK_AND,
 			       ((1ULL << MAX_BGX_CHANS_PER_LMAC) - 1) <<
 			       (i * MAX_BGX_CHANS_PER_LMAC));
@@ -1470,6 +1483,7 @@ static int bgx_init_of_phy(struct bgx *bgx)
 {
 	struct fwnode_handle *fwn;
 	struct device_node *node = NULL;
+	bool phy_reset;
 	u8 lmac = 0;
 
 	device_for_each_child_node(&bgx->pdev->dev, fwn) {
@@ -1477,6 +1491,7 @@ static int bgx_init_of_phy(struct bgx *bgx)
 		struct device_node *phy_np;
 		const char *mac;
 
+		phy_reset = false;
 		/* Should always be an OF node.  But if it is not, we
 		 * cannot handle it, so exit the loop.
 		 */
@@ -1501,10 +1516,12 @@ static int bgx_init_of_phy(struct bgx *bgx)
 			/* Wait until the phy drivers are available */
 			pd = of_phy_find_device(phy_np);
 			if (!pd)
-				goto defer;
+				phy_reset = true;
 			bgx->lmac[lmac].phydev = pd;
 		}
 
+		if (!phy_reset)
+			set_bit(bgx->lmac[lmac].lmacid, &bgx->lmac_bmap);
 		lmac++;
 		if (lmac == bgx->max_lmac) {
 			of_node_put(node);
@@ -1512,20 +1529,6 @@ static int bgx_init_of_phy(struct bgx *bgx)
 		}
 	}
 	return 0;
-
-defer:
-	/* We are bailing out, try not to leak device reference counts
-	 * for phy devices we may have already found.
-	 */
-	while (lmac) {
-		if (bgx->lmac[lmac].phydev) {
-			put_device(&bgx->lmac[lmac].phydev->mdio.dev);
-			bgx->lmac[lmac].phydev = NULL;
-		}
-		lmac--;
-	}
-	of_node_put(node);
-	return -EPROBE_DEFER;
 }
 
 #else
@@ -1551,7 +1554,7 @@ static irqreturn_t bgx_intr_handler(int irq, void *data)
 	u64 status, val;
 	int lmac;
 
-	for (lmac = 0; lmac < bgx->lmac_count; lmac++) {
+	for_each_set_bit(lmac, &bgx->lmac_bmap, MAX_LMAC_PER_BGX) {
 		status = bgx_reg_read(bgx, lmac, BGX_GMP_GMI_TXX_INT);
 		if (status & GMI_TXX_INT_UNDFLW) {
 			pci_err(bgx->pdev, "BGX%d lmac%d UNDFLW\n",
@@ -1650,8 +1653,10 @@ static int bgx_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	bgx_get_qlm_mode(bgx);
 
-	err = bgx_init_phy(bgx);
-	if (err)
+	bgx_init_phy(bgx);
+
+	/* Fail case where no lmac is enabled */
+	if (!bgx->lmac_bmap)
 		goto err_enable;
 
 	bgx_init_hw(bgx);
@@ -1659,7 +1664,7 @@ static int bgx_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	bgx_register_intr(pdev);
 
 	/* Enable all LMACs */
-	for (lmac = 0; lmac < bgx->lmac_count; lmac++) {
+	for_each_set_bit(lmac, &bgx->lmac_bmap, MAX_LMAC_PER_BGX) {
 		err = bgx_lmac_enable(bgx, lmac);
 		if (err) {
 			dev_err(dev, "BGX%d failed to enable lmac%d\n",
@@ -1689,7 +1694,7 @@ static void bgx_remove(struct pci_dev *pdev)
 	u8 lmac;
 
 	/* Disable all LMACs */
-	for (lmac = 0; lmac < bgx->lmac_count; lmac++)
+	for_each_set_bit(lmac, &bgx->lmac_bmap, MAX_LMAC_PER_BGX)
 		bgx_lmac_disable(bgx, lmac);
 
 	pci_free_irq(pdev, GMPX_GMI_TX_INT, bgx);
diff --git a/drivers/net/ethernet/cavium/thunder/thunder_bgx.h b/drivers/net/ethernet/cavium/thunder/thunder_bgx.h
index cdea49392185..38732c593464 100644
--- a/drivers/net/ethernet/cavium/thunder/thunder_bgx.h
+++ b/drivers/net/ethernet/cavium/thunder/thunder_bgx.h
@@ -240,6 +240,7 @@ u64 bgx_get_rx_stats(int node, int bgx_idx, int lmac, int idx);
 u64 bgx_get_tx_stats(int node, int bgx_idx, int lmac, int idx);
 #define BGX_RX_STATS_COUNT 11
 #define BGX_TX_STATS_COUNT 18
+unsigned long bgx_get_lmac_bmap(int node, int bgx);
 
 struct bgx_stats {
 	u64 rx_stats[BGX_RX_STATS_COUNT];
-- 
2.31.1

