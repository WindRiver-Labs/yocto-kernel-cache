From 29dd1028d60c4fb7bd0fdee739e8458198396927 Mon Sep 17 00:00:00 2001
From: Hariprasad Kelam <hkelam@marvell.com>
Date: Mon, 8 Mar 2021 14:31:53 +0530
Subject: [PATCH 725/767] octeontx2-pf: Backport physical link settings

commit 2e605b8e20c73a9a74d4f4035b108cc24d2b2b5f from
git@git.assembla.com:cavium/WindRiver.linux.git

The current implementation does not reject user requested
modes event its not in support modes list. This patch
adds the same. Refactore the code such that adds input
validation before acquiring mbox lock.

Pass advertisied mode directly instead of BIT_ULL.

Change-Id: I1abb7dd80adbc674b0e537b2e4ed27c26dff7705
Signed-off-by: Hariprasad Kelam <hkelam@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/47407
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Signed-off-by: Abhishek Paliwal <paliwal.abhishek@windriver.com>
---
 .../marvell/octeontx2/nic/otx2_ethtool.c      | 103 +++++++++---------
 1 file changed, 50 insertions(+), 53 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_ethtool.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_ethtool.c
index 87cdff8c0cb4..89e645b26e87 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_ethtool.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_ethtool.c
@@ -44,7 +44,6 @@ struct otx2_stat {
 
 /* Physical link config */
 #define OTX2_ETHTOOL_SUPPORTED_MODES 0x638CFFF //110001110001100111111111111
-#define OTX2_ETHTOOL_ALL_MODES (ULLONG_MAX)
 
 enum link_mode {
        OTX2_MODE_SUPPORTED,
@@ -1149,75 +1148,73 @@ static int otx2_get_link_ksettings(struct net_device *netdev,
 	return 0;
 }
 
-#define OTX2_OVERWRITE_DEF	0x1
-static int otx2_populate_input_params(struct otx2_nic *pfvf,
-				      struct cgx_set_link_mode_req *req,
-				      u32 speed, u8 duplex, u8 autoneg,
-				      u8 phy_address)
+static void otx2_get_advertised_mode(const struct ethtool_link_ksettings *cmd,
+				     u64 *mode)
 {
-	if (!ethtool_validate_speed(speed) ||
-	    !ethtool_validate_duplex(duplex))
-		return -EINVAL;
-
-	if (autoneg != AUTONEG_ENABLE && autoneg != AUTONEG_DISABLE)
-		return -EINVAL;
-
-	if (phy_address == OTX2_OVERWRITE_DEF) {
-		req->args.speed = speed;
-		/* firmware expects 1 for half duplex and 0 for full duplex
-		 * hence inverting
-		 */
-		req->args.duplex = duplex ^ 0x1;
-		req->args.an = autoneg;
-	} else {
-		req->args.speed = SPEED_UNKNOWN;
-		req->args.duplex = DUPLEX_UNKNOWN;
-		req->args.an = AUTONEG_UNKNOWN;
-	}
+	u32 bit_pos;
 
-	return 0;
+	/* Firmware does not support requesting multiple advertised modes
+	 * return first set bit
+	 */
+	bit_pos = find_first_bit(cmd->link_modes.advertising,
+				 __ETHTOOL_LINK_MODE_MASK_NBITS);
+	if (bit_pos != __ETHTOOL_LINK_MODE_MASK_NBITS)
+		*mode = bit_pos;
 }
 
+#define OTX2_OVERWRITE_DEF 1
 static int otx2_set_link_ksettings(struct net_device *netdev,
 				   const struct ethtool_link_ksettings *cmd)
 {
-	unsigned long advertising = 0;
-	struct otx2_nic *pfvf = netdev_priv(netdev);
+	struct otx2_nic *pf = netdev_priv(netdev);
+	struct ethtool_link_ksettings cur_ks;
 	struct cgx_set_link_mode_req *req;
-	struct cgx_set_link_mode_rsp *rsp;
+	struct mbox *mbox = &pf->mbox;
 	int err = 0;
 
-	mutex_lock(&pfvf->mbox.lock);
-	req = otx2_mbox_alloc_msg_cgx_set_link_mode(&pfvf->mbox);
-	if (!req) {
-		mutex_unlock(&pfvf->mbox.lock);
-		return -EAGAIN;
-	}
+	memset(&cur_ks, 0, sizeof(struct ethtool_link_ksettings));
 
-	advertising = (*cmd->link_modes.advertising) & (OTX2_ETHTOOL_ALL_MODES);
-	if (!(advertising & (advertising - 1)) &&
-	    (advertising <= BIT_ULL(ETHTOOL_LINK_MODE_10000baseLRM_Full_BIT))) {
-		req->args.mode = advertising;
-	} else {
-		mutex_unlock(&pfvf->mbox.lock);
+	if (!ethtool_validate_speed(cmd->base.speed) ||
+	    !ethtool_validate_duplex(cmd->base.duplex))
 		return -EINVAL;
-	}
 
-	if (otx2_populate_input_params(pfvf, req, cmd->base.speed,
-				       cmd->base.duplex, cmd->base.autoneg,
-				       cmd->base.phy_address)) {
-		mutex_unlock(&pfvf->mbox.lock);
+	if (cmd->base.autoneg != AUTONEG_ENABLE &&
+	    cmd->base.autoneg != AUTONEG_DISABLE)
+		return -EINVAL;
+
+	otx2_get_link_ksettings(netdev, &cur_ks);
+
+	/* Check requested modes against supported modes by hardware */
+	if (!bitmap_subset(cmd->link_modes.advertising,
+			   cur_ks.link_modes.supported,
+			   __ETHTOOL_LINK_MODE_MASK_NBITS))
 		return -EINVAL;
+
+	mutex_lock(&mbox->lock);
+	req = otx2_mbox_alloc_msg_cgx_set_link_mode(&pf->mbox);
+	if (!req) {
+		err = -ENOMEM;
+		goto end;
 	}
 
-	err =  otx2_sync_mbox_msg(&pfvf->mbox);
-	if (!err) {
-		rsp = (struct cgx_set_link_mode_rsp *)
-			otx2_mbox_get_rsp(&pfvf->mbox.mbox, 0, &req->hdr);
-		if (rsp->status)
-			err =  rsp->status;
+	if (cmd->base.phy_address == OTX2_OVERWRITE_DEF) {
+		req->args.speed = cmd->base.speed;
+		/* firmware expects 1 for half duplex and 0 for full duplex
+		 * hence inverting
+		 */
+		req->args.duplex = cmd->base.duplex ^ 0x1;
+		req->args.an = cmd->base.autoneg;
+	} else {
+		req->args.speed = SPEED_UNKNOWN;
+		req->args.duplex = DUPLEX_UNKNOWN;
+		req->args.an = AUTONEG_UNKNOWN;
 	}
-	mutex_unlock(&pfvf->mbox.lock);
+
+	otx2_get_advertised_mode(cmd, &req->args.mode);
+
+	err = otx2_sync_mbox_msg(&pf->mbox);
+end:
+	mutex_unlock(&mbox->lock);
 	return err;
 }
 
-- 
2.31.1

