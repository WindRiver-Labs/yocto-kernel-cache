From bac086ef21a0386f5edae9495644043a3a6bf910 Mon Sep 17 00:00:00 2001
From: Witold Sadowski <wsadowski@marvell.com>
Date: Fri, 23 Jul 2021 06:33:49 -0700
Subject: [PATCH 1669/1921] sw_update: Add firmware clone support.

Add support for new IOCTL clone firmware command.
With additional clone flag copy firmware
from one bootdevice to another.
All firmware operations are performed in ATF.
Unify structure names.

Signed-off-by: Witold Sadowski <wsadowski@marvell.com>
Change-Id: I5c5eeed576bd44189b47857859a3d7508908ba6d
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/57116
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Sunil Kovvuri Goutham <sgoutham@marvell.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 drivers/soc/marvell/cn10ka-swup/mrvl_swup.c | 284 +++++++++++++++-----
 drivers/soc/marvell/cn10ka-swup/mrvl_swup.h |  77 +++++-
 2 files changed, 276 insertions(+), 85 deletions(-)

diff --git a/drivers/soc/marvell/cn10ka-swup/mrvl_swup.c b/drivers/soc/marvell/cn10ka-swup/mrvl_swup.c
index 2d5d90e2ff6c..d967816d50c9 100644
--- a/drivers/soc/marvell/cn10ka-swup/mrvl_swup.c
+++ b/drivers/soc/marvell/cn10ka-swup/mrvl_swup.c
@@ -17,17 +17,31 @@
 #include <linux/slab.h>
 #include <linux/bitops.h>
 #include <linux/debugfs.h>
+#include <linux/smp.h>
 
 #include <linux/dma-mapping.h>
 #include <linux/dmapool.h>
 #include <linux/device.h>
+#include <linux/gfp.h>
 
 #include <soc/marvell/octeontx/octeontx_smc.h>
 #include "mrvl_swup.h"
 
+#define TO_VERSION_DESC(x) ((struct mrvl_get_versions *)(x))
+#define TO_CLONE_DESC(x) ((struct mrvl_clone_fw *)(x))
+#define TO_UPDATE_DESC(x) ((struct mrvl_update *)(x))
+#define TO_PHYS_BUFFER(x) ((struct mrvl_phys_buffer *)(x))
+
+static int alloc_buffers(struct memory_desc *memdesc, uint32_t required_buf);
+static void free_buffers(void);
+
 /*Debugfs interface root */;
 struct dentry *mrvl_swup_root;
 
+static int alloc_buffers(struct memory_desc *memdesc, uint32_t required_buf);
+static void free_buffers(void);
+
+
 /* Buffers for SMC call
  * 0 -> 25MB for SW update CPIO blob
  * 1 -> 1MB for passing data structures
@@ -35,14 +49,19 @@ struct dentry *mrvl_swup_root;
 #define BUF_CPIO 0
 #define BUF_DATA 1
 #define BUF_SIGNATURE 2
-static struct memory_desc memdesc[] = {
-	{0, 0, 25*1024*1024, "cpio buffer"},
+#define BUF_COUNT 3
+static struct memory_desc memdesc[BUF_COUNT] = {
+	{0, 0, 32*1024*1024, "cpio buffer"},
 	{0, 0, 1*1024*1024,  "data buffer"},
 	{0, 0, 1*1024*1024,  "signature buffer"},
 };
 
+static struct allocated_pages {
+	struct page *p;
+	int order;
+} page_handler = {0};
 /* IOCTL mapping to fw name */
-const struct {
+static const struct {
 	const char *str;
 	uint8_t bit;
 } name_to_sel_obj[] = {
@@ -62,7 +81,7 @@ const struct {
 	{"switch_fw_super.fw", 13},
 };
 
-const char *obj_bit_to_str(uint32_t bit)
+static const char *obj_bit_to_str(uint32_t bit)
 {
 	int i;
 
@@ -74,7 +93,7 @@ const char *obj_bit_to_str(uint32_t bit)
 }
 
 /* Prepare objects for limited read */
-void prepare_names(struct smc_version_info *info, uint32_t objects)
+static void prepare_names(struct smc_version_info *info, uint32_t objects)
 {
 	int i;
 	int obj_count = 0;
@@ -93,38 +112,35 @@ void prepare_names(struct smc_version_info *info, uint32_t objects)
 	}
 }
 
-static void mrvl_fw_dev_release(struct device *dev)
+struct arm_smccc_res mrvl_exec_smc(uint64_t smc, uint64_t buf, uint64_t size)
 {
-	pr_info("releasing firmware device\n");
-}
-
-static struct device dev = {
-	.release = mrvl_fw_dev_release
-};
+	struct arm_smccc_res res;
 
+	arm_smccc_smc(smc, buf, size, 0, 0, 0, 0, 0, &res);
+	return res;
+}
 
-enum smc_version_entry_retcode mrvl_get_version(unsigned long arg, uint8_t calculate_hash)
+static enum smc_version_entry_retcode mrvl_get_version(unsigned long arg, uint8_t calculate_hash)
 {
 	int i, ret = 0;
-	uint64_t x0_addr, x1_size;
-	struct marlin_bootflash_get_versions *user_desc;
+	struct mrvl_get_versions *user_desc;
 	struct arm_smccc_res res;
 	struct smc_version_info *swup_info = (struct smc_version_info *)memdesc[BUF_DATA].virt;
 
-	user_desc = kzalloc(sizeof(struct marlin_bootflash_get_versions), GFP_KERNEL);
+	user_desc = kzalloc(sizeof(*user_desc), GFP_KERNEL);
 	if (!user_desc)
 		return -ENOMEM;
 
 	if (copy_from_user(user_desc,
-			  (struct marlin_bootflash_get_versions *)arg,
-			  sizeof(struct marlin_bootflash_get_versions))) {
+			  TO_VERSION_DESC(arg),
+			  sizeof(*user_desc))) {
 		pr_err("Data Read Error\n");
 		ret = -EFAULT;
 		goto mem_error;
 	}
 
 	/* We have to perform conversion from IOCTL interface to smc */
-	memset(swup_info, 0x00, sizeof(struct smc_version_info));
+	memset(swup_info, 0x00, sizeof(*swup_info));
 
 	swup_info->magic_number = VERSION_MAGIC;
 	swup_info->version      = VERSION_INFO_VERSION;
@@ -142,11 +158,90 @@ enum smc_version_entry_retcode mrvl_get_version(unsigned long arg, uint8_t calcu
 		swup_info->num_objects = SMC_MAX_OBJECTS;
 	}
 
-	//SMC call
-	x0_addr = memdesc[BUF_DATA].phys;
-	x1_size = sizeof(struct smc_version_info);
+	res = mrvl_exec_smc(PLAT_CN10K_VERIFY_FIRMWARE,
+			    memdesc[BUF_DATA].phys,
+			    sizeof(struct smc_version_info));
+
+	if (res.a0) {
+		pr_err("Error during SMC processing\n");
+		ret = res.a0;
+		goto mem_error;
+	}
+
+	user_desc->retcode = swup_info->retcode;
+	for (i = 0; i < SMC_MAX_VERSION_ENTRIES; i++)
+		memcpy(&user_desc->desc[i],
+		       &swup_info->objects[i],
+		       sizeof(struct smc_version_info_entry));
+
+	if (copy_to_user(TO_VERSION_DESC(arg),
+			user_desc,
+			sizeof(*user_desc))) {
+		pr_err("Data Write Error\n");
+		ret = -EFAULT;
+	}
+
+mem_error:
+	kfree(user_desc);
+	return ret;
+}
+
+static int mrvl_clone_fw(unsigned long arg)
+{
+	int i, ret = 0;
+	struct mrvl_clone_fw *user_desc;
+	struct arm_smccc_res res;
+	struct smc_version_info *swup_info = (struct smc_version_info *)memdesc[BUF_DATA].virt;
+
+	user_desc = kzalloc(sizeof(*user_desc), GFP_KERNEL);
+	if (!user_desc)
+		return -ENOMEM;
+
+	if (copy_from_user(user_desc,
+			  TO_CLONE_DESC(arg),
+			  sizeof(*user_desc))) {
+		pr_err("Data Read Error\n");
+		ret = -EFAULT;
+		goto mem_error;
+	}
+
+	memset(swup_info, 0x00, sizeof(*swup_info));
+
+	swup_info->magic_number = VERSION_MAGIC;
+	swup_info->version      = VERSION_INFO_VERSION;
+	swup_info->bus = user_desc->bus;
+	swup_info->cs = user_desc->cs;
+	swup_info->version_flags |= SMC_VERSION_CHECK_VALIDATE_HASH;
+
+	if (user_desc->version_flags & MARLIN_CHECK_PREDEFINED_OBJ) {
+		swup_info->version_flags |= SMC_VERSION_CHECK_SPECIFIC_OBJECTS;
+		prepare_names(swup_info, user_desc->selected_objects);
+		swup_info->num_objects = hweight_long(user_desc->selected_objects);
+	} else {
+		swup_info->num_objects = SMC_MAX_OBJECTS;
+	}
+
+
+	switch (user_desc->clone_op) {
+	case CLONE_SPI:
+		swup_info->target_bus = user_desc->target_bus;
+		swup_info->target_cs = user_desc->target_cs;
+		swup_info->version_flags |= SMC_VERSION_COPY_TO_BACKUP_FLASH;
+		break;
+	case CLONE_MMC:
+		swup_info->version_flags |= SMC_VERSION_COPY_TO_BACKUP_EMMC;
+		break;
+	case CLONE_OFFSET:
+		swup_info->version_flags |= SMC_VERSION_COPY_TO_BACKUP_OFFSET;
+		break;
+	default:
+		pr_err("Incorrect clone parameter.\n");
+		goto mem_error;
+	}
 
-	arm_smccc_smc(PLAT_CN10K_VERIFY_FIRMWARE, x0_addr, x1_size, 0, 0, 0, 0, 0, &res);
+	res = mrvl_exec_smc(PLAT_CN10K_VERIFY_FIRMWARE,
+			    memdesc[BUF_DATA].phys,
+			    sizeof(struct smc_version_info));
 
 	if (res.a0) {
 		pr_err("Error during SMC processing\n");
@@ -160,9 +255,9 @@ enum smc_version_entry_retcode mrvl_get_version(unsigned long arg, uint8_t calcu
 		       &swup_info->objects[i],
 		       sizeof(struct smc_version_info_entry));
 
-	if (copy_to_user((struct marlin_bootflash_get_versions *)arg,
+	if (copy_to_user(TO_CLONE_DESC(arg),
 			user_desc,
-			sizeof(struct marlin_bootflash_get_versions))) {
+			sizeof(*user_desc))) {
 		pr_err("Data Write Error\n");
 		ret = -EFAULT;
 	}
@@ -174,7 +269,7 @@ enum smc_version_entry_retcode mrvl_get_version(unsigned long arg, uint8_t calcu
 
 static int mrvl_get_membuf(unsigned long arg)
 {
-	struct marlin_bootflash_phys_buffer buf;
+	struct mrvl_phys_buffer buf;
 
 	buf.cpio_buf = memdesc[BUF_CPIO].phys;
 	buf.cpio_buf_size = memdesc[BUF_CPIO].size;
@@ -184,9 +279,9 @@ static int mrvl_get_membuf(unsigned long arg)
 	buf.reserved_buf_size = 0;
 
 
-	if (copy_to_user((struct marlin_bootflash_phys_buffer *)arg,
+	if (copy_to_user(TO_PHYS_BUFFER(arg),
 			  &buf,
-			  sizeof(struct marlin_bootflash_phys_buffer))) {
+			  sizeof(buf))) {
 		pr_err("Data Write Error\n");
 		return -EFAULT;
 	}
@@ -195,16 +290,16 @@ static int mrvl_get_membuf(unsigned long arg)
 
 static int mrvl_run_fw_update(unsigned long arg)
 {
-	struct marlin_bootflash_update ioctl_desc = {0};
+	struct mrvl_update ioctl_desc = {0};
 	struct smc_update_descriptor *smc_desc;
 	struct arm_smccc_res res;
 
 	smc_desc = (struct smc_update_descriptor *)memdesc[BUF_DATA].virt;
-	memset(smc_desc, 0x00, sizeof(struct smc_update_descriptor));
+	memset(smc_desc, 0x00, sizeof(*smc_desc));
 
 	if (copy_from_user(&ioctl_desc,
-			  (struct marlin_bootflash_update *)arg,
-			  sizeof(struct marlin_bootflash_update))) {
+			  TO_UPDATE_DESC(arg),
+			  sizeof(ioctl_desc))) {
 		pr_err("Data Read Error\n");
 		return -EFAULT;
 	}
@@ -243,14 +338,14 @@ static int mrvl_run_fw_update(unsigned long arg)
 	smc_desc->bus        = ioctl_desc.bus;
 	smc_desc->cs	     = ioctl_desc.cs;
 
-	arm_smccc_smc(PLAT_OCTEONTX_SPI_SECURE_UPDATE, memdesc[BUF_DATA].phys,
-			sizeof(struct smc_update_descriptor),
-			0, 0, 0, 0, 0, &res);
+	res = mrvl_exec_smc(PLAT_OCTEONTX_SPI_SECURE_UPDATE,
+			    memdesc[BUF_DATA].phys,
+			    sizeof(struct smc_update_descriptor));
 
 	ioctl_desc.ret = res.a0;
-	if (copy_to_user((struct marlin_bootflash_update *)arg,
+	if (copy_to_user(TO_UPDATE_DESC(arg),
 			 &ioctl_desc,
-			 sizeof(struct marlin_bootflash_update))) {
+			 sizeof(ioctl_desc))) {
 		pr_err("Data Write Error\n");
 		return -EFAULT;
 	}
@@ -259,20 +354,49 @@ static int mrvl_run_fw_update(unsigned long arg)
 
 static long mrvl_swup_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
+	int ret;
+
 	switch (cmd) {
 	case GET_VERSION:
-		return mrvl_get_version(arg, 0);
 	case VERIFY_HASH:
-		return mrvl_get_version(arg, 1);
+	case CLONE_FW:
+		ret = alloc_buffers(memdesc, 1<<BUF_DATA | 1<<BUF_SIGNATURE);
+		break;
 	case GET_MEMBUF:
-		return mrvl_get_membuf(arg);
+		ret = alloc_buffers(memdesc, 1<<BUF_DATA | 1<<BUF_SIGNATURE | 1<<BUF_CPIO);
+		break;
+	default:
+		break;
+	}
+
+	if (ret)
+		return ret;
+
+	switch (cmd) {
+	case GET_VERSION:
+		ret = mrvl_get_version(arg, 0);
+		free_buffers();
+		break;
+	case VERIFY_HASH:
+		ret = mrvl_get_version(arg, 1);
+		free_buffers();
+		break;
+	case GET_MEMBUF:
+		ret =  mrvl_get_membuf(arg);
+		break;
 	case RUN_UPDATE:
-		return mrvl_run_fw_update(arg);
+		ret = mrvl_run_fw_update(arg);
+		free_buffers();
+		break;
+	case CLONE_FW:
+		ret = mrvl_clone_fw(arg);
+		free_buffers();
+		break;
 	default:
 		pr_err("Not supported IOCTL\n");
 		return -ENXIO;
 	}
-	return 0;
+	return ret;
 }
 
 static const struct file_operations mrvl_fops = {
@@ -281,18 +405,54 @@ static const struct file_operations mrvl_fops = {
 	.llseek			= no_llseek,
 };
 
-static int setup_cma(struct device *dev, struct memory_desc *memdesc)
+static int alloc_buffers(struct memory_desc *memdesc, uint32_t required_buf)
 {
-	memdesc->virt = dma_alloc_coherent(dev, memdesc->size, &memdesc->phys, GFP_KERNEL);
-	memset(memdesc->virt, 0x01, memdesc->size);
-	pr_info("Allocated %llx b for pool: %s. Virt: %llx. Phys: %llx\n",
-						memdesc->size,
-						memdesc->pool_name,
-						(uint64_t)memdesc->virt,
-						(uint64_t)memdesc->phys);
+	int i, required_mem = 0, page_order;
+	void *page_addr;
+
+	for (i = 0; i < BUF_COUNT; i++) {
+		if (required_buf & 1<<i)
+			required_mem += memdesc[i].size;
+	}
+
+	if (!required_mem)
+		return 0;
+
+	page_order = get_order(required_mem);
+	page_handler.p = alloc_pages(GFP_KERNEL, page_order);
+	if (!page_handler.p)
+		return -ENOMEM;
 
+	page_handler.order = page_order;
+	page_addr = page_address(page_handler.p);
+	memset(page_addr, 0x00, 1<<page_order);
+
+	for (i = 0; i < BUF_COUNT; i++) {
+		if (required_buf & 1<<i) {
+			memdesc[i].virt = page_addr;
+			memdesc[i].phys = virt_to_phys(page_addr);
+			page_addr += memdesc[i].size;
+		}
+	}
 	return 0;
 }
+
+static void free_buffers(void)
+{
+	int i;
+
+	for (i = 0; i < BUF_COUNT; i++) {
+		memdesc[i].phys = 0;
+		memdesc[i].virt = 0;
+	}
+
+	if (page_handler.p) {
+		__free_pages(page_handler.p, page_handler.order);
+		page_handler.p = NULL;
+		page_handler.order = 0;
+	}
+}
+
 static int mrvl_swup_setup_debugfs(void)
 {
 	struct dentry *pfile;
@@ -314,7 +474,7 @@ static int mrvl_swup_setup_debugfs(void)
 
 static int __init mrvl_swup_init(void)
 {
-	int i, ret;
+	int ret;
 
 	ret = octeontx_soc_check_smc();
 	if (ret != 2) {
@@ -322,34 +482,12 @@ static int __init mrvl_swup_init(void)
 		return -EPERM;
 	}
 
-	dev_set_name(&dev, "mrvl_swup_dev");
-	ret = device_register(&dev);
-
-	if (ret) {
-		pr_err("Failed to register device\n");
-		return ret;
-	}
-
-	/* Will not be used bt any HW, so use mask with ones only */
-	dev.coherent_dma_mask = ~0;
-
-	/* Allocate memory */
-	for (i = 0; i < ARRAY_SIZE(memdesc); i++)
-		setup_cma(&dev, &memdesc[i]);
-
 	return mrvl_swup_setup_debugfs();
 }
 
 static void __exit mrvl_swup_exit(void)
 {
-	int i;
-
 	debugfs_remove_recursive(mrvl_swup_root);
-	for (i = 0; i < ARRAY_SIZE(memdesc); i++) {
-		if (memdesc[i].phys != 0)
-			dma_free_coherent(&dev, memdesc[i].size,
-					  memdesc[i].virt, memdesc[i].phys);
-	}
 }
 
 module_init(mrvl_swup_init)
diff --git a/drivers/soc/marvell/cn10ka-swup/mrvl_swup.h b/drivers/soc/marvell/cn10ka-swup/mrvl_swup.h
index df08e2a1162d..34cc94e1f0f0 100644
--- a/drivers/soc/marvell/cn10ka-swup/mrvl_swup.h
+++ b/drivers/soc/marvell/cn10ka-swup/mrvl_swup.h
@@ -28,8 +28,25 @@
 #define SMC_VERSION_CHECK_SPECIFIC_OBJECTS	BIT(2)
 #define SMC_VERSION_CHECK_VALIDATE_HASH		BIT(3)
 
+/**
+ * Set this to copy objects to the backup flash after verification.
+ * Do not set this and SCM_VERSION_COPY_TO_BACKUP_EMMC.
+ */
+#define SMC_VERSION_COPY_TO_BACKUP_FLASH	BIT(4)
+
+/**
+ * Set this to copy objects to the backup eMMC after verification.
+ * Do not set this and SCM_VERSION_COPY_TO_BACKUP_FLASH.
+ */
+#define SMC_VERSION_COPY_TO_BACKUP_EMMC		BIT(5)
+
+/**
+ * Set this to copy objects to the backup flash offset after verification.
+ */
+#define SMC_VERSION_COPY_TO_BACKUP_OFFSET	BIT(6)
+
 #define VERSION_MAGIC		0x4e535256	/** VRSN */
-#define VERSION_INFO_VERSION	0x0100	/** 1.0.0.0 */
+#define VERSION_INFO_VERSION	0x0101	/** 1.0.0.0 */
 
 struct memory_desc {
 	void	   *virt;
@@ -64,6 +81,18 @@ enum smc_version_ret {
 	TOO_MANY_OBJECTS,
 	INVALID_DEVICE_TREE,
 	VERSION_NOT_SUPPORTED,
+		/** SMC_VERSION_CHECK_VALIDATE_HASH must be set */
+	BACKUP_SRC_NOT_VALIDATED,
+	/** An object failed the verification stage */
+	BACKUP_SRC_FAILED_VALIDATION,
+	/** Both the source and destination are the same */
+	BACKUP_SRC_AND_DEST_ARE_SAME,
+	/** An I/O error with the source occurred copying an object */
+	BACKUP_IO_SRC_ERROR,
+	/** An I/O error with the destination occurred writing an object */
+	BACKUP_IO_DST_ERROR,
+	/** An I/O error with the destination occurred erasing the media */
+	BACKUP_IO_ERASE_ERROR,
 };
 
 /** This is used for each object (version entry) */
@@ -88,13 +117,14 @@ struct smc_version_info_entry {
 	uint8_t tim_hash[HASH_SIZE];	/** Hash value stored in the TIM */
 	uint8_t obj_hash[HASH_SIZE];	/** Calculated hash value */
 	uint64_t tim_address;		/** Address of TIM in flash */
+	uint64_t tim_size;		/** Size of TIM in bytes */
 	uint64_t max_size;		/** Maximum space for object and TIM */
 	uint64_t object_size;		/** Size of flash object in bytes */
 	uint64_t object_address;	/** Address of object in flash */
 	uint16_t hash_size;		/** Size of hash in bytes */
 	uint16_t flags;			/** Flags for this object */
 	enum smc_version_entry_retcode retcode;	/** Return code if error */
-	uint64_t reserved[8];		/** Reserved for future growth */
+	uint64_t reserved[7];		/** Reserved for future growth */
 	uint8_t log[VERIFY_LOG_SIZE];	/** Log for object */
 };
 
@@ -104,13 +134,15 @@ struct smc_version_info {
 	uint16_t	version_flags;	/** Flags passed to version process */
 	uint32_t	bus;		/** SPI BUS number */
 	uint32_t	cs;		/** SPI chip select number */
+	uint32_t	target_bus;	/** Target bus used for copying */
+	uint32_t	target_cs;	/** Target CS used for copying */
 	uintptr_t	work_buffer_addr;/** Used to decompress objects */
 	uint64_t	work_buffer_size;/** Size of decompression buffer */
 	enum smc_version_ret	retcode;
 	uint32_t	num_objects;
 	uint32_t	timeout;	/** Timeout in ms */
-	uint32_t	pad32;		/** Pad to 64 bits */
-	uint64_t	reserved[5];	/** Reserved for future growth */
+	uint32_t	reserved32;		/** Pad to 64 bits */
+	uint64_t	reserved[4];	/** Reserved for future growth */
 	struct smc_version_info_entry objects[SMC_MAX_VERSION_ENTRIES];
 };
 
@@ -206,13 +238,20 @@ struct smc_update_descriptor {
 	struct smc_update_obj_info object_retinfo[SMC_MAX_OBJECTS];
 };
 
+
+enum marlin_bootflash_clone_op {
+	CLONE_SPI = 0,
+	CLONE_MMC = 1,
+	CLONE_OFFSET = 2,
+};
+
+
 /* IOCTL interface
  * Use same data structure for:
  * get_version
  * verify_hash
  */
-
-struct marlin_bootflash_get_versions {
+struct mrvl_get_versions {
 	uint32_t  bus;              /** SPI BUS number */
 	uint32_t  cs;               /** SPI chip select number */
 	uintptr_t log_addr;         /** Pointer to a buffer where to store log */
@@ -224,7 +263,20 @@ struct marlin_bootflash_get_versions {
 	struct smc_version_info_entry desc[SMC_MAX_VERSION_ENTRIES];
 } __packed;
 
-struct marlin_bootflash_phys_buffer {
+struct mrvl_clone_fw {
+	uint32_t bus;              /** SPI BUS number */
+	uint32_t cs;               /** SPI chip select number */
+	uint32_t target_bus;	   /** Target SPI BUS number */
+	uint32_t target_cs;	   /** Target SPI chip select number */
+	enum marlin_bootflash_clone_op	clone_op; /** Clone configuration */
+	uint16_t  version_flags;    /** Flags to specify options */
+	uint32_t  selected_objects; /** Mask of a selection of TIMs (32 max) */
+	uint64_t reserved[5];	   /** Reserved for future growth */
+	enum smc_version_ret	retcode;
+	struct smc_version_info_entry desc[SMC_MAX_VERSION_ENTRIES];
+} __packed;
+
+struct mrvl_phys_buffer {
 	uint64_t cpio_buf;
 	uint64_t cpio_buf_size;
 	uint64_t sign_buf;
@@ -233,7 +285,7 @@ struct marlin_bootflash_phys_buffer {
 	uint64_t reserved_buf_size;
 } __packed;
 
-struct marlin_bootflash_update {
+struct mrvl_update {
 	uint32_t bus;
 	uint32_t cs;
 	uint64_t image_size;
@@ -245,9 +297,10 @@ struct marlin_bootflash_update {
 } __packed;
 
 
-#define GET_VERSION _IOWR('a', 'a', struct marlin_bootflash_get_versions*)
-#define VERIFY_HASH _IOWR('a', 'b', struct marlin_bootflash_get_versions*)
-#define GET_MEMBUF  _IOWR('a', 'c', struct marlin_bootflash_phys_buffer*)
-#define RUN_UPDATE  _IOWR('a', 'd', struct marlin_bootflash_update*)
+#define GET_VERSION _IOWR('a', 'a', struct mrvl_get_versions*)
+#define VERIFY_HASH _IOWR('a', 'b', struct mrvl_get_versions*)
+#define GET_MEMBUF  _IOWR('a', 'c', struct mrvl_phys_buffer*)
+#define RUN_UPDATE  _IOWR('a', 'd', struct mrvl_update*)
+#define CLONE_FW    _IOWR('a', 'e', struct mrvl_clone_fw*)
 
 #endif	/* __TIM_UPDATE_H__ */
-- 
2.31.1

