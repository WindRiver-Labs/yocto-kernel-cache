From 335495d3ef4350c1e593bc1dc6d8c8f54b67009c Mon Sep 17 00:00:00 2001
From: Naveen Mamindlapalli <naveenm@marvell.com>
Date: Fri, 3 Sep 2021 14:39:33 +0530
Subject: [PATCH 9/9] otx2-bphy-netdev: disable cpri code when cpri hw is not
 present

commit 943d925ae2ae2b3cf3902b50f98cb24d3af0b13b from
git@git.assembla.com:cavium/WindRiver.linux.git

This commit disables cpri code when cpri hw block is not available.

Change-Id: I3a020a48d43f1d90953a8aa0c57ae1c447fdd5b0
Signed-off-by: Naveen Mamindlapalli <naveenm@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/60570
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Sunil Kovvuri Goutham <sgoutham@marvell.com>
Integrated-by: Abhishek Paliwal <paliwal.abhishek@windriver.com>
---
 .../marvell/octeontx2/bphy/otx2_bphy_main.c   | 35 +++++++++++--------
 1 file changed, 21 insertions(+), 14 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_bphy_main.c b/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_bphy_main.c
index 7cea0110424c..a0b8eb86da1f 100644
--- a/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_bphy_main.c
+++ b/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_bphy_main.c
@@ -40,6 +40,9 @@ void __iomem *bcn_reg_base;
 void __iomem *ptp_reg_base;
 void __iomem *cpri_reg_base;
 
+/* check if cpri block is available */
+#define cpri_available()		((cpri_reg_base) ? 1 : 0)
+
 /* GPINT(1) interrupt handler routine */
 static irqreturn_t otx2_bphy_intr_handler(int irq, void *dev_id)
 {
@@ -145,10 +148,12 @@ static long otx2_bphy_cdev_ioctl(struct file *filp, unsigned int cmd,
 			goto out;
 		}
 
-		ret = otx2_cpri_parse_and_init_intf(cdev, intf_cfg);
-		if (ret < 0) {
-			dev_err(cdev->dev, "odp <-> netdev parse error\n");
-			goto out;
+		if (cpri_available()) {
+			ret = otx2_cpri_parse_and_init_intf(cdev, intf_cfg);
+			if (ret < 0) {
+				dev_err(cdev->dev, "odp <-> netdev parse error\n");
+				goto out;
+			}
 		}
 
 		/* The MSIXEN bit is getting cleared when ODP BPHY driver
@@ -194,7 +199,8 @@ static long otx2_bphy_cdev_ioctl(struct file *filp, unsigned int cmd,
 		writeq(status, bphy_reg_base + PSM_INT_GP_SUM_W1C(1));
 
 		otx2_bphy_rfoe_cleanup();
-		otx2_bphy_cpri_cleanup();
+		if (cpri_available())
+			otx2_bphy_cpri_cleanup();
 
 		cdev->odp_intf_cfg = 0;
 
@@ -520,7 +526,8 @@ static int otx2_bphy_cdev_release(struct inode *inode, struct file *filp)
 	writeq(status, bphy_reg_base + PSM_INT_GP_SUM_W1C(1));
 
 	otx2_bphy_rfoe_cleanup();
-	otx2_bphy_cpri_cleanup();
+	if (cpri_available())
+		otx2_bphy_cpri_cleanup();
 
 	cdev->odp_intf_cfg = 0;
 
@@ -635,14 +642,14 @@ static int otx2_bphy_probe(struct platform_device *pdev)
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 5);
 	if (!res) {
 		dev_err(&pdev->dev, "failed to get cpri resource\n");
-		err = -ENXIO;
-		goto out_unmap_ptp_reg;
-	}
-	cpri_reg_base = ioremap_nocache(res->start, resource_size(res));
-	if (IS_ERR(cpri_reg_base)) {
-		dev_err(&pdev->dev, "failed to ioremap cpri registers\n");
-		err = PTR_ERR(cpri_reg_base);
-		goto out_unmap_ptp_reg;
+		cpri_reg_base = NULL;
+	} else {
+		cpri_reg_base = ioremap_nocache(res->start, resource_size(res));
+		if (IS_ERR(cpri_reg_base)) {
+			dev_err(&pdev->dev, "failed to ioremap cpri registers\n");
+			err = PTR_ERR(cpri_reg_base);
+			goto out_unmap_ptp_reg;
+		}
 	}
 	/* get irq */
 	cdev_priv->irq = platform_get_irq(pdev, 0);
-- 
2.31.1

