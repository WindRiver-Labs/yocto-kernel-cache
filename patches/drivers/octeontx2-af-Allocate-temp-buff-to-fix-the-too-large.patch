From 1cb1148db93b84a790b336004c4c3ac4ae7ddd0a Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Mon, 20 Jan 2020 15:02:04 +0800
Subject: [PATCH 459/767] octeontx2-af: Allocate temp buff to fix the too
 larger frame warning
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Fix the build warning by using dynamic allocated temp buff.
  drivers/net/ethernet/marvell/octeontx2/af/rvu_fixes.c: In function ‘rvu_nix_get_tx_stall_counters’:
  drivers/net/ethernet/marvell/octeontx2/af/rvu_fixes.c:868:1: warning: the frame size of 2016 bytes is larger than 1340 bytes [-Wframe-larger-than=]
    868 | }
        | ^

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../ethernet/marvell/octeontx2/af/rvu_fixes.c  | 18 +++++++++++++-----
 1 file changed, 13 insertions(+), 5 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_fixes.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_fixes.c
index 7e6cc8d1ee5a..2925d1554ad9 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_fixes.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_fixes.c
@@ -822,7 +822,8 @@ ssize_t rvu_nix_get_tx_stall_counters(struct rvu *rvu,
 	struct rvu_block *block;
 	struct nix_hw *nix_hw;
 	int blkaddr, len, lf;
-	char kbuf[2000];
+	char *kbuf;
+	int size = 2000;
 
 	if (*ppos)
 		return 0;
@@ -839,10 +840,14 @@ ssize_t rvu_nix_get_tx_stall_counters(struct rvu *rvu,
 	if (!tx_stall)
 		return -EFAULT;
 
-	len = snprintf(kbuf, sizeof(kbuf), "\n  NIX transmit stall stats\n");
-	len += snprintf(kbuf + len, sizeof(kbuf),
+	kbuf = kmalloc(size, GFP_KERNEL);
+	if (!kbuf)
+		return -ENOMEM;
+
+	len = snprintf(kbuf, size, "\n  NIX transmit stall stats\n");
+	len += snprintf(kbuf + len, size,
 			"\t\tPolled: \t\t%lld\n", tx_stall->poll_cntr);
-	len += snprintf(kbuf + len, sizeof(kbuf),
+	len += snprintf(kbuf + len, size,
 			"\t\tTx stall detected: \t%lld\n\n",
 			tx_stall->stalled_cntr);
 
@@ -859,11 +864,14 @@ ssize_t rvu_nix_get_tx_stall_counters(struct rvu *rvu,
 	mutex_unlock(&rvu->rsrc_lock);
 
 	if (len > 0) {
-		if (copy_to_user(buffer, kbuf, len))
+		if (copy_to_user(buffer, kbuf, len)) {
+			kfree(kbuf);
 			return -EFAULT;
+		}
 	}
 
 	*ppos += len;
+	kfree(kbuf);
 	return len;
 }
 
-- 
2.31.1

