From c986522b3b3fb983157d4e36b8305cf2b550fe01 Mon Sep 17 00:00:00 2001
From: Vasyl Gomonovych <vgomonovych@marvell.com>
Date: Sat, 31 Jul 2021 07:16:53 -0700
Subject: [PATCH 1891/1921] drivers: marvell: otx2-sdei-ghes: Cleanup RAS
 driver

 - Make callback generic
 - Rename t9x specific function
 - Leaving error injection only for QA request

Change-Id: Ife68c220a58c506afb63fb991ad5a9386c5614b1
Signed-off-by: Vasyl Gomonovych <vgomonovych@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/57775
Reviewed-by: Chandrakala Chavva <cchavva@marvell.com>
Reviewed-by: Sunil Kovvuri Goutham <sgoutham@marvell.com>
Tested-by: Sunil Kovvuri Goutham <sgoutham@marvell.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 .../marvell/octeontx2-ghes/otx2-ghes-bert.c   |   9 +-
 .../marvell/octeontx2-ghes/otx2-ghes-bert.h   |  10 +-
 .../marvell/octeontx2-ghes/otx2-sdei-ghes.c   | 525 ++++++++++--------
 .../marvell/octeontx2-ghes/otx2-sdei-ghes.h   |  22 +-
 4 files changed, 307 insertions(+), 259 deletions(-)

diff --git a/drivers/soc/marvell/octeontx2-ghes/otx2-ghes-bert.c b/drivers/soc/marvell/octeontx2-ghes/otx2-ghes-bert.c
index 746d8a73833d..a4716ee952c9 100644
--- a/drivers/soc/marvell/octeontx2-ghes/otx2-ghes-bert.c
+++ b/drivers/soc/marvell/octeontx2-ghes/otx2-ghes-bert.c
@@ -1,7 +1,7 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Marvell CN10K Generic Hardware Error Source
- * Boot Error Data (BED) ACPI BERT & DT
+ * Supports OcteonTX2 Generic Hardware Error Source (BED)
+ * Boot Error Data (BED) from BERT table DT and ACPI
  *
  * Copyright (C) 2021 Marvell.
  */
@@ -24,13 +24,13 @@
 #define DRV_NAME	"bed-bert"
 
 #define initerrmsg(fmt, ...) pr_err(DRV_NAME ":" fmt, __VA_ARGS__)
-#ifdef CONFIG_MARVELL_SDEI_GHES_DEBUG
+#ifdef CONFIG_OCTEONTX2_SDEI_GHES_DEBUG
 #  define initdbgmsg(fmt, ...) pr_info(DRV_NAME ":" fmt, __VA_ARGS__)
 #  define dbgmsg(dev, ...) dev_info((dev), __VA_ARGS__)
 #else
 #  define initdbgmsg(fmt, ...) (void)(fmt)
 #  define dbgmsg(dev, ...) (void)(dev)
-#endif // CONFIG_MARVELL_SDEI_GHES_DEBUG
+#endif // CONFIG_OCTEONTX2_SDEI_GHES_DEBUG
 
 #define BERT_TBL_OEM_ID	"OTX2    "
 #define BERT_OEM_ID     "MRVL  "
@@ -417,4 +417,3 @@ module_init(ghes_bert_init);
 MODULE_DESCRIPTION("OcteonTX2 GHES BERT Module");
 MODULE_LICENSE("GPL v2");
 MODULE_ALIAS("platform:" DRV_NAME);
-
diff --git a/drivers/soc/marvell/octeontx2-ghes/otx2-ghes-bert.h b/drivers/soc/marvell/octeontx2-ghes/otx2-ghes-bert.h
index 410e2084cc7b..2cf4efc46a15 100644
--- a/drivers/soc/marvell/octeontx2-ghes/otx2-ghes-bert.h
+++ b/drivers/soc/marvell/octeontx2-ghes/otx2-ghes-bert.h
@@ -1,13 +1,13 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Marvell CN10K Generic Hardware Error Source
- * Boot Error Data (BED) ACPI BERT & DT
+ * Supports OcteonTX2 Generic Hardware Error Source (BED)
+ * Boot Error Data (BED) from BERT table DT and ACPI
  *
  * Copyright (C) 2021 Marvell.
  */
 
-#ifndef __MRVL_GHES_BERT_H__
-#define __MRVL_GHES_BERT_H__
+#ifndef __OTX2_GHES_BERT_H__
+#define __OTX2_GHES_BERT_H__
 
 /*
  * Boot Error Data Source
@@ -32,4 +32,4 @@ struct bed_bert_mem_entry {
 	struct cper_sec_mem_err_old     mem_err;
 } __packed;
 
-#endif //__MRVL_GHES_BERT_H__
+#endif //__OTX2_GHES_BERT_H__
diff --git a/drivers/soc/marvell/octeontx2-ghes/otx2-sdei-ghes.c b/drivers/soc/marvell/octeontx2-ghes/otx2-sdei-ghes.c
index 64ff90141f88..b74216aa622f 100644
--- a/drivers/soc/marvell/octeontx2-ghes/otx2-sdei-ghes.c
+++ b/drivers/soc/marvell/octeontx2-ghes/otx2-sdei-ghes.c
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Marvell CN10K Generic Hardware Error Source[s] (GHES)
+ * Supports OcteonTX2 Generic Hardware Error Source[s] (GHES).
  * GHES ACPI HEST & DT
  *
  * Copyright (C) 2021 Marvell.
@@ -31,17 +31,15 @@
 #  define dbgmsg(dev, ...) (void)(dev)
 #endif // CONFIG_OCTEONTX2_SDEI_GHES_DEBUG
 
-#define MRVL_HEST_OEM_ID "MRVL  "
-#define HEST_TBL_OEM_ID	"OTX2    "
+#define OTX2_HEST_OEM_ID	"MRVL  "
+#define HEST_TBL_OEM_ID		"OTX2    "
 
 
-#ifdef CONFIG_OF
 static const struct of_device_id sdei_ghes_of_match[] = {
 	{ .compatible = "marvell,sdei-ghes", },
 	{},
 };
 MODULE_DEVICE_TABLE(of, sdei_ghes_of_match);
-#endif
 
 #ifdef CONFIG_ACPI
 static const struct acpi_device_id sdei_ghes_acpi_match[] = {
@@ -51,8 +49,6 @@ static const struct acpi_device_id sdei_ghes_acpi_match[] = {
 MODULE_DEVICE_TABLE(acpi, sdei_ghes_acpi_match);
 #endif
 
-static const char * const sdei_ghes_mrvl[] = {"mdc", "mcc", "lmc"};
-
 #define PCI_VENDOR_ID_CAVIUM            0x177d
 #define PCI_DEVICE_ID_OCTEONTX2_LMC     0xa022
 #define PCI_DEVICE_ID_OCTEONTX2_MCC     0xa070
@@ -65,113 +61,96 @@ static const struct pci_device_id sdei_ghes_mrvl_pci_tbl[] = {
 	{ 0, },
 };
 
-/* SDEI event notification callback. */
+static struct page *error_status_block_page;
+static u32 order;
+
 static int sdei_ghes_callback(u32 event_id, struct pt_regs *regs, void *arg)
 {
-	struct acpi_hest_generic_status *esb;
-	struct acpi_hest_generic_data *esb_data;
-	struct cper_sec_mem_err_old *esb_err;
+	struct acpi_hest_generic_status *estatus;
+	struct acpi_hest_generic_data *gdata;
+	void *esb_err;
 	struct mrvl_ghes_err_record *ring_rec;
-	struct mrvl_sdei_ghes_drv *ghes_drv;
 	struct mrvl_ghes_source *gsrc;
 	u32 head, tail;
-	size_t i;
 
 	initdbgmsg("%s event id 0x%x\n", __func__, event_id);
 
-	ghes_drv = arg;
+	if (!arg) {
+		initerrmsg("%s Failed callback\n", __func__);
+		return -1;
+	}
 
-	for (i = 0; i < ghes_drv->source_count; i++) {
-		gsrc = &ghes_drv->source_list[i];
+	gsrc = arg;
 
-		if (gsrc->esa_va && *gsrc->esa_va != gsrc->esb_pa) {
-			initdbgmsg("%s ACPI ESB address 0x%llx 0x%llx\n",
-					__func__, *gsrc->esa_va, gsrc->esb_pa);
-			*gsrc->esa_va = gsrc->esb_pa;
-		} else
-			initdbgmsg("%s no need patch address\n", __func__);
+	if (gsrc->esa_va && *gsrc->esa_va != gsrc->esb_pa) {
+		initerrmsg("%s ACPI ESB address 0x%llx 0x%llx\n",
+				__func__, *gsrc->esa_va, gsrc->esb_pa);
+		*gsrc->esa_va = gsrc->esb_pa;
+	} else
+		initdbgmsg("%s no need patch address\n", __func__);
 
-		initdbgmsg("%s is match event id 0x%x\n", __func__, gsrc->id);
+	initdbgmsg("%s matching event id 0x%x\n", __func__, gsrc->id);
 
-		if (gsrc->id != event_id)
-			continue;
+	head = gsrc->ring->head;
+	tail = gsrc->ring->tail;
 
-		initdbgmsg("%s matching event id 0x%x\n", __func__, gsrc->id);
+	/*Ensure that head updated*/
+	rmb();
 
-		head = gsrc->ring->head;
-		tail = gsrc->ring->tail;
+	if (head == tail) {
+		initerrmsg("event 0x%x ring is empty, head=%d, size=%d\n",
+				event_id, head, gsrc->ring->size);
+		return -1;
+	}
 
-		/*Ensure that head updated*/
-		rmb();
+	ring_rec = &gsrc->ring->records[tail];
 
-		if (head == tail) {
-			initerrmsg("ghes 0x%x ring is empty, head=%d, size=%d\n",
-					event_id, head, gsrc->ring->size);
-			break;
-		}
+	estatus = gsrc->esb_va;
+	gdata = (struct acpi_hest_generic_data *)(estatus + 1);
+	esb_err = (gdata + 1);
 
-		/*
-		 * Error Records Ring an array of records
-		 */
-		ring_rec = &gsrc->ring->records[tail];
-
-		/*
-		 * Error Status Block memory layout:
-		 * [1] acpi_hest_generic_status
-		 * [2] acpi_hest_generic_data
-		 * [3] cper_sec_mem_er_old
-		 */
-		esb = gsrc->esb_va;
-		esb_data = (struct acpi_hest_generic_data *)(esb + 1);
-		esb_err = (struct cper_sec_mem_err_old *)(esb_data + 1);
-
-		initdbgmsg("%s esb=%p, esb_data=%p, esb_err=%p\n", __func__,
-				esb, esb_data, esb_err);
-
-		// Error Status
-		esb->raw_data_length = 0;
-		esb->data_length =
-				sizeof(*esb_data) +
-				sizeof(struct cper_sec_mem_err_old);
-		esb->error_severity = ring_rec->severity;
-
-		// Error Generic Data
-		memset(esb_data, 0, sizeof(*esb_data));
-		esb_data->revision = 0x201; /* ACPI 4.x */
-		if (ring_rec->fru_text[0]) {
-			esb_data->validation_bits = ACPI_HEST_GEN_VALID_FRU_STRING;
-			strncpy(esb_data->fru_text, ring_rec->fru_text,
-				sizeof(esb_data->fru_text));
-		}
-		esb_data->error_severity = esb->error_severity;
-		guid_copy((guid_t *)esb_data->section_type, &CPER_SEC_PLATFORM_MEM);
-		esb_data->error_data_length = sizeof(struct cper_sec_mem_err_old);
-
-		initdbgmsg("%s err_sev=%x,\n", __func__,
-				ring_rec->severity);
-
-		// Error Record
-		memcpy(esb_err, &ring_rec->u.mcc, sizeof(*esb_err));
-
-		/* Ensure that error status (esb) is committed to memory prior to
-		 * setting block_status.
-		 */
-		wmb();
-
-		/*
-		 * This simply needs the entry count to be non-zero.
-		 * Set entry count to one (see ACPI_HEST_ERROR_ENTRY_COUNT).
-		 */
-		esb->block_status = (1 << 4); /* i.e. one entry */
-
-		if (++tail >= gsrc->ring->size)
-			tail = 0;
-		gsrc->ring->tail = tail;
-		break;
+	initdbgmsg("%s esb=%p, gdata=%p, esb_err=%p\n", __func__,
+			estatus, gdata, esb_err);
+
+	estatus->raw_data_offset = sizeof(*estatus) + sizeof(*gdata);
+	estatus->raw_data_length = 0;
+	estatus->data_length = gsrc->esb_sz - sizeof(*estatus);
+	estatus->error_severity = ring_rec->severity;
+
+	initdbgmsg("%s[%d] block_sz=0x%zx raw_data_offset=%d raw_data_length=%d "
+			"data_length=%d error_severity=%d\n",
+			gsrc->name, gsrc->id, gsrc->esb_sz, estatus->raw_data_offset,
+			estatus->raw_data_length, estatus->data_length,
+			estatus->error_severity);
+
+	memset(gdata, 0, sizeof(*gdata));
+	gdata->revision = 0x201; // ACPI 4.x
+	if (ring_rec->fru_text[0]) {
+		gdata->validation_bits = ACPI_HEST_GEN_VALID_FRU_STRING;
+		strncpy(gdata->fru_text, ring_rec->fru_text, sizeof(gdata->fru_text));
 	}
+	gdata->error_severity = estatus->error_severity;
 
-	if (i == ghes_drv->source_count)
-		initerrmsg("%s no source event id match\n", __func__);
+	guid_copy((guid_t *)gdata->section_type, &CPER_SEC_PLATFORM_MEM);
+	initdbgmsg("%s CPER_SEC_PLATFORM_MEM\n", __func__);
+
+	gdata->error_data_length = gsrc->esb_sz -
+			(sizeof(*estatus) + sizeof(*gdata));
+
+	initdbgmsg("%s err_sev=%x,\n", __func__, ring_rec->severity);
+
+	memcpy(esb_err, &ring_rec->u.mcc, gdata->error_data_length);
+
+	/*Ensure that error status is committed to memory prior to set block_status*/
+	wmb();
+
+	//This simply needs the entry count to be non-zero.
+	//Set entry count to one (see ACPI_HEST_ERROR_ENTRY_COUNT).
+	estatus->block_status = (1 << 4); // i.e. one entry
+
+	if (++tail >= gsrc->ring->size)
+		tail = 0;
+	gsrc->ring->tail = tail;
 
 	return 0;
 }
@@ -183,10 +162,12 @@ static int sdei_ghes_callback(u32 event_id, struct pt_regs *regs, void *arg)
  * NOTE: We SHOULD be able to use PCCPVF_XXX_VSEC_SCTL[MSIX_SEC_EN]
  * to enable our SECURE IRQs, but for errata PCC-34263...
  */
-static void dev_enable_msix(struct pci_dev *pdev)
+static void dev_enable_msix_t9x(struct pci_dev *pdev)
 {
 	u16 ctrl;
 
+	initdbgmsg("%s: entry\n", __func__);
+
 	if ((pdev->msi_enabled) || (pdev->msix_enabled)) {
 		initerrmsg("MSI(%d) or MSIX(%d) already enabled\n",
 				pdev->msi_enabled, pdev->msix_enabled);
@@ -213,7 +194,7 @@ static void dev_enable_msix(struct pci_dev *pdev)
  * This is required due to an errata against
  * PCCPVF_XXX_VSEC_SCTL[MSIX_SEC_EN].
  */
-static void sdei_ghes_msix_init(void)
+static void sdei_ghes_msix_init_t9x(void)
 {
 	const struct pci_device_id *pdevid;
 	struct pci_dev *pdev;
@@ -226,7 +207,7 @@ static void sdei_ghes_msix_init(void)
 		pdev = NULL;
 
 		while ((pdev = pci_get_device(pdevid->vendor, pdevid->device, pdev)))
-			dev_enable_msix(pdev);
+			dev_enable_msix_t9x(pdev);
 	}
 }
 
@@ -246,18 +227,18 @@ static int sdei_ghes_driver_init(struct platform_device *pdev)
 	for (i = 0; i < ghes_drv->source_count; i++) {
 		gsrc = &ghes_drv->source_list[i];
 
-		ret = sdei_event_register(gsrc->id, sdei_ghes_callback, ghes_drv);
+		ret = sdei_event_register(gsrc->id, sdei_ghes_callback, gsrc);
 		if (ret < 0) {
-			dev_err(dev, "Error %d registering gsrc 0x%x (%s)\n",
+			dev_err(dev, "Error %d registering ghes 0x%x (%s)\n",
 				ret, gsrc->id, gsrc->name);
-			break;
+			continue;
 		}
 
 		ret = sdei_event_enable(gsrc->id);
 		if (ret < 0) {
-			dev_err(dev, "Error %d enabling gsrc 0x%x (%s)\n",
+			dev_err(dev, "Error %d enabling ghes 0x%x (%s)\n",
 				ret, gsrc->id, gsrc->name);
-			break;
+			continue;
 		}
 
 		initdbgmsg("Register GHES 0x%x (%s) [%llx, %llx, %llx, %llx]\n",
@@ -267,9 +248,9 @@ static int sdei_ghes_driver_init(struct platform_device *pdev)
 	}
 
 	if (i != ghes_drv->source_count)
-		return -ENODEV;
-
-	dev_info(dev, "Registered & enabled %ld GHES\n", ghes_drv->source_count);
+		dev_err(dev, "Error cannot register all ghes\n");
+	else
+		dev_info(dev, "Registered & enabled %ld GHES\n", ghes_drv->source_count);
 
 	return 0;
 }
@@ -282,6 +263,8 @@ static int sdei_ghes_driver_deinit(struct platform_device *pdev)
 	struct mrvl_ghes_source *gsrc;
 	int ret, i;
 
+	initdbgmsg("%s: entry\n", __func__);
+
 	ghes_drv = platform_get_drvdata(pdev);
 
 	for (i = 0; i < ghes_drv->source_count; i++) {
@@ -310,32 +293,33 @@ static int sdei_ghes_driver_deinit(struct platform_device *pdev)
  * to this block; THIS driver does so, in response to SDEI
  * notifications).
  */
-static int sdei_ghes_adjust_error_status_block(struct page **pg,
-		struct mrvl_sdei_ghes_drv *ghes_drv)
+//TODO: alloc pages fr all ghes
+static int sdei_ghes_adjust_error_status_block(struct mrvl_sdei_ghes_drv *ghes_drv)
 {
 	struct mrvl_ghes_source *gsrc;
 	phys_addr_t pg_pa;
 	void *pg_va;
 	int i;
 
-	initdbgmsg("%s: entry\n", __func__);
-
-	if (!pg)
-		return -EFAULT;
+	gsrc = ghes_drv->source_list;
 
-	gsrc = &ghes_drv->source_list[0];
-
-	if (pfn_valid(PHYS_PFN(gsrc->esa_pa)))
+	if (pfn_valid(PHYS_PFN(gsrc->esa_pa))) {
+		initdbgmsg("%s not required\n", __func__);
 		return 0;
+	} else
+		initdbgmsg("%s required\n", __func__);
+
+	if (ghes_drv->source_count > ARRAY_SIZE(sdei_ghes_mrvl_pci_tbl))
+		order = 4;
 
-	*pg = alloc_page(GFP_KERNEL);
-	if (!*pg) {
+	error_status_block_page = alloc_pages(GFP_KERNEL, order);
+	if (!error_status_block_page) {
 		pr_err("Unable to allocate error status block\n");
 		return -ENOMEM;
 	}
 
-	pg_pa = PFN_PHYS(page_to_pfn(*pg));
-	pg_va = page_address(*pg);
+	pg_pa = PFN_PHYS(page_to_pfn(error_status_block_page));
+	pg_va = page_address(error_status_block_page);
 
 	initdbgmsg("! Allocated Error Status Address %p (%llx)\n",
 			pg_va, (unsigned long long)pg_pa);
@@ -444,6 +428,32 @@ static int __init sdei_ghes_of_match_resource(struct platform_device *pdev)
 	return 0;
 }
 
+static void __init sdei_ghes_set_name(struct mrvl_sdei_ghes_drv *ghes_drv)
+{
+	u32 i;
+	struct device_node *of_node;
+	struct device_node *child_node;
+	struct mrvl_ghes_source *gsrc;
+
+	of_node = of_find_matching_node(NULL, sdei_ghes_of_match);
+	i = 0;
+
+	if (of_node) {
+		for_each_available_child_of_node(of_node, child_node) {
+			gsrc = &ghes_drv->source_list[i];
+			strncpy(gsrc->name, child_node->name, sizeof(gsrc->name) - 1);
+			initdbgmsg("%s %s\n", __func__, gsrc->name);
+			i++;
+		}
+	} else {
+		for (i = 0; i < ghes_drv->source_count; i++) {
+			gsrc = &ghes_drv->source_list[i];
+			sprintf(gsrc->name, "GHES%d", i);
+			initdbgmsg("%s %s\n", __func__, gsrc->name);
+		}
+	}
+}
+
 static int __init sdei_ghes_acpi_match_resource(struct platform_device *pdev)
 {
 	struct mrvl_sdei_ghes_drv *ghes_drv;
@@ -458,11 +468,11 @@ static int __init sdei_ghes_acpi_match_resource(struct platform_device *pdev)
 
 	initdbgmsg("%s: entry\n", __func__);
 
+	sdei_ghes_set_name(ghes_drv);
+
 	for (i = 0; i < ghes_drv->source_count; i++) {
 		gsrc = &ghes_drv->source_list[i];
 
-		strncpy(gsrc->name, sdei_ghes_mrvl[i], strlen(sdei_ghes_mrvl[i]));
-
 		// Error Status Address
 		res = platform_get_resource(pdev, IORESOURCE_MEM, idx);
 		if (!res) {
@@ -516,10 +526,11 @@ static int __init sdei_ghes_acpi_match_resource(struct platform_device *pdev)
 	return 0;
 }
 
-static int  sdei_ghes_map_resource(struct mrvl_sdei_ghes_drv *ghes_drv)
+static int  sdei_ghes_setup_resource(struct mrvl_sdei_ghes_drv *ghes_drv)
 {
 	struct mrvl_ghes_source *gsrc;
-	size_t i;
+	size_t i = 0;
+	struct device *dev = ghes_drv->dev;
 
 	initdbgmsg("%s: entry\n", __func__);
 
@@ -535,46 +546,66 @@ static int  sdei_ghes_map_resource(struct mrvl_sdei_ghes_drv *ghes_drv)
 		if (pfn_valid(PHYS_PFN(gsrc->ring_pa)))
 			gsrc->ring = phys_to_virt(gsrc->ring_pa);
 
-		initdbgmsg("0x%p/0x%p/0x%p\n", gsrc->esa_va, gsrc->esb_va, gsrc->ring);
+		initdbgmsg("%s %s 0x%llx/0x%llx/0x%llx\n", __func__, gsrc->name,
+				(unsigned long long)gsrc->esa_va,
+				(unsigned long long)gsrc->esb_va,
+				(unsigned long long)gsrc->ring);
 
-		if (gsrc->esa_va && gsrc->esb_va && gsrc->ring)
-			continue;
+		if (!gsrc->esa_va || !gsrc->esb_va || !gsrc->ring) {
+			dev_err(dev, "estatus invalid phys addr");
+			return -EFAULT;
+		}
+	}
 
-		if (!gsrc->esa_va)
-			gsrc->esa_va = ioremap(gsrc->esa_pa, sizeof(gsrc->esa_va));
+	return 0;
+}
 
-		if (!gsrc->esb_va)
-			gsrc->esb_va = ioremap(gsrc->esb_pa, gsrc->esb_sz);
+static int  sdei_ghes_map_resource(struct mrvl_sdei_ghes_drv *ghes_drv)
+{
+	struct mrvl_ghes_source *gsrc;
+	size_t i;
+	struct device *dev = ghes_drv->dev;
 
-		if (!gsrc->ring)
-			gsrc->ring = ioremap(gsrc->ring_pa, gsrc->ring_sz);
+	initdbgmsg("%s: entry\n", __func__);
 
-		initdbgmsg("0x%p/0x%p/0x%p\n", gsrc->esa_va, gsrc->esb_va, gsrc->ring);
+	for (i = 0; i < ghes_drv->source_count; i++) {
+		gsrc = &ghes_drv->source_list[i];
 
-		if (!gsrc->esa_va || !gsrc->esb_va || !gsrc->ring)
-			goto err;
-	}
+		gsrc->esa_va = devm_ioremap(dev, gsrc->esa_pa, sizeof(gsrc->esa_va));
+		if (!gsrc->esa_va) {
+			dev_err(dev, "estatus unable map phys addr");
+			return -EFAULT;
+		}
 
-	return 0;
+		gsrc->esb_va = devm_ioremap(dev, gsrc->esb_pa, gsrc->esb_sz);
+		if (!gsrc->esb_va) {
+			dev_err(dev, "gdata unable map phys addr");
+			return -EFAULT;
+		}
 
-err:
-	initerrmsg("%s Unable to map error block.\n", __func__);
-	while (i >= 0) {
-		gsrc = &ghes_drv->source_list[i];
-		iounmap(gsrc->esa_va);
-		iounmap(gsrc->esb_va);
-		iounmap(gsrc->ring);
-		i--;
+		gsrc->ring   = devm_ioremap(dev, gsrc->ring_pa, gsrc->ring_sz);
+		if (!gsrc->ring) {
+			dev_err(dev, "ring unable map phys addr");
+			return -EFAULT;
+		}
+
+		initdbgmsg("%s %s 0x%llx/0x%llx/0x%llx\n", __func__, gsrc->name,
+				(unsigned long long)gsrc->esa_va,
+				(unsigned long long)gsrc->esb_va,
+				(unsigned long long)gsrc->ring);
 	}
 
-	return -EFAULT;
+	return 0;
 }
 
-static void  sdei_ghes_init_source(struct mrvl_sdei_ghes_drv *ghes_drv)
+
+static void sdei_ghes_init_source(struct mrvl_sdei_ghes_drv *ghes_drv)
 {
 	struct mrvl_ghes_source *gsrc;
 	size_t i;
 
+	initdbgmsg("%s: entry\n", __func__);
+
 	for (i = 0; i < ghes_drv->source_count; i++) {
 		gsrc = &ghes_drv->source_list[i];
 
@@ -584,21 +615,46 @@ static void  sdei_ghes_init_source(struct mrvl_sdei_ghes_drv *ghes_drv)
 	}
 }
 
-static void  sdei_ghes_count_source(struct mrvl_sdei_ghes_drv *ghes_drv)
+static int sdei_ghes_count(struct acpi_hest_header *hest_hdr, void *data)
+{
+	int *count = data;
+
+	if (hest_hdr->type == ACPI_HEST_TYPE_GENERIC_ERROR ||
+		hest_hdr->type == ACPI_HEST_TYPE_GENERIC_ERROR_V2)
+		(*count)++;
+
+	return 0;
+}
+
+static size_t sdei_ghes_count_source(struct mrvl_sdei_ghes_drv *ghes_drv)
 {
 	size_t count;
+	struct device_node *of_node;
+	struct device_node *child_node;
+
+	count = 0;
+	of_node = of_find_matching_node(NULL, sdei_ghes_of_match);
+
+	if (of_node) {
+		for_each_available_child_of_node(of_node, child_node) {
+			initdbgmsg("%s %s\n", __func__, child_node->name);
+			count++;
+		}
+	} else {
+		count = 0;
+		apei_hest_parse(sdei_ghes_count, &count);
+	}
+	initdbgmsg("%s %zu\n", __func__, count);
 
-	count = ARRAY_SIZE(sdei_ghes_mrvl_pci_tbl) - 1;
-	ghes_drv->source_count = count;
-	initdbgmsg("%s: %ld\n", __func__, count);
+	return count;
 }
 
-static int  sdei_ghes_alloc_source(struct device *dev,
+static int sdei_ghes_alloc_source(struct device *dev,
 		struct mrvl_sdei_ghes_drv *ghes_drv)
 {
 	size_t size = 0;
 
-	initdbgmsg("%s()\n", __func__);
+	initdbgmsg("%s\n", __func__);
 
 	size = ghes_drv->source_count * sizeof(struct mrvl_ghes_source);
 
@@ -609,37 +665,38 @@ static int  sdei_ghes_alloc_source(struct device *dev,
 	return 0;
 }
 
-static void * __init sdei_ghes_of_alloc_hest(struct device *dev,
-		struct mrvl_sdei_ghes_drv *ghes_drv)
+static int __init sdei_ghes_of_alloc_hest(struct mrvl_sdei_ghes_drv *ghes_drv)
 {
 	struct mrvl_ghes_source *gsrc;
 	unsigned int size;
 	struct acpi_table_hest *hest;
 	struct acpi_table_header *hdr;
-	struct acpi_hest_generic *hest_gen;
+	struct acpi_hest_generic *generic;
 	size_t i;
 	u8 *p;
 	u8 sum = 0;
+	struct device *dev = ghes_drv->dev;
 
 	initdbgmsg("%s: entry\n", __func__);
 
 	size = sizeof(struct acpi_table_hest) +
 			ghes_drv->source_count * sizeof(struct acpi_hest_generic);
 
-	hest = kzalloc(size, GFP_KERNEL);
+	hest = devm_kzalloc(dev, size, GFP_KERNEL);
 	if (!hest)
-		return NULL;
+		return -ENOMEM;
 
-	hest_gen = (struct acpi_hest_generic *)(hest + 1);
+	generic = (struct acpi_hest_generic *)(hest + 1);
 
 	hdr = &hest->header;
+
 	strncpy(hdr->signature, ACPI_SIG_HEST, sizeof(hdr->signature));
 	hdr->length = size;
 	hdr->revision = 1;
-	strncpy(hdr->oem_id, MRVL_HEST_OEM_ID, sizeof(hdr->oem_id));
+	strncpy(hdr->oem_id, OTX2_HEST_OEM_ID, sizeof(hdr->oem_id));
 	strncpy(hdr->oem_table_id, HEST_TBL_OEM_ID, sizeof(hdr->oem_table_id));
 	hdr->oem_revision = 1;
-	strncpy(hdr->asl_compiler_id, MRVL_HEST_OEM_ID, sizeof(hdr->asl_compiler_id));
+	strncpy(hdr->asl_compiler_id, OTX2_HEST_OEM_ID, sizeof(hdr->asl_compiler_id));
 	hdr->asl_compiler_revision = 1;
 	p = (u8 *)hdr;
 	while (p < (u8 *)(hdr + 1))
@@ -647,50 +704,53 @@ static void * __init sdei_ghes_of_alloc_hest(struct device *dev,
 	hdr->checksum -= sum;
 	hest->error_source_count = ghes_drv->source_count;
 
-	for (i = 0; i < hest->error_source_count; i++, hest_gen++) {
+	for (i = 0; i < hest->error_source_count; i++, generic++) {
 		gsrc = &ghes_drv->source_list[i];
 
-		hest_gen->header.type = ACPI_HEST_TYPE_GENERIC_ERROR;
-		hest_gen->header.source_id = i;
-		hest_gen->related_source_id = i;
-		hest_gen->reserved = 0;
-		hest_gen->enabled = 1;
-		hest_gen->records_to_preallocate = 1;
-		hest_gen->max_sections_per_record = 1;
-		hest_gen->max_raw_data_length = 0;
-
-		hest_gen->error_status_address.space_id = ACPI_ADR_SPACE_SYSTEM_MEMORY;
-		hest_gen->error_status_address.bit_width = 64;
-		hest_gen->error_status_address.bit_offset = 0;
-		hest_gen->error_status_address.access_width = 4;
-		hest_gen->error_status_address.address = gsrc->esa_pa;
-		hest_gen->notify.type = ACPI_HEST_NOTIFY_POLLED;
-		hest_gen->notify.length = sizeof(struct acpi_hest_notify);
-		hest_gen->notify.config_write_enable = 0;
-		hest_gen->notify.poll_interval = 1000; /* i.e. 1 sec */
-		hest_gen->notify.vector = gsrc->id;
-		hest_gen->notify.error_threshold_value = 1;
-		hest_gen->notify.error_threshold_window = 1;
-		hest_gen->error_block_length =
-				sizeof(struct acpi_hest_generic_status) +
-				sizeof(struct acpi_hest_generic_data) +
-				sizeof(struct cper_sec_mem_err_old);
+		generic->header.type = ACPI_HEST_TYPE_GENERIC_ERROR;
+		generic->header.source_id = i;
+		generic->related_source_id = i;
+		generic->reserved = 0;
+		generic->enabled = 1;
+		generic->records_to_preallocate = 1;
+		generic->max_sections_per_record = 1;
+		generic->max_raw_data_length = 0;
+
+		generic->error_status_address.space_id = ACPI_ADR_SPACE_SYSTEM_MEMORY;
+		generic->error_status_address.bit_width = 64;
+		generic->error_status_address.bit_offset = 0;
+		generic->error_status_address.access_width = 4;
+		generic->error_status_address.address = gsrc->esa_pa;
+
+		generic->notify.type = ACPI_HEST_NOTIFY_POLLED;
+		generic->notify.length = sizeof(struct acpi_hest_notify);
+		generic->notify.config_write_enable = 0;
+		generic->notify.poll_interval = 1000; /* i.e. 1 sec */
+		generic->notify.vector = gsrc->id;
+		generic->notify.error_threshold_value = 1;
+		generic->notify.error_threshold_window = 1;
+
+		generic->error_block_length = gsrc->esb_sz;
+
+		initdbgmsg("%s %s [%x] estatus=%llx, poll=%d, block_sz=%x\n", __func__,
+				gsrc->name, gsrc->id,
+				(unsigned long long)generic->error_status_address.address,
+				generic->notify.poll_interval,
+				generic->error_block_length);
 	}
 
 	hest_table_set(hest);
 
 	acpi_hest_init();
-	dbgmsg(dev, "%s: registering HEST\n", __func__);
+	initdbgmsg("%s registering HEST\n", __func__);
 
-	return hest;
+	return 0;
 }
 
 static int __init sdei_ghes_probe(struct platform_device *pdev)
 {
 	struct mrvl_sdei_ghes_drv *ghes_drv = NULL;
 	struct device *dev = &pdev->dev;
-	struct page *pg = NULL;
-	struct acpi_table_hest *hest = NULL;
 	const struct acpi_device_id *acpi_id = NULL;
 	int ret = -ENODEV;
 
@@ -702,101 +762,90 @@ static int __init sdei_ghes_probe(struct platform_device *pdev)
 #endif
 		return ret;
 
-	initdbgmsg("%s: entry\n", __func__);
+	initdbgmsg("%s\n", __func__);
 
 	ghes_drv = devm_kzalloc(dev, sizeof(struct mrvl_sdei_ghes_drv), GFP_KERNEL);
 	if (!ghes_drv)
 		return -ENOMEM;
 
-	sdei_ghes_count_source(ghes_drv);
+	ghes_drv->dev = dev;
+
+	ghes_drv->source_count = sdei_ghes_count_source(ghes_drv);
+	if (!ghes_drv->source_count) {
+		dev_err(dev, "Not available resource.\n");
+		return -EINVAL;
+	}
+	initdbgmsg("%s source count %ld\n", __func__, ghes_drv->source_count);
 
 	ret = sdei_ghes_alloc_source(dev, ghes_drv);
 	if (ret)
-		goto exit0;
+		return ret;
 
 	platform_set_drvdata(pdev, ghes_drv);
 
 	if (has_acpi_companion(dev)) {
-		dbgmsg(dev, "%s ACPI\n", __func__);
+		initdbgmsg("%s ACPI\n", __func__);
 		acpi_id = acpi_match_device(dev->driver->acpi_match_table, dev);
 		ret = sdei_ghes_acpi_match_resource(pdev);
 	} else {
-		dbgmsg(dev, "%s DeviceTree\n", __func__);
+		initdbgmsg("%s DeviceTree\n", __func__);
 		ret = sdei_ghes_of_match_resource(pdev);
 	}
 	if (ret)
-		goto exit1;
+		return ret;
 
-	ret = sdei_ghes_adjust_error_status_block(&pg, ghes_drv);
+	ret = sdei_ghes_adjust_error_status_block(ghes_drv);
 	if (ret) {
 		dev_err(dev, "Unable adjust status block.\n");
-		goto exit1;
+		return ret;
 	}
 
-	ret = sdei_ghes_map_resource(ghes_drv);
+	ret = sdei_ghes_setup_resource(ghes_drv);
 	if (ret) {
-		dev_err(dev, "Unable map resource.\n");
-		goto exit2;
+		ret = sdei_ghes_map_resource(ghes_drv);
+		if (ret)
+			goto exit0;
 	}
 
 	sdei_ghes_init_source(ghes_drv);
 
 	if (!has_acpi_companion(dev)) {
-		hest = sdei_ghes_of_alloc_hest(dev, ghes_drv);
-		if (!hest) {
+		ret = sdei_ghes_of_alloc_hest(ghes_drv);
+		if (ret) {
 			dev_err(dev, "Unable allocate HEST.\n");
-			goto exit2;
+			goto exit0;
 		}
 	}
 
-	sdei_ghes_msix_init();
+	sdei_ghes_msix_init_t9x();
 
 	ret = sdei_ghes_driver_init(pdev);
-	if (ret)
-		goto exit3;
+	if (ret) {
+		dev_err(dev, "Error initializing SDEI GHES support.\n");
+		sdei_ghes_driver_deinit(pdev);
+		goto exit0;
+	}
 
 	return 0;
 
-exit3:
-	dev_err(dev, "Error initializing SDEI GHES support.\n");
-	sdei_ghes_driver_deinit(pdev);
-	kfree(hest);
-exit2:
-	if (pg)
-		__free_page(pg);
-exit1:
-	devm_kfree(dev, ghes_drv->source_list);
 exit0:
-	devm_kfree(dev, ghes_drv);
-
-	return -ENODEV;
+	if (error_status_block_page)
+		__free_pages(error_status_block_page, order);
+	return ret;
 }
 
 static int sdei_ghes_remove(struct platform_device *pdev)
 {
-	struct mrvl_sdei_ghes_drv *ghes_drv;
-	struct device *dev = &pdev->dev;
-
-	ghes_drv = platform_get_drvdata(pdev);
-
-	dbgmsg(dev, "%s: entry\n", __func__);
+	initdbgmsg("%s: entry\n", __func__);
 
 	sdei_ghes_driver_deinit(pdev);
 
-	devm_kfree(dev, ghes_drv->source_list);
-
-	devm_kfree(dev, ghes_drv);
+	if (error_status_block_page)
+		__free_pages(error_status_block_page, order);
 
 	return 0;
 }
 
-static void sdei_ghes_shutdown(struct platform_device *pdev)
-{
-	struct device *dev = &pdev->dev;
-
-	dbgmsg(dev, "%s: entry\n", __func__);
-}
-
 static const struct platform_device_id sdei_ghes_pdev_match[] = {
 	{ .name = DRV_NAME, },
 	{},
@@ -811,9 +860,11 @@ static struct platform_driver sdei_ghes_drv_probe = {
 	},
 	.probe    = sdei_ghes_probe,
 	.remove   = sdei_ghes_remove,
-	.shutdown = sdei_ghes_shutdown,
 	.id_table = sdei_ghes_pdev_match,
 };
 module_platform_driver(sdei_ghes_drv_probe);
 
+
 MODULE_DESCRIPTION("OcteonTX2 SDEI GHES Driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DRV_NAME);
diff --git a/drivers/soc/marvell/octeontx2-ghes/otx2-sdei-ghes.h b/drivers/soc/marvell/octeontx2-ghes/otx2-sdei-ghes.h
index d31c4eddfd6c..205662db5f9b 100644
--- a/drivers/soc/marvell/octeontx2-ghes/otx2-sdei-ghes.h
+++ b/drivers/soc/marvell/octeontx2-ghes/otx2-sdei-ghes.h
@@ -1,13 +1,13 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Marvell CN10K Generic Hardware Error Source[s] (GHES)
+ * Supports OcteonTX2 Generic Hardware Error Source[s] (GHES).
  * GHES ACPI HEST & DT
  *
  * Copyright (C) 2021 Marvell.
  */
 
-#ifndef __MRVL_SDEI_GHES_H__
-#define __MRVL_SDEI_GHES_H__
+#ifndef __OTX2_SDEI_GHES_H__
+#define __OTX2_SDEI_GHES_H__
 
 #define SDEI_GHES_EVENT_NAME_MAX_CHARS 16
 /*
@@ -42,26 +42,24 @@ struct mrvl_ghes_source {
 /**
  * struct mrvl_sdei_ghes_drv: driver state
  *
- * @of_node:                  associated device tree node
  * @source_list:              list of [SDEI] producers
  *                            (1 for each error source)
  * @source_count:             count of [SDEI] producers
  *                            (size of @source_list)
  */
 struct mrvl_sdei_ghes_drv {
-	struct device_node                   *of_node;  //remove TODO:
-	struct mrvl_ghes_source              *source_list;
-	size_t                               source_count;
+	struct device           *dev;
+	struct mrvl_ghes_source *source_list;
+	size_t                  source_count;
 };
 
 #define MRVL_GHES_ERR_REC_FRU_TEXT_LEN 32
 /* This is shared with ATF */
 struct mrvl_ghes_err_record {
 	union {
-		struct cper_sec_mem_err_old  mcc;
-		struct cper_sec_mem_err_old  mdc;
-		struct cper_sec_mem_err_old  lmc;
-		struct cper_arm_err_info     ap; /* application processor */
+		struct cper_sec_mem_err_old mcc;
+		struct cper_sec_mem_err_old mdc;
+		struct cper_sec_mem_err_old lmc;
 	} u;
 	uint32_t severity; /* CPER_SEV_xxx */
 	char fru_text[MRVL_GHES_ERR_REC_FRU_TEXT_LEN];
@@ -79,4 +77,4 @@ struct mrvl_ghes_err_ring {
 	struct mrvl_ghes_err_record records[1] __aligned(8);
 };
 
-#endif // __MRVL_SDEI_GHES_H__
+#endif // __OTX2_SDEI_GHES_H__
-- 
2.31.1

