From 99e80d7813c7eed058d83608f270360f3a550252 Mon Sep 17 00:00:00 2001
From: Felix Manlunas <fmanlunas@marvell.com>
Date: Thu, 20 Jun 2019 14:09:21 -0700
Subject: [PATCH 256/767] octeontx2-pf: Add ethtool priv flag to control PAM4
 on/off

commit 279972b4113517969e0192bd720cd46f35bee96b from
git@git.assembla.com:cavium/WindRiver.linux.git

For PHYs that support changing modulation type (NRZ or PAM4), enable these
commands:

    ethtool --set-priv-flags  ethX pam4 on
    ethtool --set-priv-flags  ethX pam4 off    # means NRZ modulation
    ethtool --show-priv-flags ethX

Add new fields (pertaining to PHY modulation type) to rvu->fwdata.  The new
fields replace one element of the reserved u64 array in struct
cgx_lmac_fwdata_s, so the reserved array element count is decreased by one.

Rename the macro RESERVED_MEM in mbox.h to LMAC_FWDATA_RESERVED_MEM
because RESERVED_MEM is used by two arrays that can independently change
size.

Put #define RESERVED_MEM in rvu.h right above the array that references it.

Change-Id: I96f20c2d903f4438e1274d33438d9fcf14e7278c
Signed-off-by: Felix Manlunas <fmanlunas@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/11305
Reviewed-by: Derek Chickles <Derek.Chickles@cavium.com>
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Tested-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Signed-off-by: Sunil Goutham <sgoutham@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/11458
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../net/ethernet/marvell/octeontx2/af/mbox.h  | 10 ++-
 .../net/ethernet/marvell/octeontx2/af/rvu.h   |  1 +
 .../marvell/octeontx2/nic/otx2_ethtool.c      | 75 ++++++++++++++++++-
 3 files changed, 83 insertions(+), 3 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/af/mbox.h b/drivers/net/ethernet/marvell/octeontx2/af/mbox.h
index 88ac0257f5c2..cd0de9103f11 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/mbox.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/mbox.h
@@ -486,6 +486,11 @@ enum fec_type {
 	OTX2_FEC_RS,
 };
 
+struct phy_s {
+	u64 can_change_mod_type : 1;
+	u64 mod_type            : 1;
+};
+
 struct cgx_lmac_fwdata_s {
 	u16 rw_valid;
 	u64 supported_fec;
@@ -496,8 +501,9 @@ struct cgx_lmac_fwdata_s {
 	u64 advertised_link_modes;
 	/* Only applicable if SFP/QSFP slot is present */
 	struct sfp_eeprom_s sfp_eeprom;
-#define RESERVED_MEM 1024
-	u64 reserved[RESERVED_MEM];
+	struct phy_s phy;
+#define LMAC_FWDATA_RESERVED_MEM 1023
+	u64 reserved[LMAC_FWDATA_RESERVED_MEM];
 };
 
 struct cgx_fw_data {
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu.h b/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
index f6a082c9fe92..b6c927199e3b 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
@@ -387,6 +387,7 @@ struct rvu_fwdata {
 	u64 rclk;
 	u64 mcam_addr;
 	u64 mcam_sz;
+#define RESERVED_MEM 1024
 	u64 reserved[RESERVED_MEM];
 #define CGX_MAX         3
 #define CGX_LMACS_MAX   4
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_ethtool.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_ethtool.c
index a5c46301a61c..6f98b4fcbc16 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_ethtool.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_ethtool.c
@@ -25,6 +25,11 @@
 
 #define OTX2_DEFAULT_ACTION	0x1
 
+static const char otx2_priv_flags_strings[][ETH_GSTRING_LEN] = {
+#define OTX2_PRIV_FLAGS_PAM4 BIT(0)
+	"pam4",
+};
+
 struct otx2_stat {
 	char name[ETH_GSTRING_LEN];
 	unsigned int index;
@@ -95,6 +100,12 @@ static void otx2_get_strings(struct net_device *netdev, u32 sset, u8 *data)
 	struct otx2_nic *pfvf = netdev_priv(netdev);
 	int stats;
 
+	if (sset == ETH_SS_PRIV_FLAGS) {
+		memcpy(data, otx2_priv_flags_strings,
+		       ARRAY_SIZE(otx2_priv_flags_strings) * ETH_GSTRING_LEN);
+		return;
+	}
+
 	if (sset != ETH_SS_STATS)
 		return;
 
@@ -172,6 +183,9 @@ static int otx2_get_sset_count(struct net_device *netdev, int sset)
 	struct otx2_nic *pfvf = netdev_priv(netdev);
 	int qstats_count;
 
+	if (sset == ETH_SS_PRIV_FLAGS)
+		return ARRAY_SIZE(otx2_priv_flags_strings);
+
 	if (sset != ETH_SS_STATS)
 		return -EINVAL;
 
@@ -1293,7 +1307,7 @@ end:	otx2_mbox_unlock(&pfvf->mbox);
 	return err;
 }
 
-static const struct ethtool_ops otx2_ethtool_ops = {
+static struct ethtool_ops otx2_ethtool_ops = {
 	.get_drvinfo		= otx2_get_drvinfo,
 	.get_strings		= otx2_get_strings,
 	.get_ethtool_stats	= otx2_get_ethtool_stats,
@@ -1322,8 +1336,67 @@ static const struct ethtool_ops otx2_ethtool_ops = {
 	.get_module_eeprom	= otx2_get_module_eeprom,
 };
 
+static int otx2_set_priv_flags(struct net_device *netdev, u32 priv_flags)
+{
+	struct otx2_nic *pfvf = netdev_priv(netdev);
+	struct cgx_phy_mod_type *req, *rsp;
+	int rc = 0;
+
+	otx2_mbox_lock(&pfvf->mbox);
+	req = otx2_mbox_alloc_msg_cgx_set_phy_mod_type(&pfvf->mbox);
+	if (!req) {
+		rc = -EAGAIN;
+		goto end;
+	}
+	req->mod = priv_flags & OTX2_PRIV_FLAGS_PAM4;
+	rc = otx2_sync_mbox_msg(&pfvf->mbox);
+	if (rc)
+		goto end;
+
+	rsp = (struct cgx_phy_mod_type *)otx2_mbox_get_rsp(&pfvf->mbox.mbox, 0,
+							   &req->hdr);
+	if (IS_ERR(rsp)) {
+		rc = PTR_ERR(rsp);
+		goto end;
+	}
+	if (rsp->hdr.rc) {
+		rc = rsp->hdr.rc;
+		goto end;
+	}
+
+end:	otx2_mbox_unlock(&pfvf->mbox);
+	return rc;
+}
+
+static u32 otx2_get_priv_flags(struct net_device *netdev)
+{
+	struct otx2_nic *pfvf = netdev_priv(netdev);
+	struct cgx_fw_data *rsp;
+	u32 priv_flags = 0;
+
+	rsp = otx2_get_fwdata(pfvf);
+
+	if (IS_ERR(rsp))
+		return 0;
+
+	if (rsp->fwdata.phy.mod_type)
+		priv_flags |= OTX2_PRIV_FLAGS_PAM4;
+
+	return priv_flags;
+}
+
 void otx2_set_ethtool_ops(struct net_device *netdev)
 {
+	struct otx2_nic *pfvf = netdev_priv(netdev);
+	struct cgx_fw_data *rsp;
+
+	rsp = otx2_get_fwdata(pfvf);
+
+	if (!IS_ERR(rsp) && rsp->fwdata.phy.can_change_mod_type) {
+		otx2_ethtool_ops.set_priv_flags = otx2_set_priv_flags;
+		otx2_ethtool_ops.get_priv_flags = otx2_get_priv_flags;
+	}
+
 	netdev->ethtool_ops = &otx2_ethtool_ops;
 }
 
-- 
2.31.1

