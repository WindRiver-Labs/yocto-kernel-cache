From 40dd0293ccc1c99bb9292df3510cbdbb7ca48114 Mon Sep 17 00:00:00 2001
From: Suneel Garapati <sgarapati@marvell.com>
Date: Mon, 24 Aug 2020 18:59:51 -0700
Subject: [PATCH 0984/1921] drivers: i2c: octeon: Reduce latency for HS mode

In high-speed mode, clear IFLG early to release SCL line.
Wait with timeout kernel mechanisms add delay between
data byte transfers and impacts total duration in High
speed mode so use polling with delay.

Change-Id: I2b25cf556ba4fe7724e91190ad476b67109ccfba
Signed-off-by: Suneel Garapati <sgarapati@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/37864
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
(cherry picked from commit 71e333f6fcdc3927c7d10811a9ac5195d10d5221)
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/42598
Reviewed-by: Chandrakala Chavva <cchavva@marvell.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 drivers/i2c/busses/i2c-octeon-core.c | 35 ++++++++++++++++++++++++----
 1 file changed, 30 insertions(+), 5 deletions(-)

diff --git a/drivers/i2c/busses/i2c-octeon-core.c b/drivers/i2c/busses/i2c-octeon-core.c
index 23a9790a455c..1f37e3e6dae2 100644
--- a/drivers/i2c/busses/i2c-octeon-core.c
+++ b/drivers/i2c/busses/i2c-octeon-core.c
@@ -32,6 +32,14 @@ irqreturn_t octeon_i2c_isr(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
+static void octeon_i2c_clear_iflg(struct octeon_i2c *i2c)
+{
+	int ctl = octeon_i2c_ctl_read(i2c);
+
+	ctl &= (~TWSI_CTL_IFLG);
+	octeon_i2c_ctl_write(i2c, ctl);
+}
+
 static bool octeon_i2c_test_iflg(struct octeon_i2c *i2c)
 {
 	return (octeon_i2c_ctl_read(i2c) & TWSI_CTL_IFLG);
@@ -61,11 +69,19 @@ static int octeon_i2c_wait(struct octeon_i2c *i2c)
 		return octeon_i2c_test_iflg(i2c) ? 0 : -ETIMEDOUT;
 	}
 
-	i2c->int_enable(i2c);
-	time_left = wait_event_timeout(i2c->queue, octeon_i2c_test_iflg(i2c),
-				       i2c->adap.timeout);
-	i2c->int_disable(i2c);
-
+	if (i2c->twsi_freq <= FREQ_400KHZ) {
+		i2c->int_enable(i2c);
+		time_left = wait_event_timeout(i2c->queue,
+					       octeon_i2c_test_iflg(i2c),
+					       i2c->adap.timeout);
+		i2c->int_disable(i2c);
+	} else {
+		time_left = 1000; /* 1ms */
+		do {
+			if (time_left--)
+				__udelay(1);
+		} while (!octeon_i2c_test_iflg(i2c));
+	}
 	if (i2c->broken_irq_check && !time_left &&
 	    octeon_i2c_test_iflg(i2c)) {
 		dev_err(i2c->dev, "broken irq connection detected, switching to polling mode.\n");
@@ -321,6 +337,9 @@ static int octeon_i2c_read(struct octeon_i2c *i2c, int target,
 	result = octeon_i2c_check_status(i2c, false);
 	if (result)
 		return result;
+	/* Clear IFLG bit early incase of HS Mode */
+	if (i2c->twsi_freq > FREQ_400KHZ)
+		octeon_i2c_clear_iflg(i2c);
 
 	for (i = 0; i < length; i++) {
 		/*
@@ -356,6 +375,9 @@ static int octeon_i2c_read(struct octeon_i2c *i2c, int target,
 		result = octeon_i2c_check_status(i2c, final_read);
 		if (result)
 			return result;
+		/* Clear IFLG bit early incase of HS Mode */
+		if (i2c->twsi_freq > FREQ_400KHZ)
+			octeon_i2c_clear_iflg(i2c);
 	}
 	*rlength = length;
 	return 0;
@@ -388,6 +410,9 @@ static int octeon_i2c_write(struct octeon_i2c *i2c, int target,
 		result = octeon_i2c_check_status(i2c, false);
 		if (result)
 			return result;
+		/* Clear IFLG bit early incase of HS Mode */
+		if (i2c->twsi_freq > FREQ_400KHZ)
+			octeon_i2c_clear_iflg(i2c);
 
 		octeon_i2c_data_write(i2c, data[i]);
 		octeon_i2c_ctl_write(i2c, TWSI_CTL_ENAB);
-- 
2.31.1

