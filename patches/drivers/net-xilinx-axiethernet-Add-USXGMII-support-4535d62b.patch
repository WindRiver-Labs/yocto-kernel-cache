From ce00c4d1edc20ae6ff61685902b58cfaa1b850b3 Mon Sep 17 00:00:00 2001
From: Harini Katakam <harini.katakam@xilinx.com>
Date: Fri, 24 Jan 2020 20:52:38 +0530
Subject: [PATCH 1062/1851] net: xilinx: axiethernet: Add USXGMII support

commit a93cf3684501214ce3beefc4ade801452551c785 from
https://github.com/Xilinx/linux-xlnx.git

This patch adds support for USXGMII IP in axiethernet driver.
This IP has a MAC similar to 10G/25G IP and supports USXGMII phy protocol.
USXGMII phy supports speeds from 10Mbps to 10Gbps. Only one phy speed
can be advertised at a time and this choice is obtained from the user
via a devicetree property. This patch was tested at 1G and 2.5G speeds.
Since the MAC functionality is similar to 10G/25G, the same mac type is
used in the config structure. USXGMII IP requires a GT reset and this is
added to axienet_device_reset with a check based on mac type.

Signed-off-by: Harini Katakam <harini.katakam@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
Signed-off-by: Radhey Shyam Pandey <radhey.shyam.pandey@xilinx.com>
State: not-upstreamable
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 drivers/net/ethernet/xilinx/xilinx_axienet.h  |  25 +++++
 .../net/ethernet/xilinx/xilinx_axienet_main.c | 105 +++++++++++++++++-
 include/linux/xilinx_phy.h                    |   1 +
 3 files changed, 128 insertions(+), 3 deletions(-)

diff --git a/drivers/net/ethernet/xilinx/xilinx_axienet.h b/drivers/net/ethernet/xilinx/xilinx_axienet.h
index a82a768aab7c..9ce225343db0 100644
--- a/drivers/net/ethernet/xilinx/xilinx_axienet.h
+++ b/drivers/net/ethernet/xilinx/xilinx_axienet.h
@@ -378,13 +378,17 @@
 #define TX_PTP_TS_OFFSET        0x4C
 
 /* XXV MAC Register Definitions */
+#define XXV_GT_RESET_OFFSET		0x00000000
 #define XXV_TC_OFFSET			0x0000000C
 #define XXV_RCW1_OFFSET			0x00000014
 #define XXV_JUM_OFFSET			0x00000018
 #define XXV_TICKREG_OFFSET		0x00000020
 #define XXV_STATRX_BLKLCK_OFFSET	0x0000040C
+#define XXV_USXGMII_AN_OFFSET		0x000000C8
+#define XXV_USXGMII_AN_STS_OFFSET	0x00000458
 
 /* XXV MAC Register Mask Definitions */
+#define XXV_GT_RESET_MASK	BIT(0)
 #define XXV_TC_TX_MASK		BIT(0)
 #define XXV_RCW1_RX_MASK	BIT(0)
 #define XXV_RCW1_FCS_MASK	BIT(1)
@@ -394,6 +398,25 @@
 #define XXV_RX_BLKLCK_MASK	BIT(0)
 #define XXV_TICKREG_STATEN_MASK BIT(0)
 #define XXV_MAC_MIN_PKT_LEN	64
+
+/* USXGMII Register Mask Definitions  */
+#define USXGMII_AN_EN		BIT(5)
+#define USXGMII_AN_RESET	BIT(6)
+#define USXGMII_AN_RESTART	BIT(7)
+#define USXGMII_EN		BIT(16)
+#define USXGMII_RATE_MASK	0x0E000700
+#define USXGMII_RATE_1G		0x04000200
+#define USXGMII_RATE_2G5	0x08000400
+#define USXGMII_RATE_10M	0x0
+#define USXGMII_RATE_100M	0x02000100
+#define USXGMII_RATE_5G		0x0A000500
+#define USXGMII_RATE_10G	0x06000300
+#define USXGMII_FD		BIT(28)
+#define USXGMII_LINK_STS	BIT(31)
+
+/* USXGMII AN STS register mask definitions */
+#define USXGMII_AN_STS_COMP_MASK	BIT(16)
+
 /* MCDMA Register Definitions */
 #define XMCDMA_CR_OFFSET	0x00
 #define XMCDMA_SR_OFFSET	0x04
@@ -625,6 +648,7 @@ struct aximcdma_bd {
  * @chan_id:  MCMDA Channel id used in conjunction with weight parameter.
  * @weight:   MCDMA Channel weight value to be configured for.
  * @dma_mask: Specify the width of the DMA address space.
+ * @usxgmii_rate: USXGMII PHY speed.
  */
 struct axienet_local {
 	struct net_device *ndev;
@@ -697,6 +721,7 @@ struct axienet_local {
 	u16 weight;
 
 	u8 dma_mask;
+	u32 usxgmii_rate;
 };
 
 /**
diff --git a/drivers/net/ethernet/xilinx/xilinx_axienet_main.c b/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
index c2ee00b8d334..2de3b6d10994 100644
--- a/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
+++ b/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
@@ -419,12 +419,21 @@ static void axienet_device_reset(struct net_device *ndev)
 	struct axienet_dma_q *q;
 	u32 i;
 
+	if (lp->axienet_config->mactype == XAXIENET_10G_25G) {
+		/* Reset the XXV MAC */
+		val = axienet_ior(lp, XXV_GT_RESET_OFFSET);
+		val |= XXV_GT_RESET_MASK;
+		axienet_iow(lp, XXV_GT_RESET_OFFSET, val);
+		/* Wait for 1ms for GT reset to complete as per spec */
+		mdelay(1);
+		val = axienet_ior(lp, XXV_GT_RESET_OFFSET);
+		val &= ~XXV_GT_RESET_MASK;
+		axienet_iow(lp, XXV_GT_RESET_OFFSET, val);
+	}
+
 	for_each_rx_dma_queue(lp, i) {
 		q = lp->dq[i];
 		__axienet_device_reset(q);
-#ifndef CONFIG_AXIENET_HAS_MCDMA
-		__axienet_device_reset(q);
-#endif
 	}
 
 	lp->max_frm_size = XAE_MAX_VLAN_FRAME_SIZE;
@@ -1391,6 +1400,7 @@ static int axienet_open(struct net_device *ndev)
 	int ret = 0, i;
 	struct axienet_local *lp = netdev_priv(ndev);
 	struct axienet_dma_q *q;
+	u32 reg, err;
 
 	dev_dbg(&ndev->dev, "axienet_open()\n");
 
@@ -1466,6 +1476,78 @@ static int axienet_open(struct net_device *ndev)
 #endif
 	}
 
+	if (lp->phy_mode == PHY_INTERFACE_MODE_USXGMII) {
+		netdev_dbg(ndev, "RX reg: 0x%x\n",
+			   axienet_ior(lp, XXV_RCW1_OFFSET));
+		/* USXGMII setup at selected speed */
+		reg = axienet_ior(lp, XXV_USXGMII_AN_OFFSET);
+		reg &= ~USXGMII_RATE_MASK;
+		netdev_dbg(ndev, "usxgmii_rate %d\n", lp->usxgmii_rate);
+		switch (lp->usxgmii_rate) {
+		case SPEED_1000:
+			reg |= USXGMII_RATE_1G;
+			break;
+		case SPEED_2500:
+			reg |= USXGMII_RATE_2G5;
+			break;
+		case SPEED_10:
+			reg |= USXGMII_RATE_10M;
+			break;
+		case SPEED_100:
+			reg |= USXGMII_RATE_100M;
+			break;
+		case SPEED_5000:
+			reg |= USXGMII_RATE_5G;
+			break;
+		case SPEED_10000:
+			reg |= USXGMII_RATE_10G;
+			break;
+		default:
+			reg |= USXGMII_RATE_1G;
+		}
+		reg |= USXGMII_FD;
+		reg |= (USXGMII_EN | USXGMII_LINK_STS);
+		axienet_iow(lp, XXV_USXGMII_AN_OFFSET, reg);
+		reg |= USXGMII_AN_EN;
+		axienet_iow(lp, XXV_USXGMII_AN_OFFSET, reg);
+		/* AN Restart bit should be reset, set and then reset as per
+		 * spec with a 1 ms delay for a raising edge trigger
+		 */
+		axienet_iow(lp, XXV_USXGMII_AN_OFFSET,
+			    reg & ~USXGMII_AN_RESTART);
+		mdelay(1);
+		axienet_iow(lp, XXV_USXGMII_AN_OFFSET,
+			    reg | USXGMII_AN_RESTART);
+		mdelay(1);
+		axienet_iow(lp, XXV_USXGMII_AN_OFFSET,
+			    reg & ~USXGMII_AN_RESTART);
+
+		/* Check block lock bit to make sure RX path is ok with
+		 * USXGMII initialization.
+		 */
+		err = readl_poll_timeout(lp->regs + XXV_STATRX_BLKLCK_OFFSET,
+					 reg, (reg & XXV_RX_BLKLCK_MASK),
+					 100, DELAY_OF_ONE_MILLISEC);
+		if (err) {
+			netdev_err(ndev, "%s: USXGMII Block lock bit not set",
+				   __func__);
+			ret = -ENODEV;
+			goto err_eth_irq;
+		}
+
+		err = readl_poll_timeout(lp->regs + XXV_USXGMII_AN_STS_OFFSET,
+					 reg, (reg & USXGMII_AN_STS_COMP_MASK),
+					 1000000, DELAY_OF_ONE_MILLISEC);
+		if (err) {
+			netdev_err(ndev, "%s: USXGMII AN not complete",
+				   __func__);
+			ret = -ENODEV;
+			goto err_eth_irq;
+		}
+
+		netdev_info(ndev, "USXGMII setup at %d\n", lp->usxgmii_rate);
+	}
+
 	/* Enable interrupts for Axi Ethernet core (if defined) */
 	if (!lp->eth_hasnobuf && (lp->axienet_config->mactype == XAXIENET_1G)) {
 		ret = request_irq(lp->eth_irq, axienet_eth_irq, IRQF_SHARED,
@@ -2688,6 +2770,13 @@ static const struct axienet_config axienet_10g25g_config = {
 	.tx_ptplen = XXV_TX_PTP_LEN,
 };
 
+static const struct axienet_config axienet_usxgmii_config = {
+	.mactype = XAXIENET_10G_25G,
+	.setoptions = xxvenet_setoptions,
+	.clk_init = xxvenet_clk_init,
+	.tx_ptplen = 0,
+};
+
 /* Match table for of_platform binding */
 static const struct of_device_id axienet_of_match[] = {
 	{ .compatible = "xlnx,axi-ethernet-1.00.a", .data = &axienet_1g_config},
@@ -2698,6 +2787,8 @@ static const struct of_device_id axienet_of_match[] = {
 	{ .compatible = "xlnx,ten-gig-eth-mac", .data = &axienet_10g_config},
 	{ .compatible = "xlnx,xxv-ethernet-1.0",
 						.data = &axienet_10g25g_config},
+	{ .compatible = "xlnx,xxv-usxgmii-ethernet-1.0",
+					.data = &axienet_usxgmii_config},
 	{},
 };
 
@@ -2857,6 +2948,9 @@ static int axienet_probe(struct platform_device *pdev)
 		case XAE_PHY_TYPE_1000BASE_X:
 			lp->phy_mode = PHY_INTERFACE_MODE_1000BASEX;
 			break;
+		case XXE_PHY_TYPE_USXGMII:
+			lp->phy_mode = PHY_INTERFACE_MODE_USXGMII;
+			break;
 		default:
 			/* Don't error out as phy-type is an optional property */
 			break;
@@ -2868,6 +2962,11 @@ static int axienet_probe(struct platform_device *pdev)
 		}
 	}
 
+	/* Set default USXGMII rate */
+	lp->usxgmii_rate = SPEED_1000;
+	of_property_read_u32(pdev->dev.of_node, "xlnx,usxgmii-rate",
+			     &lp->usxgmii_rate);
+
 	lp->eth_hasnobuf = of_property_read_bool(pdev->dev.of_node,
 						 "xlnx,eth-hasnobuf");
 	lp->eth_hasptp = of_property_read_bool(pdev->dev.of_node,
diff --git a/include/linux/xilinx_phy.h b/include/linux/xilinx_phy.h
index c523fd9a4c57..34a048f7dbe6 100644
--- a/include/linux/xilinx_phy.h
+++ b/include/linux/xilinx_phy.h
@@ -15,5 +15,6 @@
 #define XAE_PHY_TYPE_SGMII		4
 #define XAE_PHY_TYPE_1000BASE_X		5
 #define XAE_PHY_TYPE_2500		6
+#define XXE_PHY_TYPE_USXGMII		7
 
 #endif /* _XILINX_PHY_H */
-- 
2.31.1

