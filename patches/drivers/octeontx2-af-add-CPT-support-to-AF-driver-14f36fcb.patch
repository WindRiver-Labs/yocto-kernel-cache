From bf1a869fa162f2aca95eeda536af6d5207d5f15c Mon Sep 17 00:00:00 2001
From: Lukasz Bartosik <lbartosik@marvell.com>
Date: Fri, 1 Feb 2019 19:19:52 +0530
Subject: [PATCH 0030/1921] octeontx2-af: add CPT support to AF driver

Change-Id: Ic264b4e64112c27d78e4550055a3b809d4f48adc
Signed-off-by: Lukasz Bartosik <lbartosik@marvell.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 .../ethernet/marvell/octeontx2/af/Makefile    |   2 +-
 .../net/ethernet/marvell/octeontx2/af/mbox.h  |  46 +++
 .../net/ethernet/marvell/octeontx2/af/rvu.c   |   8 +
 .../net/ethernet/marvell/octeontx2/af/rvu.h   |  15 +
 .../ethernet/marvell/octeontx2/af/rvu_cpt.c   | 390 ++++++++++++++++++
 .../ethernet/marvell/octeontx2/af/rvu_reg.h   |  59 ++-
 .../marvell/octeontx2/af/rvu_struct.h         |   9 +
 7 files changed, 522 insertions(+), 7 deletions(-)
 create mode 100644 drivers/net/ethernet/marvell/octeontx2/af/rvu_cpt.c

diff --git a/drivers/net/ethernet/marvell/octeontx2/af/Makefile b/drivers/net/ethernet/marvell/octeontx2/af/Makefile
index 0bb77928b25a..cf4a4a005c2f 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/Makefile
+++ b/drivers/net/ethernet/marvell/octeontx2/af/Makefile
@@ -9,4 +9,4 @@ obj-$(CONFIG_OCTEONTX2_AF) += octeontx2_af.o
 octeontx2_mbox-y := mbox.o
 octeontx2_af-y := cgx.o rvu.o rvu_cgx.o rvu_npa.o rvu_nix.o \
 		  rvu_reg.o rvu_npc.o rvu_validation.o rvu_sso.o \
-		  rvu_tim.o
+		  rvu_tim.o rvu_cpt.o
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/mbox.h b/drivers/net/ethernet/marvell/octeontx2/af/mbox.h
index 2bb6f0e28aa2..6c97f4950f18 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/mbox.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/mbox.h
@@ -176,6 +176,14 @@ M(TIM_CONFIG_RING,	0x802, tim_config_ring, tim_config_req, msg_rsp)\
 M(TIM_ENABLE_RING,	0x803, tim_enable_ring, tim_ring_req, tim_enable_rsp)\
 M(TIM_DISABLE_RING,	0x804, tim_disable_ring, tim_ring_req, msg_rsp)	\
 /* CPT mbox IDs (range 0xA00 - 0xBFF) */				\
+M(CPT_LF_ALLOC,		0xA00, cpt_lf_alloc, cpt_lf_alloc_req_msg,	\
+			       cpt_lf_alloc_rsp_msg)			\
+M(CPT_LF_FREE,		0xA01, cpt_lf_free, msg_req, msg_rsp)		\
+M(CPT_RD_WR_REGISTER,	0xA02, cpt_rd_wr_register,  cpt_rd_wr_reg_msg,	\
+			       cpt_rd_wr_reg_msg)			\
+M(CPT_SET_CRYPTO_GRP,	0xA03, cpt_set_crypto_grp,			\
+			       cpt_set_crypto_grp_req_msg,		\
+			       cpt_set_crypto_grp_req_msg)		\
 /* NPC mbox IDs (range 0x6000 - 0x7FFF) */				\
 M(NPC_MCAM_ALLOC_ENTRY,	0x6000, npc_mcam_alloc_entry, npc_mcam_alloc_entry_req,\
 				npc_mcam_alloc_entry_rsp)		\
@@ -1010,4 +1018,42 @@ struct tim_enable_rsp {
 	u32	currentbucket;
 };
 
+/* CPT mailbox error codes
+ * Range 901 - 1000.
+ */
+enum cpt_af_status {
+	CPT_AF_ERR_PARAM		= -901,
+	CPT_AF_ERR_GRP_INVALID		= -902,
+	CPT_AF_ERR_LF_INVALID		= -903,
+	CPT_AF_ERR_ACCESS_DENIED	= -904,
+	CPT_AF_ERR_SSO_PF_FUNC_INVALID	= -905,
+	CPT_AF_ERR_NIX_PF_FUNC_INVALID	= -906
+};
+
+/* CPT mbox message formats */
+
+struct cpt_rd_wr_reg_msg {
+	struct mbox_msghdr hdr;
+	u64 reg_offset;
+	u64 *ret_val;
+	u64 val;
+	u8 is_write;
+};
+
+struct cpt_set_crypto_grp_req_msg {
+	struct mbox_msghdr hdr;
+	u8 crypto_eng_grp;
+};
+
+struct cpt_lf_alloc_req_msg {
+	struct mbox_msghdr hdr;
+	u16 nix_pf_func;
+	u16 sso_pf_func;
+};
+
+struct cpt_lf_alloc_rsp_msg {
+	struct mbox_msghdr hdr;
+	u8 crypto_eng_grp;
+};
+
 #endif /* MBOX_H */
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu.c
index fa42eefc9e62..2dc122103293 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu.c
@@ -838,6 +838,10 @@ static int rvu_setup_hw_resources(struct rvu *rvu)
 	if (err)
 		goto cgx_err;
 
+	err = rvu_cpt_init(rvu);
+	if (err)
+		goto cgx_err;
+
 	return 0;
 
 cgx_err:
@@ -2485,6 +2489,10 @@ static int rvu_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	if (err)
 		goto err_flr;
 
+	err = rvu_cpt_register_interrupts(rvu);
+	if (err)
+		goto err_irq;
+
 	err = rvu_policy_init(rvu);
 	if (err)
 		goto err_irq;
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu.h b/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
index 10bcf229efd7..55e3a619fb8f 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
@@ -338,6 +338,7 @@ int rvu_get_lf(struct rvu *rvu, struct rvu_block *block, u16 pcifunc, u16 slot);
 int rvu_lf_reset(struct rvu *rvu, struct rvu_block *block, int lf);
 int rvu_get_blkaddr(struct rvu *rvu, int blktype, u16 pcifunc);
 int rvu_poll_reg(struct rvu *rvu, u64 block, u64 offset, u64 mask, bool zero);
+u16 rvu_get_rsrc_mapcount(struct rvu_pfvf *pfvf, int blkid);
 
 /* RVU HW reg validation */
 enum regmap_block {
@@ -559,6 +560,20 @@ int rvu_mbox_handler_npc_mcam_alloc_and_write_entry(struct rvu *rvu,
 			  struct npc_mcam_alloc_and_write_entry_rsp *rsp);
 int rvu_mbox_handler_npc_get_kex_cfg(struct rvu *rvu, struct msg_req *req,
 				     struct npc_get_kex_cfg_rsp *rsp);
+/* CPT APIs */
+int rvu_cpt_init(struct rvu *rvu);
+int rvu_cpt_register_interrupts(struct rvu *rvu);
+int rvu_mbox_handler_cpt_set_crypto_grp(struct rvu *rvu,
+				struct cpt_set_crypto_grp_req_msg *req,
+				struct cpt_set_crypto_grp_req_msg *rsp);
+int rvu_mbox_handler_cpt_rd_wr_register(struct rvu *rvu,
+					struct cpt_rd_wr_reg_msg *req,
+					struct cpt_rd_wr_reg_msg *rsp);
+int rvu_mbox_handler_cpt_lf_alloc(struct rvu *rvu,
+				  struct cpt_lf_alloc_req_msg *req,
+				  struct cpt_lf_alloc_rsp_msg *rsp);
+int rvu_mbox_handler_cpt_lf_free(struct rvu *rvu, struct msg_req *req,
+				 struct msg_rsp *rsp);
 
 /* TIM APIs */
 int rvu_tim_init(struct rvu *rvu);
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_cpt.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_cpt.c
new file mode 100644
index 000000000000..acaf1ce340c2
--- /dev/null
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_cpt.c
@@ -0,0 +1,390 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Marvell OcteonTx2 RVU Admin Function driver
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include "rvu_struct.h"
+#include "rvu_reg.h"
+#include "mbox.h"
+#include "rvu.h"
+
+/* CPT PF device id */
+#define	PCI_DEVID_OTX2_CPT_PF	0xA0FD
+
+/* Maximum supported microcode groups */
+#define CPT_MAX_ENGINE_GROUPS	8
+
+/* Invalid engine group */
+#define INVALID_ENGINE_GRP	0xFF
+
+/* Number of engine group for symmetric crypto */
+static int crypto_eng_grp = INVALID_ENGINE_GRP;
+
+/* CPT PF number */
+static int cpt_pf_num = -1;
+
+/* Fault interrupts names */
+static const char *cpt_flt_irq_name[2] = { "CPTAF FLT0", "CPTAF FLT1" };
+
+static irqreturn_t rvu_cpt_af_flr_intr_handler(int irq, void *ptr)
+{
+	struct rvu *rvu = (struct rvu *) ptr;
+	u64 reg0, reg1;
+
+	reg0 = rvu_read64(rvu, BLKADDR_CPT0, CPT_AF_FLTX_INT(0));
+	reg1 = rvu_read64(rvu, BLKADDR_CPT0, CPT_AF_FLTX_INT(1));
+	dev_err(rvu->dev, "Received CPTAF FLT irq : 0x%llx, 0x%llx",
+		reg0, reg1);
+
+	rvu_write64(rvu, BLKADDR_CPT0, CPT_AF_FLTX_INT(0), reg0);
+	rvu_write64(rvu, BLKADDR_CPT0, CPT_AF_FLTX_INT(1), reg1);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t rvu_cpt_af_rvu_intr_handler(int irq, void *ptr)
+{
+	struct rvu *rvu = (struct rvu *) ptr;
+	u64 reg;
+
+	reg = rvu_read64(rvu, BLKADDR_CPT0, CPT_AF_RVU_INT);
+	dev_err(rvu->dev, "Received CPTAF RVU irq : 0x%llx", reg);
+
+	rvu_write64(rvu, BLKADDR_CPT0, CPT_AF_RVU_INT, reg);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t rvu_cpt_af_ras_intr_handler(int irq, void *ptr)
+{
+	struct rvu *rvu = (struct rvu *) ptr;
+	u64 reg;
+
+	reg = rvu_read64(rvu, BLKADDR_CPT0, CPT_AF_RAS_INT);
+	dev_err(rvu->dev, "Received CPTAF RAS irq : 0x%llx", reg);
+
+	rvu_write64(rvu, BLKADDR_CPT0, CPT_AF_RAS_INT, reg);
+	return IRQ_HANDLED;
+}
+
+static int rvu_cpt_do_register_interrupt(struct rvu *rvu, int irq_offs,
+					 irq_handler_t handler,
+					 const char *name)
+{
+	int ret = 0;
+
+	ret = request_irq(pci_irq_vector(rvu->pdev, irq_offs), handler, 0,
+			  name, rvu);
+	if (ret) {
+		dev_err(rvu->dev, "RVUAF: %s irq registration failed", name);
+		goto err;
+	}
+
+	WARN_ON(rvu->irq_allocated[irq_offs]);
+	rvu->irq_allocated[irq_offs] = true;
+err:
+	return ret;
+}
+
+static void rvu_cpt_unregister_interrupts(struct rvu *rvu)
+{
+	int i, offs;
+	u64 reg;
+
+	reg = rvu_read64(rvu, BLKADDR_CPT0, CPT_PRIV_AF_INT_CFG);
+	offs = reg & 0x7FF;
+
+	/* Disable all CPT AF interrupts */
+	for (i = 0; i < 2; i++)
+		rvu_write64(rvu, BLKADDR_CPT0, CPT_AF_FLTX_INT_ENA_W1C(i), 0x1);
+	rvu_write64(rvu, BLKADDR_CPT0, CPT_AF_RVU_INT_ENA_W1C, 0x1);
+	rvu_write64(rvu, BLKADDR_CPT0, CPT_AF_RAS_INT_ENA_W1C, 0x1);
+
+	for (i = 0; i < CPT_AF_INT_VEC_CNT; i++)
+		if (rvu->irq_allocated[offs + i]) {
+			free_irq(pci_irq_vector(rvu->pdev, offs + i), rvu);
+			rvu->irq_allocated[offs + i] = false;
+		}
+}
+
+static bool is_cpt_pf(u16 pcifunc)
+{
+	if (rvu_get_pf(pcifunc) != cpt_pf_num)
+		return false;
+	if (pcifunc & RVU_PFVF_FUNC_MASK)
+		return false;
+
+	return true;
+}
+
+static bool is_cpt_vf(u16 pcifunc)
+{
+	if (rvu_get_pf(pcifunc) != cpt_pf_num)
+		return false;
+	if (!(pcifunc & RVU_PFVF_FUNC_MASK))
+		return false;
+
+	return true;
+}
+
+int rvu_cpt_init(struct rvu *rvu)
+{
+	struct pci_dev *pdev;
+	int i;
+
+	for (i = 0; i < rvu->hw->total_pfs; i++) {
+		pdev = pci_get_domain_bus_and_slot(
+				pci_domain_nr(rvu->pdev->bus), i + 1, 0);
+		if (!pdev)
+			continue;
+
+		if (pdev->device == PCI_DEVID_OTX2_CPT_PF) {
+			cpt_pf_num = i;
+			put_device(&pdev->dev);
+			break;
+		}
+
+		put_device(&pdev->dev);
+	}
+
+	return 0;
+}
+
+int rvu_cpt_register_interrupts(struct rvu *rvu)
+{
+
+	int i, offs, ret = 0;
+	u64 reg;
+
+	reg = rvu_read64(rvu, BLKADDR_CPT0, CPT_PRIV_AF_INT_CFG);
+	offs = reg & 0x7FF;
+
+	for (i = 0; i < 2; i++) {
+		ret = rvu_cpt_do_register_interrupt(rvu, offs +
+						    CPT_AF_INT_VEC_FLT0 + i,
+						    rvu_cpt_af_flr_intr_handler,
+						    cpt_flt_irq_name[i]);
+		if (ret)
+			goto err;
+		rvu_write64(rvu, BLKADDR_CPT0, CPT_AF_FLTX_INT_ENA_W1S(i), 0x1);
+	}
+
+	ret = rvu_cpt_do_register_interrupt(rvu, offs + CPT_AF_INT_VEC_RVU,
+					    rvu_cpt_af_rvu_intr_handler,
+					    "CPTAF RVU");
+	if (ret)
+		goto err;
+	rvu_write64(rvu, BLKADDR_CPT0, CPT_AF_RVU_INT_ENA_W1S, 0x1);
+
+	ret = rvu_cpt_do_register_interrupt(rvu, offs + CPT_AF_INT_VEC_RAS,
+					    rvu_cpt_af_ras_intr_handler,
+					    "CPTAF RAS");
+	if (ret)
+		goto err;
+	rvu_write64(rvu, BLKADDR_CPT0, CPT_AF_RAS_INT_ENA_W1S, 0x1);
+
+	return 0;
+err:
+	rvu_cpt_unregister_interrupts(rvu);
+	return ret;
+}
+
+int rvu_mbox_handler_cpt_lf_alloc(struct rvu *rvu,
+				  struct cpt_lf_alloc_req_msg *req,
+				  struct cpt_lf_alloc_rsp_msg *rsp)
+{
+	u16 pcifunc = req->hdr.pcifunc;
+	int num_lfs, slot, grp_mask;
+	struct rvu_block *block;
+	int cptlf, blkaddr;
+	u64 val;
+
+	if (crypto_eng_grp == INVALID_ENGINE_GRP)
+		return CPT_AF_ERR_GRP_INVALID;
+
+	blkaddr = rvu_get_blkaddr(rvu, BLKTYPE_CPT, pcifunc);
+	if (blkaddr < 0)
+		return CPT_AF_ERR_LF_INVALID;
+
+	block = &rvu->hw->block[blkaddr];
+	num_lfs = rvu_get_rsrc_mapcount(rvu_get_pfvf(rvu, pcifunc),
+					block->type);
+	if (!num_lfs)
+		return CPT_AF_ERR_LF_INVALID;
+
+	/* Check if requested 'CPTLF <=> NIXLF' mapping is valid */
+	if (req->nix_pf_func) {
+		/* If default, use 'this' CPTLF's PFFUNC */
+		if (req->nix_pf_func == RVU_DEFAULT_PF_FUNC)
+			req->nix_pf_func = pcifunc;
+		if (!is_pffunc_map_valid(rvu, req->nix_pf_func, BLKTYPE_NIX))
+			return CPT_AF_ERR_NIX_PF_FUNC_INVALID;
+	}
+
+	/* Check if requested 'CPTLF <=> SSOLF' mapping is valid */
+	if (req->sso_pf_func) {
+		/* If default, use 'this' CPTLF's PFFUNC */
+		if (req->sso_pf_func == RVU_DEFAULT_PF_FUNC)
+			req->sso_pf_func = pcifunc;
+		if (!is_pffunc_map_valid(rvu, req->sso_pf_func, BLKTYPE_SSO))
+			return CPT_AF_ERR_SSO_PF_FUNC_INVALID;
+	}
+
+	for (slot = 0; slot < num_lfs; slot++) {
+		cptlf = rvu_get_lf(rvu, block, pcifunc, slot);
+		if (cptlf < 0)
+			return CPT_AF_ERR_LF_INVALID;
+
+		/* Set CPT LF group and priority */
+		grp_mask = 1 << crypto_eng_grp;
+		val = (u64) grp_mask << 48 | 1;
+		rvu_write64(rvu, blkaddr, CPT_AF_LFX_CTL(cptlf), val);
+
+		/* Set CPT LF NIX_PF_FUNC and SSO_PF_FUNC */
+		val = (u64) req->nix_pf_func << 48 |
+		      (u64) req->sso_pf_func << 32;
+		rvu_write64(rvu, blkaddr, CPT_AF_LFX_CTL2(cptlf), val);
+	}
+
+	rsp->crypto_eng_grp = crypto_eng_grp;
+	return 0;
+}
+
+int rvu_mbox_handler_cpt_lf_free(struct rvu *rvu, struct msg_req *req,
+				 struct msg_rsp *rsp)
+{
+	u16 pcifunc = req->hdr.pcifunc;
+	struct rvu_block *block;
+	int cptlf, blkaddr;
+	int num_lfs, slot;
+
+	blkaddr = rvu_get_blkaddr(rvu, BLKTYPE_CPT, pcifunc);
+	if (blkaddr < 0)
+		return CPT_AF_ERR_LF_INVALID;
+
+	block = &rvu->hw->block[blkaddr];
+	num_lfs = rvu_get_rsrc_mapcount(rvu_get_pfvf(rvu, pcifunc),
+					block->type);
+	if (!num_lfs)
+		return CPT_AF_ERR_LF_INVALID;
+
+	for (slot = 0; slot < num_lfs; slot++) {
+		cptlf = rvu_get_lf(rvu, block, pcifunc, slot);
+		if (cptlf < 0)
+			return CPT_AF_ERR_LF_INVALID;
+
+		/* Reset CPT LF group and priority */
+		rvu_write64(rvu, blkaddr, CPT_AF_LFX_CTL(cptlf), 0x0);
+		/* Reset CPT LF NIX_PF_FUNC and SSO_PF_FUNC */
+		rvu_write64(rvu, blkaddr, CPT_AF_LFX_CTL2(cptlf), 0x0);
+	}
+
+	return 0;
+}
+
+int rvu_mbox_handler_cpt_set_crypto_grp(struct rvu *rvu,
+					struct cpt_set_crypto_grp_req_msg *req,
+					struct cpt_set_crypto_grp_req_msg *rsp)
+{
+	/* This message is accepted only if sent from CPT PF */
+	if (!is_cpt_pf(req->hdr.pcifunc))
+		return CPT_AF_ERR_ACCESS_DENIED;
+
+	rsp->crypto_eng_grp = req->crypto_eng_grp;
+
+	if (req->crypto_eng_grp != INVALID_ENGINE_GRP &&
+	    (req->crypto_eng_grp < 0 ||
+	    req->crypto_eng_grp >= CPT_MAX_ENGINE_GROUPS))
+		return CPT_AF_ERR_GRP_INVALID;
+
+	crypto_eng_grp = req->crypto_eng_grp;
+	return 0;
+}
+
+int rvu_mbox_handler_cpt_rd_wr_register(struct rvu *rvu,
+					struct cpt_rd_wr_reg_msg *req,
+					struct cpt_rd_wr_reg_msg *rsp)
+{
+	struct rvu_block *block;
+	int num_lfs, offs, lf;
+
+	/* This message is accepted only if sent from CPT PF/VF */
+	if (!is_cpt_pf(req->hdr.pcifunc) &&
+	    !is_cpt_vf(req->hdr.pcifunc))
+		return CPT_AF_ERR_ACCESS_DENIED;
+
+	rsp->reg_offset = req->reg_offset;
+	rsp->ret_val = req->ret_val;
+	rsp->is_write = req->is_write;
+
+	if (req->hdr.pcifunc & RVU_PFVF_FUNC_MASK) {
+		/* Registers that can be accessed from VF */
+		switch (req->reg_offset & 0xFF000) {
+		case CPT_AF_LFX_CTL(0):
+			offs = req->reg_offset & 0xFFF;
+			if (offs % 8)
+				goto error;
+			lf = offs >> 3;
+		break;
+
+		default:
+			goto error;
+		}
+
+		block = &rvu->hw->block[BLKADDR_CPT0];
+		num_lfs = rvu_get_rsrc_mapcount(
+					rvu_get_pfvf(rvu, req->hdr.pcifunc),
+					block->type);
+		if (lf >= num_lfs)
+			/* Slot is not valid for that VF */
+			goto error;
+
+		/* Need to translate CPT LF slot to global number because
+		 * VFs use local numbering from 0 to number of LFs - 1
+		 */
+		lf = rvu_get_lf(rvu, &rvu->hw->block[BLKADDR_CPT0],
+				req->hdr.pcifunc, lf);
+		if (lf < 0)
+			goto error;
+
+		req->reg_offset &= 0xFF000;
+		req->reg_offset += lf << 3;
+		rsp->reg_offset = req->reg_offset;
+	} else {
+		/* Registers that can be accessed from PF */
+		switch (req->reg_offset & 0xFF000) {
+		case CPT_AF_PF_FUNC:
+		case CPT_AF_BLK_RST:
+		case CPT_AF_CONSTANTS1:
+			if (req->reg_offset & 0xFFF)
+				goto error;
+		break;
+
+		case CPT_AF_EXEX_STS(0):
+		case CPT_AF_EXEX_CTL(0):
+		case CPT_AF_EXEX_CTL2(0):
+		case CPT_AF_EXEX_UCODE_BASE(0):
+			offs = req->reg_offset & 0xFFF;
+			if ((offs % 8) || (offs >> 3) > 127)
+				goto error;
+		break;
+
+		default:
+			goto error;
+		}
+	}
+
+	if (req->is_write)
+		rvu_write64(rvu, BLKADDR_CPT0, req->reg_offset, req->val);
+	else
+		rsp->val = rvu_read64(rvu, BLKADDR_CPT0, req->reg_offset);
+
+	return 0;
+error:
+	/* Access to register denied */
+	return CPT_AF_ERR_ACCESS_DENIED;
+}
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_reg.h b/drivers/net/ethernet/marvell/octeontx2/af/rvu_reg.h
index dceb976030a5..2971bd4c6fe8 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_reg.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_reg.h
@@ -582,12 +582,59 @@
 #define TIM_AF_RINGX_CTL1_RCF_BUSY	BIT_ULL(50)
 
 /* CPT */
-#define CPT_AF_CONSTANTS0		(0x0000)
-#define CPT_PRIV_LFX_CFG		(0x41000)
-#define CPT_PRIV_LFX_INT_CFG		(0x43000)
-#define CPT_AF_RVU_LF_CFG_DEBUG		(0x45000)
-#define CPT_AF_LF_RST			(0x44000)
-#define CPT_AF_BLK_RST			(0x46000)
+#define CPT_AF_CONSTANTS0               (0x0ull)
+#define CPT_AF_CONSTANTS1               (0x1000ull)
+#define CPT_AF_DIAG                     (0x3000ull)
+#define CPT_AF_FLTX_INT(a)              (0xa000ull | (u64)(a) << 3)
+#define CPT_AF_FLTX_INT_W1S(a)          (0xb000ull | (u64)(a) << 3)
+#define CPT_AF_FLTX_INT_ENA_W1C(a)      (0xc000ull | (u64)(a) << 3)
+#define CPT_AF_FLTX_INT_ENA_W1S(a)      (0xd000ull | (u64)(a) << 3)
+#define CPT_AF_PSNX_EXE(a)              (0xe000ull | (u64)(a) << 3)
+#define CPT_AF_PSNX_EXE_W1S(a)          (0xf000ull | (u64)(a) << 3)
+#define CPT_AF_PSNX_LF(a)               (0x10000ull | (u64)(a) << 3)
+#define CPT_AF_PSNX_LF_W1S(a)           (0x11000ull | (u64)(a) << 3)
+#define CPT_AF_EXEX_CTL2(a)             (0x12000ull | (u64)(a) << 3)
+#define CPT_AF_EXEX_STS(a)              (0x13000ull | (u64)(a) << 3)
+#define CPT_AF_EXE_ERR_INFO             (0x14000ull)
+#define CPT_AF_EXEX_ACTIVE(a)           (0x16000ull | (u64)(a) << 3)
+#define CPT_AF_INST_REQ_PC              (0x17000ull)
+#define CPT_AF_INST_LATENCY_PC          (0x18000ull)
+#define CPT_AF_RD_REQ_PC                (0x19000ull)
+#define CPT_AF_RD_LATENCY_PC            (0x1a000ull)
+#define CPT_AF_RD_UC_PC                 (0x1b000ull)
+#define CPT_AF_ACTIVE_CYCLES_PC         (0x1c000ull)
+#define CPT_AF_EXE_DBG_CTL              (0x1d000ull)
+#define CPT_AF_EXE_DBG_DATA             (0x1e000ull)
+#define CPT_AF_EXE_REQ_TIMER            (0x1f000ull)
+#define CPT_AF_EXEX_CTL(a)              (0x20000ull | (u64)(a) << 3)
+#define CPT_AF_EXE_PERF_CTL             (0x21000ull)
+#define CPT_AF_EXE_DBG_CNTX(a)          (0x22000ull | (u64)(a) << 3)
+#define CPT_AF_EXE_PERF_EVENT_CNT       (0x23000ull)
+#define CPT_AF_EXE_EPCI_INBX_CNT(a)     (0x24000ull | (u64)(a) << 3)
+#define CPT_AF_EXE_EPCI_OUTBX_CNT(a)    (0x25000ull | (u64)(a) << 3)
+#define CPT_AF_EXEX_UCODE_BASE(a)       (0x26000ull | (u64)(a) << 3)
+#define CPT_AF_LFX_CTL(a)               (0x27000ull | (u64)(a) << 3)
+#define CPT_AF_LFX_CTL2(a)              (0x29000ull | (u64)(a) << 3)
+#define CPT_AF_CPTCLK_CNT               (0x2a000ull)
+#define CPT_AF_PF_FUNC                  (0x2b000ull)
+#define CPT_AF_LFX_PTR_CTL(a)           (0x2c000ull | (u64)(a) << 3)
+#define CPT_AF_GRPX_THR(a)              (0x2d000ull | (u64)(a) << 3)
+#define CPT_AF_CTL                      (0x2e000ull)
+#define CPT_AF_XEX_THR(a)               (0x2f000ull | (u64)(a) << 3)
+#define CPT_PRIV_LFX_CFG		(0x41000ull)
+#define CPT_PRIV_AF_INT_CFG             (0x42000ull)
+#define CPT_PRIV_LFX_INT_CFG		(0x43000ull)
+#define CPT_AF_LF_RST                   (0x44000ull)
+#define CPT_AF_RVU_LF_CFG_DEBUG         (0x45000ull)
+#define CPT_AF_BLK_RST                  (0x46000ull)
+#define CPT_AF_RVU_INT                  (0x47000ull)
+#define CPT_AF_RVU_INT_W1S              (0x47008ull)
+#define CPT_AF_RVU_INT_ENA_W1S          (0x47010ull)
+#define CPT_AF_RVU_INT_ENA_W1C          (0x47018ull)
+#define CPT_AF_RAS_INT                  (0x47020ull)
+#define CPT_AF_RAS_INT_W1S              (0x47028ull)
+#define CPT_AF_RAS_INT_ENA_W1S          (0x47030ull)
+#define CPT_AF_RAS_INT_ENA_W1C          (0x47038ull)
 
 #define NDC_AF_BLK_RST                  (0x002F0)
 #define NPC_AF_BLK_RST                  (0x00040)
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_struct.h b/drivers/net/ethernet/marvell/octeontx2/af/rvu_struct.h
index f920dac74e6c..49a6fa17abb7 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_struct.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_struct.h
@@ -57,6 +57,15 @@ enum rvu_af_int_vec_e {
 	RVU_AF_INT_VEC_CNT    = 0x5,
 };
 
+/* CPT Admin function Interrupt Vector Enumeration */
+enum cpt_af_int_vec_e {
+	CPT_AF_INT_VEC_FLT0	= 0x0,
+	CPT_AF_INT_VEC_FLT1	= 0x1,
+	CPT_AF_INT_VEC_RVU	= 0x2,
+	CPT_AF_INT_VEC_RAS	= 0x3,
+	CPT_AF_INT_VEC_CNT	= 0x4,
+};
+
 /**
  * RVU PF Interrupt Vector Enumeration
  */
-- 
2.31.1

