From ff7a316835d3b5fce1f638a12582f43bed28f316 Mon Sep 17 00:00:00 2001
From: Vasileios Bimpikas <vasileios.bimpikas@xilinx.com>
Date: Thu, 1 Nov 2018 16:41:46 +0000
Subject: [PATCH 1158/1852] staging: xroeframer: add support for multi-port
 Ethernet

commit ec06ff2a1126687db32af58ec485cb07918a66db from
https://github.com/Xilinx/linux-xlnx.git

Support for up to 4 Ethernet ports. This wraps all the "store" & "show"
functions of sysfs entries in a function which calculates the current
Ethernet port (when applicable) and adds the correct offset to the
address' register, which is ADDRESS + (0x100 * port_num). It defaults
to 0 for the non-applicable cases so no other entries are affected.

Signed-off-by: Vasileios Bimpikas <vasileios.bimpikas@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
State: not-upstreamable
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 drivers/staging/xroeframer/roe_framer_ctrl.h  | 129 +++++--
 drivers/staging/xroeframer/sysfs_xroe.c       | 175 ++++++---
 .../xroeframer/sysfs_xroe_framer_ipv4.c       | 304 +++++++--------
 .../xroeframer/sysfs_xroe_framer_ipv6.c       | 348 +++++++-----------
 .../xroeframer/sysfs_xroe_framer_udp.c        |  77 ++--
 drivers/staging/xroeframer/xroe_framer.h      |   9 +
 6 files changed, 510 insertions(+), 532 deletions(-)

diff --git a/drivers/staging/xroeframer/roe_framer_ctrl.h b/drivers/staging/xroeframer/roe_framer_ctrl.h
index 445fa49255aa..162c49a9bc3b 100644
--- a/drivers/staging/xroeframer/roe_framer_ctrl.h
+++ b/drivers/staging/xroeframer/roe_framer_ctrl.h
@@ -77,6 +77,20 @@
 #define CFG_MASTER_INT_ENABLE_WIDTH 0x1 /* 1 */
 #define CFG_MASTER_INT_ENABLE_DEFAULT 0x0 /* 0 */
 
+/* Type = rw */
+#define CFG_FRAM_FIFO_OF_ENABLE_ADDR 0x14 /* 20 */
+#define CFG_FRAM_FIFO_OF_ENABLE_MASK 0x1 /* 1 */
+#define CFG_FRAM_FIFO_OF_ENABLE_OFFSET 0x0 /* 0 */
+#define CFG_FRAM_FIFO_OF_ENABLE_WIDTH 0x1 /* 1 */
+#define CFG_FRAM_FIFO_OF_ENABLE_DEFAULT 0x0 /* 0 */
+
+/* Type = rw */
+#define CFG_FRAM_FIFO_UF_ENABLE_ADDR 0x14 /* 20 */
+#define CFG_FRAM_FIFO_UF_ENABLE_MASK 0x2 /* 2 */
+#define CFG_FRAM_FIFO_UF_ENABLE_OFFSET 0x1 /* 1 */
+#define CFG_FRAM_FIFO_UF_ENABLE_WIDTH 0x1 /* 1 */
+#define CFG_FRAM_FIFO_UF_ENABLE_DEFAULT 0x0 /* 0 */
+
 /* Type = rw */
 #define CFG_AXI_TIMEOUT_ENABLE_ADDR 0x14 /* 20 */
 #define CFG_AXI_TIMEOUT_ENABLE_MASK 0x80000000 /* 2147483648 */
@@ -84,6 +98,55 @@
 #define CFG_AXI_TIMEOUT_ENABLE_WIDTH 0x1 /* 1 */
 #define CFG_AXI_TIMEOUT_ENABLE_DEFAULT 0x1 /* 1 */
 
+/* Type = rw */
+#define CFG_INTERRUPT_STATUS_SAMPLE_ADDR 0x1c /* 28 */
+#define CFG_INTERRUPT_STATUS_SAMPLE_MASK 0x1 /* 1 */
+#define CFG_INTERRUPT_STATUS_SAMPLE_OFFSET 0x0 /* 0 */
+#define CFG_INTERRUPT_STATUS_SAMPLE_WIDTH 0x1 /* 1 */
+#define CFG_INTERRUPT_STATUS_SAMPLE_DEFAULT 0x1 /* 1 */
+
+/* Type = roSig */
+#define CFG_FRAM_RESET_STATUS_ADDR 0x18 /* 24 */
+#define CFG_FRAM_RESET_STATUS_MASK 0x1 /* 1 */
+#define CFG_FRAM_RESET_STATUS_OFFSET 0x0 /* 0 */
+#define CFG_FRAM_RESET_STATUS_WIDTH 0x1 /* 1 */
+#define CFG_FRAM_RESET_STATUS_DEFAULT 0x0 /* 0 */
+
+/* Type = roSig */
+#define CFG_DEFM_RESET_STATUS_ADDR 0x18 /* 24 */
+#define CFG_DEFM_RESET_STATUS_MASK 0x2 /* 2 */
+#define CFG_DEFM_RESET_STATUS_OFFSET 0x1 /* 1 */
+#define CFG_DEFM_RESET_STATUS_WIDTH 0x1 /* 1 */
+#define CFG_DEFM_RESET_STATUS_DEFAULT 0x0 /* 0 */
+
+/* Type = roSig */
+#define CFG_FRAM_ANT_OF_INTERRUPT_ADDR 0x18 /* 24 */
+#define CFG_FRAM_ANT_OF_INTERRUPT_MASK 0x100 /* 256 */
+#define CFG_FRAM_ANT_OF_INTERRUPT_OFFSET 0x8 /* 8 */
+#define CFG_FRAM_ANT_OF_INTERRUPT_WIDTH 0x1 /* 1 */
+#define CFG_FRAM_ANT_OF_INTERRUPT_DEFAULT 0x0 /* 0 */
+
+/* Type = roSig */
+#define CFG_FRAM_ETH_OF_INTERRUPT_ADDR 0x18 /* 24 */
+#define CFG_FRAM_ETH_OF_INTERRUPT_MASK 0x200 /* 512 */
+#define CFG_FRAM_ETH_OF_INTERRUPT_OFFSET 0x9 /* 9 */
+#define CFG_FRAM_ETH_OF_INTERRUPT_WIDTH 0x1 /* 1 */
+#define CFG_FRAM_ETH_OF_INTERRUPT_DEFAULT 0x0 /* 0 */
+
+/* Type = roSig */
+#define CFG_FRAM_ANT_UF_INTERRUPT_ADDR 0x18 /* 24 */
+#define CFG_FRAM_ANT_UF_INTERRUPT_MASK 0x400 /* 1024 */
+#define CFG_FRAM_ANT_UF_INTERRUPT_OFFSET 0xa /* 10 */
+#define CFG_FRAM_ANT_UF_INTERRUPT_WIDTH 0x1 /* 1 */
+#define CFG_FRAM_ANT_UF_INTERRUPT_DEFAULT 0x0 /* 0 */
+
+/* Type = roSig */
+#define CFG_FRAM_ETH_UF_INTERRUPT_ADDR 0x18 /* 24 */
+#define CFG_FRAM_ETH_UF_INTERRUPT_MASK 0x800 /* 2048 */
+#define CFG_FRAM_ETH_UF_INTERRUPT_OFFSET 0xb /* 11 */
+#define CFG_FRAM_ETH_UF_INTERRUPT_WIDTH 0x1 /* 1 */
+#define CFG_FRAM_ETH_UF_INTERRUPT_DEFAULT 0x0 /* 0 */
+
 /* Type = roSig */
 #define CFG_AXI_TIMEOUT_STATUS_ADDR 0x18 /* 24 */
 #define CFG_AXI_TIMEOUT_STATUS_MASK 0x80000000 /* 2147483648 */
@@ -125,11 +188,11 @@
  *------------------------------------------------------------------------------
  */
 /* Type = rwpdef */
-#define FRAM_RESTART_ADDR 0x2000 /* 8192 */
-#define FRAM_RESTART_MASK 0x1 /* 1 */
-#define FRAM_RESTART_OFFSET 0x0 /* 0 */
-#define FRAM_RESTART_WIDTH 0x1 /* 1 */
-#define FRAM_RESTART_DEFAULT 0x1 /* 1 */
+#define FRAM_DISABLE_ADDR 0x2000 /* 8192 */
+#define FRAM_DISABLE_MASK 0x1 /* 1 */
+#define FRAM_DISABLE_OFFSET 0x0 /* 0 */
+#define FRAM_DISABLE_WIDTH 0x1 /* 1 */
+#define FRAM_DISABLE_DEFAULT 0x1 /* 1 */
 
 /* Type = roSig */
 #define FRAM_READY_ADDR 0x2000 /* 8192 */
@@ -139,11 +202,11 @@
 #define FRAM_READY_DEFAULT 0x0 /* 0 */
 
 /* Type = roSig */
-#define FRAM_AUTO_RESTART_CNT_ADDR 0x2004 /* 8196 */
-#define FRAM_AUTO_RESTART_CNT_MASK 0xffffffff /* 4294967295 */
-#define FRAM_AUTO_RESTART_CNT_OFFSET 0x0 /* 0 */
-#define FRAM_AUTO_RESTART_CNT_WIDTH 0x20 /* 32 */
-#define FRAM_AUTO_RESTART_CNT_DEFAULT 0x0 /* 0 */
+#define FRAM_FIFO_FULL_INDICATOR_ADDR 0x2004 /* 8196 */
+#define FRAM_FIFO_FULL_INDICATOR_MASK 0xffffffff /* 4294967295 */
+#define FRAM_FIFO_FULL_INDICATOR_OFFSET 0x0 /* 0 */
+#define FRAM_FIFO_FULL_INDICATOR_WIDTH 0x20 /* 32 */
+#define FRAM_FIFO_FULL_INDICATOR_DEFAULT 0x0 /* 0 */
 
 /* Type = rw */
 #define FRAM_SN_DATA_LOW_CNT_MIN_ADDR 0x2020 /* 8224 */
@@ -281,7 +344,7 @@
 /*-----------------------------------------------------------------------------
  * C Header bank register definitions for bank roe_framer_v1_0_fram_drp
  * with prefix fram_drp @ address 0x4000
- *-----------------------------------------------------------------------------
+ *------------------------------------------------------------------------------
  */
 /* Type = rw */
 #define FRAM_DRPFRAM_DATA_PC_ID_ADDR 0x4000 /* 16384 */
@@ -592,7 +655,7 @@
 /*-----------------------------------------------------------------------------
  * C Header bank register definitions for bank roe_framer_v1_0_defm_drp
  * with prefix defm_drp @ address 0x8000
- *-----------------------------------------------------------------------------
+ *------------------------------------------------------------------------------
  */
 /* Type = rw */
 #define DEFM_DRPDEFM_DATA_PC_ID_ADDR 0x8000 /* 32768 */
@@ -695,7 +758,7 @@
 /*-----------------------------------------------------------------------------
  * C Header bank register definitions for bank roe_framer_v1_0_eth
  * with prefix eth_ @ address 0xa000
- *-----------------------------------------------------------------------------
+ *------------------------------------------------------------------------------
  */
 /* Type = rwpdef */
 #define ETH_DEST_ADDR_31_0_ADDR 0xa000 /* 40960 */
@@ -901,32 +964,32 @@
 #define ETH_IPV6_SOURCE_ADD_127_96_DEFAULT 0x0 /* 0 */
 
 /* Type = rwpdef */
-#define ETH_IPV6_DESTINATION_ADD_31_0_ADDR 0xa0a4 /* 41124 */
-#define ETH_IPV6_DESTINATION_ADD_31_0_MASK 0xffffffff /* 4294967295 */
-#define ETH_IPV6_DESTINATION_ADD_31_0_OFFSET 0x0 /* 0 */
-#define ETH_IPV6_DESTINATION_ADD_31_0_WIDTH 0x20 /* 32 */
-#define ETH_IPV6_DESTINATION_ADD_31_0_DEFAULT 0x0 /* 0 */
+#define ETH_IPV6_DEST_ADD_31_0_ADDR 0xa0a4 /* 41124 */
+#define ETH_IPV6_DEST_ADD_31_0_MASK 0xffffffff /* 4294967295 */
+#define ETH_IPV6_DEST_ADD_31_0_OFFSET 0x0 /* 0 */
+#define ETH_IPV6_DEST_ADD_31_0_WIDTH 0x20 /* 32 */
+#define ETH_IPV6_DEST_ADD_31_0_DEFAULT 0x0 /* 0 */
 
 /* Type = rwpdef */
-#define ETH_IPV6_DESTINATION_ADD_63_32_ADDR 0xa0a8 /* 41128 */
-#define ETH_IPV6_DESTINATION_ADD_63_32_MASK 0xffffffff /* 4294967295 */
-#define ETH_IPV6_DESTINATION_ADD_63_32_OFFSET 0x0 /* 0 */
-#define ETH_IPV6_DESTINATION_ADD_63_32_WIDTH 0x20 /* 32 */
-#define ETH_IPV6_DESTINATION_ADD_63_32_DEFAULT 0x0 /* 0 */
+#define ETH_IPV6_DEST_ADD_63_32_ADDR 0xa0a8 /* 41128 */
+#define ETH_IPV6_DEST_ADD_63_32_MASK 0xffffffff /* 4294967295 */
+#define ETH_IPV6_DEST_ADD_63_32_OFFSET 0x0 /* 0 */
+#define ETH_IPV6_DEST_ADD_63_32_WIDTH 0x20 /* 32 */
+#define ETH_IPV6_DEST_ADD_63_32_DEFAULT 0x0 /* 0 */
 
 /* Type = rwpdef */
-#define ETH_IPV6_DESTINATION_ADD_95_64_ADDR 0xa0ac /* 41132 */
-#define ETH_IPV6_DESTINATION_ADD_95_64_MASK 0xffffffff /* 4294967295 */
-#define ETH_IPV6_DESTINATION_ADD_95_64_OFFSET 0x0 /* 0 */
-#define ETH_IPV6_DESTINATION_ADD_95_64_WIDTH 0x20 /* 32 */
-#define ETH_IPV6_DESTINATION_ADD_95_64_DEFAULT 0x0 /* 0 */
+#define ETH_IPV6_DEST_ADD_95_64_ADDR 0xa0ac /* 41132 */
+#define ETH_IPV6_DEST_ADD_95_64_MASK 0xffffffff /* 4294967295 */
+#define ETH_IPV6_DEST_ADD_95_64_OFFSET 0x0 /* 0 */
+#define ETH_IPV6_DEST_ADD_95_64_WIDTH 0x20 /* 32 */
+#define ETH_IPV6_DEST_ADD_95_64_DEFAULT 0x0 /* 0 */
 
 /* Type = rwpdef */
-#define ETH_IPV6_DESTINATION_ADD_127_96_ADDR 0xa0b0 /* 41136 */
-#define ETH_IPV6_DESTINATION_ADD_127_96_MASK 0xffffffff /* 4294967295 */
-#define ETH_IPV6_DESTINATION_ADD_127_96_OFFSET 0x0 /* 0 */
-#define ETH_IPV6_DESTINATION_ADD_127_96_WIDTH 0x20 /* 32 */
-#define ETH_IPV6_DESTINATION_ADD_127_96_DEFAULT 0x0 /* 0 */
+#define ETH_IPV6_DEST_ADD_127_96_ADDR 0xa0b0 /* 41136 */
+#define ETH_IPV6_DEST_ADD_127_96_MASK 0xffffffff /* 4294967295 */
+#define ETH_IPV6_DEST_ADD_127_96_OFFSET 0x0 /* 0 */
+#define ETH_IPV6_DEST_ADD_127_96_WIDTH 0x20 /* 32 */
+#define ETH_IPV6_DEST_ADD_127_96_DEFAULT 0x0 /* 0 */
 
 /*-----------------------------------------------------------------------------
  * C Header bank register definitions for bank roe_framer_v1_0_stats
diff --git a/drivers/staging/xroeframer/sysfs_xroe.c b/drivers/staging/xroeframer/sysfs_xroe.c
index d718a803dbcf..169e87dc1ec3 100644
--- a/drivers/staging/xroeframer/sysfs_xroe.c
+++ b/drivers/staging/xroeframer/sysfs_xroe.c
@@ -30,30 +30,19 @@ static char xroe_tmp[XROE_SIZE_MAX];
 static ssize_t version_show(struct kobject *kobj, struct kobj_attribute *attr,
 			    char *buff)
 {
-	u32 offset = CFG_MAJOR_REVISION_OFFSET;
-	unsigned long mask = CFG_MAJOR_REVISION_MASK;
-	u32 buffer = 0;
-	u32 major_rev = 0, minor_rev = 0, version_rev = 0;
-	void __iomem *working_address = ((u8 *)lp->base_addr +
-	CFG_MAJOR_REVISION_ADDR);
-
-	buffer = ioread32(working_address);
-	major_rev = (buffer & mask) >> offset;
-
-	offset = CFG_MINOR_REVISION_OFFSET;
-	mask = CFG_MINOR_REVISION_MASK;
-	working_address = ((u8 *)lp->base_addr + CFG_MINOR_REVISION_ADDR);
-
-	buffer = ioread32(working_address);
-	minor_rev = (buffer & mask) >> offset;
-
-	offset = CFG_VERSION_REVISION_OFFSET;
-	mask = CFG_VERSION_REVISION_MASK;
-	working_address = ((u8 *)lp->base_addr + CFG_VERSION_REVISION_ADDR);
-
-	buffer = ioread32(working_address);
-	version_rev = (buffer & mask) >> offset;
-
+	u32 major_rev;
+	u32 minor_rev;
+	u32 version_rev;
+
+	major_rev = utils_sysfs_show_wrapper(CFG_MAJOR_REVISION_ADDR,
+					     CFG_MAJOR_REVISION_OFFSET,
+					     CFG_MAJOR_REVISION_MASK, kobj);
+	minor_rev = utils_sysfs_show_wrapper(CFG_MINOR_REVISION_ADDR,
+					     CFG_MINOR_REVISION_OFFSET,
+					     CFG_MINOR_REVISION_MASK, kobj);
+	version_rev = utils_sysfs_show_wrapper(CFG_VERSION_REVISION_ADDR,
+					       CFG_VERSION_REVISION_OFFSET,
+					       CFG_VERSION_REVISION_MASK, kobj);
 	sprintf(buff, "%d.%d.%d\n", major_rev, minor_rev, version_rev);
 	return XROE_SIZE_MAX;
 }
@@ -88,15 +77,11 @@ static ssize_t version_store(struct  kobject *kobj, struct kobj_attribute *attr,
 static ssize_t enable_show(struct kobject *kobj, struct kobj_attribute *attr,
 			   char *buff)
 {
-	u32 offset = CFG_MASTER_INT_ENABLE_OFFSET;
-	u32 mask = CFG_MASTER_INT_ENABLE_MASK;
-	u32 buffer = 0;
-	u32 enable = 0;
-	void __iomem *working_address = ((u8 *)lp->base_addr +
-	CFG_MASTER_INT_ENABLE_ADDR);
+	u32 enable;
 
-	buffer = ioread32(working_address);
-	enable = (buffer & mask) >> offset;
+	enable = utils_sysfs_show_wrapper(CFG_MASTER_INT_ENABLE_ADDR,
+					  CFG_MASTER_INT_ENABLE_OFFSET,
+					  CFG_MASTER_INT_ENABLE_MASK, kobj);
 	if (enable)
 		sprintf(buff, "true\n");
 	else
@@ -119,17 +104,17 @@ static ssize_t enable_show(struct kobject *kobj, struct kobj_attribute *attr,
 static ssize_t enable_store(struct kobject *kobj, struct kobj_attribute *attr,
 			    const char *buff, size_t count)
 {
-	u32 offset = CFG_MASTER_INT_ENABLE_OFFSET;
-	u32 mask = CFG_MASTER_INT_ENABLE_MASK;
-	void __iomem *working_address = ((u8 *)lp->base_addr +
-	CFG_MASTER_INT_ENABLE_ADDR);
+	u32 enable = 0;
 
 	xroe_size = min_t(size_t, count, (size_t)XROE_SIZE_MAX);
 	strncpy(xroe_tmp, buff, xroe_size);
 	if (strncmp(xroe_tmp, "true", xroe_size) == 0)
-		utils_write32withmask(working_address, 1, mask, offset);
+		enable = 1;
 	else if (strncmp(xroe_tmp, "false", xroe_size) == 0)
-		utils_write32withmask(working_address, 0, mask, offset);
+		enable = 0;
+	utils_sysfs_store_wrapper(CFG_MASTER_INT_ENABLE_ADDR,
+				  CFG_MASTER_INT_ENABLE_OFFSET,
+				  CFG_MASTER_INT_ENABLE_MASK, enable, kobj);
 	return xroe_size;
 }
 
@@ -146,15 +131,11 @@ static ssize_t enable_store(struct kobject *kobj, struct kobj_attribute *attr,
 static ssize_t framer_restart_show(struct kobject *kobj,
 				   struct kobj_attribute *attr, char *buff)
 {
-	u32 offset = FRAM_RESTART_OFFSET;
-	u32 mask = FRAM_RESTART_MASK;
-	u32 buffer = 0;
-	u32 restart = 0;
-	void __iomem *working_address = ((u8 *)lp->base_addr
-	+ FRAM_RESTART_ADDR);
+	u32 restart;
 
-	buffer = ioread32(working_address);
-	restart = (buffer & mask) >> offset;
+	restart = utils_sysfs_show_wrapper(FRAM_DISABLE_ADDR,
+					   FRAM_DISABLE_OFFSET,
+					   FRAM_DISABLE_MASK, kobj);
 	if (restart)
 		sprintf(buff, "true\n");
 
@@ -180,24 +161,16 @@ static ssize_t framer_restart_store(struct  kobject *kobj,
 				    struct kobj_attribute *attr,
 				    const char *buff, size_t count)
 {
-	u32 offset = FRAM_RESTART_OFFSET;
-	u32 mask = FRAM_RESTART_MASK;
-	void __iomem *working_address = ((u8 *)lp->base_addr
-	+ FRAM_RESTART_ADDR);
 	u32 restart = 0;
 
 	xroe_size = min_t(size_t, count, (size_t)XROE_SIZE_MAX);
 	strncpy(xroe_tmp, buff, xroe_size);
-	if (strncmp(xroe_tmp, "true", xroe_size) == 0) {
+	if (strncmp(xroe_tmp, "true", xroe_size) == 0)
 		restart = 0x01;
-		utils_write32withmask(working_address, restart,
-				      mask, offset);
-	} else if (strncmp(xroe_tmp, "false", xroe_size) == 0) {
+	else if (strncmp(xroe_tmp, "false", xroe_size) == 0)
 		restart = 0x00;
-		utils_write32withmask(working_address, restart,
-				      mask, offset);
-	}
-
+	utils_sysfs_store_wrapper(FRAM_DISABLE_ADDR, FRAM_DISABLE_OFFSET,
+				  FRAM_DISABLE_MASK, restart, kobj);
 	return xroe_size;
 }
 
@@ -467,10 +440,15 @@ int xroe_sysfs_init(void)
  */
 void xroe_sysfs_exit(void)
 {
-	kobject_put(root_xroe_kobj);
+	int i;
+
 	xroe_sysfs_ipv4_exit();
 	xroe_sysfs_ipv6_exit();
 	xroe_sysfs_udp_exit();
+	for (i = 0; i < MAX_NUM_ETH_PORTS; i++)
+		kobject_put(kobj_eth_ports[i]);
+	kobject_put(kobj_framer);
+	kobject_put(root_xroe_kobj);
 }
 
 /**
@@ -499,3 +477,82 @@ int utils_write32withmask(void __iomem *working_address, u32 value,
 	iowrite32(register_value_to_write, working_address);
 	return 0;
 }
+
+/**
+ * utils_sysfs_path_to_eth_port_num - Get the current ethernet port
+ * @kobj:	The kobject of the entry calling the function
+ *
+ * Extracts the number of the current ethernet port instance
+ *
+ * Return: The number of the ethernet port instance (0 - MAX_NUM_ETH_PORTS) on
+ * success, -1 otherwise
+ */
+static int utils_sysfs_path_to_eth_port_num(struct kobject *kobj)
+{
+	char *current_path = NULL;
+	int port;
+	int ret;
+
+	current_path = kobject_get_path(kobj, GFP_KERNEL);
+	ret = sscanf(current_path, "/kernel/xroe/framer/eth_port_%d/", &port);
+	/* if sscanf() returns 0, no fields were assigned, therefore no
+	 * adjustments will be made for port number
+	 */
+	if (ret == 0)
+		port = 0;
+//	printk(KERN_ALERT "current_path: %s port: %d\n", current_path, port);
+	kfree(current_path);
+	return port;
+}
+
+/**
+ * utils_sysfs_store_wrapper - Wraps the storing function for sysfs entries
+ * @address:	The address of the register to be written
+ * @offset:	The offset from the address of the register
+ * @mask:	The mask to be used on the value to be written
+ * @value:	The value to be written to the register
+ * @kobj:	The kobject of the entry calling the function
+ *
+ * Wraps the core functionality of all "store" functions of sysfs entries.
+ * After calculating the ethernet port number (in N/A cases, it's 0), the value
+ * is written to the designated register
+ *
+ */
+void utils_sysfs_store_wrapper(u32 address, u32 offset, u32 mask, u32 value,
+			       struct kobject *kobj)
+{
+	int port;
+	void __iomem *working_address;
+
+	port = utils_sysfs_path_to_eth_port_num(kobj);
+	working_address = (void __iomem *)(lp->base_addr +
+			  (address + (0x100 * port)));
+	utils_write32withmask(working_address, value, mask, offset);
+}
+
+/**
+ * utils_sysfs_store_wrapper - Wraps the storing function for sysfs entries
+ * @address:	The address of the register to be read
+ * @offset:	The offset from the address of the register
+ * @mask:	The mask to be used on the value to be read
+ * @kobj:	The kobject of the entry calling the function
+ *
+ * Wraps the core functionality of all "show" functions of sysfs entries.
+ * After calculating the ethernet port number (in N/A cases, it's 0), the value
+ * is read from the designated register and returned.
+ *
+ * Return: The value designated by the address, offset and mask
+ */
+u32 utils_sysfs_show_wrapper(u32 address, u32 offset, u32 mask,
+			     struct kobject *kobj)
+{
+	int port;
+	void __iomem *working_address;
+	u32 buffer;
+
+	port = utils_sysfs_path_to_eth_port_num(kobj);
+	working_address = (void __iomem *)(lp->base_addr +
+			  (address + (0x100 * port)));
+	buffer = ioread32(working_address);
+	return (buffer & mask) >> offset;
+}
diff --git a/drivers/staging/xroeframer/sysfs_xroe_framer_ipv4.c b/drivers/staging/xroeframer/sysfs_xroe_framer_ipv4.c
index 5b04a41be0c6..aaaefb10c597 100644
--- a/drivers/staging/xroeframer/sysfs_xroe_framer_ipv4.c
+++ b/drivers/staging/xroeframer/sysfs_xroe_framer_ipv4.c
@@ -33,15 +33,11 @@ static int utils_ipv4addr_chartohex(char *ip_addr, uint32_t *p_ip_addr);
 static ssize_t ipv4_version_show(struct kobject *kobj,
 				 struct kobj_attribute *attr, char *buff)
 {
-	u32 offset = ETH_IPV4_VERSION_OFFSET;
-	u32 mask = ETH_IPV4_VERSION_MASK;
-	u32 buffer = 0;
-	u32 version = 0;
-	void __iomem *working_address = ((u8 *)lp->base_addr +
-	ETH_IPV4_VERSION_ADDR);
-
-	buffer = ioread32(working_address);
-	version = (buffer & mask) >> offset;
+	u32 version;
+
+	version = utils_sysfs_show_wrapper(ETH_IPV4_VERSION_ADDR,
+					   ETH_IPV4_VERSION_OFFSET,
+					   ETH_IPV4_VERSION_MASK, kobj);
 	sprintf(buff, "%d\n", version);
 	return XROE_SIZE_MAX;
 }
@@ -78,15 +74,10 @@ static ssize_t ipv4_version_store(struct kobject *kobj,
 static ssize_t ipv4_ihl_show(struct kobject *kobj,
 			     struct kobj_attribute *attr, char *buff)
 {
-	u32 offset = ETH_IPV4_IHL_OFFSET;
-	u32 mask = ETH_IPV4_IHL_MASK;
-	u32 buffer = 0;
-	u32 ihl = 0;
-	void __iomem *working_address = ((u8 *)lp->base_addr
-	+ ETH_IPV4_IHL_ADDR);
-
-	buffer = ioread32(working_address);
-	ihl = (buffer & mask) >> offset;
+	u32 ihl;
+
+	ihl = utils_sysfs_show_wrapper(ETH_IPV4_IHL_ADDR, ETH_IPV4_IHL_OFFSET,
+				       ETH_IPV4_IHL_MASK, kobj);
 	sprintf(buff, "%d\n", ihl);
 	return XROE_SIZE_MAX;
 }
@@ -106,18 +97,15 @@ static ssize_t ipv4_ihl_store(struct kobject *kobj,
 			      struct kobj_attribute *attr, const char *buff,
 			      size_t count)
 {
-	int ret = 0;
-	u32 offset = ETH_IPV4_IHL_OFFSET;
-	u32 mask = ETH_IPV4_IHL_MASK;
-	void __iomem *working_address = ((u8 *)lp->base_addr
-	+ ETH_IPV4_IHL_ADDR);
-	unsigned int ihl = 0;
+	int ret;
+	u32 ihl;
 
 	xroe_size = min_t(size_t, count, (size_t)XROE_SIZE_MAX);
 	ret = kstrtouint(buff, 10, &ihl);
 	if (ret)
 		return ret;
-	utils_write32withmask(working_address, (u32)ihl, mask, offset);
+	utils_sysfs_store_wrapper(ETH_IPV4_IHL_ADDR, ETH_IPV4_IHL_OFFSET,
+				  ETH_IPV4_IHL_MASK, ihl, kobj);
 	return xroe_size;
 }
 
@@ -134,15 +122,11 @@ static ssize_t ipv4_ihl_store(struct kobject *kobj,
 static ssize_t ipv4_dscp_show(struct kobject *kobj,
 			      struct kobj_attribute *attr, char *buff)
 {
-	u32 offset = ETH_IPV4_DSCP_OFFSET;
-	u32 mask = ETH_IPV4_DSCP_MASK;
-	u32 buffer = 0;
-	u32 dscp = 0;
-	void __iomem *working_address = ((u8 *)lp->base_addr
-	+ ETH_IPV4_DSCP_ADDR);
-
-	buffer = ioread32(working_address);
-	dscp = (buffer & mask) >> offset;
+	u32 dscp;
+
+	dscp = utils_sysfs_show_wrapper(ETH_IPV4_DSCP_ADDR,
+					ETH_IPV4_DSCP_OFFSET,
+					ETH_IPV4_DSCP_MASK, kobj);
 	sprintf(buff, "%d\n", dscp);
 	return XROE_SIZE_MAX;
 }
@@ -162,18 +146,15 @@ static ssize_t ipv4_dscp_store(struct kobject *kobj,
 			       struct kobj_attribute *attr, const char *buff,
 			       size_t count)
 {
-	int ret = 0;
-	u32 offset = ETH_IPV4_DSCP_OFFSET;
-	u32 mask = ETH_IPV4_DSCP_MASK;
-	unsigned int dscp = 0;
-	void __iomem *working_address = ((u8 *)lp->base_addr
-	+ ETH_IPV4_DSCP_ADDR);
+	int ret;
+	u32 dscp;
 
 	xroe_size = min_t(size_t, count, (size_t)XROE_SIZE_MAX);
 	ret = kstrtouint(buff, 10, &dscp);
 	if (ret)
 		return ret;
-	utils_write32withmask(working_address, (u32)dscp, mask, offset);
+	utils_sysfs_store_wrapper(ETH_IPV4_DSCP_ADDR, ETH_IPV4_DSCP_OFFSET,
+				  ETH_IPV4_DSCP_MASK, dscp, kobj);
 	return xroe_size;
 }
 
@@ -190,15 +171,10 @@ static ssize_t ipv4_dscp_store(struct kobject *kobj,
 static ssize_t ipv4_ecn_show(struct kobject *kobj,
 			     struct kobj_attribute *attr, char *buff)
 {
-	u32 offset = ETH_IPV4_ECN_OFFSET;
-	u32 mask = ETH_IPV4_ECN_MASK;
-	u32 buffer = 0;
-	u32 ecn = 0;
-	void __iomem *working_address = ((u8 *)lp->base_addr
-	+ ETH_IPV4_ECN_ADDR);
-
-	buffer = ioread32(working_address);
-	ecn = (buffer & mask) >> offset;
+	u32 ecn;
+
+	ecn = utils_sysfs_show_wrapper(ETH_IPV4_ECN_ADDR, ETH_IPV4_ECN_OFFSET,
+				       ETH_IPV4_ECN_MASK, kobj);
 	sprintf(buff, "%d\n", ecn);
 	return XROE_SIZE_MAX;
 }
@@ -218,18 +194,15 @@ static ssize_t ipv4_ecn_store(struct kobject *kobj,
 			      struct kobj_attribute *attr, const char *buff,
 			      size_t count)
 {
-	int ret = 0;
-	u32 offset = ETH_IPV4_ECN_OFFSET;
-	u32 mask = ETH_IPV4_ECN_MASK;
-	unsigned int ecn = 0;
-	void __iomem *working_address = ((u8 *)lp->base_addr
-	+ ETH_IPV4_ECN_ADDR);
+	int ret;
+	u32 ecn;
 
 	xroe_size = min_t(size_t, count, (size_t)XROE_SIZE_MAX);
 	ret = kstrtouint(buff, 10, &ecn);
 	if (ret)
 		return ret;
-	utils_write32withmask(working_address, (u32)ecn, mask, offset);
+	utils_sysfs_store_wrapper(ETH_IPV4_ECN_ADDR, ETH_IPV4_ECN_OFFSET,
+				  ETH_IPV4_ECN_MASK, ecn, kobj);
 	return xroe_size;
 }
 
@@ -246,15 +219,10 @@ static ssize_t ipv4_ecn_store(struct kobject *kobj,
 static ssize_t ipv4_id_show(struct kobject *kobj,
 			    struct kobj_attribute *attr, char *buff)
 {
-	u32 offset = ETH_IPV4_ID_OFFSET;
-	u32 mask = ETH_IPV4_ID_MASK;
-	u32 buffer = 0;
-	u32 id = 0;
-	void __iomem *working_address = ((u8 *)lp->base_addr
-	+ ETH_IPV4_ID_ADDR);
-
-	buffer = ioread32(working_address);
-	id = (buffer & mask) >> offset;
+	u32 id;
+
+	id = utils_sysfs_show_wrapper(ETH_IPV4_ID_ADDR, ETH_IPV4_ID_OFFSET,
+				      ETH_IPV4_ID_MASK, kobj);
 	sprintf(buff, "%d\n", id);
 	return XROE_SIZE_MAX;
 }
@@ -274,18 +242,15 @@ static ssize_t ipv4_id_store(struct kobject *kobj,
 			     struct kobj_attribute *attr, const char *buff,
 			     size_t count)
 {
-	int ret = 0;
-	u32 offset = ETH_IPV4_ID_OFFSET;
-	u32 mask = ETH_IPV4_ID_MASK;
-	unsigned int id = 0;
-	void __iomem *working_address = ((u8 *)lp->base_addr
-	+ ETH_IPV4_ID_ADDR);
+	int ret;
+	u32 id;
 
 	xroe_size = min_t(size_t, count, (size_t)XROE_SIZE_MAX);
 	ret = kstrtouint(buff, 10, &id);
 	if (ret)
 		return ret;
-	utils_write32withmask(working_address, (u32)id, mask, offset);
+	utils_sysfs_store_wrapper(ETH_IPV4_ID_ADDR, ETH_IPV4_ID_OFFSET,
+				  ETH_IPV4_ID_MASK, id, kobj);
 	return xroe_size;
 }
 
@@ -302,15 +267,11 @@ static ssize_t ipv4_id_store(struct kobject *kobj,
 static ssize_t ipv4_flags_show(struct kobject *kobj,
 			       struct kobj_attribute *attr, char *buff)
 {
-	u32 offset = ETH_IPV4_FLAGS_OFFSET;
-	u32 mask = ETH_IPV4_FLAGS_MASK;
-	u32 buffer = 0;
-	u32 flags = 0;
-	void __iomem *working_address = ((u8 *)lp->base_addr
-	+ ETH_IPV4_FLAGS_ADDR);
-
-	buffer = ioread32(working_address);
-	flags = (buffer & mask) >> offset;
+	u32 flags;
+
+	flags = utils_sysfs_show_wrapper(ETH_IPV4_FLAGS_ADDR,
+					 ETH_IPV4_FLAGS_OFFSET,
+					 ETH_IPV4_FLAGS_MASK, kobj);
 	sprintf(buff, "%d\n", flags);
 	return XROE_SIZE_MAX;
 }
@@ -330,18 +291,15 @@ static ssize_t ipv4_flags_store(struct kobject *kobj,
 				struct kobj_attribute *attr, const char *buff,
 				size_t count)
 {
-	int ret = 0;
-	u32 offset = ETH_IPV4_FLAGS_OFFSET;
-	u32 mask = ETH_IPV4_FLAGS_MASK;
-	unsigned int flags = 0;
-	void __iomem *working_address = ((u8 *)lp->base_addr
-	+ ETH_IPV4_FLAGS_ADDR);
+	int ret;
+	u32 flags;
 
 	xroe_size = min_t(size_t, count, (size_t)XROE_SIZE_MAX);
 	ret = kstrtouint(buff, 10, &flags);
 	if (ret)
 		return ret;
-	utils_write32withmask(working_address, (u32)flags, mask, offset);
+	utils_sysfs_store_wrapper(ETH_IPV4_FLAGS_ADDR, ETH_IPV4_FLAGS_OFFSET,
+				  ETH_IPV4_FLAGS_MASK, flags, kobj);
 	return xroe_size;
 }
 
@@ -358,16 +316,13 @@ static ssize_t ipv4_flags_store(struct kobject *kobj,
 static ssize_t ipv4_fragment_offset_show
 (struct kobject *kobj, struct kobj_attribute *attr, char *buff)
 {
-	u32 offset = ETH_IPV4_FRAGMENT_OFFSET_OFFSET;
-	u32 mask = ETH_IPV4_FRAGMENT_OFFSET_MASK;
-	u32 buffer = 0;
-	u32 fragment_offset = 0;
-	void __iomem *working_address = ((u8 *)lp->base_addr +
-	ETH_IPV4_FRAGMENT_OFFSET_ADDR);
-
-	buffer = ioread32(working_address);
-	fragment_offset = (buffer & mask) >> offset;
-	sprintf(buff, "%d\n", fragment_offset);
+	u32 fragment;
+
+	fragment = utils_sysfs_show_wrapper(ETH_IPV4_FRAGMENT_OFFSET_ADDR,
+					    ETH_IPV4_FRAGMENT_OFFSET_OFFSET,
+					    ETH_IPV4_FRAGMENT_OFFSET_MASK,
+					    kobj);
+	sprintf(buff, "%d\n", fragment);
 	return XROE_SIZE_MAX;
 }
 
@@ -386,19 +341,17 @@ static ssize_t ipv4_fragment_offset_store
 (struct kobject *kobj, struct kobj_attribute *attr, const char *buff,
 size_t count)
 {
-	int ret = 0;
-	u32 offset = ETH_IPV4_FRAGMENT_OFFSET_OFFSET;
-	u32 mask = ETH_IPV4_FRAGMENT_OFFSET_MASK;
-	unsigned int fragment_offset = 0;
-	void __iomem *working_address = ((u8 *)lp->base_addr +
-	ETH_IPV4_FRAGMENT_OFFSET_ADDR);
+	int ret;
+	u32 fragment;
 
 	xroe_size = min_t(size_t, count, (size_t)XROE_SIZE_MAX);
-	ret = kstrtouint(buff, 10, &fragment_offset);
+	ret = kstrtouint(buff, 10, &fragment);
 	if (ret)
 		return ret;
-	utils_write32withmask(working_address, (u32)fragment_offset,
-			      mask, offset);
+	utils_sysfs_store_wrapper(ETH_IPV4_FRAGMENT_OFFSET_ADDR,
+				  ETH_IPV4_FRAGMENT_OFFSET_OFFSET,
+				  ETH_IPV4_FRAGMENT_OFFSET_MASK, fragment,
+				  kobj);
 	return xroe_size;
 }
 
@@ -415,15 +368,11 @@ size_t count)
 static ssize_t ipv4_ttl_show(struct kobject *kobj, struct kobj_attribute *attr,
 			     char *buff)
 {
-	u32 offset = ETH_IPV4_TIME_TO_LIVE_OFFSET;
-	u32 mask = ETH_IPV4_TIME_TO_LIVE_MASK;
-	u32 buffer = 0;
-	u32 ttl = 0;
-	void __iomem *working_address = ((u8 *)lp->base_addr +
-	ETH_IPV4_TIME_TO_LIVE_ADDR);
-
-	buffer = ioread32(working_address);
-	ttl = (buffer & mask) >> offset;
+	u32 ttl;
+
+	ttl = utils_sysfs_show_wrapper(ETH_IPV4_TIME_TO_LIVE_ADDR,
+				       ETH_IPV4_TIME_TO_LIVE_OFFSET,
+				       ETH_IPV4_TIME_TO_LIVE_MASK, kobj);
 	sprintf(buff, "%d\n", ttl);
 	return XROE_SIZE_MAX;
 }
@@ -443,18 +392,16 @@ static ssize_t ipv4_ttl_store(struct kobject *kobj,
 			      struct kobj_attribute *attr, const char *buff,
 			      size_t count)
 {
-	int ret = 0;
-	u32 offset = ETH_IPV4_TIME_TO_LIVE_OFFSET;
-	u32 mask = ETH_IPV4_TIME_TO_LIVE_MASK;
-	unsigned int ttl = 0;
-	void __iomem *working_address = ((u8 *)lp->base_addr +
-	ETH_IPV4_TIME_TO_LIVE_ADDR);
+	int ret;
+	u32 ttl;
 
 	xroe_size = min_t(size_t, count, (size_t)XROE_SIZE_MAX);
 	ret = kstrtouint(buff, 10, &ttl);
 	if (ret)
 		return ret;
-	utils_write32withmask(working_address, (u32)ttl, mask, offset);
+	utils_sysfs_store_wrapper(ETH_IPV4_TIME_TO_LIVE_ADDR,
+				  ETH_IPV4_TIME_TO_LIVE_OFFSET,
+				  ETH_IPV4_TIME_TO_LIVE_MASK, ttl, kobj);
 	return xroe_size;
 }
 
@@ -471,15 +418,11 @@ static ssize_t ipv4_ttl_store(struct kobject *kobj,
 static ssize_t ipv4_protocol_show(struct kobject *kobj,
 				  struct kobj_attribute *attr, char *buff)
 {
-	u32 offset = ETH_IPV4_PROTOCOL_OFFSET;
-	u32 mask = ETH_IPV4_PROTOCOL_MASK;
-	u32 buffer = 0;
-	u32 protocol = 0;
-	void __iomem *working_address = ((u8 *)lp->base_addr +
-	ETH_IPV4_PROTOCOL_ADDR);
-
-	buffer = ioread32(working_address);
-	protocol = (buffer & mask) >> offset;
+	u32 protocol;
+
+	protocol = utils_sysfs_show_wrapper(ETH_IPV4_PROTOCOL_ADDR,
+					    ETH_IPV4_PROTOCOL_OFFSET,
+					    ETH_IPV4_PROTOCOL_MASK, kobj);
 	sprintf(buff, "%d\n", protocol);
 	return XROE_SIZE_MAX;
 }
@@ -499,19 +442,16 @@ static ssize_t ipv4_protocol_store(struct kobject *kobj,
 				   struct kobj_attribute *attr,
 				   const char *buff, size_t count)
 {
-	int ret = 0;
-	u32 offset = ETH_IPV4_PROTOCOL_OFFSET;
-	u32 mask = ETH_IPV4_PROTOCOL_MASK;
-	unsigned int protocol = 0;
-	void __iomem *working_address = ((u8 *)lp->base_addr +
-	ETH_IPV4_PROTOCOL_ADDR);
+	int ret;
+	u32 protocol;
 
 	xroe_size = min_t(size_t, count, (size_t)XROE_SIZE_MAX);
 	ret = kstrtouint(buff, 10, &protocol);
 	if (ret)
 		return ret;
-	utils_write32withmask(working_address, (u32)protocol,
-			      mask, offset);
+	utils_sysfs_store_wrapper(ETH_IPV4_PROTOCOL_ADDR,
+				  ETH_IPV4_PROTOCOL_OFFSET,
+				  ETH_IPV4_PROTOCOL_MASK, protocol, kobj);
 	return xroe_size;
 }
 
@@ -528,16 +468,12 @@ static ssize_t ipv4_protocol_store(struct kobject *kobj,
 static ssize_t ipv4_source_address_show
 (struct kobject *kobj, struct kobj_attribute *attr, char *buff)
 {
-	u32 offset = ETH_IPV4_SOURCE_ADD_OFFSET;
-	unsigned long mask = ETH_IPV4_SOURCE_ADD_MASK;
-	u32 buffer = 0;
 	u32 source_add = 0;
 	unsigned char ip_addr_char[4];
-	void __iomem *working_address = ((u8 *)lp->base_addr +
-	ETH_IPV4_SOURCE_ADD_ADDR);
 
-	buffer = ioread32(working_address);
-	source_add = (buffer & mask) >> offset;
+	source_add = utils_sysfs_show_wrapper(ETH_IPV4_SOURCE_ADD_ADDR,
+					      ETH_IPV4_SOURCE_ADD_OFFSET,
+					      ETH_IPV4_SOURCE_ADD_MASK, kobj);
 	utils_ipv4addr_hextochar(source_add, ip_addr_char);
 	sprintf(buff, "%d.%d.%d.%d\n", ip_addr_char[3], ip_addr_char[2],
 		ip_addr_char[1], ip_addr_char[0]);
@@ -560,17 +496,15 @@ static ssize_t ipv4_source_address_store
 (struct kobject *kobj, struct kobj_attribute *attr, const char *buff,
 size_t count)
 {
-	u32 offset = ETH_IPV4_SOURCE_ADD_OFFSET;
-	unsigned long mask = ETH_IPV4_SOURCE_ADD_MASK;
 	u32 source_add = 0;
-	void __iomem *working_address = ((u8 *)lp->base_addr +
-	ETH_IPV4_SOURCE_ADD_ADDR);
 
 	xroe_size = min_t(size_t, count, (size_t)XROE_SIZE_MAX);
 	strncpy(xroe_tmp, buff, xroe_size);
 	if (utils_ipv4addr_chartohex(xroe_tmp, &source_add) == 4)
-		utils_write32withmask(working_address,
-				      source_add, mask, offset);
+		utils_sysfs_store_wrapper(ETH_IPV4_SOURCE_ADD_ADDR,
+					  ETH_IPV4_SOURCE_ADD_OFFSET,
+					  ETH_IPV4_SOURCE_ADD_MASK, source_add,
+					  kobj);
 	return xroe_size;
 }
 
@@ -587,19 +521,17 @@ size_t count)
 static ssize_t ipv4_destination_address_show
 (struct kobject *kobj, struct kobj_attribute *attr, char *buff)
 {
-	u32 offset = ETH_IPV4_DESTINATION_ADD_OFFSET;
-	unsigned long mask = ETH_IPV4_DESTINATION_ADD_MASK;
-	u32 buffer = 0;
-	u32 destination_add = 0;
+	u32 dest_add = 0;
 	unsigned char ip_addr_char[4];
-	void __iomem *working_address = ((u8 *)lp->base_addr +
-	ETH_IPV4_DESTINATION_ADD_ADDR);
 
-	buffer = ioread32(working_address);
-	destination_add = (buffer & mask) >> offset;
-	utils_ipv4addr_hextochar(destination_add, ip_addr_char);
+	dest_add = utils_sysfs_show_wrapper(ETH_IPV4_DESTINATION_ADD_ADDR,
+					    ETH_IPV4_DESTINATION_ADD_OFFSET,
+					    ETH_IPV4_DESTINATION_ADD_MASK,
+					    kobj);
+	utils_ipv4addr_hextochar(dest_add, ip_addr_char);
 	sprintf(buff, "%d.%d.%d.%d\n", ip_addr_char[3], ip_addr_char[2],
 		ip_addr_char[1], ip_addr_char[0]);
+
 	return XROE_SIZE_MAX;
 }
 
@@ -619,18 +551,15 @@ static ssize_t ipv4_destination_address_store
 (struct kobject *kobj, struct kobj_attribute *attr, const char *buff,
 size_t count)
 {
-	u32 offset = ETH_IPV4_DESTINATION_ADD_OFFSET;
-	unsigned long mask = ETH_IPV4_DESTINATION_ADD_MASK;
-	u32 destination_add = 0;
-	void __iomem *working_address = ((u8 *)lp->base_addr +
-	ETH_IPV4_DESTINATION_ADD_ADDR);
+	u32 dest_add = 0;
 
 	xroe_size = min_t(size_t, count, (size_t)XROE_SIZE_MAX);
 	strncpy(xroe_tmp, buff, xroe_size);
-	if (utils_ipv4addr_chartohex(xroe_tmp,
-				     &destination_add) == 4)
-		utils_write32withmask(working_address,
-				      destination_add, mask, offset);
+	if (utils_ipv4addr_chartohex(xroe_tmp, &dest_add) == 4)
+		utils_sysfs_store_wrapper(ETH_IPV4_DESTINATION_ADD_ADDR,
+					  ETH_IPV4_DESTINATION_ADD_OFFSET,
+					  ETH_IPV4_DESTINATION_ADD_MASK,
+					  dest_add, kobj);
 	return xroe_size;
 }
 
@@ -682,7 +611,8 @@ static struct attribute_group attr_group = {
 };
 
 struct kobject *kobj_framer;
-static struct kobject *kobj_ipv4;
+static struct kobject *kobj_ipv4[MAX_NUM_ETH_PORTS];
+struct kobject *kobj_eth_ports[MAX_NUM_ETH_PORTS];
 
 /**
  * xroe_sysfs_ipv4_init - Creates the xroe sysfs "ipv4" subdirectory & entries
@@ -695,16 +625,27 @@ static struct kobject *kobj_ipv4;
 int xroe_sysfs_ipv4_init(void)
 {
 	int ret;
+	int i;
+	char eth_port_dir_name[11];
 
 	kobj_framer = kobject_create_and_add("framer", root_xroe_kobj);
 	if (!kobj_framer)
 		return -ENOMEM;
-	kobj_ipv4 = kobject_create_and_add("ipv4", kobj_framer);
-	if (!kobj_ipv4)
-		return -ENOMEM;
-	ret = sysfs_create_group(kobj_ipv4, &attr_group);
-	if (ret)
-		kobject_put(kobj_ipv4);
+	for (i = 0; i < 4; i++) {
+		snprintf(eth_port_dir_name, sizeof(eth_port_dir_name),
+			 "eth_port_%d", i);
+		kobj_eth_ports[i] = kobject_create_and_add(eth_port_dir_name,
+							   kobj_framer);
+		if (!kobj_eth_ports[i])
+			return -ENOMEM;
+		kobj_ipv4[i] = kobject_create_and_add("ipv4",
+						      kobj_eth_ports[i]);
+		if (!kobj_ipv4[i])
+			return -ENOMEM;
+		ret = sysfs_create_group(kobj_ipv4[i], &attr_group);
+		if (ret)
+			kobject_put(kobj_ipv4[i]);
+	}
 	return ret;
 }
 
@@ -716,7 +657,10 @@ int xroe_sysfs_ipv4_init(void)
  */
 void xroe_sysfs_ipv4_exit(void)
 {
-	kobject_put(kobj_ipv4);
+	int i;
+
+	for (i = 0; i < MAX_NUM_ETH_PORTS; i++)
+		kobject_put(kobj_ipv4[i]);
 }
 
 /**
diff --git a/drivers/staging/xroeframer/sysfs_xroe_framer_ipv6.c b/drivers/staging/xroeframer/sysfs_xroe_framer_ipv6.c
index e9ba77f77917..c26eae426cc1 100644
--- a/drivers/staging/xroeframer/sysfs_xroe_framer_ipv6.c
+++ b/drivers/staging/xroeframer/sysfs_xroe_framer_ipv6.c
@@ -33,15 +33,10 @@ static int utils_ipv6addr_chartohex(char *ip_addr, uint32_t *p_ip_addr);
 static ssize_t ipv6_version_show(struct kobject *kobj,
 				 struct kobj_attribute *attr, char *buff)
 {
-	u32 offset = ETH_IPV6_V_OFFSET;
-	u32 mask = ETH_IPV6_V_MASK;
-	u32 buffer = 0;
-	u32 version = 0;
-	void __iomem *working_address = ((u8 *)lp->base_addr
-	+ ETH_IPV6_V_ADDR);
-
-	buffer = ioread32(working_address);
-	version = (buffer & mask) >> offset;
+	u32 version;
+
+	version = utils_sysfs_show_wrapper(ETH_IPV6_V_ADDR, ETH_IPV6_V_OFFSET,
+					   ETH_IPV6_V_MASK, kobj);
 	sprintf(buff, "%d\n", version);
 	return XROE_SIZE_MAX;
 }
@@ -78,15 +73,12 @@ static ssize_t ipv6_version_store(struct kobject *kobj,
 static ssize_t ipv6_traffic_class_show(struct kobject *kobj,
 				       struct kobj_attribute *attr, char *buff)
 {
-	u32 offset = ETH_IPV6_TRAFFIC_CLASS_OFFSET;
-	u32 mask = ETH_IPV6_TRAFFIC_CLASS_MASK;
-	u32 buffer = 0;
-	u32 traffic_class = 0;
-	void __iomem *working_address = ((u8 *)lp->base_addr +
-	ETH_IPV6_TRAFFIC_CLASS_ADDR);
-
-	buffer = ioread32(working_address);
-	traffic_class = (buffer & mask) >> offset;
+	u32 traffic_class;
+
+	traffic_class = utils_sysfs_show_wrapper(ETH_IPV6_TRAFFIC_CLASS_ADDR,
+						 ETH_IPV6_TRAFFIC_CLASS_OFFSET,
+						 ETH_IPV6_TRAFFIC_CLASS_MASK,
+						 kobj);
 	sprintf(buff, "%d\n", traffic_class);
 	return XROE_SIZE_MAX;
 }
@@ -107,19 +99,16 @@ static ssize_t ipv6_traffic_class_store(struct kobject *kobj,
 					const char *buff, size_t count)
 {
 	int ret;
-	u32 offset = ETH_IPV6_TRAFFIC_CLASS_OFFSET;
-	u32 mask = ETH_IPV6_TRAFFIC_CLASS_MASK;
-	unsigned int traffic_class = 0;
-	void __iomem *working_address = ((u8 *)lp->base_addr +
-	ETH_IPV6_TRAFFIC_CLASS_ADDR);
+	u32 traffic_class;
 
-	ret = 0;
 	xroe_size = min_t(size_t, count, (size_t)XROE_SIZE_MAX);
 	ret = kstrtouint(buff, 10, &traffic_class);
 	if (ret)
 		return ret;
-	utils_write32withmask(working_address, (u32)traffic_class,
-			      mask, offset);
+	utils_sysfs_store_wrapper(ETH_IPV6_TRAFFIC_CLASS_ADDR,
+				  ETH_IPV6_TRAFFIC_CLASS_OFFSET,
+				  ETH_IPV6_TRAFFIC_CLASS_MASK, traffic_class,
+				  kobj);
 	return xroe_size;
 }
 
@@ -136,15 +125,11 @@ static ssize_t ipv6_traffic_class_store(struct kobject *kobj,
 static ssize_t ipv6_flow_label_show(struct kobject *kobj,
 				    struct kobj_attribute *attr, char *buff)
 {
-	u32 offset = ETH_IPV6_FLOW_LABEL_OFFSET;
-	u32 mask = ETH_IPV6_FLOW_LABEL_MASK;
-	u32 buffer = 0;
-	u32 flow_label = 0;
-	void __iomem *working_address = ((u8 *)lp->base_addr +
-	ETH_IPV6_FLOW_LABEL_ADDR);
-
-	buffer = ioread32(working_address);
-	flow_label = (buffer & mask) >> offset;
+	u32 flow_label;
+
+	flow_label = utils_sysfs_show_wrapper(ETH_IPV6_FLOW_LABEL_ADDR,
+					      ETH_IPV6_FLOW_LABEL_OFFSET,
+					      ETH_IPV6_FLOW_LABEL_MASK, kobj);
 	sprintf(buff, "%d\n", flow_label);
 	return XROE_SIZE_MAX;
 }
@@ -165,19 +150,15 @@ static ssize_t ipv6_flow_label_store(struct kobject *kobj,
 				     const char *buff, size_t count)
 {
 	int ret;
-	u32 offset = ETH_IPV6_FLOW_LABEL_OFFSET;
-	u32 mask = ETH_IPV6_FLOW_LABEL_MASK;
-	unsigned int flow_label = 0;
-	void __iomem *working_address = ((u8 *)lp->base_addr +
-	ETH_IPV6_FLOW_LABEL_ADDR);
+	u32 flow_label;
 
 	xroe_size = min_t(size_t, count, (size_t)XROE_SIZE_MAX);
-	ret = 0;
 	ret = kstrtouint(buff, 10, &flow_label);
 	if (ret)
 		return ret;
-	utils_write32withmask(working_address, (u32)flow_label,
-			      mask, offset);
+	utils_sysfs_store_wrapper(ETH_IPV6_FLOW_LABEL_ADDR,
+				  ETH_IPV6_FLOW_LABEL_OFFSET,
+				  ETH_IPV6_FLOW_LABEL_MASK, flow_label, kobj);
 	return xroe_size;
 }
 
@@ -195,15 +176,11 @@ static ssize_t ipv6_next_header_show(struct kobject *kobj,
 				     struct kobj_attribute *attr,
 				     char *buff)
 {
-	u32 offset = ETH_IPV6_NEXT_HEADER_OFFSET;
-	u32 mask = ETH_IPV6_NEXT_HEADER_MASK;
-	u32 buffer = 0;
-	u32 next_header = 0;
-	void __iomem *working_address = ((u8 *)lp->base_addr +
-	ETH_IPV6_NEXT_HEADER_ADDR);
-
-	buffer = ioread32(working_address);
-	next_header = (buffer & mask) >> offset;
+	u32 next_header;
+
+	next_header = utils_sysfs_show_wrapper(ETH_IPV6_NEXT_HEADER_ADDR,
+					       ETH_IPV6_NEXT_HEADER_OFFSET,
+					       ETH_IPV6_NEXT_HEADER_MASK, kobj);
 	sprintf(buff, "%d\n", next_header);
 	return XROE_SIZE_MAX;
 }
@@ -224,19 +201,15 @@ static ssize_t ipv6_next_header_store(struct kobject *kobj,
 				      const char *buff, size_t count)
 {
 	int ret;
-	u32 offset = ETH_IPV6_NEXT_HEADER_OFFSET;
-	u32 mask = ETH_IPV6_NEXT_HEADER_MASK;
-	unsigned int next_header = 0;
-	void __iomem *working_address = ((u8 *)lp->base_addr +
-	ETH_IPV6_NEXT_HEADER_ADDR);
+	u32 next_header;
 
 	xroe_size = min_t(size_t, count, (size_t)XROE_SIZE_MAX);
-	ret = 0;
 	ret = kstrtouint(buff, 10, &next_header);
 	if (ret)
 		return ret;
-	utils_write32withmask(working_address, (u32)next_header,
-			      mask, offset);
+	utils_sysfs_store_wrapper(ETH_IPV6_NEXT_HEADER_ADDR,
+				  ETH_IPV6_NEXT_HEADER_OFFSET,
+				  ETH_IPV6_NEXT_HEADER_MASK, next_header, kobj);
 	return xroe_size;
 }
 
@@ -253,15 +226,11 @@ static ssize_t ipv6_next_header_store(struct kobject *kobj,
 static ssize_t ipv6_hop_limit_show(struct kobject *kobj,
 				   struct kobj_attribute *attr, char *buff)
 {
-	u32 offset = ETH_IPV6_HOP_LIMIT_OFFSET;
-	u32 mask = ETH_IPV6_HOP_LIMIT_MASK;
-	u32 buffer = 0;
-	u32 hop_limit = 0;
-	void __iomem *working_address = ((u8 *)lp->base_addr +
-	ETH_IPV6_HOP_LIMIT_ADDR);
-
-	buffer = ioread32(working_address);
-	hop_limit = (buffer & mask) >> offset;
+	u32 hop_limit;
+
+	hop_limit = utils_sysfs_show_wrapper(ETH_IPV6_HOP_LIMIT_ADDR,
+					     ETH_IPV6_HOP_LIMIT_OFFSET,
+					     ETH_IPV6_HOP_LIMIT_MASK, kobj);
 	sprintf(buff, "%d\n", hop_limit);
 	return XROE_SIZE_MAX;
 }
@@ -282,19 +251,15 @@ static ssize_t ipv6_hop_limit_store
 size_t count)
 {
 	int ret;
-	u32 offset = ETH_IPV6_HOP_LIMIT_OFFSET;
-	u32 mask = ETH_IPV6_HOP_LIMIT_MASK;
-	unsigned int hop_limit = 0;
-	void __iomem *working_address = ((u8 *)lp->base_addr +
-	ETH_IPV6_HOP_LIMIT_ADDR);
+	u32 hop_limit;
 
 	xroe_size = min_t(size_t, count, (size_t)XROE_SIZE_MAX);
-	ret = 0;
 	ret = kstrtouint(buff, 10, &hop_limit);
 	if (ret)
 		return ret;
-	utils_write32withmask(working_address, (u32)hop_limit,
-			      mask, offset);
+	utils_sysfs_store_wrapper(ETH_IPV6_HOP_LIMIT_ADDR,
+				  ETH_IPV6_HOP_LIMIT_OFFSET,
+				  ETH_IPV6_HOP_LIMIT_MASK, hop_limit, kobj);
 	return xroe_size;
 }
 
@@ -312,42 +277,27 @@ size_t count)
 static ssize_t ipv6_source_address_show
 (struct kobject *kobj, struct kobj_attribute *attr, char *buff)
 {
-	u32 offset = ETH_IPV6_SOURCE_ADD_31_0_OFFSET;
-	unsigned long mask = ETH_IPV6_SOURCE_ADD_31_0_MASK;
-	u32 buffer = 0;
-	u32 source_add[4];
+	u32 source[4];
 	u16 source_add16[8];
-	void __iomem *working_address = ((u8 *)lp->base_addr +
-	ETH_IPV6_SOURCE_ADD_31_0_ADDR);
-
-	buffer = ioread32(working_address);
-	source_add[0] = (buffer & mask) >> offset;
-
-	working_address = ((u8 *)lp->base_addr +
-	ETH_IPV6_SOURCE_ADD_63_32_ADDR);
-	mask = ETH_IPV6_SOURCE_ADD_63_32_MASK;
-	offset = ETH_IPV6_SOURCE_ADD_63_32_OFFSET;
-
-	buffer = ioread32(working_address);
-	source_add[1] = (buffer & mask) >> offset;
-
-	working_address = ((u8 *)lp->base_addr +
-	ETH_IPV6_SOURCE_ADD_95_64_ADDR);
-	mask = ETH_IPV6_SOURCE_ADD_95_64_MASK;
-	offset = ETH_IPV6_SOURCE_ADD_95_64_OFFSET;
 
-	buffer = ioread32(working_address);
-	source_add[2] = (buffer & mask) >> offset;
-
-	working_address = ((u8 *)lp->base_addr +
-	ETH_IPV6_SOURCE_ADD_127_96_ADDR);
-	mask = ETH_IPV6_SOURCE_ADD_127_96_MASK;
-	offset = ETH_IPV6_SOURCE_ADD_127_96_OFFSET;
-
-	buffer = ioread32(working_address);
-	source_add[3] = (buffer & mask) >> offset;
-
-	utils_ipv6addr_32to16(source_add, source_add16);
+	source[0] = utils_sysfs_show_wrapper(ETH_IPV6_SOURCE_ADD_31_0_ADDR,
+					     ETH_IPV6_SOURCE_ADD_31_0_OFFSET,
+					     ETH_IPV6_SOURCE_ADD_31_0_MASK,
+					     kobj);
+	source[1] = utils_sysfs_show_wrapper(ETH_IPV6_SOURCE_ADD_63_32_ADDR,
+					     ETH_IPV6_SOURCE_ADD_63_32_OFFSET,
+					     ETH_IPV6_SOURCE_ADD_63_32_MASK,
+					     kobj);
+	source[2] = utils_sysfs_show_wrapper(ETH_IPV6_SOURCE_ADD_95_64_ADDR,
+					     ETH_IPV6_SOURCE_ADD_95_64_OFFSET,
+					     ETH_IPV6_SOURCE_ADD_95_64_MASK,
+					     kobj);
+	source[3] = utils_sysfs_show_wrapper(ETH_IPV6_SOURCE_ADD_127_96_ADDR,
+					     ETH_IPV6_SOURCE_ADD_127_96_OFFSET,
+					     ETH_IPV6_SOURCE_ADD_127_96_MASK,
+					     kobj);
+
+	utils_ipv6addr_32to16(source, source_add16);
 	sprintf(buff, "%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x\n",
 		source_add16[0], source_add16[1], source_add16[2],
 		source_add16[3],
@@ -371,41 +321,27 @@ static ssize_t ipv6_source_address_store
 (struct kobject *kobj, struct kobj_attribute *attr, const char *buff,
 size_t count)
 {
-	u32 offset = ETH_IPV6_SOURCE_ADD_31_0_OFFSET;
-	unsigned long mask = ETH_IPV6_SOURCE_ADD_31_0_MASK;
 	u32 source_add[4];
-	void __iomem *working_address = ((u8 *)lp->base_addr +
-	ETH_IPV6_SOURCE_ADD_31_0_ADDR);
 
 	xroe_size = min_t(size_t, count, (size_t)XROE_SIZE_MAX);
 	strncpy(xroe_tmp, buff, xroe_size);
 	if (utils_ipv6addr_chartohex(xroe_tmp, source_add) == 8) {
-		utils_write32withmask(working_address, source_add[0],
-				      mask, offset);
-
-		working_address = ((u8 *)lp->base_addr +
-		ETH_IPV6_SOURCE_ADD_63_32_ADDR);
-		mask = ETH_IPV6_SOURCE_ADD_63_32_MASK;
-		offset = ETH_IPV6_SOURCE_ADD_63_32_OFFSET;
-
-		utils_write32withmask(working_address, source_add[1],
-				      mask, offset);
-
-		working_address = ((u8 *)lp->base_addr +
-		ETH_IPV6_SOURCE_ADD_95_64_ADDR);
-		mask = ETH_IPV6_SOURCE_ADD_95_64_MASK;
-		offset = ETH_IPV6_SOURCE_ADD_95_64_OFFSET;
-
-		utils_write32withmask(working_address, source_add[2],
-				      mask, offset);
-
-		working_address = ((u8 *)lp->base_addr +
-		ETH_IPV6_SOURCE_ADD_127_96_ADDR);
-		mask = ETH_IPV6_SOURCE_ADD_127_96_MASK;
-		offset = ETH_IPV6_SOURCE_ADD_127_96_OFFSET;
-
-		utils_write32withmask(working_address, source_add[3],
-				      mask, offset);
+		utils_sysfs_store_wrapper(ETH_IPV6_SOURCE_ADD_31_0_ADDR,
+					  ETH_IPV6_SOURCE_ADD_31_0_OFFSET,
+					  ETH_IPV6_SOURCE_ADD_31_0_MASK,
+					  source_add[0], kobj);
+		utils_sysfs_store_wrapper(ETH_IPV6_SOURCE_ADD_63_32_ADDR,
+					  ETH_IPV6_SOURCE_ADD_63_32_OFFSET,
+					  ETH_IPV6_SOURCE_ADD_63_32_MASK,
+					  source_add[1], kobj);
+		utils_sysfs_store_wrapper(ETH_IPV6_SOURCE_ADD_95_64_ADDR,
+					  ETH_IPV6_SOURCE_ADD_95_64_OFFSET,
+					  ETH_IPV6_SOURCE_ADD_95_64_MASK,
+					  source_add[2], kobj);
+		utils_sysfs_store_wrapper(ETH_IPV6_SOURCE_ADD_127_96_ADDR,
+					  ETH_IPV6_SOURCE_ADD_127_96_OFFSET,
+					  ETH_IPV6_SOURCE_ADD_127_96_MASK,
+					  source_add[3], kobj);
 	}
 	return xroe_size;
 }
@@ -424,45 +360,32 @@ size_t count)
 static ssize_t ipv6_destination_address_show
 (struct kobject *kobj, struct kobj_attribute *attr, char *buff)
 {
-	u32 offset = ETH_IPV6_DESTINATION_ADD_31_0_OFFSET;
-	unsigned long mask = ETH_IPV6_DESTINATION_ADD_31_0_MASK;
-	u32 buffer = 0;
-	u32 dest_add[4];
+	u32 dest[4];
 	u16 dest_add16[8];
-	void __iomem *working_address = ((u8 *)lp->base_addr +
-	ETH_IPV6_DESTINATION_ADD_31_0_ADDR);
-
-	buffer = ioread32(working_address);
-	dest_add[0] = (buffer & mask) >> offset;
-
-	working_address = ((u8 *)lp->base_addr +
-	ETH_IPV6_DESTINATION_ADD_63_32_ADDR);
-	mask = ETH_IPV6_DESTINATION_ADD_63_32_MASK;
-	offset = ETH_IPV6_DESTINATION_ADD_63_32_OFFSET;
-
-	buffer = ioread32(working_address);
-	dest_add[1] = (buffer & mask) >> offset;
-
-	working_address = ((u8 *)lp->base_addr +
-	ETH_IPV6_DESTINATION_ADD_95_64_ADDR);
-	mask = ETH_IPV6_DESTINATION_ADD_95_64_MASK;
-	offset = ETH_IPV6_DESTINATION_ADD_95_64_OFFSET;
 
-	buffer = ioread32(working_address);
-	dest_add[2] = (buffer & mask) >> offset;
-
-	working_address = ((u8 *)lp->base_addr +
-	ETH_IPV6_DESTINATION_ADD_127_96_ADDR);
-	mask = ETH_IPV6_DESTINATION_ADD_127_96_MASK;
-	offset = ETH_IPV6_DESTINATION_ADD_127_96_OFFSET;
-
-	buffer = ioread32(working_address);
-	dest_add[3] = (buffer & mask) >> offset;
-
-	utils_ipv6addr_32to16(dest_add, dest_add16);
+	dest[0] = utils_sysfs_show_wrapper(ETH_IPV6_DEST_ADD_31_0_ADDR,
+					   ETH_IPV6_DEST_ADD_31_0_OFFSET,
+					   ETH_IPV6_DEST_ADD_31_0_MASK,
+					   kobj);
+	dest[1] = utils_sysfs_show_wrapper(ETH_IPV6_DEST_ADD_63_32_ADDR,
+					   ETH_IPV6_DEST_ADD_63_32_OFFSET,
+					   ETH_IPV6_DEST_ADD_63_32_MASK,
+					   kobj);
+	dest[2] = utils_sysfs_show_wrapper(ETH_IPV6_DEST_ADD_95_64_ADDR,
+					   ETH_IPV6_DEST_ADD_95_64_OFFSET,
+					   ETH_IPV6_DEST_ADD_95_64_MASK,
+					   kobj);
+	dest[3] = utils_sysfs_show_wrapper(ETH_IPV6_DEST_ADD_127_96_ADDR,
+					   ETH_IPV6_DEST_ADD_127_96_OFFSET,
+					   ETH_IPV6_DEST_ADD_127_96_MASK,
+					   kobj);
+
+	utils_ipv6addr_32to16(dest, dest_add16);
 	sprintf(buff, "%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x\n",
-		dest_add16[0], dest_add16[1], dest_add16[2], dest_add16[3],
-		dest_add16[4], dest_add16[5], dest_add16[6], dest_add16[7]);
+		dest_add16[0], dest_add16[1], dest_add16[2],
+		dest_add16[3],
+		dest_add16[4], dest_add16[5], dest_add16[6],
+		dest_add16[7]);
 	return XROE_SIZE_MAX;
 }
 
@@ -482,41 +405,27 @@ static ssize_t ipv6_destination_address_store
 (struct kobject *kobj, struct kobj_attribute *attr, const char *buff,
 size_t count)
 {
-	u32 offset = ETH_IPV6_DESTINATION_ADD_31_0_OFFSET;
-	unsigned long mask = ETH_IPV6_DESTINATION_ADD_31_0_MASK;
 	u32 dest_add[4];
-	void __iomem *working_address = ((u8 *)lp->base_addr +
-	ETH_IPV6_DESTINATION_ADD_31_0_ADDR);
 
 	xroe_size = min_t(size_t, count, (size_t)XROE_SIZE_MAX);
 	strncpy(xroe_tmp, buff, xroe_size);
 	if (utils_ipv6addr_chartohex(xroe_tmp, dest_add) == 8) {
-		utils_write32withmask(working_address, dest_add[0],
-				      mask, offset);
-
-		working_address = ((u8 *)lp->base_addr +
-		ETH_IPV6_DESTINATION_ADD_63_32_ADDR);
-		mask = ETH_IPV6_DESTINATION_ADD_63_32_MASK;
-		offset = ETH_IPV6_DESTINATION_ADD_63_32_OFFSET;
-
-		utils_write32withmask(working_address, dest_add[1],
-				      mask, offset);
-
-		working_address = ((u8 *)lp->base_addr +
-		ETH_IPV6_DESTINATION_ADD_95_64_ADDR);
-		mask = ETH_IPV6_DESTINATION_ADD_95_64_MASK;
-		offset = ETH_IPV6_DESTINATION_ADD_95_64_OFFSET;
-
-		utils_write32withmask(working_address, dest_add[2],
-				      mask, offset);
-
-		working_address = ((u8 *)lp->base_addr +
-		ETH_IPV6_DESTINATION_ADD_127_96_ADDR);
-		mask = ETH_IPV6_DESTINATION_ADD_127_96_MASK;
-		offset = ETH_IPV6_DESTINATION_ADD_127_96_OFFSET;
-
-		utils_write32withmask(working_address, dest_add[3],
-				      mask, offset);
+		utils_sysfs_store_wrapper(ETH_IPV6_DEST_ADD_31_0_ADDR,
+					  ETH_IPV6_DEST_ADD_31_0_OFFSET,
+					  ETH_IPV6_DEST_ADD_31_0_MASK,
+					  dest_add[0], kobj);
+		utils_sysfs_store_wrapper(ETH_IPV6_DEST_ADD_63_32_ADDR,
+					  ETH_IPV6_DEST_ADD_63_32_OFFSET,
+					  ETH_IPV6_DEST_ADD_63_32_MASK,
+					  dest_add[1], kobj);
+		utils_sysfs_store_wrapper(ETH_IPV6_DEST_ADD_95_64_ADDR,
+					  ETH_IPV6_DEST_ADD_95_64_OFFSET,
+					  ETH_IPV6_DEST_ADD_95_64_MASK,
+					  dest_add[2], kobj);
+		utils_sysfs_store_wrapper(ETH_IPV6_DEST_ADD_127_96_ADDR,
+					  ETH_IPV6_DEST_ADD_127_96_OFFSET,
+					  ETH_IPV6_DEST_ADD_127_96_MASK,
+					  dest_add[3], kobj);
 	}
 	return xroe_size;
 }
@@ -557,7 +466,7 @@ static struct attribute_group attr_group = {
 	.attrs = attrs,
 };
 
-static struct kobject *kobj_ipv6;
+static struct kobject *kobj_ipv6[MAX_NUM_ETH_PORTS];
 
 /**
  * xroe_sysfs_ipv6_init - Creates the xroe sysfs "ipv6" subdirectory & entries
@@ -570,13 +479,17 @@ static struct kobject *kobj_ipv6;
 int xroe_sysfs_ipv6_init(void)
 {
 	int ret;
-
-	kobj_ipv6 = kobject_create_and_add("ipv6", kobj_framer);
-	if (!kobj_ipv6)
-		return -ENOMEM;
-	ret = sysfs_create_group(kobj_ipv6, &attr_group);
-	if (ret)
-		kobject_put(kobj_ipv6);
+	int i;
+
+	for (i = 0; i < 4; i++) {
+		kobj_ipv6[i] = kobject_create_and_add("ipv6",
+						      kobj_eth_ports[i]);
+		if (!kobj_ipv6[i])
+			return -ENOMEM;
+		ret = sysfs_create_group(kobj_ipv6[i], &attr_group);
+		if (ret)
+			kobject_put(kobj_ipv6[i]);
+	}
 	return ret;
 }
 
@@ -589,7 +502,10 @@ int xroe_sysfs_ipv6_init(void)
  */
 void xroe_sysfs_ipv6_exit(void)
 {
-	kobject_put(kobj_ipv6);
+	int i;
+
+	for (i = 0; i < MAX_NUM_ETH_PORTS; i++)
+		kobject_put(kobj_ipv6[i]);
 }
 
 /**
diff --git a/drivers/staging/xroeframer/sysfs_xroe_framer_udp.c b/drivers/staging/xroeframer/sysfs_xroe_framer_udp.c
index 7117d89ed53b..8f8a77b25da7 100644
--- a/drivers/staging/xroeframer/sysfs_xroe_framer_udp.c
+++ b/drivers/staging/xroeframer/sysfs_xroe_framer_udp.c
@@ -30,18 +30,12 @@ static ssize_t udp_source_port_show(struct kobject *kobj,
 				    struct kobj_attribute *attr,
 				    char *buff)
 {
-	u32 offset = ETH_UDP_SOURCE_PORT_OFFSET;
-	u32 mask = ETH_UDP_SOURCE_PORT_MASK;
-	u32 buffer = 0;
-	u32 source_port = 0;
-	void __iomem *working_address = ((u8 *)lp->base_addr +
-	ETH_UDP_SOURCE_PORT_ADDR);
-
-	buffer = ioread32(working_address);
-	source_port = (buffer & mask) >> offset;
+	u32 source_port;
 
+	source_port = utils_sysfs_show_wrapper(ETH_UDP_SOURCE_PORT_ADDR,
+					       ETH_UDP_SOURCE_PORT_OFFSET,
+					       ETH_UDP_SOURCE_PORT_MASK, kobj);
 	sprintf(buff, "%d\n", source_port);
-
 	return XROE_SIZE_MAX;
 }
 
@@ -61,18 +55,15 @@ static ssize_t udp_source_port_store(struct kobject *kobj,
 				     const char *buff, size_t count)
 {
 	int ret;
-	u32 offset = ETH_UDP_SOURCE_PORT_OFFSET;
-	u32 mask = ETH_UDP_SOURCE_PORT_MASK;
-	unsigned int source_port = 0;
-	void __iomem *working_address = ((u8 *)lp->base_addr +
-	ETH_UDP_SOURCE_PORT_ADDR);
+	u32 source_port;
 
 	xroe_size = min_t(size_t, count, (size_t)XROE_SIZE_MAX);
-	ret = 0;
 	ret = kstrtouint(buff, 10, &source_port);
 	if (ret)
 		return ret;
-	utils_write32withmask(working_address, (u32)source_port, mask, offset);
+	utils_sysfs_store_wrapper(ETH_UDP_SOURCE_PORT_ADDR,
+				  ETH_UDP_SOURCE_PORT_OFFSET,
+				  ETH_UDP_SOURCE_PORT_MASK, source_port, kobj);
 	return xroe_size;
 }
 
@@ -90,18 +81,13 @@ static ssize_t udp_destination_port_show(struct kobject *kobj,
 					 struct kobj_attribute *attr,
 					 char *buff)
 {
-	u32 offset = ETH_UDP_DESTINATION_PORT_OFFSET;
-	unsigned long mask = ETH_UDP_DESTINATION_PORT_MASK;
-	u32 buffer = 0;
-	u32 dest_port = 0;
-	void __iomem *working_address = ((u8 *)lp->base_addr +
-	ETH_UDP_DESTINATION_PORT_ADDR);
-
-	buffer = ioread32(working_address);
-	dest_port = (buffer & mask) >> offset;
+	u32 dest_port;
 
+	dest_port = utils_sysfs_show_wrapper(ETH_UDP_DESTINATION_PORT_ADDR,
+					     ETH_UDP_DESTINATION_PORT_OFFSET,
+					     ETH_UDP_DESTINATION_PORT_MASK,
+					     kobj);
 	sprintf(buff, "%d\n", dest_port);
-
 	return XROE_SIZE_MAX;
 }
 
@@ -121,19 +107,16 @@ static ssize_t udp_destination_port_store(struct kobject *kobj,
 					  const char *buff, size_t count)
 {
 	int ret;
-	u32 offset = ETH_UDP_DESTINATION_PORT_OFFSET;
-	unsigned long mask = ETH_UDP_DESTINATION_PORT_MASK;
-	unsigned int dest_port = 0;
-	void __iomem *working_address = ((u8 *)lp->base_addr +
-	ETH_UDP_DESTINATION_PORT_ADDR);
+	u32 dest_port;
 
 	xroe_size = min_t(size_t, count, (size_t)XROE_SIZE_MAX);
-	ret = 0;
 	ret = kstrtouint(buff, 10, &dest_port);
 	if (ret)
 		return ret;
-	utils_write32withmask(working_address, (u32)dest_port,
-			      mask, offset);
+	utils_sysfs_store_wrapper(ETH_UDP_DESTINATION_PORT_ADDR,
+				  ETH_UDP_DESTINATION_PORT_OFFSET,
+				  ETH_UDP_DESTINATION_PORT_MASK, dest_port,
+				  kobj);
 	return xroe_size;
 }
 
@@ -156,7 +139,7 @@ static struct attribute_group attr_group = {
 	.attrs = attrs,
 };
 
-static struct kobject *kobj_udp;
+static struct kobject *kobj_udp[MAX_NUM_ETH_PORTS];
 
 /**
  * xroe_sysfs_udp_init - Creates the xroe sysfs "udp" subdirectory and entries
@@ -169,13 +152,16 @@ static struct kobject *kobj_udp;
 int xroe_sysfs_udp_init(void)
 {
 	int ret;
-
-	kobj_udp = kobject_create_and_add("udp", kobj_framer);
-	if (!kobj_udp)
-		return -ENOMEM;
-	ret = sysfs_create_group(kobj_udp, &attr_group);
-	if (ret)
-		kobject_put(kobj_udp);
+	int i;
+
+	for (i = 0; i < 4; i++) {
+		kobj_udp[i] = kobject_create_and_add("udp",  kobj_eth_ports[i]);
+		if (!kobj_udp[i])
+			return -ENOMEM;
+		ret = sysfs_create_group(kobj_udp[i], &attr_group);
+		if (ret)
+			kobject_put(kobj_udp[i]);
+	}
 	return ret;
 }
 
@@ -188,5 +174,8 @@ int xroe_sysfs_udp_init(void)
  */
 void xroe_sysfs_udp_exit(void)
 {
-	kobject_put(kobj_udp);
+	int i;
+
+	for (i = 0; i < MAX_NUM_ETH_PORTS; i++)
+		kobject_put(kobj_udp[i]);
 }
diff --git a/drivers/staging/xroeframer/xroe_framer.h b/drivers/staging/xroeframer/xroe_framer.h
index 45dac0c682ca..8d1c2da1ea35 100644
--- a/drivers/staging/xroeframer/xroe_framer.h
+++ b/drivers/staging/xroeframer/xroe_framer.h
@@ -32,6 +32,10 @@
 #define STATS_SIZE 0x00000050
 #define RADIO_CTRL_BASE 0xA0060000
 #define RADIO_CTRL_SIZE 0x0000FFFF
+/* TODO: Remove hardcoded value of number of Ethernet ports and read the value
+ * from the device tree.
+ */
+#define MAX_NUM_ETH_PORTS 0x4
 /* TODO: to be made static as well, so that multiple instances can be used. As
  * of now, the following 3 structures are shared among the multiple
  * source files
@@ -39,6 +43,7 @@
 extern struct framer_local *lp;
 extern struct kobject *root_xroe_kobj;
 extern struct kobject *kobj_framer;
+extern struct kobject *kobj_eth_ports[MAX_NUM_ETH_PORTS];
 struct framer_local {
 	int irq;
 	unsigned long mem_start;
@@ -62,3 +67,7 @@ void xroe_sysfs_udp_exit(void);
 int utils_write32withmask(void __iomem *working_address, u32 value,
 			  u32 mask, u32 offset);
 int utils_check_address_offset(u32 offset, size_t device_size);
+void utils_sysfs_store_wrapper(u32 address, u32 offset, u32 mask, u32 value,
+			       struct kobject *kobj);
+u32 utils_sysfs_show_wrapper(u32 address, u32 offset, u32 mask,
+			     struct kobject *kobj);
-- 
2.31.1

