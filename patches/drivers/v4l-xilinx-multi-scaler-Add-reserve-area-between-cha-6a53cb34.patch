From fccf1918b965e1fb04f248104a0630ee832df208 Mon Sep 17 00:00:00 2001
From: Suresh Gupta <suresh.gupta@xilinx.com>
Date: Fri, 5 Oct 2018 19:48:08 +0530
Subject: [PATCH 0461/1851] v4l: xilinx-multi-scaler: Add reserve area between
 channel 4 and 5

commit a3a263eeb0cca6ea893441a330a3f0d8eb64dc70 from
https://github.com/Xilinx/linux-xlnx.git

There is reserve area between XM2MSC_DSTIMGBUF0 and XM2MSC_DSTIMGBUF1
of channel 4 due to which the offset for XM2MSC_DSTIMGBUF1 channel 4
is 0x01000 instead of 0x0A00.

Also, this shift the base offset of channels 5 and onward.
So, the effective base offsets for channels are:
Channel 0: 0x100,
Channel 1: 0x300,
Channel 2: 0x500,
Channel 3: 0x700,
Channel 4: 0x900,
Channel 5: 0x1100, <-- Should be 0xb00
Channel 6: 0x1300,
Channel 7: 0x1500;

This patch fixes this problem by increment the offset of channel 5, 6,
and 7 by reserved value. And increments the XM2MSC_DSTIMGBUF1
of channel 4 by reserved value.

This is temporary fix and can be taken care in next version of IP.

Signed-off-by: Suresh Gupta <suresh.gupta@xilinx.com>
Reviewed-by: Vishal Sagar <vishal.sagar@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
State: pending
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 .../platform/xilinx/xilinx-multi-scaler.c     | 40 ++++++++++++++++---
 1 file changed, 34 insertions(+), 6 deletions(-)

diff --git a/drivers/media/platform/xilinx/xilinx-multi-scaler.c b/drivers/media/platform/xilinx/xilinx-multi-scaler.c
index 1b4603c2b2b5..45cf6f822ee7 100644
--- a/drivers/media/platform/xilinx/xilinx-multi-scaler.c
+++ b/drivers/media/platform/xilinx/xilinx-multi-scaler.c
@@ -73,6 +73,12 @@
 
 #define XM2MSC_CHAN_REGS_START(x)	(0x100 + 0x200 * x)
 
+/*
+ * IP has reserved area between XM2MSC_DSTIMGBUF0 and
+ * XM2MSC_DSTIMGBUF1 registers of channel 4
+ */
+#define XM2MSC_RESERVED_AREA		0x600
+
 /* GPIO RESET MACROS */
 #define XM2MSC_RESET_ASSERT	(0x1)
 #define XM2MSC_RESET_DEASSERT	(0x0)
@@ -653,8 +659,10 @@ xm2msc_pr_screg(struct device *dev, const volatile void __iomem *base)
 }
 
 static void
-xm2msc_pr_chanreg(struct device *dev, const volatile void __iomem *base)
+xm2msc_pr_chanreg(struct device *dev, struct xm2msc_chan_ctx *chan)
 {
+	const void __iomem *base = chan->regs;
+
 	dev_dbg(dev, "WIN HIN INPIXELFMT INSTRIDE SRCB0L/H SRCB1L/H\n");
 	dev_dbg(dev, "%d   %d     %d       %d      0x%x/0x%x      0x%x/0x%x\n",
 		xm2msc_readreg(base + XM2MSC_WIDTHIN),
@@ -673,8 +681,14 @@ xm2msc_pr_chanreg(struct device *dev, const volatile void __iomem *base)
 		xm2msc_readreg(base + XM2MSC_OUTSTRIDE),
 		xm2msc_readreg(base + XM2MSC_DSTIMGBUF0),
 		xm2msc_readreg(base + XM2MSC_DSTIMGBUF0 + 4),
-		xm2msc_readreg(base + XM2MSC_DSTIMGBUF1),
-		xm2msc_readreg(base + XM2MSC_DSTIMGBUF1 + 4));
+		chan->num == 4 ?
+		xm2msc_readreg(base +
+			       XM2MSC_DSTIMGBUF1 + XM2MSC_RESERVED_AREA) :
+			xm2msc_readreg(base + XM2MSC_DSTIMGBUF1),
+		chan->num == 4 ?
+		xm2msc_readreg(base +
+			       XM2MSC_DSTIMGBUF1 + XM2MSC_RESERVED_AREA + 4) :
+			xm2msc_readreg(base + XM2MSC_DSTIMGBUF1 + 4));
 
 	dev_dbg(dev, "LINERATE PIXELRATE\n");
 	dev_dbg(dev, "0x%x     0x%x\n",
@@ -695,7 +709,7 @@ xm2msc_pr_allchanreg(struct xm2m_msc_dev *xm2msc)
 		chan_ctx = &xm2msc->xm2msc_chan[i];
 		dev_dbg(dev, "Regs val for channel %d\n", i);
 		dev_dbg(dev, "______________________________________________\n");
-		xm2msc_pr_chanreg(dev, chan_ctx->regs);
+		xm2msc_pr_chanreg(dev, chan_ctx);
 		dev_dbg(dev, "processed frames = %lu\n", chan_ctx->frames);
 		dev_dbg(dev, "______________________________________________\n");
 	}
@@ -909,12 +923,24 @@ static int xm2msc_set_bufaddr(struct xm2m_msc_dev *xm2msc)
 			xm2msc_write64reg(base + XM2MSC_SRCIMGBUF0, src_luma);
 			xm2msc_write64reg(base + XM2MSC_SRCIMGBUF1, src_croma);
 			xm2msc_write64reg(base + XM2MSC_DSTIMGBUF0, dst_luma);
-			xm2msc_write64reg(base + XM2MSC_DSTIMGBUF1, dst_croma);
+			if (chan_ctx->num == 4) /* TODO: To be fixed in HW */
+				xm2msc_write64reg(base + XM2MSC_DSTIMGBUF1 +
+						  XM2MSC_RESERVED_AREA,
+						  dst_croma);
+			else
+				xm2msc_write64reg(base + XM2MSC_DSTIMGBUF1,
+						  dst_croma);
 		} else {
 			xm2msc_writereg(base + XM2MSC_SRCIMGBUF0, src_luma);
 			xm2msc_writereg(base + XM2MSC_SRCIMGBUF1, src_croma);
 			xm2msc_writereg(base + XM2MSC_DSTIMGBUF0, dst_luma);
-			xm2msc_writereg(base + XM2MSC_DSTIMGBUF1, dst_croma);
+			if (chan_ctx->num == 4) /* TODO: To be fixed in HW */
+				xm2msc_writereg(base + XM2MSC_DSTIMGBUF1 +
+						XM2MSC_RESERVED_AREA,
+						dst_croma);
+			else
+				xm2msc_writereg(base + XM2MSC_DSTIMGBUF1,
+						dst_croma);
 		}
 	}
 	return 0;
@@ -1938,6 +1964,8 @@ static int xm2m_msc_probe(struct platform_device *pdev)
 		}
 		chan_ctx->xm2msc_dev = xm2msc;
 		chan_ctx->regs = xm2msc->regs + XM2MSC_CHAN_REGS_START(chan);
+		if (chan > 4) /* TODO: To be fixed in HW */
+			chan_ctx->regs += XM2MSC_RESERVED_AREA;
 		chan_ctx->num = chan;
 		chan_ctx->minor = vfd->minor;
 		xm2msc_pr_chanctx(chan_ctx, __func__);
-- 
2.31.1

