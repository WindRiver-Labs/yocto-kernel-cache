From ba2f0e894fcd29d349b86541e69cb47968d33e3f Mon Sep 17 00:00:00 2001
From: Amit Kumar Mahapatra <amit.kumar-mahapatra@xilinx.com>
Date: Sun, 19 Jan 2020 10:58:21 -0700
Subject: [PATCH 0872/1852] spi: Add Zynq QSPI controller driver

commit 3780469dd372e934445de2fbb5e8cf6e712b9b99 from
https://github.com/Xilinx/linux-xlnx.git

 - Upstreamed Zynq QSPI controller driver is under spi-mem framework,
   updated the driver to register under spi-master framework.
 - Added SPI_ZYNQ_QSPI_DUAL_STACKED config flag, This selects the
   Zynq QSPI controller in dual stacked mode.
 - Added stripe flag to distinguish between command and data,
   in dual parallel mode.

Signed-off-by: Amit Kumar Mahapatra <amit.kumar-mahapatra@xilinx.com>
Signed-off-by: Naga Sureshkumar Relli <naga.sureshkumar.relli@xilinx.com>
Signed-off-by: Harini Katakam <harinik@xilinx.com>
Signed-off-by: Punnaiah Choudary Kalluri <punnaia@xilinx.com>
Signed-off-by: Soren Brinkmann <soren.brinkmann@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
State: pending
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 drivers/spi/Kconfig         |  10 +-
 drivers/spi/spi-mem.c       |  21 ++
 drivers/spi/spi-zynq-qspi.c | 407 ++++++++++++++++++++++--------------
 include/linux/spi/spi.h     |  11 +
 4 files changed, 296 insertions(+), 153 deletions(-)

diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 30a40280c157..41638b8fee13 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -852,10 +852,18 @@ config SPI_XTENSA_XTFPGA
 config SPI_ZYNQ_QSPI
 	tristate "Xilinx Zynq QSPI controller"
 	depends on ARCH_ZYNQ || COMPILE_TEST
+	depends on SPI_MASTER
 	help
 	  This enables support for the Zynq Quad SPI controller
 	  in master mode.
-	  This controller only supports SPI memory interface.
+
+config SPI_ZYNQ_QSPI_DUAL_STACKED
+	bool "Xilinx Zynq QSPI Dual stacked configuration"
+	depends on SPI_ZYNQ_QSPI
+	help
+	  This selects the Xilinx ZYNQ Quad SPI controller in dual stacked mode.
+	  Enable this option if your hw design is using dual stacked
+	  configuration.
 
 config SPI_ZYNQMP_GQSPI
 	tristate "Xilinx ZynqMP GQSPI controller"
diff --git a/drivers/spi/spi-mem.c b/drivers/spi/spi-mem.c
index de0ba3e5449f..83f5d722120f 100644
--- a/drivers/spi/spi-mem.c
+++ b/drivers/spi/spi-mem.c
@@ -7,6 +7,7 @@
  */
 #include <linux/dmaengine.h>
 #include <linux/pm_runtime.h>
+#include <linux/mtd/spi-nor.h>
 #include <linux/spi/spi.h>
 #include <linux/spi/spi-mem.h>
 
@@ -14,6 +15,24 @@
 
 #define SPI_MEM_MAX_BUSWIDTH		8
 
+bool update_stripe(const u8 opcode)
+{
+	if (opcode ==  SPINOR_OP_BE_4K ||
+	    opcode ==  SPINOR_OP_BE_32K ||
+	    opcode ==  SPINOR_OP_CHIP_ERASE ||
+	    opcode ==  SPINOR_OP_SE ||
+	    opcode ==  SPINOR_OP_BE_32K_4B ||
+	    opcode ==  SPINOR_OP_SE_4B ||
+	    opcode == SPINOR_OP_BE_4K_4B ||
+	    opcode ==  SPINOR_OP_WRSR ||
+	    opcode ==  SPINOR_OP_WREAR ||
+	    opcode ==  SPINOR_OP_BRWR ||
+	    opcode ==  SPINOR_OP_WRSR2)
+		return false;
+
+	return true;
+}
+
 /**
  * spi_controller_dma_map_mem_op_data() - DMA-map the buffer attached to a
  *					  memory operation
@@ -348,6 +367,7 @@ int spi_mem_exec_op(struct spi_mem *mem, const struct spi_mem_op *op)
 		xfers[xferpos].tx_buf = tmpbuf + op->addr.nbytes + 1;
 		xfers[xferpos].len = op->dummy.nbytes;
 		xfers[xferpos].tx_nbits = op->dummy.buswidth;
+		xfers[xferpos].dummy = op->dummy.nbytes * 8;
 		spi_message_add_tail(&xfers[xferpos], &msg);
 		xferpos++;
 		totalxferlen += op->dummy.nbytes;
@@ -362,6 +382,7 @@ int spi_mem_exec_op(struct spi_mem *mem, const struct spi_mem_op *op)
 			xfers[xferpos].tx_nbits = op->data.buswidth;
 		}
 
+		xfers[xferpos].stripe = update_stripe(op->cmd.opcode);
 		xfers[xferpos].len = op->data.nbytes;
 		spi_message_add_tail(&xfers[xferpos], &msg);
 		xferpos++;
diff --git a/drivers/spi/spi-zynq-qspi.c b/drivers/spi/spi-zynq-qspi.c
index 5cf6993ddce5..9d70cd2862f6 100644
--- a/drivers/spi/spi-zynq-qspi.c
+++ b/drivers/spi/spi-zynq-qspi.c
@@ -16,7 +16,7 @@
 #include <linux/platform_device.h>
 #include <linux/spi/spi.h>
 #include <linux/workqueue.h>
-#include <linux/spi/spi-mem.h>
+
 
 /* Register offset definitions */
 #define ZYNQ_QSPI_CONFIG_OFFSET		0x00 /* Configuration  Register, RW */
@@ -129,19 +129,21 @@
  * @rxbuf:		Pointer to the RX buffer
  * @tx_bytes:		Number of bytes left to transfer
  * @rx_bytes:		Number of bytes left to receive
- * @data_completion:	completion structure
+ * @is_dual:		Flag to indicate whether dual flash memories are used
+ * @is_instr:		Flag to indicate if transfer contains an instruction
+ *			(Used in dual parallel configuration)
  */
 struct zynq_qspi {
-	struct device *dev;
 	void __iomem *regs;
 	struct clk *refclk;
 	struct clk *pclk;
 	int irq;
-	u8 *txbuf;
-	u8 *rxbuf;
+	const void *txbuf;
+	void *rxbuf;
 	int tx_bytes;
 	int rx_bytes;
-	struct completion data_completion;
+	u32 is_dual;
+	u8 is_instr;
 };
 
 /*
@@ -213,38 +215,45 @@ static void zynq_qspi_init_hw(struct zynq_qspi *xqspi)
 	zynq_qspi_write(xqspi, ZYNQ_QSPI_TX_THRESH_OFFSET,
 			ZYNQ_QSPI_TX_THRESHOLD);
 
+	if (xqspi->is_dual)
+		/* Enable two memories on separate buses */
+		zynq_qspi_write(xqspi, ZYNQ_QSPI_LINEAR_CFG_OFFSET,
+				(ZYNQ_QSPI_LCFG_TWO_MEM_MASK |
+				ZYNQ_QSPI_LCFG_SEP_BUS_MASK |
+				(1 << ZYNQ_QSPI_LCFG_DUMMY_SHIFT) |
+				ZYNQ_QSPI_FAST_READ_QOUT_CODE));
+#ifdef CONFIG_SPI_ZYNQ_QSPI_DUAL_STACKED
+	/* Enable two memories on shared bus */
+	zynq_qspi_write(xqspi, ZYNQ_QSPI_LINEAR_CFG_OFFSET,
+			(ZYNQ_QSPI_LCFG_TWO_MEM_MASK |
+			(1 << ZYNQ_QSPI_LCFG_DUMMY_SHIFT) |
+			ZYNQ_QSPI_FAST_READ_QOUT_CODE));
+#endif
 	zynq_qspi_write(xqspi, ZYNQ_QSPI_ENABLE_OFFSET,
 			ZYNQ_QSPI_ENABLE_ENABLE_MASK);
 }
 
-static bool zynq_qspi_supports_op(struct spi_mem *mem,
-				  const struct spi_mem_op *op)
-{
-	if (!spi_mem_default_supports_op(mem, op))
-		return false;
-
-	/*
-	 * The number of address bytes should be equal to or less than 3 bytes.
-	 */
-	if (op->addr.nbytes > 3)
-		return false;
-
-	return true;
-}
-
 /**
  * zynq_qspi_rxfifo_op - Read 1..4 bytes from RxFIFO to RX buffer
  * @xqspi:	Pointer to the zynq_qspi structure
  * @size:	Number of bytes to be read (1..4)
+ *
+ * Note: In case of dual parallel connection, even number of bytes are read
+ * when odd bytes are requested to avoid transfer of a nibble to each flash.
+ * The receive buffer though, is populated with the number of bytes requested.
  */
 static void zynq_qspi_rxfifo_op(struct zynq_qspi *xqspi, unsigned int size)
 {
+	unsigned int xsize;
 	u32 data;
 
 	data = zynq_qspi_read(xqspi, ZYNQ_QSPI_RXD_OFFSET);
 
 	if (xqspi->rxbuf) {
-		memcpy(xqspi->rxbuf, ((u8 *)&data) + 4 - size, size);
+		xsize = size;
+		if (xqspi->is_dual && !xqspi->is_instr && (size % 2))
+			xsize++;
+		memcpy(xqspi->rxbuf, ((u8 *)&data) + 4 - xsize, size);
 		xqspi->rxbuf += size;
 	}
 
@@ -257,12 +266,19 @@ static void zynq_qspi_rxfifo_op(struct zynq_qspi *xqspi, unsigned int size)
  * zynq_qspi_txfifo_op - Write 1..4 bytes from TX buffer to TxFIFO
  * @xqspi:	Pointer to the zynq_qspi structure
  * @size:	Number of bytes to be written (1..4)
+ *
+ * In dual parallel configuration, when read/write data operations
+ * are performed, odd data bytes have to be converted to even to
+ * avoid a nibble (of data when programming / dummy when reading)
+ * going to individual flash devices, where a byte is expected.
+ * This check is only for data and will not apply for commands.
  */
 static void zynq_qspi_txfifo_op(struct zynq_qspi *xqspi, unsigned int size)
 {
 	static const unsigned int offset[4] = {
 		ZYNQ_QSPI_TXD_00_01_OFFSET, ZYNQ_QSPI_TXD_00_10_OFFSET,
 		ZYNQ_QSPI_TXD_00_11_OFFSET, ZYNQ_QSPI_TXD_00_00_OFFSET };
+	unsigned int xsize;
 	u32 data;
 
 	if (xqspi->txbuf) {
@@ -274,29 +290,96 @@ static void zynq_qspi_txfifo_op(struct zynq_qspi *xqspi, unsigned int size)
 	}
 
 	xqspi->tx_bytes -= size;
-	zynq_qspi_write(xqspi, offset[size - 1], data);
+	xsize = size;
+	if (xqspi->is_dual && !xqspi->is_instr && (size % 2))
+		xsize++;
+	zynq_qspi_write(xqspi, offset[xsize - 1], data);
+}
+
+/**
+ * zynq_prepare_transfer_hardware - Prepares hardware for transfer.
+ * @master:	Pointer to the spi_master structure which provides
+ *		information about the controller.
+ *
+ * This function enables SPI master controller.
+ *
+ * Return:	Always 0
+ */
+static int zynq_prepare_transfer_hardware(struct spi_master *master)
+{
+	struct zynq_qspi *xqspi = spi_master_get_devdata(master);
+
+	clk_enable(xqspi->refclk);
+	clk_enable(xqspi->pclk);
+	zynq_qspi_write(xqspi, ZYNQ_QSPI_ENABLE_OFFSET,
+			ZYNQ_QSPI_ENABLE_ENABLE_MASK);
+
+	return 0;
+}
+
+/**
+ * zynq_unprepare_transfer_hardware - Relaxes hardware after transfer
+ * @master:	Pointer to the spi_master structure which provides
+ *		information about the controller.
+ *
+ * This function disables the SPI master controller.
+ *
+ * Return:	Always 0
+ */
+static int zynq_unprepare_transfer_hardware(struct spi_master *master)
+{
+	struct zynq_qspi *xqspi = spi_master_get_devdata(master);
+
+	zynq_qspi_write(xqspi, ZYNQ_QSPI_ENABLE_OFFSET, 0);
+	clk_disable(xqspi->refclk);
+	clk_disable(xqspi->pclk);
+
+	return 0;
 }
 
 /**
  * zynq_qspi_chipselect - Select or deselect the chip select line
  * @spi:	Pointer to the spi_device structure
- * @assert:	1 for select or 0 for deselect the chip select line
+ * @is_high:	Select(0) or deselect (1) the chip select line
  */
-static void zynq_qspi_chipselect(struct spi_device *spi, bool assert)
+static void zynq_qspi_chipselect(struct spi_device *spi, bool is_high)
 {
-	struct spi_controller *ctrl = spi->master;
-	struct zynq_qspi *xqspi = spi_controller_get_devdata(ctrl);
+	struct zynq_qspi *xqspi = spi_master_get_devdata(spi->master);
 	u32 config_reg;
+#ifdef CONFIG_SPI_ZYNQ_QSPI_DUAL_STACKED
+	u32 lqspi_cfg_reg;
+#endif
 
 	config_reg = zynq_qspi_read(xqspi, ZYNQ_QSPI_CONFIG_OFFSET);
-	if (assert) {
+
+	/* Select upper/lower page before asserting CS */
+#ifdef CONFIG_SPI_ZYNQ_QSPI_DUAL_STACKED
+		lqspi_cfg_reg = zynq_qspi_read(xqspi,
+					       ZYNQ_QSPI_LINEAR_CFG_OFFSET);
+		if (spi->master->flags & SPI_MASTER_U_PAGE)
+			lqspi_cfg_reg |= ZYNQ_QSPI_LCFG_U_PAGE_MASK;
+		else
+			lqspi_cfg_reg &= ~ZYNQ_QSPI_LCFG_U_PAGE_MASK;
+		zynq_qspi_write(xqspi, ZYNQ_QSPI_LINEAR_CFG_OFFSET,
+				lqspi_cfg_reg);
+#endif
+
+	if (is_high) {
+		/* Deselect the slave */
+		config_reg |= ZYNQ_QSPI_CONFIG_SSCTRL_MASK;
+	} else {
 		/* Select the slave */
 		config_reg &= ~ZYNQ_QSPI_CONFIG_SSCTRL_MASK;
-		config_reg |= (((~(BIT(spi->chip_select))) <<
-				ZYNQ_QSPI_SS_SHIFT) &
-				ZYNQ_QSPI_CONFIG_SSCTRL_MASK);
-	} else {
-		config_reg |= ZYNQ_QSPI_CONFIG_SSCTRL_MASK;
+		if (gpio_is_valid(spi->cs_gpio)) {
+			config_reg |= (((~(BIT(0))) <<
+					ZYNQ_QSPI_SS_SHIFT) &
+					ZYNQ_QSPI_CONFIG_SSCTRL_MASK);
+		} else {
+			config_reg |= (((~(BIT(spi->chip_select))) <<
+					ZYNQ_QSPI_SS_SHIFT) &
+					ZYNQ_QSPI_CONFIG_SSCTRL_MASK);
+		}
+		xqspi->is_instr = 1;
 	}
 
 	zynq_qspi_write(xqspi, ZYNQ_QSPI_CONFIG_OFFSET, config_reg);
@@ -304,8 +387,9 @@ static void zynq_qspi_chipselect(struct spi_device *spi, bool assert)
 
 /**
  * zynq_qspi_config_op - Configure QSPI controller for specified transfer
- * @xqspi:	Pointer to the zynq_qspi structure
  * @qspi:	Pointer to the spi_device structure
+ * @transfer:	Pointer to the spi_transfer structure which provides information
+ *		about next transfer setup parameters
  *
  * Sets the operational mode of QSPI controller for the next QSPI transfer and
  * sets the requested clock frequency.
@@ -319,9 +403,16 @@ static void zynq_qspi_chipselect(struct spi_device *spi, bool assert)
  * controller the driver will set the highest or lowest frequency supported by
  * controller.
  */
-static int zynq_qspi_config_op(struct zynq_qspi *xqspi, struct spi_device *spi)
+static int zynq_qspi_config_op(struct spi_device *spi,
+			       struct spi_transfer *transfer)
 {
-	u32 config_reg, baud_rate_val = 0;
+	struct zynq_qspi *xqspi = spi_master_get_devdata(spi->master);
+	u32 config_reg, req_hz, baud_rate_val = 0;
+
+	if (transfer)
+		req_hz = transfer->speed_hz;
+	else
+		req_hz = spi->max_speed_hz;
 
 	/*
 	 * Set the clock frequency
@@ -333,8 +424,7 @@ static int zynq_qspi_config_op(struct zynq_qspi *xqspi, struct spi_device *spi)
 	 *      111 - divide by 256
 	 */
 	while ((baud_rate_val < ZYNQ_QSPI_BAUD_DIV_MAX)  &&
-	       (clk_get_rate(xqspi->refclk) / (2 << baud_rate_val)) >
-		spi->max_speed_hz)
+	       (clk_get_rate(xqspi->refclk) / (2 << baud_rate_val)) > req_hz)
 		baud_rate_val++;
 
 	config_reg = zynq_qspi_read(xqspi, ZYNQ_QSPI_CONFIG_OFFSET);
@@ -365,18 +455,24 @@ static int zynq_qspi_config_op(struct zynq_qspi *xqspi, struct spi_device *spi)
  */
 static int zynq_qspi_setup_op(struct spi_device *spi)
 {
-	struct spi_controller *ctrl = spi->master;
-	struct zynq_qspi *qspi = spi_controller_get_devdata(ctrl);
+	struct device *dev = &spi->master->dev;
+	int ret;
+
+	if (gpio_is_valid(spi->cs_gpio)) {
+		ret = devm_gpio_request(dev, spi->cs_gpio, dev_name(dev));
+		if (ret) {
+			dev_err(dev, "Invalid cs_gpio\n");
+			return ret;
+		}
 
-	if (ctrl->busy)
-		return -EBUSY;
+		gpio_direction_output(spi->cs_gpio,
+				      !(spi->mode & SPI_CS_HIGH));
+	}
 
-	clk_enable(qspi->refclk);
-	clk_enable(qspi->pclk);
-	zynq_qspi_write(qspi, ZYNQ_QSPI_ENABLE_OFFSET,
-			ZYNQ_QSPI_ENABLE_ENABLE_MASK);
+	if (spi->master->busy)
+		return -EBUSY;
 
-	return 0;
+	return zynq_qspi_config_op(spi, NULL);
 }
 
 /**
@@ -460,9 +556,10 @@ static void zynq_qspi_read_op(struct zynq_qspi *xqspi, int rxcount)
  */
 static irqreturn_t zynq_qspi_irq(int irq, void *dev_id)
 {
+	struct spi_master *master = dev_id;
+	struct zynq_qspi *xqspi = spi_master_get_devdata(master);
 	u32 intr_status;
 	bool txempty;
-	struct zynq_qspi *xqspi = (struct zynq_qspi *)dev_id;
 
 	intr_status = zynq_qspi_read(xqspi, ZYNQ_QSPI_STATUS_OFFSET);
 	zynq_qspi_write(xqspi, ZYNQ_QSPI_STATUS_OFFSET, intr_status);
@@ -490,7 +587,8 @@ static irqreturn_t zynq_qspi_irq(int irq, void *dev_id)
 				zynq_qspi_write(xqspi,
 						ZYNQ_QSPI_IDIS_OFFSET,
 						ZYNQ_QSPI_IXR_RXTX_MASK);
-				complete(&xqspi->data_completion);
+				spi_finalize_current_transfer(master);
+				xqspi->is_instr = 0;
 			}
 		}
 		return IRQ_HANDLED;
@@ -500,110 +598,100 @@ static irqreturn_t zynq_qspi_irq(int irq, void *dev_id)
 }
 
 /**
- * zynq_qspi_exec_mem_op() - Initiates the QSPI transfer
- * @mem: the SPI memory
- * @op: the memory operation to execute
+ * zynq_qspi_start_transfer - Initiates the QSPI transfer
+ * @master:	Pointer to the spi_master structure which provides
+ *		information about the controller.
+ * @qspi:	Pointer to the spi_device structure
+ * @transfer:	Pointer to the spi_transfer structure which provide information
+ *		about next transfer parameters
+ *
+ * This function fills the TX FIFO, starts the QSPI transfer, and waits for the
+ * transfer to be completed.
  *
- * Executes a memory operation.
+ * Return:	Number of bytes transferred in the last transfer
+ */
+static int zynq_qspi_start_transfer(struct spi_master *master,
+				    struct spi_device *qspi,
+				    struct spi_transfer *transfer)
+{
+	struct zynq_qspi *xqspi = spi_master_get_devdata(master);
+
+	xqspi->txbuf = transfer->tx_buf;
+	xqspi->rxbuf = transfer->rx_buf;
+	xqspi->tx_bytes = transfer->len;
+	xqspi->rx_bytes = transfer->len;
+
+	if (!transfer->stripe)
+		xqspi->is_instr = true;
+	else
+		xqspi->is_instr = false;
+	zynq_qspi_config_op(qspi, transfer);
+
+	zynq_qspi_write_op(xqspi, ZYNQ_QSPI_FIFO_DEPTH, true);
+
+	zynq_qspi_write(xqspi, ZYNQ_QSPI_IEN_OFFSET,
+			ZYNQ_QSPI_IXR_RXTX_MASK);
+
+	return transfer->len;
+}
+
+/**
+ * zynq_qspi_suspend - Suspend method for the QSPI driver
+ * @_dev:	Address of the platform_device structure
  *
- * This function first selects the chip and starts the memory operation.
+ * This function stops the QSPI driver queue and disables the QSPI controller
  *
- * Return: 0 in case of success, a negative error code otherwise.
+ * Return:	Always 0
  */
-static int zynq_qspi_exec_mem_op(struct spi_mem *mem,
-				 const struct spi_mem_op *op)
+static int __maybe_unused zynq_qspi_suspend(struct device *_dev)
 {
-	struct zynq_qspi *xqspi = spi_controller_get_devdata(mem->spi->master);
-	int err = 0, i;
-	u8 *tmpbuf;
-
-	dev_dbg(xqspi->dev, "cmd:%#x mode:%d.%d.%d.%d\n",
-		op->cmd.opcode, op->cmd.buswidth, op->addr.buswidth,
-		op->dummy.buswidth, op->data.buswidth);
-
-	zynq_qspi_chipselect(mem->spi, true);
-	zynq_qspi_config_op(xqspi, mem->spi);
-
-	if (op->cmd.opcode) {
-		reinit_completion(&xqspi->data_completion);
-		xqspi->txbuf = (u8 *)&op->cmd.opcode;
-		xqspi->rxbuf = NULL;
-		xqspi->tx_bytes = sizeof(op->cmd.opcode);
-		xqspi->rx_bytes = sizeof(op->cmd.opcode);
-		zynq_qspi_write_op(xqspi, ZYNQ_QSPI_FIFO_DEPTH, true);
-		zynq_qspi_write(xqspi, ZYNQ_QSPI_IEN_OFFSET,
-				ZYNQ_QSPI_IXR_RXTX_MASK);
-		if (!wait_for_completion_interruptible_timeout(&xqspi->data_completion,
-							       msecs_to_jiffies(1000)))
-			err = -ETIMEDOUT;
-	}
+	struct platform_device *pdev = container_of(_dev,
+			struct platform_device, dev);
+	struct spi_master *master = platform_get_drvdata(pdev);
 
-	if (op->addr.nbytes) {
-		for (i = 0; i < op->addr.nbytes; i++) {
-			xqspi->txbuf[i] = op->addr.val >>
-					(8 * (op->addr.nbytes - i - 1));
-		}
+	spi_master_suspend(master);
 
-		reinit_completion(&xqspi->data_completion);
-		xqspi->rxbuf = NULL;
-		xqspi->tx_bytes = op->addr.nbytes;
-		xqspi->rx_bytes = op->addr.nbytes;
-		zynq_qspi_write_op(xqspi, ZYNQ_QSPI_FIFO_DEPTH, true);
-		zynq_qspi_write(xqspi, ZYNQ_QSPI_IEN_OFFSET,
-				ZYNQ_QSPI_IXR_RXTX_MASK);
-		if (!wait_for_completion_interruptible_timeout(&xqspi->data_completion,
-							       msecs_to_jiffies(1000)))
-			err = -ETIMEDOUT;
-	}
+	zynq_unprepare_transfer_hardware(master);
 
-	if (op->dummy.nbytes) {
-		tmpbuf = kzalloc(op->dummy.nbytes, GFP_KERNEL);
-		memset(tmpbuf, 0xff, op->dummy.nbytes);
-		reinit_completion(&xqspi->data_completion);
-		xqspi->txbuf = tmpbuf;
-		xqspi->rxbuf = NULL;
-		xqspi->tx_bytes = op->dummy.nbytes;
-		xqspi->rx_bytes = op->dummy.nbytes;
-		zynq_qspi_write_op(xqspi, ZYNQ_QSPI_FIFO_DEPTH, true);
-		zynq_qspi_write(xqspi, ZYNQ_QSPI_IEN_OFFSET,
-				ZYNQ_QSPI_IXR_RXTX_MASK);
-		if (!wait_for_completion_interruptible_timeout(&xqspi->data_completion,
-							       msecs_to_jiffies(1000)))
-			err = -ETIMEDOUT;
-
-		kfree(tmpbuf);
-	}
+	return 0;
+}
 
-	if (op->data.nbytes) {
-		reinit_completion(&xqspi->data_completion);
-		if (op->data.dir == SPI_MEM_DATA_OUT) {
-			xqspi->txbuf = (u8 *)op->data.buf.out;
-			xqspi->tx_bytes = op->data.nbytes;
-			xqspi->rxbuf = NULL;
-			xqspi->rx_bytes = op->data.nbytes;
-		} else {
-			xqspi->txbuf = NULL;
-			xqspi->rxbuf = (u8 *)op->data.buf.in;
-			xqspi->rx_bytes = op->data.nbytes;
-			xqspi->tx_bytes = op->data.nbytes;
-		}
+/**
+ * zynq_qspi_resume - Resume method for the QSPI driver
+ * @dev:	Address of the platform_device structure
+ *
+ * The function starts the QSPI driver queue and initializes the QSPI controller
+ *
+ * Return:	0 on success and error value on error
+ */
+static int __maybe_unused zynq_qspi_resume(struct device *dev)
+{
+	struct platform_device *pdev = container_of(dev,
+			struct platform_device, dev);
+	struct spi_master *master = platform_get_drvdata(pdev);
+	struct zynq_qspi *xqspi = spi_master_get_devdata(master);
+	int ret = 0;
+
+	ret = clk_enable(xqspi->pclk);
+	if (ret) {
+		dev_err(dev, "Cannot enable APB clock.\n");
+		return ret;
+	}
 
-		zynq_qspi_write_op(xqspi, ZYNQ_QSPI_FIFO_DEPTH, true);
-		zynq_qspi_write(xqspi, ZYNQ_QSPI_IEN_OFFSET,
-				ZYNQ_QSPI_IXR_RXTX_MASK);
-		if (!wait_for_completion_interruptible_timeout(&xqspi->data_completion,
-							       msecs_to_jiffies(1000)))
-			err = -ETIMEDOUT;
+	ret = clk_enable(xqspi->refclk);
+	if (ret) {
+		dev_err(dev, "Cannot enable device clock.\n");
+		clk_disable(xqspi->pclk);
+		return ret;
 	}
-	zynq_qspi_chipselect(mem->spi, false);
 
-	return err;
+	spi_master_resume(master);
+
+	return 0;
 }
 
-static const struct spi_controller_mem_ops zynq_qspi_mem_ops = {
-	.supports_op = zynq_qspi_supports_op,
-	.exec_op = zynq_qspi_exec_mem_op,
-};
+static SIMPLE_DEV_PM_OPS(zynq_qspi_dev_pm_ops, zynq_qspi_suspend,
+			 zynq_qspi_resume);
 
 /**
  * zynq_qspi_probe - Probe method for the QSPI driver
@@ -617,9 +705,8 @@ static int zynq_qspi_probe(struct platform_device *pdev)
 {
 	int ret = 0;
 	struct spi_controller *ctlr;
-	struct device *dev = &pdev->dev;
-	struct device_node *np = dev->of_node;
 	struct zynq_qspi *xqspi;
+	struct resource *res;
 	u32 num_cs;
 
 	ctlr = spi_alloc_master(&pdev->dev, sizeof(*xqspi));
@@ -627,14 +714,21 @@ static int zynq_qspi_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	xqspi = spi_controller_get_devdata(ctlr);
-	xqspi->dev = dev;
-	platform_set_drvdata(pdev, xqspi);
-	xqspi->regs = devm_platform_ioremap_resource(pdev, 0);
+	ctlr->dev.of_node = pdev->dev.of_node;
+	platform_set_drvdata(pdev, ctlr);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	xqspi->regs = devm_ioremap_resource(&pdev->dev, res);
 	if (IS_ERR(xqspi->regs)) {
 		ret = PTR_ERR(xqspi->regs);
 		goto remove_master;
 	}
 
+	if (of_property_read_u32(pdev->dev.of_node, "is-dual",
+				 &xqspi->is_dual)) {
+		dev_warn(&pdev->dev, "couldn't determine configuration info");
+		dev_warn(&pdev->dev, "about dual memories. defaulting to single memory\n");
+	}
 	xqspi->pclk = devm_clk_get(&pdev->dev, "pclk");
 	if (IS_ERR(xqspi->pclk)) {
 		dev_err(&pdev->dev, "pclk clock not found.\n");
@@ -642,7 +736,6 @@ static int zynq_qspi_probe(struct platform_device *pdev)
 		goto remove_master;
 	}
 
-	init_completion(&xqspi->data_completion);
 
 	xqspi->refclk = devm_clk_get(&pdev->dev, "ref_clk");
 	if (IS_ERR(xqspi->refclk)) {
@@ -669,29 +762,36 @@ static int zynq_qspi_probe(struct platform_device *pdev)
 	xqspi->irq = platform_get_irq(pdev, 0);
 	if (xqspi->irq <= 0) {
 		ret = -ENXIO;
+		dev_err(&pdev->dev, "irq resource not found\n");
 		goto remove_master;
 	}
 	ret = devm_request_irq(&pdev->dev, xqspi->irq, zynq_qspi_irq,
-			       0, pdev->name, xqspi);
+			       0, pdev->name, ctlr);
 	if (ret != 0) {
 		ret = -ENXIO;
 		dev_err(&pdev->dev, "request_irq failed\n");
 		goto remove_master;
 	}
 
-	ret = of_property_read_u32(np, "num-cs",
+	ret = of_property_read_u32(pdev->dev.of_node, "num-cs",
 				   &num_cs);
 	if (ret < 0)
 		ctlr->num_chipselect = ZYNQ_QSPI_DEFAULT_NUM_CS;
 	else
 		ctlr->num_chipselect = num_cs;
 
-	ctlr->mode_bits =  SPI_RX_DUAL | SPI_RX_QUAD |
-			    SPI_TX_DUAL | SPI_TX_QUAD;
-	ctlr->mem_ops = &zynq_qspi_mem_ops;
 	ctlr->setup = zynq_qspi_setup_op;
+	ctlr->set_cs = zynq_qspi_chipselect;
+	ctlr->transfer_one = zynq_qspi_start_transfer;
+	ctlr->prepare_transfer_hardware = zynq_prepare_transfer_hardware;
+	ctlr->unprepare_transfer_hardware = zynq_unprepare_transfer_hardware;
+	ctlr->flags = SPI_MASTER_QUAD_MODE | SPI_MASTER_GPIO_SS;
+
 	ctlr->max_speed_hz = clk_get_rate(xqspi->refclk) / 2;
-	ctlr->dev.of_node = np;
+	ctlr->bits_per_word_mask = SPI_BPW_MASK(8);
+	ctlr->mode_bits = SPI_CPOL | SPI_CPHA | SPI_RX_DUAL | SPI_RX_QUAD |
+			    SPI_TX_DUAL | SPI_TX_QUAD;
+
 	ret = devm_spi_register_controller(&pdev->dev, ctlr);
 	if (ret) {
 		dev_err(&pdev->dev, "spi_register_master failed\n");
@@ -722,13 +822,15 @@ static int zynq_qspi_probe(struct platform_device *pdev)
  */
 static int zynq_qspi_remove(struct platform_device *pdev)
 {
-	struct zynq_qspi *xqspi = platform_get_drvdata(pdev);
+	struct spi_master *master = platform_get_drvdata(pdev);
+	struct zynq_qspi *xqspi = spi_master_get_devdata(master);
 
 	zynq_qspi_write(xqspi, ZYNQ_QSPI_ENABLE_OFFSET, 0);
 
 	clk_disable_unprepare(xqspi->refclk);
 	clk_disable_unprepare(xqspi->pclk);
 
+	spi_unregister_master(master);
 	return 0;
 }
 
@@ -748,6 +850,7 @@ static struct platform_driver zynq_qspi_driver = {
 	.driver = {
 		.name = "zynq-qspi",
 		.of_match_table = zynq_qspi_of_match,
+		.pm = &zynq_qspi_dev_pm_ops,
 	},
 };
 
diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 4a4be59cdbea..3ef6f020a974 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -464,6 +464,13 @@ struct spi_controller {
 
 #define SPI_MASTER_GPIO_SS		BIT(5)	/* GPIO CS must select slave */
 
+#define SPI_MASTER_QUAD_MODE	BIT(6) /* support quad mode */
+	/*
+	 * Controller may support asserting more than one chip select at once.
+	 * This flag will enable that feature.
+	 */
+#define SPI_MASTER_BOTH_CS	BIT(8)		/* assert both chip selects */
+#define SPI_MASTER_U_PAGE	BIT(9)		/* select upper flash */
 	/* flag indicating this is an SPI slave controller */
 	bool			slave;
 
@@ -732,6 +739,7 @@ extern void spi_res_release(struct spi_controller *ctlr,
  * @len: size of rx and tx buffers (in bytes)
  * @speed_hz: Select a speed other than the device default for this
  *      transfer. If 0 the default (from @spi_device) is used.
+ * @dummy: number of dummy cycles.
  * @bits_per_word: select a bits_per_word other than the device default
  *      for this transfer. If 0 the default (from @spi_device) is used.
  * @cs_change: affects chipselect after this transfer completes
@@ -751,6 +759,7 @@ extern void spi_res_release(struct spi_controller *ctlr,
  * @transfer_list: transfers are sequenced through @spi_message.transfers
  * @tx_sg: Scatterlist for transmit, currently not for client use
  * @rx_sg: Scatterlist for receive, currently not for client use
+ * @stripe: true-> enable stripe, false-> disable stripe.
  *
  * SPI transfers always write the same number of bytes as they read.
  * Protocol drivers should always provide @rx_buf and/or @tx_buf.
@@ -836,6 +845,8 @@ struct spi_transfer {
 #define SPI_DELAY_UNIT_NSECS	1
 #define SPI_DELAY_UNIT_SCK	2
 	u32		speed_hz;
+	u32		dummy;
+	bool		stripe;
 	u16		word_delay;
 
 	u32		effective_speed_hz;
-- 
2.31.1

