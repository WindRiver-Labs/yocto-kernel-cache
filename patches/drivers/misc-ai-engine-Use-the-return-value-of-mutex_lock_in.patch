From 35ebdf2ccb48ea6c1807669111533a68851b793a Mon Sep 17 00:00:00 2001
From: Hyun Kwon <hyun.kwon@xilinx.com>
Date: Tue, 23 Jun 2020 14:02:34 +0200
Subject: [PATCH 1400/1852] misc: ai-engine: Use the return value of
 mutex_lock_interruptible()
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

The use of return value is required, otherwise it falls through without
holding the lock. The build gives warnings for that.

include/linux/mutex.h:154:40: warning: ignoring return value of ‘mutex_lock_interruptible_nested’, declared with attribute warn_unused_result [-Wunused-result]
 #define mutex_lock_interruptible(lock) mutex_lock_interruptible_nested(lock, 0)
                                        ^
drivers/misc/xilinx-ai-engine/ai-engine-dev.c:169:2: note: in expansion of macro ‘mutex_lock_interruptible’
  mutex_lock_interruptible(&adev->mlock);
  ^

In most cases, the error is returned, except in aie_part_release_device(),
where it proceeds to release resources because the user won't get a chance
to recover by error return anyway.

Reported-by: kernel test robot <lkp@intel.com>
Signed-off-by: Hyun Kwon <hyun.kwon@xilinx.com>
Reviewed-by: Wendy Liang <Wendy.liang@xilinx.com>
State: pending
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 drivers/misc/xilinx-ai-engine/ai-engine-dev.c | 17 ++++--
 .../misc/xilinx-ai-engine/ai-engine-fpga.c    | 11 +++-
 .../misc/xilinx-ai-engine/ai-engine-part.c    | 53 ++++++++++++++++---
 3 files changed, 68 insertions(+), 13 deletions(-)

diff --git a/drivers/misc/xilinx-ai-engine/ai-engine-dev.c b/drivers/misc/xilinx-ai-engine/ai-engine-dev.c
index 11a70648ca0d..d81baf5df519 100644
--- a/drivers/misc/xilinx-ai-engine/ai-engine-dev.c
+++ b/drivers/misc/xilinx-ai-engine/ai-engine-dev.c
@@ -78,6 +78,7 @@ static int aie_enquire_partitions(struct aie_device *adev,
 {
 	struct aie_partition *apart;
 	u32 partition_cnt, i = 0;
+	int ret;
 
 	if (!query->partitions) {
 		/*
@@ -94,7 +95,10 @@ static int aie_enquire_partitions(struct aie_device *adev,
 	if (!partition_cnt)
 		return 0;
 
-	mutex_lock_interruptible(&adev->mlock);
+	ret = mutex_lock_interruptible(&adev->mlock);
+	if (ret)
+		return ret;
+
 	list_for_each_entry(apart, &adev->partitions, node) {
 		struct aie_range_args part;
 
@@ -163,8 +167,12 @@ struct aie_partition *aie_request_partition(struct aie_device *adev,
 					    struct aie_partition_req *req)
 {
 	struct aie_partition *apart;
+	int ret;
+
+	ret = mutex_lock_interruptible(&adev->mlock);
+	if (ret)
+		return ERR_PTR(ret);
 
-	mutex_lock_interruptible(&adev->mlock);
 	apart = aie_get_partition_from_id(adev, req->partition_id);
 	if (!apart) {
 		dev_err(&adev->dev,
@@ -179,7 +187,10 @@ struct aie_partition *aie_request_partition(struct aie_device *adev,
 	 * data to see which resources used by application.
 	 */
 
-	mutex_lock_interruptible(&apart->mlock);
+	ret = mutex_lock_interruptible(&apart->mlock);
+	if (ret)
+		return ERR_PTR(ret);
+
 	if (apart->status & XAIE_PART_STATUS_INUSE) {
 		mutex_unlock(&apart->mlock);
 		dev_err(&adev->dev,
diff --git a/drivers/misc/xilinx-ai-engine/ai-engine-fpga.c b/drivers/misc/xilinx-ai-engine/ai-engine-fpga.c
index 7816c92134fe..19ca3a018c15 100644
--- a/drivers/misc/xilinx-ai-engine/ai-engine-fpga.c
+++ b/drivers/misc/xilinx-ai-engine/ai-engine-fpga.c
@@ -10,6 +10,7 @@
 static int aie_fpga_bridge_enable_set(struct fpga_bridge *bridge, bool enable)
 {
 	struct aie_partition *apart = bridge->priv;
+	int ret;
 
 	/*
 	 * TBD:
@@ -18,7 +19,10 @@ static int aie_fpga_bridge_enable_set(struct fpga_bridge *bridge, bool enable)
 	 * until SHIM DMA stops, and disable SHIM
 	 * to PL streams within partition.
 	 */
-	mutex_lock_interruptible(&apart->mlock);
+	ret = mutex_lock_interruptible(&apart->mlock);
+	if (ret)
+		return ret;
+
 	if (enable)
 		apart->status |= XAIE_PART_STATUS_BRIDGE_ENABLED;
 	else
@@ -32,7 +36,10 @@ static int aie_fpga_bridge_enable_show(struct fpga_bridge *bridge)
 	struct aie_partition *apart = bridge->priv;
 	int ret;
 
-	mutex_lock_interruptible(&apart->mlock);
+	ret = mutex_lock_interruptible(&apart->mlock);
+	if (ret)
+		return ret;
+
 	if (apart->status & XAIE_PART_STATUS_BRIDGE_ENABLED)
 		ret = 1;
 	else
diff --git a/drivers/misc/xilinx-ai-engine/ai-engine-part.c b/drivers/misc/xilinx-ai-engine/ai-engine-part.c
index c8e3a9d23726..555b68c9f841 100644
--- a/drivers/misc/xilinx-ai-engine/ai-engine-part.c
+++ b/drivers/misc/xilinx-ai-engine/ai-engine-part.c
@@ -245,12 +245,16 @@ static int aie_part_access_regs(struct aie_partition *apart, u32 num_reqs,
 static int aie_part_release(struct inode *inode, struct file *filp)
 {
 	struct aie_partition *apart = filp->private_data;
+	int ret;
 
 	/*
 	 * TODO: It will need to reset the SHIM columns and gate the
 	 * the tiles of the partition.
 	 */
-	mutex_lock_interruptible(&apart->mlock);
+	ret = mutex_lock_interruptible(&apart->mlock);
+	if (ret)
+		return ret;
+
 	apart->status = 0;
 	mutex_unlock(&apart->mlock);
 
@@ -273,7 +277,13 @@ static ssize_t aie_part_write_iter(struct kiocb *iocb, struct iov_iter *from)
 		kfree(buf);
 		return -EFAULT;
 	}
-	mutex_lock_interruptible(&apart->mlock);
+
+	ret = mutex_lock_interruptible(&apart->mlock);
+	if (ret) {
+		kfree(buf);
+		return ret;
+	}
+
 	ret = aie_part_write_register(apart, (size_t)offset, len, buf, 0);
 	mutex_unlock(&apart->mlock);
 	kfree(buf);
@@ -293,7 +303,13 @@ static ssize_t aie_part_read_iter(struct kiocb *iocb, struct iov_iter *to)
 	buf = kzalloc(len, GFP_KERNEL);
 	if (!buf)
 		return -ENOMEM;
-	mutex_lock_interruptible(&apart->mlock);
+
+	ret = mutex_lock_interruptible(&apart->mlock);
+	if (ret) {
+		kfree(buf);
+		return ret;
+	}
+
 	ret = aie_part_read_register(apart, (size_t)offset, len, buf);
 	mutex_unlock(&apart->mlock);
 	if (ret > 0) {
@@ -363,7 +379,11 @@ static long aie_part_ioctl(struct file *fp, unsigned int cmd, unsigned long arg)
 
 		if (copy_from_user(&raccess, argp, sizeof(raccess)))
 			return -EFAULT;
-		mutex_lock_interruptible(&apart->mlock);
+
+		ret = mutex_lock_interruptible(&apart->mlock);
+		if (ret)
+			return ret;
+
 		ret = aie_part_access_regs(apart, 1, &raccess);
 		mutex_unlock(&apart->mlock);
 		break;
@@ -397,8 +417,14 @@ static void aie_part_release_device(struct device *dev)
 {
 	struct aie_partition *apart = dev_to_aiepart(dev);
 	struct aie_device *adev = apart->adev;
+	int ret;
+
+	ret = mutex_lock_interruptible(&adev->mlock);
+	if (ret) {
+		dev_warn(&apart->dev,
+			 "getting adev->mlock is interrupted by signal\n");
+	}
 
-	mutex_lock_interruptible(&adev->mlock);
 	aie_resource_put_region(&adev->cols_res, apart->range.start.col,
 				apart->range.size.col);
 	list_del(&apart->node);
@@ -427,7 +453,10 @@ static struct aie_partition *aie_create_partition(struct aie_device *adev,
 	char devname[32];
 	int ret;
 
-	mutex_lock_interruptible(&adev->mlock);
+	ret = mutex_lock_interruptible(&adev->mlock);
+	if (ret)
+		return ERR_PTR(ret);
+
 	ret = aie_resource_check_region(&adev->cols_res, range->start.col,
 					range->size.col);
 	if (ret != range->start.col) {
@@ -474,7 +503,12 @@ static struct aie_partition *aie_create_partition(struct aie_device *adev,
 		return ERR_PTR(ret);
 	}
 
-	mutex_lock_interruptible(&adev->mlock);
+	ret = mutex_lock_interruptible(&adev->mlock);
+	if (ret) {
+		put_device(dev);
+		return ERR_PTR(ret);
+	}
+
 	list_add_tail(&apart->node, &adev->partitions);
 	mutex_unlock(&adev->mlock);
 	get_device(&adev->dev);
@@ -512,7 +546,10 @@ of_aie_part_probe(struct aie_device *adev, struct device_node *nc)
 		return ERR_PTR(ret);
 	}
 
-	mutex_lock_interruptible(&adev->mlock);
+	ret = mutex_lock_interruptible(&adev->mlock);
+	if (ret)
+		return ERR_PTR(ret);
+
 	apart = aie_get_partition_from_id(adev, partition_id);
 	mutex_unlock(&adev->mlock);
 	if (apart) {
-- 
2.31.1

