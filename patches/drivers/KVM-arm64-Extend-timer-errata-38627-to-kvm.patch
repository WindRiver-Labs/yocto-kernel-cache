From 2df068ece20d913b449d650cb84e2bd0a986bbd4 Mon Sep 17 00:00:00 2001
From: Bharat Bhushan <bbhushan2@marvell.com>
Date: Mon, 21 Jun 2021 16:22:07 +0530
Subject: [PATCH 1618/1921] KVM: arm64: Extend timer errata-38627 to kvm

ARM64 timer are disabled in kvm context save
path and this can lead to hitting errata-38627.

So this patch extends workaround to ensure
maximum 2us of time gap between timer interrupt
expiry and timer disabling in kvm.

Change-Id: I6bfeecc3f8a63c4a65d7d1efc7e1b6a5f7fec06f
Signed-off-by: Linu Cherian <lcherian@marvell.com>
Signed-off-by: Bharat Bhushan <bbhushan2@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/55117
Reviewed-by: Sunil Kovvuri Goutham <sgoutham@marvell.com>
Tested-by: Sunil Kovvuri Goutham <sgoutham@marvell.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 virt/kvm/arm/arch_timer.c | 42 +++++++++++++++++++++++++++++++++++++++
 1 file changed, 42 insertions(+)

diff --git a/virt/kvm/arm/arch_timer.c b/virt/kvm/arm/arch_timer.c
index 6b222100608f..c1700994fa2a 100644
--- a/virt/kvm/arm/arch_timer.c
+++ b/virt/kvm/arm/arch_timer.c
@@ -10,6 +10,7 @@
 #include <linux/interrupt.h>
 #include <linux/irq.h>
 #include <linux/uaccess.h>
+#include <linux/delay.h>
 
 #include <clocksource/arm_arch_timer.h>
 #include <asm/arch_timer.h>
@@ -51,6 +52,34 @@ static u64 kvm_arm_timer_read(struct kvm_vcpu *vcpu,
 			      struct arch_timer_context *timer,
 			      enum kvm_arch_timer_regs treg);
 
+#ifdef CONFIG_MARVELL_ERRATUM_38627
+static DEFINE_STATIC_KEY_FALSE(timer_errata_38627);
+
+/* Workaround is to ensure maximum 2us of time gap between timer expiry
+ * and timer programming which can de-assert timer interrupt.
+ * Time calculation below is based on 100MHz as timer frequency is fixed
+ * to 100MHz on all affected parts.
+ */
+static void apply_mrvl_erratum_38627(enum kvm_arch_timers index)
+{
+
+	int32_t tval;
+
+	if(index == TIMER_VTIMER)
+		tval = read_sysreg(cntv_tval_el0);
+	else
+		tval = read_sysreg(cntp_tval_el0);
+
+	/* Timer already expired, wait for (2 - expired time)us */
+	if ((tval > -200) && (tval < 0))
+		udelay(2 + tval/100);
+
+	/* Timer is about to expire, wait for 2us + time to expire */
+	if (tval >= 0 && tval < 200)
+		udelay(3 + tval/100);
+}
+#endif
+
 u64 kvm_phys_timer_read(void)
 {
 	return timecounter->cc->read(timecounter->cc);
@@ -353,6 +382,10 @@ static void timer_save_state(struct arch_timer_context *ctx)
 		ctx->cnt_ctl = read_sysreg_el0(SYS_CNTV_CTL);
 		ctx->cnt_cval = read_sysreg_el0(SYS_CNTV_CVAL);
 
+#ifdef CONFIG_MARVELL_ERRATUM_38627
+		if (static_branch_likely(&timer_errata_38627))
+			apply_mrvl_erratum_38627(index);
+#endif
 		/* Disable the timer */
 		write_sysreg_el0(0, SYS_CNTV_CTL);
 		isb();
@@ -362,6 +395,10 @@ static void timer_save_state(struct arch_timer_context *ctx)
 		ctx->cnt_ctl = read_sysreg_el0(SYS_CNTP_CTL);
 		ctx->cnt_cval = read_sysreg_el0(SYS_CNTP_CVAL);
 
+#ifdef CONFIG_MARVELL_ERRATUM_38627
+		if (static_branch_likely(&timer_errata_38627))
+			apply_mrvl_erratum_38627(index);
+#endif
 		/* Disable the timer */
 		write_sysreg_el0(0, SYS_CNTP_CTL);
 		isb();
@@ -981,6 +1018,11 @@ int kvm_timer_hyp_init(bool has_gic)
 		goto out_free_irq;
 	}
 
+#ifdef CONFIG_MARVELL_ERRATUM_38627
+	if (cpus_have_const_cap(ARM64_WORKAROUND_MRVL_38627))
+		static_branch_enable(&timer_errata_38627);
+#endif
+
 	cpuhp_setup_state(CPUHP_AP_KVM_ARM_TIMER_STARTING,
 			  "kvm/arm/timer:starting", kvm_timer_starting_cpu,
 			  kvm_timer_dying_cpu);
-- 
2.31.1

