From 812025df4bebe8ef82e7969ddc1bc6a583649d2d Mon Sep 17 00:00:00 2001
From: Linu Cherian <lcherian@marvell.com>
Date: Wed, 22 Jan 2020 17:15:39 +0530
Subject: [PATCH 0672/1921] coresight: etr: Add workaround for broken stop on
 flush

As a workaround,
- Ensure ETM is disabled before flush and stop is expected
  to be complete.
- Avoid giving stop on flush command to hardware
- Avoid polling for TMC idle during flush and stop

Change-Id: If9ef13f4e69f9e9f1f5829de035a2ca2a6b2f241
Signed-off-by: Linu Cherian <lcherian@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/22248
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/32247
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 drivers/hwtracing/coresight/coresight-priv.h  |  1 +
 .../hwtracing/coresight/coresight-quirks.c    |  3 +-
 .../hwtracing/coresight/coresight-tmc-etr.c   | 42 ++++++++++++++++++-
 drivers/hwtracing/coresight/coresight-tmc.c   | 11 +++--
 4 files changed, 52 insertions(+), 5 deletions(-)

diff --git a/drivers/hwtracing/coresight/coresight-priv.h b/drivers/hwtracing/coresight/coresight-priv.h
index 2493a1c71923..e508f02d3578 100644
--- a/drivers/hwtracing/coresight/coresight-priv.h
+++ b/drivers/hwtracing/coresight/coresight-priv.h
@@ -77,6 +77,7 @@ extern const u32 barrier_pkt[4];
 #define CSETR_QUIRK_BUFFSIZE_8BX	(0x1U << 0) /* 8 byte size multiplier */
 #define CSETR_QUIRK_SECURE_BUFF		(0x1U << 1) /* Trace buffer is Secure */
 #define CSETR_QUIRK_RESET_CTL_REG	(0x1U << 2) /* Reset CTL on reset */
+#define CSETR_QUIRK_NO_STOP_FLUSH	(0x0U << 3) /* No Stop on flush */
 #define CSETM_QUIRK_SW_SYNC		(0x1U << 4) /* No Hardware sync */
 #define CSETM_QUIRK_TREAT_ETMv43	(0x1U << 5) /* ETMv4.2 as ETMv4.3 */
 
diff --git a/drivers/hwtracing/coresight/coresight-quirks.c b/drivers/hwtracing/coresight/coresight-quirks.c
index 1f64c7f0927c..32cacc1b37f8 100644
--- a/drivers/hwtracing/coresight/coresight-quirks.c
+++ b/drivers/hwtracing/coresight/coresight-quirks.c
@@ -17,7 +17,8 @@ u32 coresight_get_etr_quirks(unsigned int id)
 				     MIDR_CPU_VAR_REV(0, 0),
 				     MIDR_CPU_VAR_REV(2, 0)))
 		options |= CSETR_QUIRK_BUFFSIZE_8BX |
-			CSETR_QUIRK_RESET_CTL_REG;
+			CSETR_QUIRK_RESET_CTL_REG |
+			CSETR_QUIRK_NO_STOP_FLUSH;
 
 	if (id == OCTEONTX_CN9XXX_ETR)
 		options |= CSETR_QUIRK_SECURE_BUFF;
diff --git a/drivers/hwtracing/coresight/coresight-tmc-etr.c b/drivers/hwtracing/coresight/coresight-tmc-etr.c
index f75f5f4c6841..c7b5a743c5ab 100644
--- a/drivers/hwtracing/coresight/coresight-tmc-etr.c
+++ b/drivers/hwtracing/coresight/coresight-tmc-etr.c
@@ -193,9 +193,10 @@ static void tmc_etr_insert_sync(struct tmc_drvdata *drvdata)
 	int err = 0, len;
 	u64 rwp;
 
-	/* We have two contenders for ETM control.
+	/* We have three contenders for ETM control.
 	 * 1. User initiated ETM control
 	 * 2. Timer sync initiated ETM control
+	 * 3. No stop on flush initated ETM control
 	 * They all run in an atomic context and that too in
 	 * the same core. Either on a core in which ETM is associated
 	 * or in the primary core thereby mutually exclusive.
@@ -1997,6 +1998,31 @@ const struct coresight_ops tmc_etr_cs_ops = {
 	.sink_ops	= &tmc_etr_sink_ops,
 };
 
+
+/* APIs to manage ETM start/stop when ETR stop on flush is broken */
+
+void tmc_flushstop_etm_off(void *data)
+{
+	struct tmc_drvdata *drvdata = data;
+	struct coresight_device *sdev = drvdata->etm_source;
+
+	if (sdev->hw_state == USR_START) {
+		source_ops(sdev)->disable_raw(sdev);
+		sdev->hw_state = SW_STOP;
+	}
+}
+
+void tmc_flushstop_etm_on(void *data)
+{
+	struct tmc_drvdata *drvdata = data;
+	struct coresight_device *sdev = drvdata->etm_source;
+
+	if (sdev->hw_state == SW_STOP) { /* Restore the user configured state */
+		source_ops(sdev)->enable_raw(sdev);
+		sdev->hw_state = USR_START;
+	}
+}
+
 int tmc_read_prepare_etr(struct tmc_drvdata *drvdata)
 {
 	int ret = 0;
@@ -2006,6 +2032,10 @@ int tmc_read_prepare_etr(struct tmc_drvdata *drvdata)
 	if (WARN_ON_ONCE(drvdata->config_type != TMC_CONFIG_TYPE_ETR))
 		return -EINVAL;
 
+	if (drvdata->etr_options & CSETR_QUIRK_NO_STOP_FLUSH)
+		smp_call_function_single(drvdata->rc_cpu, tmc_flushstop_etm_off,
+					 drvdata, true);
+
 	spin_lock_irqsave(&drvdata->spinlock, flags);
 	if (drvdata->reading) {
 		ret = -EBUSY;
@@ -2030,6 +2060,13 @@ int tmc_read_prepare_etr(struct tmc_drvdata *drvdata)
 out:
 	spin_unlock_irqrestore(&drvdata->spinlock, flags);
 
+	if (ret && drvdata->etr_options & CSETR_QUIRK_NO_STOP_FLUSH) {
+		dev_warn(&drvdata->csdev->dev, "ETM wrongly stopped\n");
+		/* Restore back on error */
+		smp_call_function_single(drvdata->rc_cpu, tmc_flushstop_etm_on,
+					 drvdata, true);
+	}
+
 	return ret;
 }
 
@@ -2068,5 +2105,8 @@ int tmc_read_unprepare_etr(struct tmc_drvdata *drvdata)
 	if (sysfs_buf)
 		tmc_etr_free_sysfs_buf(sysfs_buf);
 
+	if (drvdata->etr_options & CSETR_QUIRK_NO_STOP_FLUSH)
+		smp_call_function_single(drvdata->rc_cpu, tmc_flushstop_etm_on,
+					drvdata, true);
 	return 0;
 }
diff --git a/drivers/hwtracing/coresight/coresight-tmc.c b/drivers/hwtracing/coresight/coresight-tmc.c
index a70fc8e2377d..4d1ad0cfab44 100644
--- a/drivers/hwtracing/coresight/coresight-tmc.c
+++ b/drivers/hwtracing/coresight/coresight-tmc.c
@@ -46,8 +46,12 @@ void tmc_flush_and_stop(struct tmc_drvdata *drvdata)
 	u32 ffcr;
 
 	ffcr = readl_relaxed(drvdata->base + TMC_FFCR);
-	ffcr |= TMC_FFCR_STOP_ON_FLUSH;
-	writel_relaxed(ffcr, drvdata->base + TMC_FFCR);
+
+	if (!(drvdata->etr_options & CSETR_QUIRK_NO_STOP_FLUSH)) {
+		/* Its assumed that ETM is stopped as an alternative */
+		ffcr |= TMC_FFCR_STOP_ON_FLUSH;
+		writel_relaxed(ffcr, drvdata->base + TMC_FFCR);
+	}
 	ffcr |= BIT(TMC_FFCR_FLUSHMAN_BIT);
 	writel_relaxed(ffcr, drvdata->base + TMC_FFCR);
 	/* Ensure flush completes */
@@ -57,7 +61,8 @@ void tmc_flush_and_stop(struct tmc_drvdata *drvdata)
 		"timeout while waiting for completion of Manual Flush\n");
 	}
 
-	tmc_wait_for_tmcready(drvdata);
+	if (!(drvdata->etr_options & CSETR_QUIRK_NO_STOP_FLUSH))
+		tmc_wait_for_tmcready(drvdata);
 }
 
 void tmc_enable_hw(struct tmc_drvdata *drvdata)
-- 
2.31.1

