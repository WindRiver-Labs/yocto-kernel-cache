From 555ab1e2ffda2fb9b3d6accac12fbd8414830ccd Mon Sep 17 00:00:00 2001
From: Wojciech Bartczak <wbartczak@marvell.com>
Date: Thu, 13 May 2021 20:54:36 -0700
Subject: [PATCH 1563/1921] driver: Add MAC management driver for OcteonTX
 platform

The new driver allows to manage MAC addresses for each port
available in the system. Driver uses debugfs to allow usert
MAC address change. It creates
/sys/kernel/debug/marvell_mac_mngt/set_mac file.
The file is write only type of interface.

Signed-off-by: Wojciech Bartczak <wbartczak@marvell.com>
Change-Id: Iee5d6ca6dc90f8ee77cb09c65b7553748a8adfa3
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/52827
Reviewed-by: Chandrakala Chavva <cchavva@marvell.com>
Reviewed-by: Sunil Kovvuri Goutham <sgoutham@marvell.com>
Tested-by: Sunil Kovvuri Goutham <sgoutham@marvell.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 drivers/soc/marvell/Kconfig            |  12 ++
 drivers/soc/marvell/Makefile           |   1 +
 drivers/soc/marvell/marvell_mac_mgmt.c | 281 +++++++++++++++++++++++++
 3 files changed, 294 insertions(+)
 create mode 100644 drivers/soc/marvell/marvell_mac_mgmt.c

diff --git a/drivers/soc/marvell/Kconfig b/drivers/soc/marvell/Kconfig
index 61a5c4dd173c..7e6bbf4fcd7a 100644
--- a/drivers/soc/marvell/Kconfig
+++ b/drivers/soc/marvell/Kconfig
@@ -153,4 +153,16 @@ config OCTEONTX_SERDES
 	  capture eye, use PRBS, configure serdes in loopback mode, and
 	  read/write TX tuning parameters.
 
+config MARVELL_CN10K_MAC_MGMT
+	tristate "Marvell CN10K MAC management support"
+	depends on ARM64
+	depends on DEBUG_FS
+	help
+	  Provides debugfs entry which allows to set MAC address value
+	  for ports presented in the system from userspace. The module creates
+	  special file /sys/kernel/debug/marvell_mac_mngt/set_mac.
+	  File has write-only type of interface, read from file provides usage
+	  for the functionality.
+	  Driver is supported only for CN10K platforms.
+
 endmenu
diff --git a/drivers/soc/marvell/Makefile b/drivers/soc/marvell/Makefile
index 5b9532b712bd..7c6a9f6ddfde 100644
--- a/drivers/soc/marvell/Makefile
+++ b/drivers/soc/marvell/Makefile
@@ -10,3 +10,4 @@ obj-y 		+= octeontx2-serdes/
 obj-$(CONFIG_OCTEONTX_INFO) += octeontx_info.o
 obj-$(CONFIG_MVMDIO_UIO) += mvmdio_uio.o
 obj-$(CONFIG_MRVL_PHY_DIAGNOSTICS) += phy_diag.o
+obj-$(CONFIG_MARVELL_CN10K_MAC_MGMT) += marvell_mac_mgmt.o
diff --git a/drivers/soc/marvell/marvell_mac_mgmt.c b/drivers/soc/marvell/marvell_mac_mgmt.c
new file mode 100644
index 000000000000..47028a94866a
--- /dev/null
+++ b/drivers/soc/marvell/marvell_mac_mgmt.c
@@ -0,0 +1,281 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 Marvell
+ *
+ */
+
+#include <linux/arm-smccc.h>
+#include <linux/debugfs.h>
+#include <linux/fs.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/uaccess.h>
+#include <linux/slab.h>
+
+/* Maximum number of MAC addressess to pass */
+#define MAC_MGMT_MAX_MACS_NUM	32
+
+/* Maximum mac data size */
+#define MAC_MGMT_MAX_MAC_TEXT_SIZE	2048
+
+/* Single entry description */
+struct mac_info {
+	u32	index;
+	u32	reserved; /* Must be zero */
+	union {
+		u64	mac_addr;
+		u8      bytes[8];
+	} s;
+};
+
+/* Data and defines for SMC call */
+#define ARM_SMC_SVC_UID			0xc200ff01
+/* SMC call number used to set MAC address */
+#define PLAT_OCTEONTX_MAC_MGMT_SET_ADDR	0xc2000e10
+
+/* This is expected CN10k response for SVC UID command */
+static const int octeontx_svc_uuid[] = {
+	0x6ff498cf,
+	0x5a4e9cfa,
+	0x2f2a3aa4,
+	0x5945b105,
+};
+
+/** Set MAC address given by user
+ *
+ * The call passes MAC address information to ATF for further processing.
+ * Information contains index and MAC address itself. Data should be validated
+ * before this call.
+ *
+ * @param minfo - MAC address information (index, value)
+ *
+ * @return 0 for success, error code otherwise
+ *
+ */
+static int mac_mgmt_set_addr(struct mac_info *minfo)
+{
+	struct arm_smccc_res res;
+
+	/* Pass validated data to ATF */
+	arm_smccc_smc(PLAT_OCTEONTX_MAC_MGMT_SET_ADDR,
+		      minfo->index, minfo->s.mac_addr, 0, 0, 0, 0, 0,
+		      &res);
+	if (res.a0)
+		return -EINVAL;
+
+	return 0;
+}
+
+/** Check software compatibility of ATF
+ *
+ * The call verifies ATF instance running on the system.
+ *
+ * @return 0 for success, error code otherwise
+ *
+ */
+static int mac_mgmt_check_smc(void)
+{
+	struct arm_smccc_res res;
+
+	/* Is the other side the CN10k? */
+	arm_smccc_smc(ARM_SMC_SVC_UID, 0, 0, 0, 0, 0, 0, 0, &res);
+	if (res.a0 != octeontx_svc_uuid[0] || res.a1 != octeontx_svc_uuid[1] ||
+	    res.a2 != octeontx_svc_uuid[2] || res.a3 != octeontx_svc_uuid[3])
+		return -EPERM;
+
+	return 0;
+}
+
+/** Parse user input in text for to MAC information structure
+ *
+ * @param buffer - ASCII string containing user's input
+ * @param n - size of the user's input
+ * @param minfo - input/output value, contains MAC information. Updated only when call succeeded
+ *
+ * @return bytes parsed for success, error code otherwise
+ *
+ */
+static ssize_t mac_mgmt_parse_buffer(const char *buffer, size_t n,
+			    struct mac_info *minfo)
+{
+	u32 index;
+	u64 mac_addr;
+	int processed, ret;
+
+	/* Data are in buffer, parse it */
+	ret = sscanf(buffer, "%u %llx %n", &index, &mac_addr, &processed);
+	if (ret <= 0)
+		return -EINVAL;
+
+	if (processed < 2)  /* Expect at least two characters in input */
+		return -EINVAL;
+
+	if (index > MAC_MGMT_MAX_MACS_NUM)
+		return -EINVAL;
+
+	if (!mac_addr)
+		return -EINVAL;
+
+	/* Store validated data */
+	minfo->index = index;
+	minfo->s.mac_addr = mac_addr & 0xffffffffffff;
+
+	pr_debug("%s: Idx: %u, addr: %llx\n", module_name(THIS_MODULE),
+		 minfo->index, minfo->s.mac_addr);
+
+	return n;
+}
+
+/** Process the write operations to debugfs.
+ *
+ * The call is supported by seq_file API form kernel
+ *
+ * @param filep - file pointer
+ * @param buffer - user's input buffer
+ * @param count - user's input buffer size
+ * @param ppos - position in file
+ *
+ * @return bytes written for success, error code otherwise
+ *
+ */
+static ssize_t mac_mgmt_write(struct file *filp, const char __user *buffer,
+			      size_t count, loff_t *ppos)
+{
+	struct mac_info minfo = { 0 };
+	char *mac_text_data = NULL;
+	size_t cnt;
+	int ret, bytes;
+
+	/* User should fit into MAC_MGMT_MAX_MAC_TEXT_SIZE - 1, otherwise truncate */
+	cnt = (count >= MAC_MGMT_MAX_MAC_TEXT_SIZE - 1) ?
+		(MAC_MGMT_MAX_MAC_TEXT_SIZE - 1) : count;
+
+	/* Leave one byte for NULL termination */
+	mac_text_data = kzalloc(cnt + 1, GFP_KERNEL);
+	if (!mac_text_data)
+		return -ENOMEM;
+
+	if (copy_from_user(mac_text_data, buffer, cnt)) {
+		ret = -EFAULT;
+		goto done;
+	}
+
+	bytes = mac_mgmt_parse_buffer(mac_text_data, cnt, &minfo);
+	if (bytes < 0) {
+		pr_warn("%s: Invalid text format!\n", module_name(THIS_MODULE));
+		ret = bytes;
+		goto done;
+	}
+
+	ret = mac_mgmt_set_addr(&minfo);
+	if (!ret)
+		pr_info("%s: MAC addresses has been updated, change takes effect after reboot\n",
+			module_name(THIS_MODULE));
+done:
+	kfree(mac_text_data);
+	return ret ? ret : bytes;
+}
+
+/** Process the read operations from debugfs.
+ *
+ * The call is supported by seq_file API form kernel.
+ * It provides usage information to user.
+ *
+ * @param s - seq_file file handle
+ * @param unused - unused parameter
+ *
+ * @return 0 for success, error code otherwise
+ *
+ */
+static int mac_mgmt_read(struct seq_file *s, void *unused)
+{
+	seq_printf(s, "Sets MAC address for available interface.\nFormat:\n"
+		      "ID BOARD-MAC-ADDRESS\n\n");
+	return 0;
+}
+
+/** Process the open call on debugfs.
+ *
+ * The call is supported by seq_file API form kernel.
+ *
+ * @param inode - inode representing debugfs entry
+ * @param file - file structure related to debugfs entry
+ *
+ * @return 0 for success, error code otherwise
+ *
+ */
+static int mac_mgmt_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, mac_mgmt_read, inode->i_private);
+}
+
+static const struct file_operations mac_mgmt_fops = {
+	.owner		= THIS_MODULE,
+	.open		= mac_mgmt_open,
+	.read		= seq_read,
+	.write		= mac_mgmt_write,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+/* Handle to debugfs root directory created by the driver */
+static struct dentry *mac_dbgfs_root;
+
+/** Initialize debugfs entries for the driver
+ *
+ * @return 0 for success, error code otherwise
+ *
+ */
+static int mac_mgmt_setup_debugfs(void)
+{
+	struct dentry *dbg_file;
+
+	mac_dbgfs_root = debugfs_create_dir("mac_mgmt", NULL);
+	if (IS_ERR(mac_dbgfs_root))
+		return PTR_ERR(mac_dbgfs_root);
+
+	dbg_file = debugfs_create_file("set_mac_addr", 0600, mac_dbgfs_root,
+				       NULL, &mac_mgmt_fops);
+	if (IS_ERR(dbg_file)) {
+		debugfs_remove(mac_dbgfs_root);
+		mac_dbgfs_root = NULL;
+		return PTR_ERR(dbg_file);
+	}
+
+	return 0;
+}
+
+static int __init mac_mgmt_init(void)
+{
+	int ret;
+
+	ret = mac_mgmt_check_smc();
+	if (ret) {
+		pr_info("%s: UIID SVC doesn't match Marvell CN10k.\n",
+			module_name(THIS_MODULE));
+		return ret;
+	}
+
+	ret = mac_mgmt_setup_debugfs();
+	if (ret) {
+		pr_err("%s: Can't create debugfs entries! (%d)\n",
+		       module_name(THIS_MODULE), ret);
+		return ret;
+	}
+
+	pr_info("Marvell CN10K MAC management\n");
+
+	return 0;
+}
+
+static void __exit mac_mgmt_exit(void)
+{
+	debugfs_remove_recursive(mac_dbgfs_root);
+}
+
+module_init(mac_mgmt_init);
+module_exit(mac_mgmt_exit);
+
+MODULE_AUTHOR("Wojciech Bartczak <wbartczak@marvell.com>");
+MODULE_DESCRIPTION("MAC address management for Marvell CN10K");
+MODULE_LICENSE("GPL v2");
-- 
2.31.1

