From 495d01ef0dca69405db6a902b2991b74c6f4a143 Mon Sep 17 00:00:00 2001
From: Naga Sureshkumar Relli <naga.sureshkumar.relli@xilinx.com>
Date: Thu, 5 Dec 2019 02:19:45 -0700
Subject: [PATCH 0017/1851] mtd: rawnand: arasan: Add runtime support

commit 3c3118cd2ce6f8af42fae81e2423b67ada5ff2d4 from
https://github.com/Xilinx/linux-xlnx.git

Add back the runtime support which is reverted during kernel upgrade.

Signed-off-by: Shubhrajyoti Datta <shubhrajyoti.datta@xilinx.com>
Signed-off-by: Naga Sureshkumar Relli <naga.sureshkumar.relli@xilinx.com>
State: pending
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 drivers/mtd/nand/raw/arasan_nand.c | 81 ++++++++++++++++++++++++++++++
 1 file changed, 81 insertions(+)

diff --git a/drivers/mtd/nand/raw/arasan_nand.c b/drivers/mtd/nand/raw/arasan_nand.c
index b182643100df..9aaacac37171 100644
--- a/drivers/mtd/nand/raw/arasan_nand.c
+++ b/drivers/mtd/nand/raw/arasan_nand.c
@@ -22,8 +22,10 @@
 #include <linux/delay.h>
 #include <linux/mtd/nand_bch.h>
 #include "internals.h"
+#include <linux/pm_runtime.h>
 
 #define EVENT_TIMEOUT_MSEC	1000
+#define ANFC_PM_TIMEOUT		1000	/* ms */
 
 #define PKT_OFST		0x00
 #define PKT_CNT_SHIFT		12
@@ -1076,15 +1078,23 @@ static const struct nand_op_parser anfc_op_parser = NAND_OP_PARSER(
 static void anfc_select_chip(struct nand_chip *chip, int num)
 {
 	u32 val;
+	int ret;
 	struct anfc_nand_chip *achip = to_anfc_nand(chip);
 	struct anfc_nand_controller *nfc = to_anfc(chip->controller);
 
 	if (num < 0) {
 		nfc->chip_active = false;
+		pm_runtime_mark_last_busy(nfc->dev);
+		pm_runtime_put_autosuspend(nfc->dev);
 		return;
 	}
 
 	nfc->chip_active = true;
+	ret = pm_runtime_get_sync(nfc->dev);
+	if (ret < 0) {
+		dev_err(nfc->dev, "runtime_get_sync failed\n");
+		return;
+	}
 
 	val = readl(nfc->base + MEM_ADDR2_OFST);
 	val &= (val & ~(CS_MASK | BCH_MODE_MASK));
@@ -1303,6 +1313,11 @@ static int anfc_probe(struct platform_device *pdev)
 		goto clk_dis_sys;
 	}
 
+	pm_runtime_set_autosuspend_delay(nfc->dev, ANFC_PM_TIMEOUT);
+	pm_runtime_use_autosuspend(nfc->dev);
+	pm_runtime_set_active(nfc->dev);
+	pm_runtime_get_noresume(nfc->dev);
+	pm_runtime_enable(nfc->dev);
 	for_each_available_child_of_node(np, child) {
 		anand_chip = devm_kzalloc(&pdev->dev, sizeof(*anand_chip),
 					  GFP_KERNEL);
@@ -1319,11 +1334,15 @@ static int anfc_probe(struct platform_device *pdev)
 
 		list_add_tail(&anand_chip->node, &nfc->chips);
 	}
+	pm_runtime_mark_last_busy(nfc->dev);
+	pm_runtime_put_autosuspend(nfc->dev);
 	return 0;
 
 nandchip_clean_up:
 	list_for_each_entry(anand_chip, &nfc->chips, node)
 		nand_release(&anand_chip->chip);
+	pm_runtime_disable(&pdev->dev);
+	pm_runtime_set_suspended(&pdev->dev);
 	clk_disable_unprepare(nfc->clk_flash);
 clk_dis_sys:
 	clk_disable_unprepare(nfc->clk_sys);
@@ -1338,6 +1357,9 @@ static int anfc_remove(struct platform_device *pdev)
 
 	list_for_each_entry(anand_chip, &nfc->chips, node)
 		nand_release(&anand_chip->chip);
+	pm_runtime_disable(&pdev->dev);
+	pm_runtime_set_suspended(&pdev->dev);
+	pm_runtime_dont_use_autosuspend(&pdev->dev);
 
 	clk_disable_unprepare(nfc->clk_sys);
 	clk_disable_unprepare(nfc->clk_flash);
@@ -1352,10 +1374,69 @@ static const struct of_device_id anfc_ids[] = {
 };
 MODULE_DEVICE_TABLE(of, anfc_ids);
 
+static int anfc_suspend(struct device *dev)
+{
+	return pm_runtime_put_sync(dev);
+}
+
+static int anfc_resume(struct device *dev)
+{
+	return pm_runtime_get_sync(dev);
+}
+
+static int __maybe_unused anfc_runtime_suspend(struct device *dev)
+{
+	struct anfc_nand_controller *nfc = dev_get_drvdata(dev);
+
+	clk_disable(nfc->clk_sys);
+	clk_disable(nfc->clk_flash);
+
+	return 0;
+}
+
+static int __maybe_unused anfc_runtime_idle(struct device *dev)
+{
+	struct anfc_nand_controller *nfc = dev_get_drvdata(dev);
+
+	if (nfc->chip_active)
+		return -EBUSY;
+
+	return 0;
+}
+
+static int __maybe_unused anfc_runtime_resume(struct device *dev)
+{
+	struct anfc_nand_controller *nfc = dev_get_drvdata(dev);
+	int ret;
+
+	ret = clk_enable(nfc->clk_sys);
+	if (ret) {
+		dev_err(dev, "Cannot enable sys clock.\n");
+		return ret;
+	}
+
+	ret = clk_enable(nfc->clk_flash);
+	if (ret) {
+		dev_err(dev, "Cannot enable flash clock.\n");
+		clk_disable(nfc->clk_sys);
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct dev_pm_ops anfc_pm_ops = {
+	.resume = anfc_resume,
+	.suspend = anfc_suspend,
+	.runtime_resume = anfc_runtime_resume,
+	.runtime_suspend = anfc_runtime_suspend,
+	.runtime_idle = anfc_runtime_idle,
+};
 static struct platform_driver anfc_driver = {
 	.driver = {
 		.name = "arasan-nand-controller",
 		.of_match_table = anfc_ids,
+		.pm = &anfc_pm_ops,
 	},
 	.probe = anfc_probe,
 	.remove = anfc_remove,
-- 
2.31.1

