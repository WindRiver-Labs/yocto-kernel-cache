From d5918109d355b97e52b2abefe36f30e1a3378d9d Mon Sep 17 00:00:00 2001
From: Rakesh Babu <rsaladi2@marvell.com>
Date: Wed, 16 Sep 2020 09:26:18 +0530
Subject: [PATCH 0768/1921] octeontx2-pf: Backport logical changes in netdev
 drivers.

Backport logical changes such as changes in xmit etc., in netdev drivers
from upstream kernel sources.

Signed-off-by: Rakesh Babu <rsaladi2@marvell.com>
Change-Id: Ide3924f5e95482d2e386f23870735c181a73a4ee
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/35896
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 .../net/ethernet/marvell/octeontx2/nic/otx2_common.h  |  4 ++--
 .../net/ethernet/marvell/octeontx2/nic/otx2_ethtool.c |  3 +--
 drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c  | 11 +++++------
 drivers/net/ethernet/marvell/octeontx2/nic/otx2_vf.c  |  7 +++----
 4 files changed, 11 insertions(+), 14 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h
index 6baff46a0f0f..0ccc668fa216 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h
@@ -1,5 +1,5 @@
-/* SPDX-License-Identifier: GPL-2.0
- * Marvell OcteonTx2 RVU Ethernet driver
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Marvell OcteonTx2 RVU Ethernet driver
  *
  * Copyright (C) 2018 Marvell International Ltd.
  *
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_ethtool.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_ethtool.c
index 493f112a9c4b..60cf2a0b70e6 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_ethtool.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_ethtool.c
@@ -419,8 +419,7 @@ static int otx2_set_ringparam(struct net_device *netdev,
 		return -EINVAL;
 
 	/* Permitted lengths are 16 64 256 1K 4K 16K 64K 256K 1M  */
-	rx_count = clamp_t(u32, ring->rx_pending,
-			   Q_COUNT(Q_SIZE_MIN), Q_COUNT(Q_SIZE_MAX));
+	rx_count = ring->rx_pending;
 	/* On some silicon variants a skid or reserved CQEs are
 	 * needed to avoid CQ overflow.
 	 */
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c
index 9bd754d9c8bb..6da073ebbed2 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c
@@ -96,6 +96,7 @@ static void otx2_flr_wq_destroy(struct otx2_nic *pf)
 		return;
 	destroy_workqueue(pf->flr_wq);
 	pf->flr_wq = NULL;
+	devm_kfree(pf->dev, pf->flr_wrk);
 }
 
 static void otx2_flr_handler(struct work_struct *work)
@@ -1484,12 +1485,11 @@ static void otx2_free_hw_resources(struct otx2_nic *pf)
 }
 
 static netdev_tx_t otx2_xmit(struct sk_buff *skb, struct net_device *netdev)
-
 {
 	struct otx2_nic *pf = netdev_priv(netdev);
-	struct otx2_snd_queue *sq;
 	int qidx = skb_get_queue_mapping(skb);
-	struct netdev_queue *txq = netdev_get_tx_queue(netdev, qidx);
+	struct otx2_snd_queue *sq;
+	struct netdev_queue *txq;
 
 	/* Check for minimum and maximum packet length */
 	if (skb->len <= ETH_HLEN ||
@@ -1499,10 +1499,9 @@ static netdev_tx_t otx2_xmit(struct sk_buff *skb, struct net_device *netdev)
 	}
 
 	sq = &pf->qset.sq[qidx];
+	txq = netdev_get_tx_queue(netdev, qidx);
 
-	if (netif_tx_queue_stopped(txq)) {
-		dev_kfree_skb(skb);
-	} else if (!otx2_sq_append_skb(netdev, sq, skb, qidx)) {
+	if (!otx2_sq_append_skb(netdev, sq, skb, qidx)) {
 		netif_tx_stop_queue(txq);
 
 		/* Check again, incase SQBs got freed up */
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_vf.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_vf.c
index 5e59a0d39bc2..5935d80b6068 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_vf.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_vf.c
@@ -386,13 +386,12 @@ static netdev_tx_t otx2vf_xmit(struct sk_buff *skb, struct net_device *netdev)
 	}
 
 	sq = &vf->qset.sq[qidx];
-
 	txq = netdev_get_tx_queue(netdev, qidx);
-	if (!netif_tx_queue_stopped(txq) &&
-	    !otx2_sq_append_skb(netdev, sq, skb, qidx)) {
+
+	if (!otx2_sq_append_skb(netdev, sq, skb, qidx)) {
 		netif_tx_stop_queue(txq);
 
-		/* Barrier, for stop_queue visible to be on other cpus */
+		/* Check again, incase SQBs got freed up */
 		smp_mb();
 		if ((sq->num_sqbs - *sq->aura_fc_addr) > 1)
 			netif_tx_start_queue(txq);
-- 
2.31.1

