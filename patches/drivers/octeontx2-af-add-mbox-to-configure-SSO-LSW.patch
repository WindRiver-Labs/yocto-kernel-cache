From 65245e3a40ce9405bd0400c7978393c6c2ffb2a1 Mon Sep 17 00:00:00 2001
From: Pavan Nikhilesh <pbhagavatula@marvell.com>
Date: Wed, 30 Dec 2020 04:54:51 +0530
Subject: [PATCH 1378/1921] octeontx2-af: add mbox to configure SSO LSW

Add mbox to configure SSO LMTST scheduling widget(LSW).
LSW mode defines whether scheduled LMTST has to be enabled on a specific
SSO workslot and also changes the behaviour of GETWORK instruction,
	LSW mode 0 - Disable Scheduled LSW.
	LSW mode 1 - Wait for a free LSW index on GETWORK.
	LSW mode 2 - Don't wait for free LSW index on GETWORK i.e.
		     return immediately if there is no free LSW index.
WQE release defines when SSO Workslot releases the WQE it's holding,
	WQE release 0 - Wait for LSW to acknowledge before releasing WQE
			index.
	WQE release 1 - Free WQE index immediately.

Also, fix capability flags not being set due to overflow from shorter
data type.

Signed-off-by: Pavan Nikhilesh <pbhagavatula@marvell.com>
Change-Id: I5573ac95ace396d441b7ae1caf7a2e8d9c2b0e60
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/48677
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 .../net/ethernet/marvell/octeontx2/af/mbox.h  | 14 +++++
 .../ethernet/marvell/octeontx2/af/rvu_sso.c   | 56 +++++++++++++++++--
 2 files changed, 65 insertions(+), 5 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/af/mbox.h b/drivers/net/ethernet/marvell/octeontx2/af/mbox.h
index 04c0e2988db0..15a5314c47b1 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/mbox.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/mbox.h
@@ -206,6 +206,8 @@ M(SSO_GRP_GET_STATS,	0x609, sso_grp_get_stats, sso_info_req, sso_grp_stats)\
 M(SSO_HWS_GET_STATS,	0x610, sso_hws_get_stats, sso_info_req, sso_hws_stats)\
 M(SSO_HW_RELEASE_XAQ,	0x611, sso_hw_release_xaq_aura,			\
 				sso_release_xaq, msg_rsp)	\
+M(SSO_CONFIG_LSW,	0x612, ssow_config_lsw,			\
+				ssow_config_lsw, msg_rsp)	\
 /* TIM mbox IDs (range 0x800 - 0x9FF) */				\
 M(TIM_LF_ALLOC,		0x800, tim_lf_alloc,				\
 				tim_lf_alloc_req, tim_lf_alloc_rsp)	\
@@ -1249,6 +1251,7 @@ enum ssow_af_status {
 	SSOW_AF_ERR_PARAM	= -601,
 	SSOW_AF_ERR_LF_INVALID	= -602,
 	SSOW_AF_ERR_AF_LF_ALLOC	= -603,
+	SSOW_AF_ERR_INVALID_CFG	= -604,
 };
 
 struct ssow_lf_alloc_req {
@@ -1263,6 +1266,17 @@ struct ssow_lf_free_req {
 	u16 hws;
 };
 
+struct ssow_config_lsw {
+	struct mbox_msghdr hdr;
+#define SSOW_LSW_DIS		0
+#define SSOW_LSW_GW_WAIT	1
+#define SSOW_LSW_GW_IMM		2
+	u8 lsw_mode;
+#define SSOW_WQE_REL_LSW_WAIT	0
+#define SSOW_WQE_REL_IMM	1
+	u8 wqe_release;
+};
+
 struct sso_grp_qos_cfg {
 	struct mbox_msghdr hdr;
 	u16 grp;
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_sso.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_sso.c
index a7ee8353d778..6fe935c94b00 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_sso.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_sso.c
@@ -319,9 +319,9 @@ int rvu_sso_lf_teardown(struct rvu *rvu, u16 pcifunc, int lf, int slot)
 
 	/* Read hardware capabilities */
 	reg = rvu_read64(rvu, blkaddr, SSO_AF_CONST1);
-	has_lsw = reg & SSO_AF_CONST1_LSW_PRESENT;
-	has_nsched = !(reg & SSO_AF_CONST1_NO_NSCHED);
-	has_prefetch = reg & SSO_AF_CONST1_PRF_PRESENT;
+	has_lsw = !!(reg & SSO_AF_CONST1_LSW_PRESENT);
+	has_nsched = !!!(reg & SSO_AF_CONST1_NO_NSCHED);
+	has_prefetch = !!(reg & SSO_AF_CONST1_PRF_PRESENT);
 
 	/* Enable BAR2 ALIAS for this pcifunc. */
 	reg = BIT_ULL(16) | pcifunc;
@@ -598,8 +598,8 @@ int rvu_ssow_lf_teardown(struct rvu *rvu, u16 pcifunc, int lf, int slot)
 
 	/* Read hardware capabilities */
 	reg = rvu_read64(rvu, blkaddr, SSO_AF_CONST1);
-	has_lsw = reg & SSO_AF_CONST1_LSW_PRESENT;
-	has_prefetch = reg & SSO_AF_CONST1_PRF_PRESENT;
+	has_lsw = !!(reg & SSO_AF_CONST1_LSW_PRESENT);
+	has_prefetch = !!(reg & SSO_AF_CONST1_PRF_PRESENT);
 
 	/* Enable BAR2 alias access. */
 	reg = BIT_ULL(16) | pcifunc;
@@ -1115,6 +1115,52 @@ int rvu_mbox_handler_ssow_lf_free(struct rvu *rvu,
 	return 0;
 }
 
+int rvu_mbox_handler_ssow_config_lsw(struct rvu *rvu,
+				     struct ssow_config_lsw *req,
+				     struct msg_rsp *rsp)
+{
+	int num_lfs, ssowlf, hws, blkaddr;
+	struct rvu_hwinfo *hw = rvu->hw;
+	u16 pcifunc = req->hdr.pcifunc;
+	struct rvu_block *block;
+	bool has_lsw;
+	u64 val;
+
+	blkaddr = rvu_get_blkaddr(rvu, BLKTYPE_SSOW, pcifunc);
+	if (blkaddr < 0)
+		return SSOW_AF_ERR_LF_INVALID;
+
+	block = &hw->block[blkaddr];
+
+	num_lfs = rvu_get_rsrc_mapcount(rvu_get_pfvf(rvu, pcifunc),
+					block->addr);
+	if (!num_lfs)
+		return SSOW_AF_ERR_LF_INVALID;
+
+	/* SSO HWS LSW config registers are part of SSO AF */
+	blkaddr = rvu_get_blkaddr(rvu, BLKTYPE_SSO, pcifunc);
+	if (blkaddr < 0)
+		return SSO_AF_ERR_LF_INVALID;
+
+	val = rvu_read64(rvu, blkaddr, SSO_AF_CONST1);
+	has_lsw = !!(val & SSO_AF_CONST1_LSW_PRESENT);
+
+	if (!has_lsw || req->lsw_mode > SSOW_LSW_GW_IMM ||
+	    req->wqe_release > SSOW_WQE_REL_IMM)
+		return SSOW_AF_ERR_INVALID_CFG;
+
+	for (hws = 0; hws < num_lfs; hws++) {
+		ssowlf = rvu_get_lf(rvu, block, pcifunc, hws);
+		if (ssowlf < 0)
+			return SSOW_AF_ERR_LF_INVALID;
+		val = req->wqe_release << 2;
+		val |= req->lsw_mode;
+		rvu_write64(rvu, blkaddr, SSO_AF_HWSX_LSW_CFG(ssowlf), val);
+	}
+
+	return 0;
+}
+
 static int rvu_sso_do_register_interrupt(struct rvu *rvu, int irq_offs,
 					 irq_handler_t handler,
 					 const char *name)
-- 
2.31.1

