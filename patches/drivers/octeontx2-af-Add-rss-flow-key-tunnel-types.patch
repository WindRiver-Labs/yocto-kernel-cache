From 8d281f6b380ce901cad28cbb16036e3bfe66f269 Mon Sep 17 00:00:00 2001
From: Kiran Kumar K <kirankumark@marvell.com>
Date: Fri, 29 Mar 2019 13:10:44 +0530
Subject: [PATCH 134/767] octeontx2-af: Add rss flow key tunnel types

commit e8a7a7911c82494b9488d332e65292478e4174d8 from
git@git.assembla.com:cavium/WindRiver.linux.git

This pacth will add support to use UDP data for flow key hash
index calculation when user enable tunnel protocols like VXLAN,
GENEVE and GTPU.
The ideas is to consider only VNI values, when user specify
tunnel protocols like VXLAN, GENEVE, GTPU without UDP for flow
key alg. If your specifiy UDP also along with tunnel protocols,
then consider UDP data also for flow key hash index calculation.

With this patch we have added support for tunnel ptotocols like
VXLAN, GENEVE, GTPU.

The new flags can be used in the following way for alg index
calculation.
IPV4 + VXLAN ==> IPV4 + VXLAN(VNI) will be used.
IPV4 + UDP + VXLAN ==> IPV4 + UDP (non tunnel) + UDP_VXLAN(SPORT +
DPORT for tunnel) + VXLAN(VNI) will be used.
Same way it will be applied to all tunnel protocols.
IPV4 + GENEVE ==> IPV4 + GENEVE(VNI)
IPV4 + UDP + GENEVE ==> IPV4 + UDP + UDP_VXLAN(sport+dport)+
VXLAN(VNI)

Change-Id: I4394ae211d218c7ffc3413292bf6edc333f7d2d4
Signed-off-by: Kiran Kumar K <kirankumark@marvell.com>
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../net/ethernet/marvell/octeontx2/af/mbox.h  |  4 ++
 .../net/ethernet/marvell/octeontx2/af/npc.h   |  3 +
 .../ethernet/marvell/octeontx2/af/rvu_nix.c   | 66 +++++++++++++++----
 3 files changed, 61 insertions(+), 12 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/af/mbox.h b/drivers/net/ethernet/marvell/octeontx2/af/mbox.h
index 9865dad0c691..24a1ad902228 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/mbox.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/mbox.h
@@ -661,6 +661,10 @@ struct nix_rss_flowkey_cfg {
 #define NIX_FLOW_KEY_TYPE_GENEVE   BIT(8)
 #define NIX_FLOW_KEY_TYPE_ETH_DMAC BIT(9)
 #define NIX_FLOW_KEY_TYPE_IPV6_EXT BIT(10)
+#define NIX_FLOW_KEY_TYPE_GTPU       BIT(11)
+#define NIX_FLOW_KEY_TYPE_UDP_VXLAN  BIT(12)
+#define NIX_FLOW_KEY_TYPE_UDP_GENEVE BIT(13)
+#define NIX_FLOW_KEY_TYPE_UDP_GTPU   BIT(14)
 	u32	flowkey_cfg; /* Flowkey types selected */
 	u8	group;       /* RSS context or group */
 };
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/npc.h b/drivers/net/ethernet/marvell/octeontx2/af/npc.h
index c61acba70d42..2dc5a6f726ba 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/npc.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/npc.h
@@ -57,6 +57,9 @@ enum npc_kpu_lc_ltype {
 /* Don't modify Ltypes upto SCTP, otherwise it will
  * effect flow tag calculation and thus RSS.
  */
+/* Dont change values of UDP_VXLAN(12) and UDP_GENEVE(13), otherwise it
+ * will effect flow tag calculation and thus RSS
+ */
 enum npc_kpu_ld_ltype {
 	NPC_LT_LD_TCP = 1,
 	NPC_LT_LD_UDP,
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c
index bba1a58a496c..3c0f5f738053 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c
@@ -2287,6 +2287,7 @@ static int set_flowkey_fields(struct nix_rx_flowkey_alg *alg, u32 flow_cfg)
 	struct nix_rx_flowkey_alg *field;
 	struct nix_rx_flowkey_alg tmp;
 	u32 key_type, valid_key;
+	u8 udp_tu_data;
 
 	if (!alg)
 		return -EINVAL;
@@ -2315,6 +2316,7 @@ static int set_flowkey_fields(struct nix_rx_flowkey_alg *alg, u32 flow_cfg)
 
 	keyoff_marker = 0; max_key_off = 0; group_member = 0;
 	nr_field = 0; key_off = 0; field_marker = 1;
+	udp_tu_data = 0;
 	field = &tmp; max_bit_pos = fls(flow_cfg);
 	for (idx = 0;
 	     idx < max_bit_pos && nr_field < FIELDS_PER_ALG &&
@@ -2325,13 +2327,13 @@ static int set_flowkey_fields(struct nix_rx_flowkey_alg *alg, u32 flow_cfg)
 		if (field_marker)
 			memset(&tmp, 0, sizeof(tmp));
 
+		field_marker = true;
+		keyoff_marker = true;
 		switch (key_type) {
 		case NIX_FLOW_KEY_TYPE_PORT:
 			field->sel_chan = true;
 			/* This should be set to 1, when SEL_CHAN is set */
 			field->bytesm1 = 1;
-			field_marker = true;
-			keyoff_marker = true;
 			break;
 		case NIX_FLOW_KEY_TYPE_IPV4:
 			field->lid = NPC_LID_LC;
@@ -2339,7 +2341,6 @@ static int set_flowkey_fields(struct nix_rx_flowkey_alg *alg, u32 flow_cfg)
 			field->hdr_offset = 12; /* SIP offset */
 			field->bytesm1 = 7; /* SIP + DIP, 8 bytes */
 			field->ltype_mask = 0xF; /* Match only IPv4 */
-			field_marker = true;
 			keyoff_marker = false;
 			break;
 		case NIX_FLOW_KEY_TYPE_IPV6:
@@ -2348,8 +2349,6 @@ static int set_flowkey_fields(struct nix_rx_flowkey_alg *alg, u32 flow_cfg)
 			field->hdr_offset = 8; /* SIP offset */
 			field->bytesm1 = 31; /* SIP + DIP, 32 bytes */
 			field->ltype_mask = 0xF; /* Match only IPv6 */
-			field_marker = true;
-			keyoff_marker = true;
 			break;
 		case NIX_FLOW_KEY_TYPE_TCP:
 		case NIX_FLOW_KEY_TYPE_UDP:
@@ -2377,8 +2376,6 @@ static int set_flowkey_fields(struct nix_rx_flowkey_alg *alg, u32 flow_cfg)
 					valid_key = true;
 					group_member = false;
 				}
-				field_marker = true;
-				keyoff_marker = true;
 			} else {
 				field_marker = false;
 				keyoff_marker = false;
@@ -2390,7 +2387,6 @@ static int set_flowkey_fields(struct nix_rx_flowkey_alg *alg, u32 flow_cfg)
 			field->lid = NPC_LID_LD;
 			field->bytesm1 = 2;
 			field->ltype_mask = 0xF;
-			field_marker = true;
 			keyoff_marker = false;
 			if (key_type == NIX_FLOW_KEY_TYPE_NVGRE && valid_key) {
 				field->hdr_offset = 4; /* VSID offset */
@@ -2418,8 +2414,6 @@ static int set_flowkey_fields(struct nix_rx_flowkey_alg *alg, u32 flow_cfg)
 			field->bytesm1 = 5; /* DMAC 6 Byte */
 			field->ltype_match = NPC_LT_LA_ETHER;
 			field->ltype_mask = 0xF;
-			field_marker = true;
-			keyoff_marker = true;
 			break;
 		case NIX_FLOW_KEY_TYPE_IPV6_EXT:
 			field->lid = NPC_LID_LC;
@@ -2427,8 +2421,56 @@ static int set_flowkey_fields(struct nix_rx_flowkey_alg *alg, u32 flow_cfg)
 			field->bytesm1 = 0; /* 1 Byte ext hdr*/
 			field->ltype_match = NPC_LT_LC_IP6_EXT;
 			field->ltype_mask = 0xF;
-			field_marker = true;
-			keyoff_marker = true;
+			break;
+		case NIX_FLOW_KEY_TYPE_GTPU:
+			field->lid = NPC_LID_LD;
+			field->hdr_offset = 12; /* UDP + hdr */
+			field->bytesm1 = 3; /* 4 bytes VNI*/
+			field->ltype_match = NPC_LT_LD_UDP_GTPU;
+			field->ltype_mask = 0xF;
+			break;
+		case NIX_FLOW_KEY_TYPE_UDP_VXLAN:
+		case NIX_FLOW_KEY_TYPE_UDP_GENEVE:
+			field->lid = NPC_LID_LD;
+			field->hdr_offset = 0; /* UDP data */
+			field->bytesm1 = 3; /* 4 bytes SPORT +  DPORT*/
+			field->ltype_mask = 0xF;
+			field_marker = false;
+			keyoff_marker = false;
+			BUILD_BUG_ON(NPC_LT_LD_UDP_VXLAN != 12);
+			BUILD_BUG_ON(NPC_LT_LD_UDP_GENEVE != 13);
+			/* Only VXLAN enabled */
+			if (key_type == NIX_FLOW_KEY_TYPE_UDP_VXLAN &&
+			    valid_key) {
+				field->ltype_match |= NPC_LT_LD_UDP_VXLAN;
+				udp_tu_data |= (1 << 0);
+			}
+
+			/* Only GENEVE enabled */
+			if (key_type == NIX_FLOW_KEY_TYPE_UDP_GENEVE &&
+			    valid_key) {
+				field->ltype_match |= NPC_LT_LD_UDP_GENEVE;
+				udp_tu_data |= (1 << 1);
+			}
+
+			if (key_type == NIX_FLOW_KEY_TYPE_UDP_GENEVE) {
+				valid_key = true;
+				field_marker = true;
+				keyoff_marker = true;
+				/* Both VXLAN and GENEVE enabled, just
+				 * update the ltype mask to match both
+				 * VXLAN and GENEVE
+				 */
+				if (udp_tu_data == 0x3)
+					field->ltype_mask = 0xE;
+			}
+			break;
+		case NIX_FLOW_KEY_TYPE_UDP_GTPU:
+			field->lid = NPC_LID_LD;
+			field->hdr_offset = 0; /* UDP data */
+			field->bytesm1 = 3; /* 4 bytes SPORT +  DPORT*/
+			field->ltype_match = NPC_LT_LD_UDP_GTPU;
+			field->ltype_mask = 0xF;
 			break;
 		}
 		field->ena = 1;
-- 
2.31.1

