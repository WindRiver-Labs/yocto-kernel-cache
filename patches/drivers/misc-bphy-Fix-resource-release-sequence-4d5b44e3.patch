From 80eaba37afc671328e09e19881b023109b7a319d Mon Sep 17 00:00:00 2001
From: Jakub Palider <jpalider@marvell.com>
Date: Wed, 24 Mar 2021 05:37:13 +0530
Subject: [PATCH 1342/1921] misc: bphy: Fix resource release sequence

Dynamically allocated structures were freed during first interrupt
cleanup cycle. When the same procedure was requested from another
context these object were no longer present which caused hard
page faults. Moving the cleanup to exit call resolves
this problem.
In order to keep allocation/deallocation symmetry related
resources from now are acquired in init().

Signed-off-by: Jakub Palider <jpalider@marvell.com>
Change-Id: I3dc931c3bdff3297018ae3c76bbf2b68e710c508
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/48954
Reviewed-by: Radha Chintakuntla <radhac@marvell.com>
Reviewed-by: Sunil Kovvuri Goutham <SunilKovvuri.Goutham@cavium.com>
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 drivers/misc/otx_bphy_ctr.c | 45 ++++++++++++++++++++-----------------
 1 file changed, 25 insertions(+), 20 deletions(-)

diff --git a/drivers/misc/otx_bphy_ctr.c b/drivers/misc/otx_bphy_ctr.c
index 3c9ce8a77261..3db28714de55 100644
--- a/drivers/misc/otx_bphy_ctr.c
+++ b/drivers/misc/otx_bphy_ctr.c
@@ -204,30 +204,10 @@ static void cleanup_el3_irqs(struct task_struct *task)
 					 i);
 		}
 	}
-
-	kfree(irq_installed);
-	kfree(irq_installed_threads);
-	kfree(irq_installed_tasks);
 }
 
 static int otx_dev_open(struct inode *inode, struct file *fp)
 {
-	struct arm_smccc_res res;
-
-	arm_smccc_smc(OCTEONTX_GET_BPHY_PSM_IRQS_BITMASK, 0,
-		      0, 0, 0, 0, 0, 0, &res);
-	bphy_irq_bmask = res.a0;
-
-	arm_smccc_smc(OCTEONTX_GET_BPHY_PSM_MAX_IRQ, 0,
-		      0, 0, 0, 0, 0, 0, &res);
-	bphy_max_irq = res.a0;
-
-	irq_installed = kcalloc(bphy_max_irq, sizeof(int), GFP_KERNEL);
-	irq_installed_threads = (struct thread_info **)
-		kcalloc(bphy_max_irq, sizeof(struct thread_info *), GFP_KERNEL);
-	irq_installed_tasks = (struct task_struct **)
-		kcalloc(bphy_max_irq, sizeof(struct task_struct *), GFP_KERNEL);
-
 	in_use = 1;
 	return 0;
 }
@@ -236,6 +216,7 @@ static int otx_dev_release(struct inode *inode, struct file *fp)
 {
 	if (in_use == 0)
 		return -EINVAL;
+
 	in_use = 0;
 	return 0;
 }
@@ -249,6 +230,7 @@ static const struct file_operations fops = {
 
 static int __init otx_ctr_dev_init(void)
 {
+	struct arm_smccc_res res;
 	int err = 0;
 
 	/* create a character device */
@@ -293,8 +275,27 @@ static int __init otx_ctr_dev_init(void)
 		goto cleanup_handler_err;
 	}
 
+	arm_smccc_smc(OCTEONTX_GET_BPHY_PSM_MAX_IRQ, 0,
+		      0, 0, 0, 0, 0, 0, &res);
+	bphy_max_irq = res.a0;
+
+	irq_installed = kcalloc(bphy_max_irq, sizeof(int), GFP_KERNEL);
+	irq_installed_threads = (struct thread_info **)
+		kcalloc(bphy_max_irq, sizeof(struct thread_info *), GFP_KERNEL);
+	irq_installed_tasks = (struct task_struct **)
+		kcalloc(bphy_max_irq, sizeof(struct task_struct *), GFP_KERNEL);
+	if (!irq_installed || !irq_installed_threads || !irq_installed_tasks) {
+		err = -ENOMEM;
+		goto alloc_err;
+	}
+
 	return err;
 
+alloc_err:
+	kfree(irq_installed);
+	kfree(irq_installed_threads);
+	kfree(irq_installed_tasks);
+
 device_create_err:
 	class_destroy(otx_class);
 
@@ -317,6 +318,10 @@ static void __exit otx_ctr_dev_exit(void)
 	unregister_chrdev_region(otx_dev, 1);
 
 	task_cleanup_handler_remove(cleanup_el3_irqs);
+
+	kfree(irq_installed);
+	kfree(irq_installed_threads);
+	kfree(irq_installed_tasks);
 }
 
 module_init(otx_ctr_dev_init);
-- 
2.31.1

