From 28301a8ea79f72031aa43975a27debb3ff547dde Mon Sep 17 00:00:00 2001
From: Peter Swain <pswain@cavium.com>
Date: Mon, 26 Aug 2019 12:19:02 -0700
Subject: [PATCH 0421/1921] mmc: cavium: reorganize before vqmmc switching

Code motion to allow the upcoming vqmmc-switching commit
to fit nicely. No change to actual operation, except to
correct  several IS_ERR() to IS_ERR_OR_NULL() which
would have segfaulted in the NULL case.

The do_switch() & cvm_mmc_switch_to() functions were
becoming unwieldly, and about to become more so, when
vqmmc-switching is introduced.

- mode_switch() does the low level EMM_MMC_SWITCH change
- pre_switch() prepares for a slot switch, notes if it's
  needed
- post_switch() performs final actions, if a slot switch
  was needed

Some code has moved from cvm_mmc_switch_to() to do_switch()
and now happens on every invocation, including probe-time,
but will have no effect on post-probe runtime

Change-Id: If21c93ea11f18bcffe79796cc7ff29e45bdf3e96
Signed-off-by: Peter Swain <pswain@cavium.com>
Signed-off-by: Sujeet Baranwal <sbaranwal@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/14923
Reviewed-by: Sujeet Kumar Baranwal <Sujeet.Baranwal@cavium.com>
Tested-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/26916
Reviewed-by: Chandrakala Chavva <cchavva@marvell.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 .../devicetree/bindings/mmc/cavium-mmc.txt    |  10 +-
 drivers/mmc/host/cavium.c                     | 102 +++++++++++-------
 drivers/mmc/host/cavium.h                     |   3 +-
 3 files changed, 71 insertions(+), 44 deletions(-)

diff --git a/Documentation/devicetree/bindings/mmc/cavium-mmc.txt b/Documentation/devicetree/bindings/mmc/cavium-mmc.txt
index 1433e6201dff..4404ea40675b 100644
--- a/Documentation/devicetree/bindings/mmc/cavium-mmc.txt
+++ b/Documentation/devicetree/bindings/mmc/cavium-mmc.txt
@@ -17,8 +17,8 @@ Required properties:
  - clocks : phandle
 
 Optional properties:
- - for cd, bus-width and additional generic mmc parameters
-   please refer to mmc.txt within this directory
+ - for cd, bus-width, vmmc-supply, vqmmc-supply, and additional generic
+   mmc parameters please refer to mmc.txt within this directory
  - cavium,cmd-clk-skew : number of coprocessor clocks before sampling command
  - cavium,dat-clk-skew : number of coprocessor clocks before sampling data
 
@@ -40,7 +40,8 @@ Examples:
 			compatible = "mmc-slot";
 			reg = <0>;
 			vmmc-supply = <&mmc_supply_3v3>;
-			max-frequency = <42000000>;
+			vqmmc-supply = <&vqmmc_3v3>;
+			max-frequency = <52000000>;
 			bus-width = <4>;
 			cap-sd-highspeed;
 		};
@@ -49,7 +50,8 @@ Examples:
 			compatible = "mmc-slot";
 			reg = <1>;
 			vmmc-supply = <&mmc_supply_3v3>;
-			max-frequency = <42000000>;
+			vqmmc-supply = <&vqmmc_1v8>;
+			max-frequency = <100000000>;
 			bus-width = <8>;
 			cap-mmc-highspeed;
 			non-removable;
diff --git a/drivers/mmc/host/cavium.c b/drivers/mmc/host/cavium.c
index f752056aff56..b2f93fec4d11 100644
--- a/drivers/mmc/host/cavium.c
+++ b/drivers/mmc/host/cavium.c
@@ -282,14 +282,14 @@ static void check_switch_errors(struct cvm_mmc_host *host)
 		dev_err(host->dev, "Switch bus width error\n");
 }
 
-static void clear_bus_id(u64 *reg)
+static inline void clear_bus_id(u64 *reg)
 {
 	u64 bus_id_mask = GENMASK_ULL(61, 60);
 
 	*reg &= ~bus_id_mask;
 }
 
-static void set_bus_id(u64 *reg, int bus_id)
+static inline void set_bus_id(u64 *reg, int bus_id)
 {
 	clear_bus_id(reg);
 	*reg |= FIELD_PREP(GENMASK(61, 60), bus_id);
@@ -300,43 +300,81 @@ static int get_bus_id(u64 reg)
 	return FIELD_GET(GENMASK_ULL(61, 60), reg);
 }
 
+/* save old slot details, switch power */
+static bool pre_switch(struct cvm_mmc_host *host, u64 emm_switch)
+{
+	int bus_id = get_bus_id(emm_switch);
+	struct cvm_mmc_slot *slot = host->slot[bus_id];
+	struct cvm_mmc_slot *old_slot;
+
+	if (host->last_slot == bus_id)
+		return false;
+
+	if (host->last_slot >= 0 && host->slot[host->last_slot]) {
+		old_slot = host->slot[host->last_slot];
+		old_slot->cached_switch =
+		    readq(host->base + MIO_EMM_SWITCH(host));
+		old_slot->cached_rca = readq(host->base + MIO_EMM_RCA(host));
+	}
+
+	host->last_slot = slot->bus_id;
+
+	return true;
+}
+
+static void post_switch(struct cvm_mmc_host *host, u64 emm_switch)
+{
+	int bus_id = get_bus_id(emm_switch);
+	struct cvm_mmc_slot *slot = host->slot[bus_id];
+
+	writeq(slot->cached_rca, host->base + MIO_EMM_RCA(host));
+}
+
+static inline void mode_switch(struct cvm_mmc_host *host, u64 emm_switch)
+{
+	u64 rsp_sts;
+	int retries = 100;
+
+	writeq(emm_switch, host->base + MIO_EMM_SWITCH(host));
+
+	/* wait for the switch to finish */
+	do {
+		rsp_sts = readq(host->base + MIO_EMM_RSP_STS(host));
+		if (!(rsp_sts & MIO_EMM_RSP_STS_SWITCH_VAL))
+			break;
+		udelay(10);
+	} while (--retries);
+}
+
 /*
  * We never set the switch_exe bit since that would interfere
  * with the commands send by the MMC core.
  */
 static void do_switch(struct cvm_mmc_host *host, u64 emm_switch)
 {
-	int retries = 100;
-	u64 rsp_sts;
 	int bus_id = get_bus_id(emm_switch);
 	struct cvm_mmc_slot *slot = host->slot[bus_id];
+	bool slot_changed = pre_switch(host, emm_switch);
 
 	/*
 	 * Modes setting only taken from slot 0. Work around that hardware
 	 * issue by first switching to slot 0.
 	 */
 	if (bus_id) {
-		clear_bus_id(&emm_switch);
-		writeq(emm_switch, host->base + MIO_EMM_SWITCH(host));
-		set_bus_id(&emm_switch, bus_id);
+		u64 switch0 = emm_switch;
+
+		clear_bus_id(&switch0);
+		mode_switch(host, switch0);
 	}
-	writeq(emm_switch, host->base + MIO_EMM_SWITCH(host));
 
-	/* wait for the switch to finish */
-	do {
-		rsp_sts = readq(host->base + MIO_EMM_RSP_STS(host));
-		if (!(rsp_sts & MIO_EMM_RSP_STS_SWITCH_VAL))
-			break;
-		udelay(10);
-	} while (--retries);
+	mode_switch(host, emm_switch);
 
 	check_switch_errors(host);
-
-	if (slot) {
-		if (emm_switch & MIO_EMM_SWITCH_CLK)
-			slot->cmd6_pending = false;
-		slot->cached_switch = emm_switch;
-	}
+	if (slot_changed)
+		post_switch(host, emm_switch);
+	slot->cached_switch = emm_switch;
+	if (emm_switch & MIO_EMM_SWITCH_CLK)
+		slot->cmd6_pending = false;
 }
 
 /* need to change hardware state to match software requirements? */
@@ -406,27 +444,15 @@ static void cvm_mmc_reset_bus(struct cvm_mmc_slot *slot)
 static void cvm_mmc_switch_to(struct cvm_mmc_slot *slot)
 {
 	struct cvm_mmc_host *host = slot->host;
-	struct cvm_mmc_slot *old_slot;
-	u64 emm_switch;
 
 	if (slot->bus_id == host->last_slot)
 		return;
 
-	if (host->last_slot >= 0 && host->slot[host->last_slot]) {
-		old_slot = host->slot[host->last_slot];
-		old_slot->cached_switch = readq(host->base + MIO_EMM_SWITCH(host));
-		old_slot->cached_rca = readq(host->base + MIO_EMM_RCA(host));
-	}
-
-	writeq(slot->cached_rca, host->base + MIO_EMM_RCA(host));
-	emm_switch = slot->cached_switch;
-
-	do_switch(host, emm_switch);
+	do_switch(host, slot->cached_switch);
 	host->powered = true;
 
 	emmc_io_drive_setup(slot);
 	cvm_mmc_configure_delay(slot);
-	host->last_slot = slot->bus_id;
 }
 
 static void do_read(struct cvm_mmc_slot *slot, struct mmc_request *req,
@@ -1302,7 +1328,7 @@ static void cvm_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 			cvm_mmc_reset_bus(slot);
 			if (host->global_pwr_gpiod)
 				host->set_shared_power(host, 0);
-			else if (!IS_ERR(mmc->supply.vmmc))
+			else if (!IS_ERR_OR_NULL(mmc->supply.vmmc))
 				mmc_regulator_set_ocr(mmc, mmc->supply.vmmc, 0);
 			host->powered = false;
 		}
@@ -1316,7 +1342,7 @@ static void cvm_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 	if (ios->power_mode == MMC_POWER_UP) {
 		if (host->global_pwr_gpiod)
 			host->set_shared_power(host, 1);
-		else if (!IS_ERR(mmc->supply.vmmc))
+		else if (!IS_ERR_OR_NULL(mmc->supply.vmmc))
 			mmc_regulator_set_ocr(mmc, mmc->supply.vmmc, ios->vdd);
 	}
 
@@ -1545,7 +1571,7 @@ static int cvm_mmc_init_lowlevel(struct cvm_mmc_slot *slot)
 	struct cvm_mmc_host *host = slot->host;
 	u64 emm_switch;
 
-	/* Enable this bus slot. */
+	/* Enable this bus slot */
 	host->emm_cfg |= (1ull << slot->bus_id);
 	writeq(host->emm_cfg, slot->host->base + MIO_EMM_CFG(host));
 	udelay(10);
@@ -1608,7 +1634,7 @@ static int cvm_mmc_of_parse(struct device *dev, struct cvm_mmc_slot *slot)
 	 * Legacy Octeon firmware has no regulator entry, fall-back to
 	 * a hard-coded voltage to get a sane OCR.
 	 */
-	if (IS_ERR(mmc->supply.vmmc))
+	if (IS_ERR_OR_NULL(mmc->supply.vmmc))
 		mmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;
 
 	/* Common MMC bindings */
diff --git a/drivers/mmc/host/cavium.h b/drivers/mmc/host/cavium.h
index e757583d9848..532440460b28 100644
--- a/drivers/mmc/host/cavium.h
+++ b/drivers/mmc/host/cavium.h
@@ -109,8 +109,8 @@ struct cvm_mmc_host {
 	int sys_freq;
 
 	bool use_sg;
-
 	bool has_ciu3;
+	bool powered;
 	bool big_dma_addr;
 	bool need_irq_handler_lock;
 	spinlock_t irq_handler_lock;
@@ -118,7 +118,6 @@ struct cvm_mmc_host {
 
 	struct gpio_desc *global_pwr_gpiod;
 	atomic_t shared_power_users;
-	bool powered;
 
 	struct cvm_mmc_slot *slot[CAVIUM_MAX_MMC];
 	struct platform_device *slot_pdev[CAVIUM_MAX_MMC];
-- 
2.31.1

