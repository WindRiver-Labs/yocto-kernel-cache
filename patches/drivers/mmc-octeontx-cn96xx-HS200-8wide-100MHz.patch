From 20f752ee52ceaeab626e2f8eeab3c4c65725e9cd Mon Sep 17 00:00:00 2001
From: Peter Swain <pswain@cavium.com>
Date: Fri, 7 Jun 2019 14:52:27 -0700
Subject: [PATCH 234/767] mmc: octeontx: cn96xx HS200-8wide-100MHz

commit c436079b271f5c10297b25d12fc699c180b4b3a9 from
git@git.assembla.com:cavium/WindRiver.linux.git

Force MIO_EMM_DEBUG[CLK_ON]=1 for cn96 A0 as workaround
for a clock issue under investigation. irq handler must
check for RSP_STS[DMA_PEND], if set, teardown hung
transfer with EMM_DMA[VAL,DAT_NULL]=1 and return, allowing
a subsequent irq to occur on completion. Added the delay
on switch cmd, a precaution while testing. Store otx2
timing taps in hw format.

Change-Id: I889a580351c3533680a160ed50c52034a7e7d629
Signed-off-by: Peter Swain <pswain@cavium.com>
Reviewed-by: Chandrakala Chavva <Chandrakala.Chavva@cavium.com>
Signed-off-by: Sujeet Baranwal <sbaranwal@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/8543
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Tested-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/mmc/host/cavium-thunderx.c |  8 ++-
 drivers/mmc/host/cavium.c          | 93 ++++++++++++++++++++++++------
 drivers/mmc/host/cavium.h          | 11 ++--
 3 files changed, 86 insertions(+), 26 deletions(-)

diff --git a/drivers/mmc/host/cavium-thunderx.c b/drivers/mmc/host/cavium-thunderx.c
index 2b38d4ac4074..7d236ac1dab4 100644
--- a/drivers/mmc/host/cavium-thunderx.c
+++ b/drivers/mmc/host/cavium-thunderx.c
@@ -162,7 +162,6 @@ static int thunder_mmc_probe(struct pci_dev *pdev,
 	host->need_irq_handler_lock = true;
 	host->last_slot = -1;
 
-	ret = dma_set_mask(dev, DMA_BIT_MASK(48));
 	if (ret)
 		goto error;
 
@@ -170,8 +169,8 @@ static int thunder_mmc_probe(struct pci_dev *pdev,
 	 * Clear out any pending interrupts that may be left over from
 	 * bootloader. Writing 1 to the bits clears them.
 	 */
-	writeq(127, host->base + MIO_EMM_INT(host));
-	writeq(3, host->base + MIO_EMM_DMA_INT_ENA_W1C(host));
+	writeq(0x1ff, host->base + MIO_EMM_INT(host));
+	writeq(0x1ff, host->base + MIO_EMM_DMA_INT_ENA_W1C(host));
 	/* Clear DMA FIFO */
 	writeq(BIT_ULL(16), host->base + MIO_EMM_DMA_FIFO_CFG(host));
 
@@ -198,12 +197,15 @@ static int thunder_mmc_probe(struct pci_dev *pdev,
 			if (!host->slot_pdev[i])
 				continue;
 
+			dev_info(dev, "Probing slot %d\n", i);
+
 			ret = cvm_mmc_of_slot_probe(&host->slot_pdev[i]->dev, host);
 			if (ret)
 				goto error;
 		}
 		i++;
 	}
+
 	dev_info(dev, "probed\n");
 	return 0;
 
diff --git a/drivers/mmc/host/cavium.c b/drivers/mmc/host/cavium.c
index 818f87e83efe..b9c3c2a0c191 100644
--- a/drivers/mmc/host/cavium.c
+++ b/drivers/mmc/host/cavium.c
@@ -38,6 +38,8 @@ const char *cvm_mmc_irq_names[] = {
 	"MMC Switch Error",
 	"MMC DMA int Fifo",
 	"MMC DMA int",
+	"MMC NCB Fault",
+	"MMC RAS",
 };
 
 /*
@@ -325,7 +327,9 @@ static void do_switch(struct cvm_mmc_host *host, u64 emm_switch)
 static bool switch_val_changed(struct cvm_mmc_slot *slot, u64 new_val)
 {
 	/* Match BUS_ID, HS_TIMING, BUS_WIDTH, POWER_CLASS, CLK_HI, CLK_LO */
-	u64 match = 0x3001070fffffffffull;
+	/* For 9xxx add HS200_TIMING and HS400_TIMING */
+	u64 match = (is_mmc_otx2(slot->host)) ?
+		0x3007070fffffffffull : 0x3001070fffffffffull;
 
 	if (!slot->host->powered)
 		return true;
@@ -390,7 +394,7 @@ static void cvm_mmc_switch_to(struct cvm_mmc_slot *slot)
 {
 	struct cvm_mmc_host *host = slot->host;
 	struct cvm_mmc_slot *old_slot;
-	u64 emm_sample, emm_switch;
+	u64 emm_switch;
 
 	if (slot->bus_id == host->last_slot)
 		return;
@@ -403,14 +407,10 @@ static void cvm_mmc_switch_to(struct cvm_mmc_slot *slot)
 
 	writeq(slot->cached_rca, host->base + MIO_EMM_RCA(host));
 	emm_switch = slot->cached_switch;
-	set_bus_id(&emm_switch, slot->bus_id);
+
 	do_switch(host, emm_switch);
 	host->powered = true;
 
-	emm_sample = FIELD_PREP(MIO_EMM_SAMPLE_CMD_CNT, slot->cmd_cnt) |
-		     FIELD_PREP(MIO_EMM_SAMPLE_DAT_CNT, slot->data_cnt);
-	writeq(emm_sample, host->base + MIO_EMM_SAMPLE(host));
-
 	emmc_io_drive_setup(slot);
 	cvm_mmc_configure_delay(slot);
 	host->last_slot = slot->bus_id;
@@ -539,7 +539,8 @@ static int check_status(u64 rsp_sts)
 	if (rsp_sts & MIO_EMM_RSP_STS_RSP_TIMEOUT ||
 	    rsp_sts & MIO_EMM_RSP_STS_BLK_TIMEOUT)
 		return -ETIMEDOUT;
-	if (rsp_sts & MIO_EMM_RSP_STS_DBUF_ERR)
+	if (rsp_sts & MIO_EMM_RSP_STS_DBUF_ERR ||
+	    rsp_sts & MIO_EMM_RSP_STS_BLK_CRC_ERR)
 		return -EIO;
 	return 0;
 }
@@ -581,6 +582,16 @@ irqreturn_t cvm_mmc_interrupt(int irq, void *dev_id)
 		goto out;
 
 	rsp_sts = readq(host->base + MIO_EMM_RSP_STS(host));
+
+	/*
+	 * dma_pend means DMA has stalled with CRC errs.
+	 * start teardown, get irq on completion, mmc stack retries.
+	 */
+	if ((rsp_sts & MIO_EMM_RSP_STS_DMA_PEND) && host->dma_active) {
+		cleanup_dma(host, rsp_sts);
+		goto out;
+	}
+
 	/*
 	 * dma_val set means DMA is still in progress. Don't touch
 	 * the request and wait for the interrupt indicating that
@@ -737,9 +748,9 @@ static u64 prepare_dma_sg(struct cvm_mmc_host *host, struct mmc_data *data)
 
 error:
 	WARN_ON_ONCE(1);
-	dma_unmap_sg(host->dev, data->sg, data->sg_len, get_dma_dir(data));
 	/* Disable FIFO */
 	writeq(BIT_ULL(16), host->dma_base + MIO_EMM_DMA_FIFO_CFG(host));
+	dma_unmap_sg(host->dev, data->sg, data->sg_len, get_dma_dir(data));
 	return 0;
 }
 
@@ -968,6 +979,9 @@ static void cvm_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq)
 	if (!retries)
 		dev_err(host->dev, "Bad status: %llx before command write\n", rsp_sts);
 	writeq(emm_cmd, host->base + MIO_EMM_CMD(host));
+	if (cmd->opcode == MMC_SWITCH)
+		udelay(1300);
+
 }
 
 static u32 max_supported_frequency(struct cvm_mmc_host *host)
@@ -991,8 +1005,8 @@ static void cvm_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 	struct cvm_mmc_slot *slot = mmc_priv(mmc);
 	struct cvm_mmc_host *host = slot->host;
 	int clk_period = 0, power_class = 10, bus_width = 0;
+	u64 clock, emm_switch, mode;
 	u32 max_f;
-	u64 clock, emm_switch;
 
 	if (ios->power_mode == MMC_POWER_OFF) {
 		if (host->powered) {
@@ -1031,8 +1045,17 @@ static void cvm_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 	}
 
 	/* DDR is available for 4/8 bit bus width */
-	if (ios->bus_width && ios->timing == MMC_TIMING_MMC_DDR52)
-		bus_width |= 4;
+	switch (ios->timing) {
+	case MMC_TIMING_UHS_DDR50:
+	case MMC_TIMING_MMC_DDR52:
+		if (ios->bus_width)
+			bus_width |= 4;
+		break;
+	case MMC_TIMING_MMC_HS400:
+		if (ios->bus_width & 2)
+			bus_width |= 4;
+		break;
+	}
 
 	/* Change the clock frequency. */
 	clock = ios->clock;
@@ -1046,21 +1069,55 @@ static void cvm_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 	if (clock)
 		clk_period = (host->sys_freq + clock - 1) / (2 * clock);
 
-	emm_switch = FIELD_PREP(MIO_EMM_SWITCH_HS_TIMING,
-				(ios->timing == MMC_TIMING_MMC_HS)) |
+	emm_switch =
 		     FIELD_PREP(MIO_EMM_SWITCH_BUS_WIDTH, bus_width) |
 		     FIELD_PREP(MIO_EMM_SWITCH_POWER_CLASS, power_class) |
 		     FIELD_PREP(MIO_EMM_SWITCH_CLK_HI, clk_period) |
 		     FIELD_PREP(MIO_EMM_SWITCH_CLK_LO, clk_period);
+	switch (ios->timing) {
+	case MMC_TIMING_LEGACY:
+		break;
+	case MMC_TIMING_MMC_HS:
+	case MMC_TIMING_SD_HS:
+		emm_switch |= FIELD_PREP(MIO_EMM_SWITCH_HS_TIMING, 1);
+		break;
+	case MMC_TIMING_UHS_SDR12:
+	case MMC_TIMING_UHS_SDR25:
+	case MMC_TIMING_UHS_SDR50:
+	case MMC_TIMING_UHS_SDR104:
+	case MMC_TIMING_MMC_HS200:
+		emm_switch |= FIELD_PREP(MIO_EMM_SWITCH_HS200_TIMING, 1);
+		break;
+	case MMC_TIMING_UHS_DDR50:
+	case MMC_TIMING_MMC_DDR52:
+	case MMC_TIMING_MMC_HS400:
+		emm_switch |= FIELD_PREP(MIO_EMM_SWITCH_HS400_TIMING, 1);
+		break;
+	}
 	set_bus_id(&emm_switch, slot->bus_id);
 
+	pr_debug("mmc-slot%d trying switch %llx w%lld hs%lld hs200:%lld hs400:%lld\n",
+		slot->bus_id, emm_switch,
+		FIELD_GET(MIO_EMM_SWITCH_BUS_WIDTH, emm_switch),
+		FIELD_GET(MIO_EMM_SWITCH_HS_TIMING, emm_switch),
+		FIELD_GET(MIO_EMM_SWITCH_HS200_TIMING, emm_switch),
+		FIELD_GET(MIO_EMM_SWITCH_HS400_TIMING, emm_switch));
+
 	if (!switch_val_changed(slot, emm_switch))
 		goto out;
 
 	set_wdog(slot, 0);
 	do_switch(host, emm_switch);
+
+	mode = readq(host->base + MIO_EMM_MODE(host, slot->bus_id));
+	pr_debug("mmc-slot%d mode %llx w%lld hs%lld hs200:%lld hs400:%lld\n",
+		slot->bus_id, mode,
+		(mode >> 40) & 7, (mode >> 48) & 1,
+		(mode >> 49) & 1, (mode >> 50) & 1);
+
 	slot->cached_switch = emm_switch;
 	host->powered = true;
+	cvm_mmc_configure_delay(slot);
 out:
 	host->release_bus(host);
 }
@@ -1158,7 +1215,7 @@ static int cvm_mmc_of_parse(struct device *dev, struct cvm_mmc_slot *slot)
 	if (ret)
 		return ret;
 
-	/* Set bus width */
+	/* Set bus width from obsolete properties, if unset */
 	if (!(mmc->caps & (MMC_CAP_8_BIT_DATA | MMC_CAP_4_BIT_DATA))) {
 		of_property_read_u32(node, "cavium,bus-max-width", &bus_width);
 		if (bus_width == 8)
@@ -1227,6 +1284,9 @@ int cvm_mmc_of_slot_probe(struct device *dev, struct cvm_mmc_host *host)
 	/* Set up host parameters */
 	mmc->ops = &cvm_mmc_ops;
 
+	mmc->caps |= MMC_CAP_ERASE | MMC_CAP_BUS_WIDTH_TEST;
+	mmc->caps |= MMC_CAP_CMD23 | MMC_CAP_POWER_OFF_CARD;
+
 	/*
 	 * We only have a 3.3v supply for slots, we cannot
 	 * support any of the UHS modes. We do support the
@@ -1235,9 +1295,6 @@ int cvm_mmc_of_slot_probe(struct device *dev, struct cvm_mmc_host *host)
 	 * Disable bounce buffers for max_segs = 1
 	 */
 
-	mmc->caps |= MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED |
-		MMC_CAP_ERASE | MMC_CAP_CMD23 | MMC_CAP_POWER_OFF_CARD;
-
 	if (!is_mmc_otx2(host))
 		mmc->caps |= MMC_CAP_3_3V_DDR;
 
diff --git a/drivers/mmc/host/cavium.h b/drivers/mmc/host/cavium.h
index 1ad1dfdd8f0c..707234eb4935 100644
--- a/drivers/mmc/host/cavium.h
+++ b/drivers/mmc/host/cavium.h
@@ -73,6 +73,7 @@
 
 /* register addresses */
 #define MIO_EMM_CFG(x)		(0x00 + x->reg_off)
+#define MIO_EMM_MODE(x, s)	(0x08 + 8*(s) + (x)->reg_off)
 /* octtx2 specific register */
 #define MIO_EMM_IO_CTL(x)	(0x40 + x->reg_off)
 #define MIO_EMM_SWITCH(x)	(0x48 + x->reg_off)
@@ -145,11 +146,8 @@ struct cvm_mmc_slot {
 	u64 cached_rca;
 
 	u64 taps;			/* otx2: MIO_EMM_TIMING */
-	unsigned int cmd_cnt;		/* sample cmd in delay */
-	unsigned int data_cnt;		/* sample data in delay */
-
-	unsigned int cmd_out_tap;	/* sample cmd out delay */
-	unsigned int data_out_tap;	/* sample data out delay */
+	unsigned int cmd_cnt;		/* otx: sample cmd in delay */
+	unsigned int data_cnt;		/* otx: sample data in delay */
 
 	int drive;			/* Current drive */
 	int slew;			/* clock skew */
@@ -225,6 +223,7 @@ struct cvm_mmc_cr_mods {
 #define MIO_EMM_TIMING_DATA_IN		GENMASK_ULL(21, 16)
 #define MIO_EMM_TIMING_DATA_OUT		GENMASK_ULL(5, 0)
 
+#define MIO_EMM_INT_NCB_RAS		BIT_ULL(8)
 #define MIO_EMM_INT_NCB_FLT		BIT_ULL(7)
 #define MIO_EMM_INT_SWITCH_ERR		BIT_ULL(6)
 #define MIO_EMM_INT_SWITCH_DONE		BIT_ULL(5)
@@ -266,6 +265,8 @@ struct cvm_mmc_cr_mods {
 #define MIO_EMM_SWITCH_ERR1		BIT_ULL(57)
 #define MIO_EMM_SWITCH_ERR2		BIT_ULL(56)
 #define MIO_EMM_SWITCH_HS_TIMING	BIT_ULL(48)
+#define MIO_EMM_SWITCH_HS200_TIMING	BIT_ULL(49)
+#define MIO_EMM_SWITCH_HS400_TIMING	BIT_ULL(50)
 #define MIO_EMM_SWITCH_BUS_WIDTH	GENMASK_ULL(42, 40)
 #define MIO_EMM_SWITCH_POWER_CLASS	GENMASK_ULL(35, 32)
 #define MIO_EMM_SWITCH_CLK_HI		GENMASK_ULL(31, 16)
-- 
2.31.1

