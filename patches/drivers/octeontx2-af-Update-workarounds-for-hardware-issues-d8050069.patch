From 248510fd705f342d062077eb0f530dea10923e91 Mon Sep 17 00:00:00 2001
From: Sunil Goutham <sgoutham@marvell.com>
Date: Fri, 7 Jun 2019 12:41:48 +0530
Subject: [PATCH 0201/1921] octeontx2-af: Update workarounds for hardware
 issues

Few hardware issues from 96xx A0 are not fixed in
95xx A0 silicon. This patch applies workarounds of
non fixed 96xx A0's hw issues to 95xx A0.

Change-Id: I8b0a3483a158c9b3c02c8ba5aee8cfa3a37c9e66
Signed-off-by: Sunil Goutham <sgoutham@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/10636
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Tested-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 .../net/ethernet/marvell/octeontx2/af/rvu.c   |  4 ++--
 .../net/ethernet/marvell/octeontx2/af/rvu.h   | 11 ++++++++-
 .../ethernet/marvell/octeontx2/af/rvu_fixes.c | 23 +++++++++++++++----
 .../ethernet/marvell/octeontx2/af/rvu_nix.c   | 12 ++--------
 .../ethernet/marvell/octeontx2/af/rvu_npc.c   |  4 ++--
 .../ethernet/marvell/octeontx2/af/rvu_sso.c   |  2 +-
 6 files changed, 36 insertions(+), 20 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu.c
index 8b4e140d96f3..0f4af69e72b4 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu.c
@@ -67,7 +67,7 @@ static void rvu_setup_hw_capabilities(struct rvu *rvu)
 	hw->cap.nix_shaping = true;
 	hw->cap.nix_tx_link_bp = true;
 
-	if ((is_rvu_9xxx_A0(rvu))) {
+	if (is_rvu_96xx_A0(rvu) || is_rvu_95xx_A0(rvu)) {
 		hw->cap.nix_fixed_txschq_mapping = true;
 		hw->cap.nix_txsch_per_cgx_lmac = 4;
 		hw->cap.nix_txsch_per_lbk_lmac = 132;
@@ -1049,7 +1049,7 @@ static int rvu_lookup_rsrc(struct rvu *rvu, struct rvu_block *block,
 {
 	u64 val;
 
-	if (block->type == BLKTYPE_TIM && is_rvu_9xxx_A0(rvu))
+	if (block->type == BLKTYPE_TIM && is_rvu_96xx_A0(rvu))
 		return rvu_lf_lookup_tim_errata(rvu, block, pcifunc, slot);
 
 	val = ((u64)pcifunc << 24) | (slot << 16) | (1ULL << 13);
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu.h b/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
index 01d8dc88c39d..9d977f55f89e 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
@@ -22,6 +22,7 @@
 
 /* Subsystem Device ID */
 #define PCI_SUBSYS_DEVID_96XX                  0xB200
+#define PCI_SUBSYS_DEVID_95XX                  0xB200
 
 /* PCI BAR nos */
 #define	PCI_AF_REG_BAR_NUM			0
@@ -471,7 +472,7 @@ static inline u64 rvupf_read64(struct rvu *rvu, u64 offset)
 	return readq(rvu->pfreg_base + offset);
 }
 
-static inline bool is_rvu_9xxx_A0(struct rvu *rvu)
+static inline bool is_rvu_96xx_A0(struct rvu *rvu)
 {
 	struct pci_dev *pdev = rvu->pdev;
 
@@ -479,6 +480,14 @@ static inline bool is_rvu_9xxx_A0(struct rvu *rvu)
 		(pdev->subsystem_device == PCI_SUBSYS_DEVID_96XX);
 }
 
+static inline bool is_rvu_95xx_A0(struct rvu *rvu)
+{
+	struct pci_dev *pdev = rvu->pdev;
+
+	return (pdev->revision == 0x10) &&
+		(pdev->subsystem_device == PCI_SUBSYS_DEVID_95XX);
+}
+
 /* Function Prototypes
  * RVU
  */
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_fixes.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_fixes.c
index 551ace87abcb..36c747a45682 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_fixes.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_fixes.c
@@ -883,7 +883,7 @@ static void rvu_nix_enable_internal_bp(struct rvu *rvu, int blkaddr)
 	 * CQ context. To avoid such condition, enable internal backpressure
 	 * with BP_TEST registers.
 	 */
-	if (is_rvu_9xxx_A0(rvu)) {
+	if (is_rvu_96xx_A0(rvu)) {
 		/* Enable internal backpressure on pipe_stg0 */
 		rvu_write64(rvu, blkaddr, NIX_AF_RQM_BP_TEST,
 			    BIT_ULL(51) | BIT_ULL(23) | BIT_ULL(22) | 0x100ULL);
@@ -898,9 +898,20 @@ int rvu_nix_fixes_init(struct rvu *rvu, struct nix_hw *nix_hw, int blkaddr)
 	int err;
 	u64 cfg;
 
-	if (!is_rvu_9xxx_A0(rvu))
+	if (!is_rvu_96xx_A0(rvu) && !is_rvu_95xx_A0(rvu))
 		return 0;
 
+	/* As per a HW errata in 96xx A0 silicon, NIX may corrupt
+	 * internal state when conditional clocks are turned off.
+	 * Hence enable them.
+	 */
+	if (is_rvu_95xx_A0(rvu))
+		rvu_write64(rvu, blkaddr, NIX_AF_CFG,
+			    rvu_read64(rvu, blkaddr, NIX_AF_CFG) | 0x40ULL);
+	else
+		rvu_write64(rvu, blkaddr, NIX_AF_CFG,
+			    rvu_read64(rvu, blkaddr, NIX_AF_CFG) | 0x5EULL);
+
 	/* Set chan/link to backpressure TL3 instead of TL2 */
 	rvu_write64(rvu, blkaddr, NIX_AF_PSE_CHANNEL_LEVEL, 0x01);
 
@@ -912,17 +923,21 @@ int rvu_nix_fixes_init(struct rvu *rvu, struct nix_hw *nix_hw, int blkaddr)
 	cfg &= ~BIT_ULL(15);
 	rvu_write64(rvu, blkaddr, NIX_AF_SQM_DBG_CTL_STATUS, cfg);
 
+	rvu_nix_enable_internal_bp(rvu, blkaddr);
+
+	if (!is_rvu_96xx_A0(rvu))
+		return 0;
+
 	err = rvu_nix_tx_stall_workaround_init(rvu, nix_hw, blkaddr);
 	if (err)
 		return err;
 
-	rvu_nix_enable_internal_bp(rvu, blkaddr);
 	return 0;
 }
 
 void rvu_nix_fixes_exit(struct rvu *rvu, struct nix_hw *nix_hw)
 {
-	if (!is_rvu_9xxx_A0(rvu))
+	if (!is_rvu_96xx_A0(rvu))
 		return;
 
 	rvu_nix_tx_stall_workaround_exit(rvu, nix_hw);
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c
index 6072829da473..41fe05d8097b 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c
@@ -131,10 +131,10 @@ static void nix_rx_sync(struct rvu *rvu, int blkaddr)
 	if (err)
 		dev_err(rvu->dev, "NIX RX software sync failed\n");
 
-	/* As per a HW errata in 9xxx A0 silicon, HW may clear SW_SYNC[ENA]
+	/* As per a HW errata in 96xx A0 silicon, HW may clear SW_SYNC[ENA]
 	 * bit too early. Hence wait for 50us more.
 	 */
-	if (is_rvu_9xxx_A0(rvu))
+	if (is_rvu_96xx_A0(rvu))
 		usleep_range(50, 60);
 }
 
@@ -3336,14 +3336,6 @@ int rvu_nix_init(struct rvu *rvu)
 		return 0;
 	block = &hw->block[blkaddr];
 
-	/* As per a HW errata in 9xxx A0 silicon, NIX may corrupt
-	 * internal state when conditional clocks are turned off.
-	 * Hence enable them.
-	 */
-	if (is_rvu_9xxx_A0(rvu))
-		rvu_write64(rvu, blkaddr, NIX_AF_CFG,
-			    rvu_read64(rvu, blkaddr, NIX_AF_CFG) | 0x5EULL);
-
 	/* Calibrate X2P bus to check if CGX/LBK links are fine */
 	err = nix_calibrate_x2p(rvu, blkaddr);
 	if (err)
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc.c
index 5e1416ea135b..b8d51ef7cebe 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc.c
@@ -1016,7 +1016,7 @@ static void npc_load_mkex_profile(struct rvu *rvu, int blkaddr)
 			 * parse nibble enable configuration has to be
 			 * identical for both Rx and Tx interfaces.
 			 */
-			if (is_rvu_9xxx_A0(rvu) &&
+			if (is_rvu_96xx_A0(rvu) &&
 			    mcam_kex->keyx_cfg[NIX_INTF_RX] !=
 			    mcam_kex->keyx_cfg[NIX_INTF_TX])
 				goto load_default;
@@ -1380,7 +1380,7 @@ int rvu_npc_init(struct rvu *rvu)
 	/* Due to an errata (35786) in A0 pass silicon, parse nibble enable
 	 * configuration has to be identical for both Rx and Tx interfaces.
 	 */
-	if (!is_rvu_9xxx_A0(rvu))
+	if (!is_rvu_96xx_A0(rvu))
 		nibble_ena = (1ULL << 19) - 1;
 	rvu_write64(rvu, blkaddr, NPC_AF_INTFX_KEX_CFG(NIX_INTF_TX),
 			((keyz & 0x3) << 32) | nibble_ena);
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_sso.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_sso.c
index 933412ccde99..b68137f015b2 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_sso.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_sso.c
@@ -377,7 +377,7 @@ int rvu_sso_lf_teardown(struct rvu *rvu, u16 pcifunc, int lf, int slot)
 	 * TAQ buffer used by HWGRP when HWGRP is reset. Use SW routine to
 	 * drain it manually.
 	 */
-	if (is_rvu_9xxx_A0(rvu))
+	if (is_rvu_96xx_A0(rvu))
 		rvu_sso_ggrp_taq_flush(rvu, pcifunc, lf, slot, ssow_lf, blkaddr,
 				       ssow_blkaddr);
 
-- 
2.31.1

