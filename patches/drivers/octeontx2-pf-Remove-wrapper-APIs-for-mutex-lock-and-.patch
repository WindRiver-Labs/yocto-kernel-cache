From 2b7fea3b4b50ead4aaef29aaf8f8be5d37efb3b3 Mon Sep 17 00:00:00 2001
From: Rakesh Babu <rsaladi2@marvell.com>
Date: Mon, 31 Aug 2020 15:43:12 +0530
Subject: [PATCH 637/767] octeontx2-pf: Remove wrapper APIs for mutex lock and
 unlock

commit 248395c2a7b3b99d3ad9b13d69d5182198bdc7c4 from
git@git.assembla.com:cavium/WindRiver.linux.git
This patch removes wrapper fn()s around mutex_init/lock/unlock.

Signed-off-by: Rakesh Babu <rsaladi2@marvell.com>
Change-Id: If52051eb0c65bbe34b03d56e1c9af045ca3ca701
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/35274
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
---
 .../marvell/octeontx2/nic/otx2_common.c       | 93 ++++++++++---------
 .../marvell/octeontx2/nic/otx2_common.h       | 15 ---
 .../marvell/octeontx2/nic/otx2_ethtool.c      | 31 ++++---
 .../marvell/octeontx2/nic/otx2_flows.c        | 74 +++++++--------
 .../ethernet/marvell/octeontx2/nic/otx2_pf.c  | 90 +++++++++---------
 .../ethernet/marvell/octeontx2/nic/otx2_ptp.c | 20 ++--
 .../marvell/octeontx2/nic/otx2_smqvf.c        | 26 +++---
 .../marvell/octeontx2/nic/otx2_txrx.c         |  6 +-
 .../ethernet/marvell/octeontx2/nic/otx2_vf.c  |  2 +-
 9 files changed, 173 insertions(+), 184 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.c
index 347ab28457a1..090b67fdb0c6 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.c
@@ -29,15 +29,15 @@ void otx2_update_lmac_stats(struct otx2_nic *pfvf)
 	if (!netif_running(pfvf->netdev))
 		return;
 
-	otx2_mbox_lock(&pfvf->mbox);
+	mutex_lock(&pfvf->mbox.lock);
 	req = otx2_mbox_alloc_msg_cgx_stats(&pfvf->mbox);
 	if (!req) {
-		otx2_mbox_unlock(&pfvf->mbox);
+		mutex_unlock(&pfvf->mbox.lock);
 		return;
 	}
 
 	otx2_sync_mbox_msg(&pfvf->mbox);
-	otx2_mbox_unlock(&pfvf->mbox);
+	mutex_unlock(&pfvf->mbox.lock);
 }
 
 void otx2_update_lmac_fec_stats(struct otx2_nic *pfvf)
@@ -46,14 +46,14 @@ void otx2_update_lmac_fec_stats(struct otx2_nic *pfvf)
 
 	if (!netif_running(pfvf->netdev))
 		return;
-	otx2_mbox_lock(&pfvf->mbox);
+	mutex_lock(&pfvf->mbox.lock);
 	req = otx2_mbox_alloc_msg_cgx_fec_stats(&pfvf->mbox);
 	if (!req) {
-		otx2_mbox_unlock(&pfvf->mbox);
+		mutex_unlock(&pfvf->mbox.lock);
 		return;
 	}
 	otx2_sync_mbox_msg(&pfvf->mbox);
-	otx2_mbox_unlock(&pfvf->mbox);
+	mutex_unlock(&pfvf->mbox.lock);
 }
 
 int otx2_update_rq_stats(struct otx2_nic *pfvf, int qidx)
@@ -131,17 +131,17 @@ int otx2_hw_set_mac_addr(struct otx2_nic *pfvf, u8 *mac)
 	struct nix_set_mac_addr *req;
 	int err;
 
-	otx2_mbox_lock(&pfvf->mbox);
+	mutex_lock(&pfvf->mbox.lock);
 	req = otx2_mbox_alloc_msg_nix_set_mac_addr(&pfvf->mbox);
 	if (!req) {
-		otx2_mbox_unlock(&pfvf->mbox);
+		mutex_unlock(&pfvf->mbox.lock);
 		return -ENOMEM;
 	}
 
 	ether_addr_copy(req->mac_addr, mac);
 
 	err = otx2_sync_mbox_msg(&pfvf->mbox);
-	otx2_mbox_unlock(&pfvf->mbox);
+	mutex_unlock(&pfvf->mbox.lock);
 	return err;
 }
 
@@ -153,27 +153,27 @@ static int otx2_hw_get_mac_addr(struct otx2_nic *pfvf,
 	struct msg_req *req;
 	int err;
 
-	otx2_mbox_lock(&pfvf->mbox);
+	mutex_lock(&pfvf->mbox.lock);
 	req = otx2_mbox_alloc_msg_nix_get_mac_addr(&pfvf->mbox);
 	if (!req) {
-		otx2_mbox_unlock(&pfvf->mbox);
+		mutex_unlock(&pfvf->mbox.lock);
 		return -ENOMEM;
 	}
 
 	err = otx2_sync_mbox_msg(&pfvf->mbox);
 	if (err) {
-		otx2_mbox_unlock(&pfvf->mbox);
+		mutex_unlock(&pfvf->mbox.lock);
 		return err;
 	}
 
 	msghdr = otx2_mbox_get_rsp(&pfvf->mbox.mbox, 0, &req->hdr);
-	if (!msghdr) {
-		otx2_mbox_unlock(&pfvf->mbox);
-		return -ENOMEM;
+	if (IS_ERR(msghdr)) {
+		mutex_unlock(&pfvf->mbox.lock);
+		return PTR_ERR(msghdr);
 	}
 	rsp = (struct nix_get_mac_addr_rsp *)msghdr;
 	ether_addr_copy(netdev->dev_addr, rsp->mac_addr);
-	otx2_mbox_unlock(&pfvf->mbox);
+	mutex_unlock(&pfvf->mbox.lock);
 
 	return 0;
 }
@@ -204,10 +204,10 @@ int otx2_hw_set_mtu(struct otx2_nic *pfvf, int mtu)
 	struct nix_frs_cfg *req;
 	int err;
 
-	otx2_mbox_lock(&pfvf->mbox);
+	mutex_lock(&pfvf->mbox.lock);
 	req = otx2_mbox_alloc_msg_nix_set_hw_frs(&pfvf->mbox);
 	if (!req) {
-		otx2_mbox_unlock(&pfvf->mbox);
+		mutex_unlock(&pfvf->mbox.lock);
 		return -ENOMEM;
 	}
 
@@ -216,7 +216,7 @@ int otx2_hw_set_mtu(struct otx2_nic *pfvf, int mtu)
 	req->maxlen = pfvf->max_frs;
 
 	err = otx2_sync_mbox_msg(&pfvf->mbox);
-	otx2_mbox_unlock(&pfvf->mbox);
+	mutex_unlock(&pfvf->mbox.lock);
 	return err;
 }
 
@@ -228,17 +228,20 @@ int otx2_config_pause_frm(struct otx2_nic *pfvf)
 	if (is_otx2_lbkvf(pfvf->pdev))
 		return 0;
 
-	otx2_mbox_lock(&pfvf->mbox);
+	mutex_lock(&pfvf->mbox.lock);
 	req = otx2_mbox_alloc_msg_cgx_cfg_pause_frm(&pfvf->mbox);
-	if (!req)
-		return -ENOMEM;
+	if (!req) {
+		err = -ENOMEM;
+		goto unlock;
+	}
 
 	req->rx_pause = !!(pfvf->flags & OTX2_FLAG_RX_PAUSE_ENABLED);
 	req->tx_pause = !!(pfvf->flags & OTX2_FLAG_TX_PAUSE_ENABLED);
 	req->set = 1;
 
 	err = otx2_sync_mbox_msg(&pfvf->mbox);
-	otx2_mbox_unlock(&pfvf->mbox);
+unlock:
+	mutex_unlock(&pfvf->mbox.lock);
 	return err;
 }
 
@@ -248,10 +251,10 @@ int otx2_set_flowkey_cfg(struct otx2_nic *pfvf)
 	struct nix_rss_flowkey_cfg *req;
 	int err;
 
-	otx2_mbox_lock(&pfvf->mbox);
+	mutex_lock(&pfvf->mbox.lock);
 	req = otx2_mbox_alloc_msg_nix_rss_flowkey_cfg(&pfvf->mbox);
 	if (!req) {
-		otx2_mbox_unlock(&pfvf->mbox);
+		mutex_unlock(&pfvf->mbox.lock);
 		return -ENOMEM;
 	}
 	req->mcam_index = -1; /* Default or reserved index */
@@ -259,7 +262,7 @@ int otx2_set_flowkey_cfg(struct otx2_nic *pfvf)
 	req->group = DEFAULT_RSS_CONTEXT_GROUP;
 
 	err = otx2_sync_mbox_msg(&pfvf->mbox);
-	otx2_mbox_unlock(&pfvf->mbox);
+	mutex_unlock(&pfvf->mbox.lock);
 	return err;
 }
 
@@ -270,7 +273,7 @@ int otx2_set_rss_table(struct otx2_nic *pfvf)
 	struct nix_aq_enq_req *aq;
 	int idx, err;
 
-	otx2_mbox_lock(mbox);
+	mutex_lock(&mbox->lock);
 	/* Get memory to put this msg */
 	for (idx = 0; idx < rss->rss_size; idx++) {
 		aq = otx2_mbox_alloc_msg_nix_aq_enq(mbox);
@@ -280,12 +283,12 @@ int otx2_set_rss_table(struct otx2_nic *pfvf)
 			 */
 			err = otx2_sync_mbox_msg(mbox);
 			if (err) {
-				otx2_mbox_unlock(mbox);
+				mutex_unlock(&mbox->lock);
 				return err;
 			}
 			aq = otx2_mbox_alloc_msg_nix_aq_enq(mbox);
 			if (!aq) {
-				otx2_mbox_unlock(mbox);
+				mutex_unlock(&mbox->lock);
 				return -ENOMEM;
 			}
 		}
@@ -298,7 +301,7 @@ int otx2_set_rss_table(struct otx2_nic *pfvf)
 		aq->op = NIX_AQ_INSTOP_INIT;
 	}
 	err = otx2_sync_mbox_msg(mbox);
-	otx2_mbox_unlock(mbox);
+	mutex_unlock(&mbox->lock);
 	return err;
 }
 
@@ -543,17 +546,17 @@ int otx2_txschq_stop(struct otx2_nic *pfvf)
 	struct nix_txsch_free_req *free_req;
 	int lvl, schq, err;
 
-	otx2_mbox_lock(&pfvf->mbox);
+	mutex_lock(&pfvf->mbox.lock);
 	/* Free the transmit schedulers */
 	free_req = otx2_mbox_alloc_msg_nix_txsch_free(&pfvf->mbox);
 	if (!free_req) {
-		otx2_mbox_unlock(&pfvf->mbox);
+		mutex_unlock(&pfvf->mbox.lock);
 		return -ENOMEM;
 	}
 
 	free_req->flags = TXSCHQ_FREE_ALL;
 	err = otx2_sync_mbox_msg(&pfvf->mbox);
-	otx2_mbox_unlock(&pfvf->mbox);
+	mutex_unlock(&pfvf->mbox.lock);
 
 	/* Clear the txschq list */
 	for (lvl = 0; lvl < NIX_TXSCH_LVL_CNT; lvl++) {
@@ -1254,10 +1257,10 @@ int otx2_detach_resources(struct mbox *mbox)
 {
 	struct rsrc_detach *detach;
 
-	otx2_mbox_lock(mbox);
+	mutex_lock(&mbox->lock);
 	detach = otx2_mbox_alloc_msg_detach_resources(mbox);
 	if (!detach) {
-		otx2_mbox_unlock(mbox);
+		mutex_unlock(&mbox->lock);
 		return -ENOMEM;
 	}
 
@@ -1266,7 +1269,7 @@ int otx2_detach_resources(struct mbox *mbox)
 
 	/* Send detach request to AF */
 	otx2_mbox_msg_send(&mbox->mbox, 0);
-	otx2_mbox_unlock(mbox);
+	mutex_unlock(&mbox->lock);
 	return 0;
 }
 EXPORT_SYMBOL(otx2_detach_resources);
@@ -1277,11 +1280,11 @@ int otx2_attach_npa_nix(struct otx2_nic *pfvf)
 	struct msg_req *msix;
 	int err;
 
-	otx2_mbox_lock(&pfvf->mbox);
+	mutex_lock(&pfvf->mbox.lock);
 	/* Get memory to put this msg */
 	attach = otx2_mbox_alloc_msg_attach_resources(&pfvf->mbox);
 	if (!attach) {
-		otx2_mbox_unlock(&pfvf->mbox);
+		mutex_unlock(&pfvf->mbox.lock);
 		return -ENOMEM;
 	}
 
@@ -1291,7 +1294,7 @@ int otx2_attach_npa_nix(struct otx2_nic *pfvf)
 	/* Send attach request to AF */
 	err = otx2_sync_mbox_msg(&pfvf->mbox);
 	if (err) {
-		otx2_mbox_unlock(&pfvf->mbox);
+		mutex_unlock(&pfvf->mbox.lock);
 		return err;
 	}
 
@@ -1306,16 +1309,16 @@ int otx2_attach_npa_nix(struct otx2_nic *pfvf)
 	/* Get NPA and NIX MSIX vector offsets */
 	msix = otx2_mbox_alloc_msg_msix_offset(&pfvf->mbox);
 	if (!msix) {
-		otx2_mbox_unlock(&pfvf->mbox);
+		mutex_unlock(&pfvf->mbox.lock);
 		return -ENOMEM;
 	}
 
 	err = otx2_sync_mbox_msg(&pfvf->mbox);
 	if (err) {
-		otx2_mbox_unlock(&pfvf->mbox);
+		mutex_unlock(&pfvf->mbox.lock);
 		return err;
 	}
-	otx2_mbox_unlock(&pfvf->mbox);
+	mutex_unlock(&pfvf->mbox.lock);
 
 	if (pfvf->hw.npa_msixoff == MSIX_VECTOR_INVALID ||
 	    pfvf->hw.nix_msixoff == MSIX_VECTOR_INVALID) {
@@ -1332,7 +1335,7 @@ void otx2_ctx_disable(struct mbox *mbox, int type, bool npa)
 {
 	struct hwctx_disable_req *req;
 
-	otx2_mbox_lock(mbox);
+	mutex_lock(&mbox->lock);
 	/* Request AQ to disable this context */
 	if (npa)
 		req = otx2_mbox_alloc_msg_npa_hwctx_disable(mbox);
@@ -1340,7 +1343,7 @@ void otx2_ctx_disable(struct mbox *mbox, int type, bool npa)
 		req = otx2_mbox_alloc_msg_nix_hwctx_disable(mbox);
 
 	if (!req) {
-		otx2_mbox_unlock(mbox);
+		mutex_unlock(&mbox->lock);
 		return;
 	}
 
@@ -1350,7 +1353,7 @@ void otx2_ctx_disable(struct mbox *mbox, int type, bool npa)
 		dev_err(mbox->pfvf->dev, "%s failed to disable context\n",
 			__func__);
 
-	otx2_mbox_unlock(mbox);
+	mutex_unlock(&mbox->lock);
 }
 
 int otx2_nix_config_bp(struct otx2_nic *pfvf, bool enable)
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h
index 1c99841b3978..e23839c90349 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h
@@ -468,21 +468,6 @@ static inline void otx2_sync_mbox_bbuf(struct otx2_mbox *mbox, int devid)
 	       hw_mbase + mbox->rx_start, msg_size + msgs_offset);
 }
 
-static inline void otx2_mbox_lock_init(struct mbox *mbox)
-{
-	mutex_init(&mbox->lock);
-}
-
-static inline void otx2_mbox_lock(struct mbox *mbox)
-{
-	mutex_lock(&mbox->lock);
-}
-
-static inline void otx2_mbox_unlock(struct mbox *mbox)
-{
-	mutex_unlock(&mbox->lock);
-}
-
 /* With the absence of API for 128-bit IO memory access for arm64,
  * implement required operations at place.
  */
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_ethtool.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_ethtool.c
index a48481f6ea7c..17b02bf62cff 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_ethtool.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_ethtool.c
@@ -232,7 +232,7 @@ static int otx2_get_phy_fec_stats(struct otx2_nic *pfvf)
 	struct msg_req *req;
 	int rc = -EAGAIN;
 
-	otx2_mbox_lock(&pfvf->mbox);
+	mutex_lock(&pfvf->mbox.lock);
 	req = otx2_mbox_alloc_msg_cgx_get_phy_fec_stats(&pfvf->mbox);
 	if (!req)
 		goto end;
@@ -240,7 +240,7 @@ static int otx2_get_phy_fec_stats(struct otx2_nic *pfvf)
 	if (!otx2_sync_mbox_msg(&pfvf->mbox))
 		rc = 0;
 end:
-	otx2_mbox_unlock(&pfvf->mbox);
+	mutex_unlock(&pfvf->mbox.lock);
 	return rc;
 }
 
@@ -1143,10 +1143,10 @@ static struct cgx_fw_data *otx2_get_fwdata(struct otx2_nic *pfvf)
 	struct msg_req *req;
 	int err = 0;
 
-	otx2_mbox_lock(&pfvf->mbox);
+	mutex_lock(&pfvf->mbox.lock);
 	req = otx2_mbox_alloc_msg_cgx_get_aux_link_info(&pfvf->mbox);
 	if (!req) {
-		otx2_mbox_unlock(&pfvf->mbox);
+		mutex_unlock(&pfvf->mbox.lock);
 		return ERR_PTR(-ENOMEM);
 	}
 
@@ -1158,7 +1158,7 @@ static struct cgx_fw_data *otx2_get_fwdata(struct otx2_nic *pfvf)
 		rsp = ERR_PTR(err);
 	}
 
-	otx2_mbox_unlock(&pfvf->mbox);
+	mutex_unlock(&pfvf->mbox.lock);
 	return rsp;
 }
 
@@ -1231,10 +1231,10 @@ static int otx2_set_link_ksettings(struct net_device *netdev,
 	struct cgx_set_link_mode_rsp *rsp;
 	int err = 0;
 
-	otx2_mbox_lock(&pfvf->mbox);
+	mutex_lock(&pfvf->mbox.lock);
 	req = otx2_mbox_alloc_msg_cgx_set_link_mode(&pfvf->mbox);
 	if (!req) {
-		otx2_mbox_unlock(&pfvf->mbox);
+		mutex_unlock(&pfvf->mbox.lock);
 		return -EAGAIN;
 	}
 
@@ -1243,7 +1243,7 @@ static int otx2_set_link_ksettings(struct net_device *netdev,
 	    (advertising <= BIT_ULL(ETHTOOL_LINK_MODE_10000baseLRM_Full_BIT))) {
 		req->args.mode = advertising;
 	} else {
-		otx2_mbox_unlock(&pfvf->mbox);
+		mutex_unlock(&pfvf->mbox.lock);
 		return -EINVAL;
 	}
 	err =  otx2_sync_mbox_msg(&pfvf->mbox);
@@ -1253,7 +1253,7 @@ static int otx2_set_link_ksettings(struct net_device *netdev,
 		if (rsp->status)
 			err =  rsp->status;
 	}
-	otx2_mbox_unlock(&pfvf->mbox);
+	mutex_unlock(&pfvf->mbox.lock);
 	return err;
 }
 
@@ -1318,7 +1318,7 @@ static int otx2_set_fecparam(struct net_device *netdev,
 	if (fec == pfvf->linfo.fec)
 		return 0;
 
-	otx2_mbox_lock(&pfvf->mbox);
+	mutex_lock(&pfvf->mbox.lock);
 	req = otx2_mbox_alloc_msg_cgx_set_fec_param(&pfvf->mbox);
 	if (!req) {
 		err = -EAGAIN;
@@ -1340,7 +1340,8 @@ static int otx2_set_fecparam(struct net_device *netdev,
 		err = rsp->fec;
 	}
 
-end:	otx2_mbox_unlock(&pfvf->mbox);
+end:
+	mutex_unlock(&pfvf->mbox.lock);
 	return err;
 }
 
@@ -1378,7 +1379,7 @@ static int otx2_set_phy_mod_type(struct net_device *netdev, bool enable)
 	if (!fwd->fwdata.phy.misc.can_change_mod_type)
 		return -EOPNOTSUPP;
 
-	otx2_mbox_lock(&pfvf->mbox);
+	mutex_lock(&pfvf->mbox.lock);
 	req = otx2_mbox_alloc_msg_cgx_set_phy_mod_type(&pfvf->mbox);
 	if (!req)
 		goto end;
@@ -1388,7 +1389,7 @@ static int otx2_set_phy_mod_type(struct net_device *netdev, bool enable)
 	if (!otx2_sync_mbox_msg(&pfvf->mbox))
 		rc = 0;
 end:
-	otx2_mbox_unlock(&pfvf->mbox);
+	mutex_unlock(&pfvf->mbox.lock);
 	return rc;
 }
 
@@ -1401,7 +1402,7 @@ int otx2_set_npc_parse_mode(struct otx2_nic *pfvf, bool unbind)
 	if (OTX2_IS_DEF_MODE_ENABLED(pfvf->ethtool_flags))
 		return 0;
 
-	otx2_mbox_lock(&pfvf->mbox);
+	mutex_lock(&pfvf->mbox.lock);
 	req = otx2_mbox_alloc_msg_npc_set_pkind(&pfvf->mbox);
 	if (!req)
 		goto end;
@@ -1435,7 +1436,7 @@ int otx2_set_npc_parse_mode(struct otx2_nic *pfvf, bool unbind)
 	else
 		pfvf->ethtool_flags &= ~interface_mode;
 end:
-	otx2_mbox_unlock(&pfvf->mbox);
+	mutex_unlock(&pfvf->mbox.lock);
 	return rc;
 }
 
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_flows.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_flows.c
index 3c97dda57715..0fdc19a87a10 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_flows.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_flows.c
@@ -76,15 +76,15 @@ int otx2_alloc_mcam_entries(struct otx2_nic *pfvf)
 	int vf_vlan_max_flows;
 	int i;
 
-	otx2_mbox_lock(&pfvf->mbox);
+	mutex_lock(&pfvf->mbox.lock);
 	if (pfvf->flags & OTX2_FLAG_MCAM_ENTRIES_ALLOC) {
-		otx2_mbox_unlock(&pfvf->mbox);
+		mutex_unlock(&pfvf->mbox.lock);
 		return 0;
 	}
 
 	req = otx2_mbox_alloc_msg_npc_mcam_alloc_entry(&pfvf->mbox);
 	if (!req) {
-		otx2_mbox_unlock(&pfvf->mbox);
+		mutex_unlock(&pfvf->mbox.lock);
 		return -ENOMEM;
 	}
 
@@ -94,7 +94,7 @@ int otx2_alloc_mcam_entries(struct otx2_nic *pfvf)
 
 	/* Send message to AF */
 	if (otx2_sync_mbox_msg(&pfvf->mbox)) {
-		otx2_mbox_unlock(&pfvf->mbox);
+		mutex_unlock(&pfvf->mbox.lock);
 		return -EINVAL;
 	}
 
@@ -129,7 +129,7 @@ int otx2_alloc_mcam_entries(struct otx2_nic *pfvf)
 		flow_cfg->entry[i] = rsp->entry_list[i];
 
 	pfvf->flags |= OTX2_FLAG_MCAM_ENTRIES_ALLOC;
-	otx2_mbox_unlock(&pfvf->mbox);
+	mutex_unlock(&pfvf->mbox.lock);
 
 	return 0;
 }
@@ -156,10 +156,10 @@ static int otx2_do_add_macfilter(struct otx2_nic *pf, const u8 *mac)
 	if (netdev_uc_count(pf->netdev) > OTX2_MAX_UNICAST_FLOWS)
 		return -ENOMEM;
 
-	otx2_mbox_lock(&pf->mbox);
+	mutex_lock(&pf->mbox.lock);
 	req = otx2_mbox_alloc_msg_npc_install_flow(&pf->mbox);
 	if (!req) {
-		otx2_mbox_unlock(&pf->mbox);
+		mutex_unlock(&pf->mbox.lock);
 		return -ENOMEM;
 	}
 
@@ -184,7 +184,7 @@ static int otx2_do_add_macfilter(struct otx2_nic *pf, const u8 *mac)
 	req->set_cntr = 1;
 
 	err = otx2_sync_mbox_msg(&pf->mbox);
-	otx2_mbox_unlock(&pf->mbox);
+	mutex_unlock(&pf->mbox.lock);
 
 	return err;
 }
@@ -230,16 +230,16 @@ int otx2_del_macfilter(struct net_device *netdev, const u8 *mac)
 	if (!otx2_get_mcamentry_for_mac(pf, mac, &mcam_entry))
 		return 0;
 
-	otx2_mbox_lock(&pf->mbox);
+	mutex_lock(&pf->mbox.lock);
 	req = otx2_mbox_alloc_msg_npc_delete_flow(&pf->mbox);
 	if (!req) {
-		otx2_mbox_unlock(&pf->mbox);
+		mutex_unlock(&pf->mbox.lock);
 		return -ENOMEM;
 	}
 	req->entry = mcam_entry;
 	/* Send message to AF */
 	err = otx2_sync_mbox_msg(&pf->mbox);
-	otx2_mbox_unlock(&pf->mbox);
+	mutex_unlock(&pf->mbox.lock);
 
 	return err;
 }
@@ -312,10 +312,10 @@ static int otx2_add_flow_msg(struct otx2_nic *pfvf, struct otx2_flow *flow)
 	struct npc_install_flow_req *req;
 	int err, vf = 0;
 
-	otx2_mbox_lock(&pfvf->mbox);
+	mutex_lock(&pfvf->mbox.lock);
 	req = otx2_mbox_alloc_msg_npc_install_flow(&pfvf->mbox);
 	if (!req) {
-		otx2_mbox_unlock(&pfvf->mbox);
+		mutex_unlock(&pfvf->mbox.lock);
 		return -ENOMEM;
 	}
 
@@ -323,7 +323,7 @@ static int otx2_add_flow_msg(struct otx2_nic *pfvf, struct otx2_flow *flow)
 	if (err) {
 		/* free the allocated msg above */
 		otx2_mbox_reset(&pfvf->mbox.mbox, 0);
-		otx2_mbox_unlock(&pfvf->mbox);
+		mutex_unlock(&pfvf->mbox.lock);
 		return err;
 	}
 
@@ -342,7 +342,7 @@ static int otx2_add_flow_msg(struct otx2_nic *pfvf, struct otx2_flow *flow)
 		req->index = ethtool_get_flow_spec_ring(ring_cookie);
 		vf = ethtool_get_flow_spec_ring_vf(ring_cookie);
 		if (vf > pci_num_vf(pfvf->pdev)) {
-			otx2_mbox_unlock(&pfvf->mbox);
+			mutex_unlock(&pfvf->mbox.lock);
 			return -EINVAL;
 		}
 	}
@@ -356,7 +356,7 @@ static int otx2_add_flow_msg(struct otx2_nic *pfvf, struct otx2_flow *flow)
 
 	/* Send message to AF */
 	err = otx2_sync_mbox_msg(&pfvf->mbox);
-	otx2_mbox_unlock(&pfvf->mbox);
+	mutex_unlock(&pfvf->mbox.lock);
 	return err;
 }
 
@@ -414,10 +414,10 @@ static int otx2_remove_flow_msg(struct otx2_nic *pfvf, u16 entry, bool all)
 	struct npc_delete_flow_req *req;
 	int err;
 
-	otx2_mbox_lock(&pfvf->mbox);
+	mutex_lock(&pfvf->mbox.lock);
 	req = otx2_mbox_alloc_msg_npc_delete_flow(&pfvf->mbox);
 	if (!req) {
-		otx2_mbox_unlock(&pfvf->mbox);
+		mutex_unlock(&pfvf->mbox.lock);
 		return -ENOMEM;
 	}
 
@@ -427,7 +427,7 @@ static int otx2_remove_flow_msg(struct otx2_nic *pfvf, u16 entry, bool all)
 
 	/* Send message to AF */
 	err = otx2_sync_mbox_msg(&pfvf->mbox);
-	otx2_mbox_unlock(&pfvf->mbox);
+	mutex_unlock(&pfvf->mbox.lock);
 	return err;
 }
 
@@ -465,10 +465,10 @@ int otx2_destroy_ntuple_flows(struct otx2_nic *pfvf)
 	if (!(pfvf->flags & OTX2_FLAG_MCAM_ENTRIES_ALLOC))
 		return 0;
 
-	otx2_mbox_lock(&pfvf->mbox);
+	mutex_lock(&pfvf->mbox.lock);
 	req = otx2_mbox_alloc_msg_npc_delete_flow(&pfvf->mbox);
 	if (!req) {
-		otx2_mbox_unlock(&pfvf->mbox);
+		mutex_unlock(&pfvf->mbox.lock);
 		return -ENOMEM;
 	}
 
@@ -476,7 +476,7 @@ int otx2_destroy_ntuple_flows(struct otx2_nic *pfvf)
 	req->end   = flow_cfg->entry[flow_cfg->ntuple_offset +
 				      flow_cfg->ntuple_max_flows - 1];
 	err = otx2_sync_mbox_msg(&pfvf->mbox);
-	otx2_mbox_unlock(&pfvf->mbox);
+	mutex_unlock(&pfvf->mbox.lock);
 
 	list_for_each_entry_safe(iter, tmp, &flow_cfg->flow_list, list) {
 		list_del(&iter->list);
@@ -507,10 +507,10 @@ int otx2_destroy_mcam_flows(struct otx2_nic *pfvf)
 		flow_cfg->nr_flows--;
 	}
 
-	otx2_mbox_lock(&pfvf->mbox);
+	mutex_lock(&pfvf->mbox.lock);
 	req = otx2_mbox_alloc_msg_npc_mcam_free_entry(&pfvf->mbox);
 	if (!req) {
-		otx2_mbox_unlock(&pfvf->mbox);
+		mutex_unlock(&pfvf->mbox.lock);
 		return -ENOMEM;
 	}
 
@@ -518,12 +518,12 @@ int otx2_destroy_mcam_flows(struct otx2_nic *pfvf)
 	/* Send message to AF to free MCAM entries */
 	err = otx2_sync_mbox_msg(&pfvf->mbox);
 	if (err) {
-		otx2_mbox_unlock(&pfvf->mbox);
+		mutex_unlock(&pfvf->mbox.lock);
 		return err;
 	}
 
 	pfvf->flags &= ~OTX2_FLAG_MCAM_ENTRIES_ALLOC;
-	otx2_mbox_unlock(&pfvf->mbox);
+	mutex_unlock(&pfvf->mbox.lock);
 
 	return 0;
 }
@@ -537,10 +537,10 @@ int otx2_install_rxvlan_offload_flow(struct otx2_nic *pfvf)
 	if (!(pfvf->flags & OTX2_FLAG_MCAM_ENTRIES_ALLOC))
 		return -ENOMEM;
 
-	otx2_mbox_lock(&pfvf->mbox);
+	mutex_lock(&pfvf->mbox.lock);
 	req = otx2_mbox_alloc_msg_npc_install_flow(&pfvf->mbox);
 	if (!req) {
-		otx2_mbox_unlock(&pfvf->mbox);
+		mutex_unlock(&pfvf->mbox.lock);
 		return -ENOMEM;
 	}
 
@@ -556,7 +556,7 @@ int otx2_install_rxvlan_offload_flow(struct otx2_nic *pfvf)
 
 	/* Send message to AF */
 	err = otx2_sync_mbox_msg(&pfvf->mbox);
-	otx2_mbox_unlock(&pfvf->mbox);
+	mutex_unlock(&pfvf->mbox.lock);
 	return err;
 }
 
@@ -566,17 +566,17 @@ static int otx2_delete_rxvlan_offload_flow(struct otx2_nic *pfvf)
 	struct npc_delete_flow_req *req;
 	int err;
 
-	otx2_mbox_lock(&pfvf->mbox);
+	mutex_lock(&pfvf->mbox.lock);
 	req = otx2_mbox_alloc_msg_npc_delete_flow(&pfvf->mbox);
 	if (!req) {
-		otx2_mbox_unlock(&pfvf->mbox);
+		mutex_unlock(&pfvf->mbox.lock);
 		return -ENOMEM;
 	}
 
 	req->entry = flow_cfg->entry[flow_cfg->rx_vlan_offset];
 	/* Send message to AF */
 	err = otx2_sync_mbox_msg(&pfvf->mbox);
-	otx2_mbox_unlock(&pfvf->mbox);
+	mutex_unlock(&pfvf->mbox.lock);
 	return err;
 }
 
@@ -604,10 +604,10 @@ int otx2_enable_rxvlan(struct otx2_nic *pf, bool enable)
 			return err;
 	}
 
-	otx2_mbox_lock(&pf->mbox);
+	mutex_lock(&pf->mbox.lock);
 	req = otx2_mbox_alloc_msg_nix_vtag_cfg(&pf->mbox);
 	if (!req) {
-		otx2_mbox_unlock(&pf->mbox);
+		mutex_unlock(&pf->mbox.lock);
 		return -ENOMEM;
 	}
 
@@ -620,16 +620,16 @@ int otx2_enable_rxvlan(struct otx2_nic *pf, bool enable)
 
 	err = otx2_sync_mbox_msg(&pf->mbox);
 	if (err) {
-		otx2_mbox_unlock(&pf->mbox);
+		mutex_unlock(&pf->mbox.lock);
 		return err;
 	}
 
 	rsp_hdr = otx2_mbox_get_rsp(&pf->mbox.mbox, 0, &req->hdr);
 	if (IS_ERR(rsp_hdr)) {
-		otx2_mbox_unlock(&pf->mbox);
+		mutex_unlock(&pf->mbox.lock);
 		return PTR_ERR(rsp_hdr);
 	}
 
-	otx2_mbox_unlock(&pf->mbox);
+	mutex_unlock(&pf->mbox.lock);
 	return rsp_hdr->rc;
 }
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c
index 35e0283a7f47..13d3e802778b 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c
@@ -101,16 +101,16 @@ static void otx2_flr_handler(struct work_struct *work)
 {
 	struct flr_work *flrwork = container_of(work, struct flr_work, work);
 	struct otx2_nic *pf = flrwork->pf;
+	struct mbox *mbox = &pf->mbox;
 	struct msg_req *req;
 	int vf, reg = 0;
 
 	vf = flrwork - pf->flr_wrk;
 
-
-	otx2_mbox_lock(&pf->mbox);
-	req = otx2_mbox_alloc_msg_vf_flr(&pf->mbox);
+	mutex_lock(&mbox->lock);
+	req = otx2_mbox_alloc_msg_vf_flr(mbox);
 	if (!req) {
-		otx2_mbox_unlock(&pf->mbox);
+		mutex_unlock(&mbox->lock);
 		return;
 	}
 	req->hdr.pcifunc &= RVU_PFVF_FUNC_MASK;
@@ -126,7 +126,7 @@ static void otx2_flr_handler(struct work_struct *work)
 		otx2_write64(pf, RVU_PF_VFFLR_INT_ENA_W1SX(reg), BIT_ULL(vf));
 	}
 
-	otx2_mbox_unlock(&pf->mbox);
+	mutex_unlock(&mbox->lock);
 }
 
 static irqreturn_t otx2_pf_flr_intr_handler(int irq, void *pf_irq)
@@ -381,7 +381,7 @@ static int otx2_forward_vf_mbox_msgs(struct otx2_nic *pf,
 
 		dst_mdev = &dst_mbox->mbox.dev[0];
 
-		otx2_mbox_lock(&pf->mbox);
+		mutex_lock(&pf->mbox.lock);
 		dst_mdev->mbase = src_mdev->mbase;
 		dst_mdev->msg_size = mbox_hdr->msg_size;
 		dst_mdev->num_msgs = num_msgs;
@@ -391,7 +391,7 @@ static int otx2_forward_vf_mbox_msgs(struct otx2_nic *pf,
 				 "AF not responding to VF%d messages\n", vf);
 			/* restore PF mbase and exit */
 			dst_mdev->mbase = pf->mbox.bbuf_base;
-			otx2_mbox_unlock(&pf->mbox);
+			mutex_unlock(&pf->mbox.lock);
 			return err;
 		}
 		/* At this point, all the VF messages sent to AF are acked
@@ -404,7 +404,7 @@ static int otx2_forward_vf_mbox_msgs(struct otx2_nic *pf,
 
 		otx2_forward_msg_pfvf(dst_mdev, &pf->mbox_pfvf[0].mbox,
 				      pf->mbox.bbuf_base, vf);
-		otx2_mbox_unlock(&pf->mbox);
+		mutex_unlock(&pf->mbox.lock);
 	} else if (dir == MBOX_DIR_PFVF_UP) {
 		src_mdev = &src_mbox->dev[0];
 		mbox_hdr = src_mbox->hwbase + src_mbox->rx_start;
@@ -1089,7 +1089,7 @@ static int otx2_pfaf_mbox_init(struct otx2_nic *pf)
 
 	INIT_WORK(&mbox->mbox_wrk, otx2_pfaf_mbox_handler);
 	INIT_WORK(&mbox->mbox_up_wrk, otx2_pfaf_mbox_up_handler);
-	otx2_mbox_lock_init(&pf->mbox);
+	mutex_init(&mbox->lock);
 
 	return 0;
 exit:
@@ -1102,19 +1102,19 @@ static int otx2_cgx_config_linkevents(struct otx2_nic *pf, bool enable)
 	struct msg_req *msg;
 	int err;
 
-	otx2_mbox_lock(&pf->mbox);
+	mutex_lock(&pf->mbox.lock);
 	if (enable)
 		msg = otx2_mbox_alloc_msg_cgx_start_linkevents(&pf->mbox);
 	else
 		msg = otx2_mbox_alloc_msg_cgx_stop_linkevents(&pf->mbox);
 
 	if (!msg) {
-		otx2_mbox_unlock(&pf->mbox);
+		mutex_unlock(&pf->mbox.lock);
 		return -ENOMEM;
 	}
 
 	err = otx2_sync_mbox_msg(&pf->mbox);
-	otx2_mbox_unlock(&pf->mbox);
+	mutex_unlock(&pf->mbox.lock);
 	return err;
 }
 
@@ -1123,19 +1123,19 @@ static int otx2_cgx_config_loopback(struct otx2_nic *pf, bool enable)
 	struct msg_req *msg;
 	int err;
 
-	otx2_mbox_lock(&pf->mbox);
+	mutex_lock(&pf->mbox.lock);
 	if (enable)
 		msg = otx2_mbox_alloc_msg_cgx_intlbk_enable(&pf->mbox);
 	else
 		msg = otx2_mbox_alloc_msg_cgx_intlbk_disable(&pf->mbox);
 
 	if (!msg) {
-		otx2_mbox_unlock(&pf->mbox);
+		mutex_unlock(&pf->mbox.lock);
 		return -ENOMEM;
 	}
 
 	err = otx2_sync_mbox_msg(&pf->mbox);
-	otx2_mbox_unlock(&pf->mbox);
+	mutex_unlock(&pf->mbox.lock);
 	return err;
 }
 
@@ -1336,7 +1336,7 @@ static int otx2_init_hw_resources(struct otx2_nic *pf)
 	pf->rbsize += OTX2_HW_TIMESTAMP_LEN + pf->addl_mtu + pf->xtra_hdr;
 	pf->rbsize = RCV_FRAG_LEN(pf->rbsize);
 
-	otx2_mbox_lock(mbox);
+	mutex_lock(&mbox->lock);
 	/* NPA init */
 	err = otx2_config_npa(pf);
 	if (err)
@@ -1353,35 +1353,35 @@ static int otx2_init_hw_resources(struct otx2_nic *pf)
 	/* Init Auras and pools used by NIX RQ, for free buffer ptrs */
 	err = otx2_rq_aura_pool_init(pf);
 	if (err) {
-		otx2_mbox_unlock(mbox);
+		mutex_unlock(&mbox->lock);
 		goto err_free_nix_lf;
 	}
 	/* Init Auras and pools used by NIX SQ, for queueing SQEs */
 	err = otx2_sq_aura_pool_init(pf);
 	if (err) {
-		otx2_mbox_unlock(mbox);
+		mutex_unlock(&mbox->lock);
 		goto err_free_rq_ptrs;
 	}
 
 	err = otx2_txsch_alloc(pf);
 	if (err) {
-		otx2_mbox_unlock(mbox);
+		mutex_unlock(&mbox->lock);
 		goto err_free_sq_ptrs;
 	}
 
 	err = otx2_config_nix_queues(pf);
 	if (err) {
-		otx2_mbox_unlock(mbox);
+		mutex_unlock(&mbox->lock);
 		goto err_free_txsch;
 	}
 	for (lvl = 0; lvl < NIX_TXSCH_LVL_CNT; lvl++) {
 		err = otx2_txschq_config(pf, lvl);
 		if (err) {
-			otx2_mbox_unlock(mbox);
+			mutex_unlock(&mbox->lock);
 			goto err_free_nix_queues;
 		}
 	}
-	otx2_mbox_unlock(mbox);
+	mutex_unlock(&mbox->lock);
 	return err;
 
 err_free_nix_queues:
@@ -1399,7 +1399,7 @@ static int otx2_init_hw_resources(struct otx2_nic *pf)
 	otx2_ctx_disable(mbox, NPA_AQ_CTYPE_AURA, true);
 	otx2_aura_pool_free(pf);
 err_free_nix_lf:
-	otx2_mbox_lock(mbox);
+	mutex_lock(&mbox->lock);
 	free_req = otx2_mbox_alloc_msg_nix_lf_free(mbox);
 	if (free_req) {
 		free_req->flags = NIX_LF_DISABLE_FLOWS;
@@ -1414,7 +1414,7 @@ static int otx2_init_hw_resources(struct otx2_nic *pf)
 			dev_err(pf->dev, "%s failed to free npalf\n", __func__);
 	}
 exit:
-	otx2_mbox_unlock(mbox);
+	mutex_unlock(&mbox->lock);
 	return err;
 }
 
@@ -1435,11 +1435,11 @@ static void otx2_free_hw_resources(struct otx2_nic *pf)
 	if (err)
 		dev_err(pf->dev, "RVUPF: Failed to stop/free TX schedulers\n");
 
-	otx2_mbox_lock(mbox);
+	mutex_lock(&mbox->lock);
 	/* Disable backpressure */
 	if (!(pf->pcifunc & RVU_PFVF_FUNC_MASK))
 		otx2_nix_config_bp(pf, false);
-	otx2_mbox_unlock(mbox);
+	mutex_unlock(&mbox->lock);
 
 	/* Disable RQs */
 	otx2_ctx_disable(mbox, NIX_AQ_CTYPE_RQ, false);
@@ -1460,7 +1460,7 @@ static void otx2_free_hw_resources(struct otx2_nic *pf)
 
 	otx2_free_cq_res(pf);
 
-	otx2_mbox_lock(mbox);
+	mutex_lock(&mbox->lock);
 	/* Reset NIX LF */
 	free_req = otx2_mbox_alloc_msg_nix_lf_free(mbox);
 	if (free_req) {
@@ -1470,21 +1470,21 @@ static void otx2_free_hw_resources(struct otx2_nic *pf)
 		if (otx2_sync_mbox_msg(mbox))
 			dev_err(pf->dev, "%s failed to free nixlf\n", __func__);
 	}
-	otx2_mbox_unlock(mbox);
+	mutex_unlock(&mbox->lock);
 
 	/* Disable NPA Pool and Aura hw context */
 	otx2_ctx_disable(mbox, NPA_AQ_CTYPE_POOL, true);
 	otx2_ctx_disable(mbox, NPA_AQ_CTYPE_AURA, true);
 	otx2_aura_pool_free(pf);
 
-	otx2_mbox_lock(mbox);
+	mutex_lock(&mbox->lock);
 	/* Reset NPA LF */
 	req = otx2_mbox_alloc_msg_npa_lf_free(mbox);
 	if (req) {
 		if (otx2_sync_mbox_msg(mbox))
 			dev_err(pf->dev, "%s failed to free npalf\n", __func__);
 	}
-	otx2_mbox_unlock(mbox);
+	mutex_unlock(&mbox->lock);
 }
 
 static netdev_tx_t otx2_xmit(struct sk_buff *skb, struct net_device *netdev)
@@ -1797,10 +1797,10 @@ void otx2_do_set_rx_mode(struct work_struct *work)
 	if (netdev->priv_flags & IFF_UNICAST_FLT)
 		__dev_uc_sync(netdev, otx2_add_macfilter, otx2_del_macfilter);
 
-	otx2_mbox_lock(&pf->mbox);
+	mutex_lock(&pf->mbox.lock);
 	req = otx2_mbox_alloc_msg_nix_set_rx_mode(&pf->mbox);
 	if (!req) {
-		otx2_mbox_unlock(&pf->mbox);
+		mutex_unlock(&pf->mbox.lock);
 		return;
 	}
 
@@ -1812,7 +1812,7 @@ void otx2_do_set_rx_mode(struct work_struct *work)
 		req->mode |= NIX_RX_MODE_ALLMULTI;
 
 	otx2_sync_mbox_msg(&pf->mbox);
-	otx2_mbox_unlock(&pf->mbox);
+	mutex_unlock(&pf->mbox.lock);
 }
 
 static void otx2_reset_task(struct work_struct *work)
@@ -1857,23 +1857,23 @@ static int otx2_config_hw_rx_tstamp(struct otx2_nic *pfvf, bool enable)
 	if (pfvf->flags & OTX2_FLAG_RX_TSTAMP_ENABLED && enable)
 		return 0;
 
-	otx2_mbox_lock(&pfvf->mbox);
+	mutex_lock(&pfvf->mbox.lock);
 	if (enable)
 		req = otx2_mbox_alloc_msg_cgx_ptp_rx_enable(&pfvf->mbox);
 	else
 		req = otx2_mbox_alloc_msg_cgx_ptp_rx_disable(&pfvf->mbox);
 	if (!req) {
-		otx2_mbox_unlock(&pfvf->mbox);
+		mutex_unlock(&pfvf->mbox.lock);
 		return -ENOMEM;
 	}
 
 	err = otx2_sync_mbox_msg(&pfvf->mbox);
 	if (err) {
-		otx2_mbox_unlock(&pfvf->mbox);
+		mutex_unlock(&pfvf->mbox.lock);
 		return err;
 	}
 
-	otx2_mbox_unlock(&pfvf->mbox);
+	mutex_unlock(&pfvf->mbox.lock);
 	if (enable)
 		pfvf->flags |= OTX2_FLAG_RX_TSTAMP_ENABLED;
 	else
@@ -1889,23 +1889,23 @@ static int otx2_config_hw_tx_tstamp(struct otx2_nic *pfvf, bool enable)
 	if (pfvf->flags & OTX2_FLAG_TX_TSTAMP_ENABLED && enable)
 		return 0;
 
-	otx2_mbox_lock(&pfvf->mbox);
+	mutex_lock(&pfvf->mbox.lock);
 	if (enable)
 		req = otx2_mbox_alloc_msg_nix_lf_ptp_tx_enable(&pfvf->mbox);
 	else
 		req = otx2_mbox_alloc_msg_nix_lf_ptp_tx_disable(&pfvf->mbox);
 	if (!req) {
-		otx2_mbox_unlock(&pfvf->mbox);
+		mutex_unlock(&pfvf->mbox.lock);
 		return -ENOMEM;
 	}
 
 	err = otx2_sync_mbox_msg(&pfvf->mbox);
 	if (err) {
-		otx2_mbox_unlock(&pfvf->mbox);
+		mutex_unlock(&pfvf->mbox.lock);
 		return err;
 	}
 
-	otx2_mbox_unlock(&pfvf->mbox);
+	mutex_unlock(&pfvf->mbox.lock);
 	if (enable)
 		pfvf->flags |= OTX2_FLAG_TX_TSTAMP_ENABLED;
 	else
@@ -1985,7 +1985,7 @@ static int otx2_do_set_vf_mac(struct otx2_nic *pf, int vf, const u8 *mac)
 	struct npc_install_flow_req *req;
 	int err;
 
-	otx2_mbox_lock(&pf->mbox);
+	mutex_lock(&pf->mbox.lock);
 	req = otx2_mbox_alloc_msg_npc_install_flow(&pf->mbox);
 	if (!req) {
 		err = -ENOMEM;
@@ -2004,7 +2004,7 @@ static int otx2_do_set_vf_mac(struct otx2_nic *pf, int vf, const u8 *mac)
 
 	err = otx2_sync_mbox_msg(&pf->mbox);
 out:
-	otx2_mbox_unlock(&pf->mbox);
+	mutex_unlock(&pf->mbox.lock);
 	return err;
 }
 
@@ -2051,7 +2051,7 @@ int otx2_do_set_vf_vlan(struct otx2_nic *pf, int vf, u16 vlan, u8 qos,
 	if (!vlan && !config->vlan)
 		goto out;
 
-	otx2_mbox_lock(&pf->mbox);
+	mutex_lock(&pf->mbox.lock);
 
 	/* free old tx vtag entry */
 	if (config->vlan) {
@@ -2175,7 +2175,7 @@ int otx2_do_set_vf_vlan(struct otx2_nic *pf, int vf, u16 vlan, u8 qos,
 	config->rule.qos	= qos;
 out:
 	config->vlan = vlan;
-	otx2_mbox_unlock(&pf->mbox);
+	mutex_unlock(&pf->mbox.lock);
 	return err;
 }
 
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_ptp.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_ptp.c
index 01a6961afc93..5b82e84897e5 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_ptp.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_ptp.c
@@ -68,9 +68,9 @@ static int otx2_ptp_adjtime(struct ptp_clock_info *ptp_info, s64 delta)
 	struct otx2_ptp *ptp = container_of(ptp_info, struct otx2_ptp,
 					    ptp_info);
 
-	otx2_mbox_lock(&ptp->nic->mbox);
+	mutex_lock(&ptp->nic->mbox.lock);
 	timecounter_adjtime(&ptp->time_counter, delta);
-	otx2_mbox_unlock(&ptp->nic->mbox);
+	mutex_unlock(&ptp->nic->mbox.lock);
 
 	return 0;
 }
@@ -82,9 +82,9 @@ static int otx2_ptp_gettime(struct ptp_clock_info *ptp_info,
 					    ptp_info);
 	u64 nsec;
 
-	otx2_mbox_lock(&ptp->nic->mbox);
+	mutex_lock(&ptp->nic->mbox.lock);
 	nsec = timecounter_read(&ptp->time_counter);
-	otx2_mbox_unlock(&ptp->nic->mbox);
+	mutex_unlock(&ptp->nic->mbox.lock);
 
 	*ts = ns_to_timespec64(nsec);
 
@@ -100,9 +100,9 @@ static int otx2_ptp_settime(struct ptp_clock_info *ptp_info,
 
 	nsec = timespec64_to_ns(ts);
 
-	otx2_mbox_lock(&ptp->nic->mbox);
+	mutex_lock(&ptp->nic->mbox.lock);
 	timecounter_init(&ptp->time_counter, &ptp->cycle_counter, nsec);
-	otx2_mbox_unlock(&ptp->nic->mbox);
+	mutex_unlock(&ptp->nic->mbox.lock);
 
 	return 0;
 }
@@ -120,11 +120,11 @@ int otx2_ptp_init(struct otx2_nic *pfvf)
 	struct ptp_req *req;
 	int err;
 
-	otx2_mbox_lock(&pfvf->mbox);
+	mutex_lock(&pfvf->mbox.lock);
 	/* check if PTP block is available */
 	req = otx2_mbox_alloc_msg_ptp_op(&pfvf->mbox);
 	if (!req) {
-		otx2_mbox_unlock(&pfvf->mbox);
+		mutex_unlock(&pfvf->mbox.lock);
 		return -ENOMEM;
 	}
 
@@ -132,10 +132,10 @@ int otx2_ptp_init(struct otx2_nic *pfvf)
 
 	err = otx2_sync_mbox_msg(&pfvf->mbox);
 	if (err) {
-		otx2_mbox_unlock(&pfvf->mbox);
+		mutex_unlock(&pfvf->mbox.lock);
 		return err;
 	}
-	otx2_mbox_unlock(&pfvf->mbox);
+	mutex_unlock(&pfvf->mbox.lock);
 
 	ptp_ptr = kzalloc(sizeof(*ptp_ptr), GFP_KERNEL);
 	if (!ptp_ptr) {
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_smqvf.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_smqvf.c
index 4f5f73f621d4..7f94acd2549e 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_smqvf.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_smqvf.c
@@ -152,11 +152,11 @@ static int otx2smqvf_install_flow(struct otx2_nic *vf)
 			goto err_free_mem;
 	}
 
-	otx2_mbox_lock(&vf->mbox);
+	mutex_lock(&vf->mbox.lock);
 
 	alloc_req = otx2_mbox_alloc_msg_npc_mcam_alloc_entry(&vf->mbox);
 	if (!alloc_req) {
-		otx2_mbox_unlock(&vf->mbox);
+		mutex_unlock(&vf->mbox.lock);
 		goto err_free_mem;
 	}
 	alloc_req->count = 1;
@@ -165,22 +165,22 @@ static int otx2smqvf_install_flow(struct otx2_nic *vf)
 	/* Send message to AF */
 	if (otx2_sync_mbox_msg(&vf->mbox)) {
 		err = -EINVAL;
-		otx2_mbox_unlock(&vf->mbox);
+		mutex_unlock(&vf->mbox.lock);
 		goto err_free_mem;
 	}
-	otx2_mbox_unlock(&vf->mbox);
+	mutex_unlock(&vf->mbox.lock);
 
 	rsp = (struct npc_mcam_alloc_entry_rsp *)otx2_mbox_get_rsp
 	       (&vf->mbox.mbox, 0, &alloc_req->hdr);
 	drop_entry = rsp->entry;
 
-	otx2_mbox_lock(&vf->mbox);
+	mutex_lock(&vf->mbox.lock);
 
 	/* Send messages to drop Tx packets at NPC and stop Rx traffic */
 	install_req = otx2_mbox_alloc_msg_npc_install_flow(&vf->mbox);
 	if (!install_req) {
 		err = -ENOMEM;
-		otx2_mbox_unlock(&vf->mbox);
+		mutex_unlock(&vf->mbox.lock);
 		goto err_free_entry;
 	}
 
@@ -193,24 +193,24 @@ static int otx2smqvf_install_flow(struct otx2_nic *vf)
 
 	msg = otx2_mbox_alloc_msg_nix_lf_stop_rx(&vf->mbox);
 	if (!msg) {
-		otx2_mbox_unlock(&vf->mbox);
+		mutex_unlock(&vf->mbox.lock);
 		goto err_free_entry;
 	}
 
 	/* Send message to AF */
 	if (otx2_sync_mbox_msg(&vf->mbox)) {
 		err = -EINVAL;
-		otx2_mbox_unlock(&vf->mbox);
+		mutex_unlock(&vf->mbox.lock);
 		goto err_free_entry;
 	}
-	otx2_mbox_unlock(&vf->mbox);
+	mutex_unlock(&vf->mbox.lock);
 
 	otx2_sq_append_skb(vf->netdev, &vf->qset.sq[0], the_skb, 0);
 
 	return 0;
 
 err_free_entry:
-	otx2_mbox_lock(&vf->mbox);
+	mutex_lock(&vf->mbox.lock);
 	free_req = otx2_mbox_alloc_msg_npc_mcam_free_entry(&vf->mbox);
 	if (!free_req) {
 		dev_err(vf->dev, "Could not allocate msg for freeing entry\n");
@@ -218,7 +218,7 @@ static int otx2smqvf_install_flow(struct otx2_nic *vf)
 		free_req->entry = drop_entry;
 		WARN_ON(otx2_sync_mbox_msg(&vf->mbox));
 	}
-	otx2_mbox_unlock(&vf->mbox);
+	mutex_unlock(&vf->mbox.lock);
 err_free_mem:
 	kfree_skb(the_skb);
 	drop_entry = 0xFFFF;
@@ -266,7 +266,7 @@ int otx2smqvf_remove(struct otx2_nic *vf)
 	the_skb = NULL;
 	mutex_unlock(&remove_lock);
 
-	otx2_mbox_lock(&vf->mbox);
+	mutex_lock(&vf->mbox.lock);
 	del_req = otx2_mbox_alloc_msg_npc_delete_flow(&vf->mbox);
 	free_req = otx2_mbox_alloc_msg_npc_mcam_free_entry(&vf->mbox);
 	if (!del_req || !free_req) {
@@ -276,7 +276,7 @@ int otx2smqvf_remove(struct otx2_nic *vf)
 		free_req->entry = drop_entry;
 		WARN_ON(otx2_sync_mbox_msg(&vf->mbox));
 	}
-	otx2_mbox_unlock(&vf->mbox);
+	mutex_unlock(&vf->mbox.lock);
 
 	otx2_stop(vf->netdev);
 	drop_entry = 0xFFFF;
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_txrx.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_txrx.c
index 4113cde3dc78..adfd11d561d2 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_txrx.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_txrx.c
@@ -999,18 +999,18 @@ int otx2_rxtx_enable(struct otx2_nic *pfvf, bool enable)
 	struct msg_req *msg;
 	int err;
 
-	otx2_mbox_lock(&pfvf->mbox);
+	mutex_lock(&pfvf->mbox.lock);
 	if (enable)
 		msg = otx2_mbox_alloc_msg_nix_lf_start_rx(&pfvf->mbox);
 	else
 		msg = otx2_mbox_alloc_msg_nix_lf_stop_rx(&pfvf->mbox);
 
 	if (!msg) {
-		otx2_mbox_unlock(&pfvf->mbox);
+		mutex_unlock(&pfvf->mbox.lock);
 		return -ENOMEM;
 	}
 
 	err = otx2_sync_mbox_msg(&pfvf->mbox);
-	otx2_mbox_unlock(&pfvf->mbox);
+	mutex_unlock(&pfvf->mbox.lock);
 	return err;
 }
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_vf.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_vf.c
index 0720a07d506c..e41fb0078071 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_vf.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_vf.c
@@ -358,7 +358,7 @@ static int otx2vf_vfaf_mbox_init(struct otx2_nic *vf)
 
 	INIT_WORK(&mbox->mbox_wrk, otx2vf_vfaf_mbox_handler);
 	INIT_WORK(&mbox->mbox_up_wrk, otx2vf_vfaf_mbox_up_handler);
-	otx2_mbox_lock_init(&vf->mbox);
+	mutex_init(&mbox->lock);
 
 	return 0;
 exit:
-- 
2.31.1

