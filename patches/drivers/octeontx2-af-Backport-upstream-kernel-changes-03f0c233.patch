From 5df69c49f3f588f4e82ab7874efdbb1ee433b2a3 Mon Sep 17 00:00:00 2001
From: Naveen Mamindlapalli <naveenm@marvell.com>
Date: Tue, 22 Dec 2020 12:35:20 +0530
Subject: [PATCH 1044/1921] octeontx2-af: Backport upstream kernel changes

Backported changes from upstream kernel.
-> Merged enum header_fields to enum key_fields.
-> Include npc.h in PF driver.
-> Added NPC_PARSE_KEX_S nibble definitions.
-> Renamed def_rule to def_ucast_rule.
-> Used eth_broadcast_addr, eth_zero_addr where ever applicable.
-> Use -EOPNOTSUPP instead of -ENOTSUPP.

Signed-off-by: Naveen Mamindlapalli <naveenm@marvell.com>
Change-Id: I542946fe27a12751672b0bb4b789fc9902618ec4
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/42674
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Tested-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 .../ethernet/marvell/octeontx2/af/common.h    |  2 +-
 .../net/ethernet/marvell/octeontx2/af/mbox.h  | 20 -----
 .../net/ethernet/marvell/octeontx2/af/npc.h   | 78 ++++++++++++++++-
 .../marvell/octeontx2/af/npc_profile.h        | 56 ++++++++-----
 .../net/ethernet/marvell/octeontx2/af/rvu.h   | 37 +-------
 .../ethernet/marvell/octeontx2/af/rvu_nix.c   |  4 +-
 .../ethernet/marvell/octeontx2/af/rvu_npc.c   |  8 +-
 .../marvell/octeontx2/af/rvu_npc_fs.c         | 84 ++++++++++---------
 .../marvell/octeontx2/af/rvu_struct.h         | 10 +++
 .../marvell/octeontx2/nic/otx2_common.h       |  1 +
 10 files changed, 177 insertions(+), 123 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/af/common.h b/drivers/net/ethernet/marvell/octeontx2/af/common.h
index 8c41de0487a5..9a77f0455388 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/common.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/common.h
@@ -164,7 +164,7 @@ enum nix_scheduler {
 #define NIX_RX_ACTIONOP_UCAST_IPSEC	(0x2ull)
 #define NIX_RX_ACTIONOP_MCAST		(0x3ull)
 #define NIX_RX_ACTIONOP_RSS		(0x4ull)
-/* Use action set in default unicast entry */
+/* Use the RX action set in the default unicast entry */
 #define NIX_RX_ACTION_DEFAULT	(0xfull)
 
 /* NIX TX action operation*/
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/mbox.h b/drivers/net/ethernet/marvell/octeontx2/af/mbox.h
index cfa136dcf186..19d215c7eecc 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/mbox.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/mbox.h
@@ -1444,26 +1444,6 @@ struct ptp_rsp {
 	u64 tsc;
 };
 
-enum header_fields {
-	NPC_DMAC,
-	NPC_SMAC,
-	NPC_ETYPE,
-	NPC_OUTER_VID,
-	NPC_TOS,
-	NPC_SIP_IPV4,
-	NPC_DIP_IPV4,
-	NPC_SIP_IPV6,
-	NPC_DIP_IPV6,
-	NPC_SPORT_TCP,
-	NPC_DPORT_TCP,
-	NPC_SPORT_UDP,
-	NPC_DPORT_UDP,
-	NPC_SPORT_SCTP,
-	NPC_DPORT_SCTP,
-	NPC_FDSA_VAL,
-	NPC_HEADER_FIELDS_MAX,
-};
-
 struct flow_msg {
 	unsigned char dmac[6];
 	unsigned char smac[6];
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/npc.h b/drivers/net/ethernet/marvell/octeontx2/af/npc.h
index cc90c3e0a009..e86ad2910f23 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/npc.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/npc.h
@@ -147,6 +147,11 @@ enum npc_kpu_lh_ltype {
 	NPC_LT_LH_CUSTOM1 = 0xF,
 };
 
+/* NPC port kind defines how the incoming or outgoing packets
+ * are processed. NPC accepts packets from up to 64 pkinds.
+ * Software assigns pkind for each incoming port such as CGX
+ * Ethernet interfaces, LBK interfaces, etc.
+ */
 enum npc_pkind_type {
 	NPC_RX_CHLEN24B_PKIND = 57ULL,
 	NPC_RX_CPT_HDR_PKIND,
@@ -154,7 +159,7 @@ enum npc_pkind_type {
 	NPC_TX_HIGIG_PKIND,
 	NPC_RX_HIGIG_PKIND,
 	NPC_RX_EDSA_PKIND,
-	NPC_TX_DEF_PKIND,
+	NPC_TX_DEF_PKIND,	/* NIX-TX PKIND */
 };
 
 enum npc_interface_type {
@@ -164,6 +169,55 @@ enum npc_interface_type {
 	NPC_INTF_MODE_FDSA,
 };
 
+/* list of known and supported fields in packet header and
+ * fields present in key structure.
+ */
+enum key_fields {
+	NPC_DMAC,
+	NPC_SMAC,
+	NPC_ETYPE,
+	NPC_OUTER_VID,
+	NPC_TOS,
+	NPC_SIP_IPV4,
+	NPC_DIP_IPV4,
+	NPC_SIP_IPV6,
+	NPC_DIP_IPV6,
+	NPC_SPORT_TCP,
+	NPC_DPORT_TCP,
+	NPC_SPORT_UDP,
+	NPC_DPORT_UDP,
+	NPC_SPORT_SCTP,
+	NPC_DPORT_SCTP,
+	NPC_FDSA_VAL,
+	NPC_HEADER_FIELDS_MAX,
+	NPC_CHAN = NPC_HEADER_FIELDS_MAX, /* Valid when Rx */
+	NPC_PF_FUNC, /* Valid when Tx */
+	NPC_ERRLEV,
+	NPC_ERRCODE,
+	NPC_LXMB,
+	NPC_LA,
+	NPC_LB,
+	NPC_LC,
+	NPC_LD,
+	NPC_LE,
+	NPC_LF,
+	NPC_LG,
+	NPC_LH,
+	/* Ethertype for untagged frame */
+	NPC_ETYPE_ETHER,
+	/* Ethertype for single tagged frame */
+	NPC_ETYPE_TAG1,
+	/* Ethertype for double tagged frame */
+	NPC_ETYPE_TAG2,
+	/* outer vlan tci for single tagged frame */
+	NPC_VLAN_TAG1,
+	/* outer vlan tci for double tagged frame */
+	NPC_VLAN_TAG2,
+	/* other header fields programmed to extract but not of our interest */
+	NPC_UNKNOWN,
+	NPC_KEY_FIELDS_MAX,
+};
+
 struct npc_kpu_profile_cam {
 	u8 state;
 	u8 state_mask;
@@ -340,6 +394,28 @@ struct nix_tx_action {
 /* NPC_AF_INTFX_KEX_CFG field masks */
 #define NPC_PARSE_NIBBLE		GENMASK_ULL(30, 0)
 
+/* NPC_PARSE_KEX_S nibble definitions for each field */
+#define NPC_PARSE_NIBBLE_CHAN		GENMASK_ULL(2, 0)
+#define NPC_PARSE_NIBBLE_ERRLEV		BIT_ULL(3)
+#define NPC_PARSE_NIBBLE_ERRCODE	GENMASK_ULL(5, 4)
+#define NPC_PARSE_NIBBLE_L2L3_BCAST	BIT_ULL(6)
+#define NPC_PARSE_NIBBLE_LA_FLAGS	GENMASK_ULL(8, 7)
+#define NPC_PARSE_NIBBLE_LA_LTYPE	BIT_ULL(9)
+#define NPC_PARSE_NIBBLE_LB_FLAGS	GENMASK_ULL(11, 10)
+#define NPC_PARSE_NIBBLE_LB_LTYPE	BIT_ULL(12)
+#define NPC_PARSE_NIBBLE_LC_FLAGS	GENMASK_ULL(14, 13)
+#define NPC_PARSE_NIBBLE_LC_LTYPE	BIT_ULL(15)
+#define NPC_PARSE_NIBBLE_LD_FLAGS	GENMASK_ULL(17, 16)
+#define NPC_PARSE_NIBBLE_LD_LTYPE	BIT_ULL(18)
+#define NPC_PARSE_NIBBLE_LE_FLAGS	GENMASK_ULL(20, 19)
+#define NPC_PARSE_NIBBLE_LE_LTYPE	BIT_ULL(21)
+#define NPC_PARSE_NIBBLE_LF_FLAGS	GENMASK_ULL(23, 22)
+#define NPC_PARSE_NIBBLE_LF_LTYPE	BIT_ULL(24)
+#define NPC_PARSE_NIBBLE_LG_FLAGS	GENMASK_ULL(26, 25)
+#define NPC_PARSE_NIBBLE_LG_LTYPE	BIT_ULL(27)
+#define NPC_PARSE_NIBBLE_LH_FLAGS	GENMASK_ULL(29, 28)
+#define NPC_PARSE_NIBBLE_LH_LTYPE	BIT_ULL(30)
+
 /* NIX Receive Vtag Action Structure */
 #define RX_VTAG0_VALID_BIT		BIT_ULL(15)
 #define RX_VTAG0_TYPE_MASK		GENMASK_ULL(14, 12)
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/npc_profile.h b/drivers/net/ethernet/marvell/octeontx2/af/npc_profile.h
index a010cd35c391..57264b893b69 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/npc_profile.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/npc_profile.h
@@ -151,6 +151,21 @@
 			(((bytesm1) << 16) | ((hdr_ofs) << 8) | ((ena) << 7) | \
 			 ((flags_ena) << 6) | ((key_ofs) & 0x3F))
 
+/* Rx parse key extract nibble enable */
+#define NPC_PARSE_NIBBLE_INTF_RX	(NPC_PARSE_NIBBLE_CHAN | \
+					 NPC_PARSE_NIBBLE_ERRCODE | \
+					 NPC_PARSE_NIBBLE_LA_LTYPE | \
+					 NPC_PARSE_NIBBLE_LB_LTYPE | \
+					 NPC_PARSE_NIBBLE_LC_LTYPE | \
+					 NPC_PARSE_NIBBLE_LD_LTYPE | \
+					 NPC_PARSE_NIBBLE_LE_LTYPE)
+/* Tx parse key extract nibble enable */
+#define NPC_PARSE_NIBBLE_INTF_TX	(NPC_PARSE_NIBBLE_LA_LTYPE | \
+					 NPC_PARSE_NIBBLE_LB_LTYPE | \
+					 NPC_PARSE_NIBBLE_LC_LTYPE | \
+					 NPC_PARSE_NIBBLE_LD_LTYPE | \
+					 NPC_PARSE_NIBBLE_LE_LTYPE)
+
 enum npc_kpu_parser_state {
 	NPC_S_NA = 0,
 	NPC_S_KPU1_ETHER,
@@ -14293,8 +14308,9 @@ static struct npc_mcam_kex npc_mkex_default = {
 	.kpu_version = NPC_KPU_PROFILE_VER,
 	.keyx_cfg = {
 		/* nibble: LA..LE (ltype only) + Error code + Channel */
-		[NIX_INTF_RX] = ((u64)NPC_MCAM_KEY_X2 << 32) | 0x249237,
-		[NIX_INTF_TX] = ((u64)NPC_MCAM_KEY_X2 << 32) | 0x249200,
+		[NIX_INTF_RX] = ((u64)NPC_MCAM_KEY_X2 << 32) | NPC_PARSE_NIBBLE_INTF_RX,
+		/* nibble: LA..LE (ltype only) */
+		[NIX_INTF_TX] = ((u64)NPC_MCAM_KEY_X2 << 32) | NPC_PARSE_NIBBLE_INTF_TX,
 	},
 	.intf_lid_lt_ld = {
 	/* Default RX MCAM KEX profile */
@@ -14355,17 +14371,13 @@ static struct npc_mcam_kex npc_mkex_default = {
 		[NPC_LID_LD] = {
 			/* Layer D:UDP */
 			[NPC_LT_LD_UDP] = {
-				/* SPORT: 2 bytes, KW3[15:0] */
-				KEX_LD_CFG(0x1, 0x0, 0x1, 0x0, 0x18),
-				/* DPORT: 2 bytes, KW3[31:16] */
-				KEX_LD_CFG(0x1, 0x2, 0x1, 0x0, 0x1a),
+				/* SPORT+DPORT: 4 bytes, KW3[31:0] */
+				KEX_LD_CFG(0x3, 0x0, 0x1, 0x0, 0x18),
 			},
 			/* Layer D:TCP */
 			[NPC_LT_LD_TCP] = {
-				/* SPORT: 2 bytes, KW3[15:0] */
-				KEX_LD_CFG(0x1, 0x0, 0x1, 0x0, 0x18),
-				/* DPORT: 2 bytes, KW3[31:16] */
-				KEX_LD_CFG(0x1, 0x2, 0x1, 0x0, 0x1a),
+				/* SPORT+DPORT: 4 bytes, KW3[31:0] */
+				KEX_LD_CFG(0x3, 0x0, 0x1, 0x0, 0x18),
 			},
 		},
 	},
@@ -14373,7 +14385,10 @@ static struct npc_mcam_kex npc_mkex_default = {
 	/* Default TX MCAM KEX profile */
 	[NIX_INTF_TX] = {
 		[NPC_LID_LA] = {
-			/* Layer A: Ethernet: */
+			/* Layer A: NIX_INST_HDR_S + Ethernet */
+			/* NIX appends 8 bytes of NIX_INST_HDR_S at the
+			 * start of each TX packet supplied to NPC.
+			 */
 			[NPC_LT_LA_IH_NIX_ETHER] = {
 				/* PF_FUNC: 2B , KW0 [47:32] */
 				KEX_LD_CFG(0x01, 0x0, 0x1, 0x0, 0x4),
@@ -14409,22 +14424,25 @@ static struct npc_mcam_kex npc_mkex_default = {
 			[NPC_LT_LC_IP] = {
 				/* SIP+DIP: 8 bytes, KW2[63:0] */
 				KEX_LD_CFG(0x07, 0xc, 0x1, 0x0, 0x10),
+				/* TOS: 1 byte, KW1[63:56] */
+				KEX_LD_CFG(0x0, 0x1, 0x1, 0x0, 0xf),
+			},
+			/* Layer C: IPv6 */
+			[NPC_LT_LC_IP6] = {
+				/* Everything up to SADDR: 8 bytes, KW2[63:0] */
+				KEX_LD_CFG(0x07, 0x0, 0x1, 0x0, 0x10),
 			},
 		},
 		[NPC_LID_LD] = {
 			/* Layer D:UDP */
 			[NPC_LT_LD_UDP] = {
-				/* SPORT: 2 bytes, KW3[15:0] */
-				KEX_LD_CFG(0x1, 0x0, 0x1, 0x0, 0x18),
-				/* DPORT: 2 bytes, KW3[31:16] */
-				KEX_LD_CFG(0x1, 0x2, 0x1, 0x0, 0x1a),
+				/* SPORT+DPORT: 4 bytes, KW3[31:0] */
+				KEX_LD_CFG(0x3, 0x0, 0x1, 0x0, 0x18),
 			},
 			/* Layer D:TCP */
 			[NPC_LT_LD_TCP] = {
-				/* SPORT: 2 bytes, KW3[15:0] */
-				KEX_LD_CFG(0x1, 0x0, 0x1, 0x0, 0x18),
-				/* DPORT: 2 bytes, KW3[31:16] */
-				KEX_LD_CFG(0x1, 0x2, 0x1, 0x0, 0x1a),
+				/* SPORT+DPORT: 4 bytes, KW3[31:0] */
+				KEX_LD_CFG(0x3, 0x0, 0x1, 0x0, 0x18),
 			},
 		},
 	},
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu.h b/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
index 10e07f4811a7..1dfa99953bf6 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
@@ -123,39 +123,7 @@ struct nix_mce_list {
 	int			max;
 };
 
-/* list of known and supported fields in packet header and
- * fields present in key structure.
- */
-enum key_fields {
-	NPC_CHAN = NPC_HEADER_FIELDS_MAX, /* Valid when Rx */
-	NPC_PF_FUNC, /* Valid when Tx */
-	NPC_ERRLEV,
-	NPC_ERRCODE,
-	NPC_LXMB,
-	NPC_LA,
-	NPC_LB,
-	NPC_LC,
-	NPC_LD,
-	NPC_LE,
-	NPC_LF,
-	NPC_LG,
-	NPC_LH,
-	/* ether type for untagged frame */
-	NPC_ETYPE_ETHER,
-	/* ether type for single tagged frame */
-	NPC_ETYPE_TAG1,
-	/* ether type for double tagged frame */
-	NPC_ETYPE_TAG2,
-	/* outer vlan tci for single tagged frame */
-	NPC_VLAN_TAG1,
-	/* outer vlan tci for double tagged frame */
-	NPC_VLAN_TAG2,
-	/* other header fields programmed to extract but not of our interest */
-	NPC_UNKNOWN,
-	NPC_KEY_FIELDS_MAX,
-};
-
-/* layer meta data to uniquely identify a packet header field */
+/* layer metadata to uniquely identify a packet header field */
 struct npc_layer_mdata {
 	u8 lid;
 	u8 ltype;
@@ -313,7 +281,7 @@ struct rvu_pfvf {
 	struct pci_dev	*pdev;
 	struct kobject	*limits_kobj;
 
-	struct rvu_npc_mcam_rule *def_rule;
+	struct rvu_npc_mcam_rule *def_ucast_rule;
 
 	bool	cgx_in_use; /* this PF/VF using CGX? */
 	int	cgx_users;  /* number of cgx users - used only by PFs */
@@ -875,7 +843,6 @@ static inline void rvu_dbg_exit(struct rvu *rvu) {}
 #endif
 
 /* HW workarounds/fixes */
-#include "npc.h"
 void rvu_nix_txsch_lock(struct nix_hw *nix_hw);
 void rvu_nix_txsch_unlock(struct nix_hw *nix_hw);
 void rvu_nix_update_link_credits(struct rvu *rvu, int blkaddr,
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c
index eda0be338e37..e8257f49fb03 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c
@@ -1247,11 +1247,11 @@ int rvu_mbox_handler_nix_lf_alloc(struct rvu *rvu,
 	/* Configure RX VTAG Type 7 (strip) for vf vlan */
 	rvu_write64(rvu, blkaddr,
 		    NIX_AF_LFX_RX_VTAG_TYPEX(nixlf, NIX_AF_LFX_RX_VTAG_TYPE7),
-		    VTAGSIZE_T4 | BIT_ULL(4));
+		    VTAGSIZE_T4 | VTAG_STRIP);
 	/* Configure RX VTAG Type 6 (strip) for fdsa */
 	rvu_write64(rvu, blkaddr,
 		    NIX_AF_LFX_RX_VTAG_TYPEX(nixlf, NIX_AF_LFX_RX_VTAG_TYPE6),
-		    VTAGSIZE_T4 | BIT_ULL(4) | BIT_ULL(5));
+		    VTAGSIZE_T4 | VTAG_STRIP | VTAG_CAPTURE);
 
 	goto exit;
 
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc.c
index 9c86d4f29231..ebe3f63eb329 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc.c
@@ -66,7 +66,7 @@ static int npc_mcam_verify_pf_func(struct rvu *rvu,
 		NPC_KEX_PF_FUNC_MASK;
 	pf_func = (entry_data->kw[0] >> 32) & NPC_KEX_PF_FUNC_MASK;
 
-	pf_func = htons(pf_func);
+	pf_func = be16_to_cpu((__force __be16)pf_func);
 	if (pf_func_mask != NPC_KEX_PF_FUNC_MASK ||
 	    ((pf_func & ~RVU_PFVF_FUNC_MASK) !=
 	     (pcifunc & ~RVU_PFVF_FUNC_MASK)))
@@ -909,8 +909,8 @@ void rvu_npc_update_flowkey_alg_idx(struct rvu *rvu, u16 pcifunc, int nixlf,
 
 	/* update the action change in default rule */
 	pfvf = rvu_get_pfvf(rvu, pcifunc);
-	if (pfvf->def_rule)
-		pfvf->def_rule->rx_action = action;
+	if (pfvf->def_ucast_rule)
+		pfvf->def_ucast_rule->rx_action = action;
 
 	index = npc_get_nixlf_mcam_index(mcam, pcifunc,
 					 nixlf, NIXLF_PROMISC_ENTRY);
@@ -1011,7 +1011,7 @@ void rvu_npc_disable_mcam_entries(struct rvu *rvu, u16 pcifunc, int nixlf)
 			rule->enable = false;
 			/* Indicate that default rule is disabled */
 			if (rule->default_rule) {
-				pfvf->def_rule = NULL;
+				pfvf->def_ucast_rule = NULL;
 				list_del(&rule->list);
 				kfree(rule);
 			}
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc_fs.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc_fs.c
index 03128e99406d..0f326e125fdf 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc_fs.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc_fs.c
@@ -218,7 +218,7 @@ static int npc_check_field(struct rvu *rvu, int blkaddr, enum key_fields type,
 {
 	if (!npc_is_field_present(rvu, type, intf) ||
 	    npc_check_overlap(rvu, blkaddr, type, 0, intf))
-		return -ENOTSUPP;
+		return -EOPNOTSUPP;
 	return 0;
 }
 
@@ -312,11 +312,11 @@ static void npc_handle_multi_layer_fields(struct rvu *rvu, int blkaddr, u8 intf)
 	vlan_tag1 = &key_fields[NPC_VLAN_TAG1];
 	vlan_tag2 = &key_fields[NPC_VLAN_TAG2];
 
-	/* if key profile programmed does not extract ether type at all */
+	/* if key profile programmed does not extract Ethertype at all */
 	if (!etype_ether->nr_kws && !etype_tag1->nr_kws && !etype_tag2->nr_kws)
 		goto vlan_tci;
 
-	/* if key profile programmed extracts ether type from one layer */
+	/* if key profile programmed extracts Ethertype from one layer */
 	if (etype_ether->nr_kws && !etype_tag1->nr_kws && !etype_tag2->nr_kws)
 		key_fields[NPC_ETYPE] = *etype_ether;
 	if (!etype_ether->nr_kws && etype_tag1->nr_kws && !etype_tag2->nr_kws)
@@ -324,7 +324,7 @@ static void npc_handle_multi_layer_fields(struct rvu *rvu, int blkaddr, u8 intf)
 	if (!etype_ether->nr_kws && !etype_tag1->nr_kws && etype_tag2->nr_kws)
 		key_fields[NPC_ETYPE] = *etype_tag2;
 
-	/* if key profile programmed extracts ether type from multiple layers */
+	/* if key profile programmed extracts Ethertype from multiple layers */
 	if (etype_ether->nr_kws && etype_tag1->nr_kws) {
 		for (i = 0; i < NPC_MAX_KWS_IN_KEY; i++) {
 			if (etype_ether->kw_mask[i] != etype_tag1->kw_mask[i])
@@ -347,7 +347,7 @@ static void npc_handle_multi_layer_fields(struct rvu *rvu, int blkaddr, u8 intf)
 		key_fields[NPC_ETYPE] = *etype_tag2;
 	}
 
-	/* check none of higher layers overwrite ether type */
+	/* check none of higher layers overwrite Ethertype */
 	start_lid = key_fields[NPC_ETYPE].layer_mdata.lid + 1;
 	if (npc_check_overlap(rvu, blkaddr, NPC_ETYPE, start_lid, intf))
 		goto vlan_tci;
@@ -585,7 +585,7 @@ static int npc_check_unsupported_flows(struct rvu *rvu, u64 features, u8 intf)
 		dev_info(rvu->dev, "Unsupported flow(s):\n");
 		for_each_set_bit(bit, (unsigned long *)&unsupported, 64)
 			dev_info(rvu->dev, "%s ", npc_get_field_name(bit));
-		return -ENOTSUPP;
+		return -EOPNOTSUPP;
 	}
 
 	return 0;
@@ -747,17 +747,7 @@ static void npc_update_flow(struct rvu *rvu, struct mcam_entry *entry,
 	if (!features)
 		return;
 
-#define NPC_WRITE_FLOW(field, member, val_lo, val_hi, mask_lo, mask_hi)	      \
-do {									      \
-	if (features & BIT_ULL(field)) {				      \
-		npc_update_entry(rvu, field, entry, val_lo, val_hi,	      \
-				 mask_lo, mask_hi, intf);		      \
-		memcpy(&opkt->member, &pkt->member, sizeof(pkt->member));     \
-		memcpy(&omask->member, &mask->member, sizeof(mask->member));  \
-	}								      \
-} while (0)
-
-	 /* For tcp/udp/sctp LTYPE should be present in entry */
+	/* For tcp/udp/sctp LTYPE should be present in entry */
 	if (features & (BIT_ULL(NPC_SPORT_TCP) | BIT_ULL(NPC_DPORT_TCP)))
 		npc_update_entry(rvu, NPC_LD, entry, NPC_LT_LD_TCP,
 				 0, ~0ULL, 0, intf);
@@ -776,6 +766,16 @@ do {									      \
 		npc_update_entry(rvu, NPC_LB, entry, NPC_LT_LB_FDSA,
 				 0, ~0ULL, 0, intf);
 
+#define NPC_WRITE_FLOW(field, member, val_lo, val_hi, mask_lo, mask_hi)	      \
+do {									      \
+	if (features & BIT_ULL((field))) {				      \
+		npc_update_entry(rvu, (field), entry, (val_lo), (val_hi),     \
+				 (mask_lo), (mask_hi), intf);		      \
+		memcpy(&opkt->member, &pkt->member, sizeof(pkt->member));     \
+		memcpy(&omask->member, &mask->member, sizeof(mask->member));  \
+	}								      \
+} while (0)
+
 	NPC_WRITE_FLOW(NPC_DMAC, dmac, dmac_val, 0, dmac_mask, 0);
 	NPC_WRITE_FLOW(NPC_SMAC, smac, smac_val, 0, smac_mask, 0);
 	NPC_WRITE_FLOW(NPC_ETYPE, etype, ntohs(pkt->etype), 0,
@@ -900,8 +900,8 @@ static void npc_update_rx_entry(struct rvu *rvu, struct rvu_pfvf *pfvf,
 	action.match_id = req->match_id;
 	action.flow_key_alg = req->flow_key_alg;
 
-	if (req->op == NIX_RX_ACTION_DEFAULT && pfvf->def_rule)
-		action = pfvf->def_rule->rx_action;
+	if (req->op == NIX_RX_ACTION_DEFAULT && pfvf->def_ucast_rule)
+		action = pfvf->def_ucast_rule->rx_action;
 
 	entry->action = *(u64 *)&action;
 
@@ -953,13 +953,13 @@ static int npc_install_flow(struct rvu *rvu, int blkaddr, u16 target,
 			       struct npc_install_flow_rsp *rsp, bool enable,
 			       bool pf_set_vfs_mac)
 {
+	struct rvu_npc_mcam_rule *def_ucast_rule = pfvf->def_ucast_rule;
 	u64 features, installed_features, missing_features = 0;
-	struct rvu_npc_mcam_rule *def_rule = pfvf->def_rule;
 	struct npc_mcam_write_entry_req write_req = { 0 };
-	bool new = false, msg_from_vf;
 	struct npc_mcam *mcam = &rvu->hw->mcam;
 	struct rvu_npc_mcam_rule dummy = { 0 };
 	struct rvu_npc_mcam_rule *rule;
+	bool new = false, msg_from_vf;
 	u16 owner = req->hdr.pcifunc;
 	struct msg_rsp write_rsp;
 	struct mcam_entry *entry;
@@ -991,12 +991,12 @@ static int npc_install_flow(struct rvu *rvu, int blkaddr, u16 target,
 	}
 
 	/* update mcam entry with default unicast rule attributes */
-	if (def_rule && (msg_from_vf || (req->default_rule && req->append))) {
-		missing_features = (def_rule->features ^ features) &
-					def_rule->features;
+	if (def_ucast_rule && (msg_from_vf || (req->default_rule && req->append))) {
+		missing_features = (def_ucast_rule->features ^ features) &
+					def_ucast_rule->features;
 		if (missing_features)
 			npc_update_flow(rvu, entry, missing_features,
-					&def_rule->packet, &def_rule->mask,
+					&def_ucast_rule->packet, &def_ucast_rule->mask,
 					&dummy, req->intf);
 		installed_features = req->features | missing_features;
 	}
@@ -1059,7 +1059,7 @@ static int npc_install_flow(struct rvu *rvu, int blkaddr, u16 target,
 	if (new)
 		rvu_mcam_add_rule(mcam, rule);
 	if (req->default_rule)
-		pfvf->def_rule = rule;
+		pfvf->def_ucast_rule = rule;
 
 	/* VF's MAC address is being changed via PF  */
 	if (pf_set_vfs_mac) {
@@ -1119,7 +1119,7 @@ int rvu_mbox_handler_npc_install_flow(struct rvu *rvu,
 		req->chan_mask = 0xFFF;
 
 	if (npc_check_unsupported_flows(rvu, req->features, req->intf))
-		return -ENOTSUPP;
+		return -EOPNOTSUPP;
 
 	if (npc_mcam_verify_channel(rvu, target, req->intf, req->channel))
 		return -EINVAL;
@@ -1135,7 +1135,7 @@ int rvu_mbox_handler_npc_install_flow(struct rvu *rvu,
 	    req->intf == NIX_INTF_RX &&
 	    is_zero_ether_addr(req->packet.dmac)) {
 		ether_addr_copy(req->packet.dmac, pfvf->mac_addr);
-		u64_to_ether_addr(0xffffffffffffull, req->mask.dmac);
+		eth_broadcast_addr((u8 *)&req->mask.dmac);
 	}
 
 	err = nix_get_nixlf(rvu, target, &nixlf, NULL);
@@ -1161,8 +1161,8 @@ int rvu_mbox_handler_npc_install_flow(struct rvu *rvu,
 	/* If message is from VF then its flow should not overlap with
 	 * reserved unicast flow.
 	 */
-	if (from_vf && pfvf->def_rule && is_npc_intf_rx(req->intf) &&
-	    pfvf->def_rule->features & req->features)
+	if (from_vf && pfvf->def_ucast_rule && is_npc_intf_rx(req->intf) &&
+	    pfvf->def_ucast_rule->features & req->features)
 		return -EINVAL;
 
 	return npc_install_flow(rvu, blkaddr, target, nixlf, pfvf,
@@ -1221,11 +1221,13 @@ int rvu_mbox_handler_npc_delete_flow(struct rvu *rvu,
 	mutex_unlock(&mcam->lock);
 
 	list_for_each_entry_safe(iter, tmp, &del_list, list) {
-		if (npc_delete_flow(rvu, iter, pcifunc))
-			dev_err(rvu->dev, "rule deletion failed for entry:%d",
-				iter->entry);
+		u16 entry = iter->entry;
+
 		/* clear the mcam entry target pcifunc */
-		mcam->entry2target_pffunc[iter->entry] = 0x0;
+		mcam->entry2target_pffunc[entry] = 0x0;
+		if (npc_delete_flow(rvu, iter, pcifunc))
+			dev_err(rvu->dev, "rule deletion failed for entry:%u",
+				entry);
 	}
 
 	return 0;
@@ -1238,19 +1240,19 @@ static int npc_update_dmac_value(struct rvu *rvu, int npcblkaddr,
 	struct npc_mcam_write_entry_req write_req = { 0 };
 	struct mcam_entry *entry = &write_req.entry_data;
 	struct npc_mcam *mcam = &rvu->hw->mcam;
-	struct npc_mcam_read_entry_rsp wrsp;
 	struct msg_rsp rsp;
+	u8 intf, enable;
 	int err;
 
 	ether_addr_copy(rule->packet.dmac, pfvf->mac_addr);
 
 	npc_read_mcam_entry(rvu, mcam, npcblkaddr, rule->entry,
-			    entry, &wrsp.intf,
-			    &wrsp.enable);
+			    entry, &intf,
+			    &enable);
 
 	npc_update_entry(rvu, NPC_DMAC, entry,
 			 ether_addr_to_u64(pfvf->mac_addr), 0,
-			 0xffffffffffffull, 0, wrsp.intf);
+			 0xffffffffffffull, 0, intf);
 
 	write_req.hdr.pcifunc = rule->owner;
 	write_req.entry = rule->entry;
@@ -1289,11 +1291,11 @@ void npc_mcam_enable_flows(struct rvu *rvu, u16 target)
 				npc_update_dmac_value(rvu, blkaddr, rule, pfvf);
 
 			if (rule->rx_action.op == NIX_RX_ACTION_DEFAULT) {
-				if (!pfvf->def_rule)
+				if (!pfvf->def_ucast_rule)
 					continue;
 				/* Use default unicast entry action */
-				rule->rx_action = pfvf->def_rule->rx_action;
-				def_action = *(u64 *)&pfvf->def_rule->rx_action;
+				rule->rx_action = pfvf->def_ucast_rule->rx_action;
+				def_action = *(u64 *)&pfvf->def_ucast_rule->rx_action;
 				bank = npc_get_bank(mcam, rule->entry);
 				rvu_write64(rvu, blkaddr,
 					    NPC_AF_MCAMEX_BANKX_ACTION
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_struct.h b/drivers/net/ethernet/marvell/octeontx2/af/rvu_struct.h
index 0decc6f33ce5..df661885cf46 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_struct.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_struct.h
@@ -741,6 +741,16 @@ enum nix_vtag_size {
 	VTAGSIZE_T8   = 0x1,
 };
 
+enum nix_tx_vtag_op {
+	NOP		= 0x0,
+	VTAG_INSERT	= 0x1,
+	VTAG_REPLACE	= 0x2,
+};
+
+/* NIX RX VTAG actions */
+#define VTAG_STRIP	BIT_ULL(4)
+#define VTAG_CAPTURE	BIT_ULL(5)
+
 /* REE admin queue instruction structure */
 struct ree_af_aq_inst_s {
 	u64 rof_ptr_addr;
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h
index d9ff7c188fc4..f013608edb46 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h
@@ -17,6 +17,7 @@
 #include <linux/iommu.h>
 
 #include <mbox.h>
+#include <npc.h>
 #include "otx2_reg.h"
 #include "otx2_txrx.h"
 #include <rvu_trace.h>
-- 
2.31.1

