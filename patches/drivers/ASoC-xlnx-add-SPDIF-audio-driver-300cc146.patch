From 45d67ee2a3a319d1e789f8fa97f81a53f91292af Mon Sep 17 00:00:00 2001
From: Maruthi Srinivas Bayyavarapu <maruthi.srinivas.bayyavarapu@xilinx.com>
Date: Fri, 30 Nov 2018 14:22:29 +0530
Subject: [PATCH 0133/1851] ASoC: xlnx: add SPDIF audio driver

commit e3b1c04ed650c931073746d2e8063150d735dc5e from
https://github.com/Xilinx/linux-xlnx.git

Added SPDIF audio driver. This provides playback and capture
of AES audio over SPDIF interface.

Signed-off-by: Maruthi Srinivas Bayyavarapu <maruthi.srinivas.bayyavarapu@xilinx.com>
Reviewed-by: Vishal Sagar <vishal.sagar@xilinx.com>
Reviewed-by: Hyun Kwon <hyun.kwon@xilinx.com>
State: pending
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 sound/soc/xilinx/xlnx_spdif.c | 110 ++++++++++++++++++++--------------
 1 file changed, 66 insertions(+), 44 deletions(-)

diff --git a/sound/soc/xilinx/xlnx_spdif.c b/sound/soc/xilinx/xlnx_spdif.c
index e2ca087adee6..10f19e243727 100644
--- a/sound/soc/xilinx/xlnx_spdif.c
+++ b/sound/soc/xilinx/xlnx_spdif.c
@@ -24,32 +24,42 @@
 #define XLNX_SPDIF_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE)
 
 #define XSPDIF_IRQ_STS_REG		0x20
+#define XSPDIF_IRQ_STS_CH_STS_MASK	BIT(5)
 #define XSPDIF_IRQ_ENABLE_REG		0x28
 #define XSPDIF_SOFT_RESET_REG		0x40
+#define XSPDIF_SOFT_RESET_VAL		0xA
 #define XSPDIF_CONTROL_REG		0x44
+#define XSPDIF_CONTROL_ENABLE_MASK	BIT(0)
+#define XSPDIF_CONTROL_FIFO_FLUSH_MASK	BIT(1)
+#define XSPDIF_CONTROL_CLK_CFG_MASK	GENMASK(5, 2)
+#define XSPDIF_CONTROL_CLK_CFG_SHIFT	2
 #define XSPDIF_CHAN_0_STS_REG		0x4C
-#define XSPDIF_GLOBAL_IRQ_ENABLE_REG	0x1C
+#define XSPDIF_GLOBAL_IRQ_REG		0x1C
+#define XSPDIF_GLOBAL_IRQ_ENABLE_MASK	BIT(31)
 #define XSPDIF_CH_A_USER_DATA_REG_0	0x64
 
-#define XSPDIF_CORE_ENABLE_MASK		BIT(0)
-#define XSPDIF_FIFO_FLUSH_MASK		BIT(1)
-#define XSPDIF_CH_STS_MASK		BIT(5)
-#define XSPDIF_GLOBAL_IRQ_ENABLE	BIT(31)
-#define XSPDIF_CLOCK_CONFIG_BITS_MASK	GENMASK(5, 2)
-#define XSPDIF_CLOCK_CONFIG_BITS_SHIFT	2
-#define XSPDIF_SOFT_RESET_VALUE		0xA
-
-#define MAX_CHANNELS			2
-#define AES_SAMPLE_WIDTH		32
-#define CH_STATUS_UPDATE_TIMEOUT	40
+#define XSPDIF_MAX_CHANNELS		2
+#define XSPDIF_AES_SAMPLE_WIDTH		32
+#define XSPDIF_CH_STS_UPDATE_TIMEOUT	40
+
+enum {
+	CLK_DIV_BY_4,
+	CLK_DIV_BY_8,
+	CLK_DIV_BY_16,
+	CLK_DIV_BY_24,
+	CLK_DIV_BY_32,
+	CLK_DIV_BY_48,
+	CLK_DIV_BY_64,
+};
 
 struct spdif_dev_data {
-	u32 mode;
-	u32 aclk;
-	bool rx_chsts_updated;
+	wait_queue_head_t chsts_q;
 	void __iomem *base;
 	struct clk *axi_clk;
-	wait_queue_head_t chsts_q;
+	struct clk *aud_clk;
+	u32 mode;
+	unsigned long aclk;
+	bool rx_chsts_updated;
 };
 
 static irqreturn_t xlnx_spdifrx_irq_handler(int irq, void *arg)
@@ -58,12 +68,12 @@ static irqreturn_t xlnx_spdifrx_irq_handler(int irq, void *arg)
 	struct spdif_dev_data *ctx = arg;
 
 	val = readl(ctx->base + XSPDIF_IRQ_STS_REG);
-	if (val & XSPDIF_CH_STS_MASK) {
-		writel(val & XSPDIF_CH_STS_MASK,
+	if (val & XSPDIF_IRQ_STS_CH_STS_MASK) {
+		writel(val & XSPDIF_IRQ_STS_CH_STS_MASK,
 		       ctx->base + XSPDIF_IRQ_STS_REG);
 		val = readl(ctx->base +
 			    XSPDIF_IRQ_ENABLE_REG);
-		writel(val & ~XSPDIF_CH_STS_MASK,
+		writel(val & ~XSPDIF_IRQ_STS_CH_STS_MASK,
 		       ctx->base + XSPDIF_IRQ_ENABLE_REG);
 
 		ctx->rx_chsts_updated = true;
@@ -81,14 +91,14 @@ static int xlnx_spdif_startup(struct snd_pcm_substream *substream,
 	struct spdif_dev_data *ctx = dev_get_drvdata(dai->dev);
 
 	val = readl(ctx->base + XSPDIF_CONTROL_REG);
-	val |= XSPDIF_FIFO_FLUSH_MASK;
+	val |= XSPDIF_CONTROL_FIFO_FLUSH_MASK;
 	writel(val, ctx->base + XSPDIF_CONTROL_REG);
 
 	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
-		writel(XSPDIF_CH_STS_MASK,
+		writel(XSPDIF_IRQ_STS_CH_STS_MASK,
 		       ctx->base + XSPDIF_IRQ_ENABLE_REG);
-		writel(XSPDIF_GLOBAL_IRQ_ENABLE,
-		       ctx->base + XSPDIF_GLOBAL_IRQ_ENABLE_REG);
+		writel(XSPDIF_GLOBAL_IRQ_ENABLE_MASK,
+		       ctx->base + XSPDIF_GLOBAL_IRQ_REG);
 	}
 
 	return 0;
@@ -99,7 +109,7 @@ static void xlnx_spdif_shutdown(struct snd_pcm_substream *substream,
 {
 	struct spdif_dev_data *ctx = dev_get_drvdata(dai->dev);
 
-	writel(XSPDIF_SOFT_RESET_VALUE, ctx->base + XSPDIF_SOFT_RESET_REG);
+	writel(XSPDIF_SOFT_RESET_VAL, ctx->base + XSPDIF_SOFT_RESET_REG);
 }
 
 static int xlnx_spdif_hw_params(struct snd_pcm_substream *substream,
@@ -109,38 +119,40 @@ static int xlnx_spdif_hw_params(struct snd_pcm_substream *substream,
 	u32 val, clk_div, clk_cfg;
 	struct spdif_dev_data *ctx = dev_get_drvdata(dai->dev);
 
-	clk_div = DIV_ROUND_CLOSEST(ctx->aclk, MAX_CHANNELS * AES_SAMPLE_WIDTH *
+	ctx->aclk = clk_get_rate(ctx->aud_clk);
+	clk_div = DIV_ROUND_CLOSEST(ctx->aclk, XSPDIF_MAX_CHANNELS *
+				    XSPDIF_AES_SAMPLE_WIDTH *
 				    params_rate(params));
 
 	switch (clk_div) {
 	case 4:
-		clk_cfg = 0;
+		clk_cfg = CLK_DIV_BY_4;
 		break;
 	case 8:
-		clk_cfg = 1;
+		clk_cfg = CLK_DIV_BY_8;
 		break;
 	case 16:
-		clk_cfg = 2;
+		clk_cfg = CLK_DIV_BY_16;
 		break;
 	case 24:
-		clk_cfg = 3;
+		clk_cfg = CLK_DIV_BY_24;
 		break;
 	case 32:
-		clk_cfg = 4;
+		clk_cfg = CLK_DIV_BY_32;
 		break;
 	case 48:
-		clk_cfg = 5;
+		clk_cfg = CLK_DIV_BY_48;
 		break;
 	case 64:
-		clk_cfg = 6;
+		clk_cfg = CLK_DIV_BY_64;
 		break;
 	default:
 		return -EINVAL;
 	}
 
 	val = readl(ctx->base + XSPDIF_CONTROL_REG);
-	val &= ~XSPDIF_CLOCK_CONFIG_BITS_MASK;
-	val |= clk_cfg << XSPDIF_CLOCK_CONFIG_BITS_SHIFT;
+	val &= ~XSPDIF_CONTROL_CLK_CFG_MASK;
+	val |= clk_cfg << XSPDIF_CONTROL_CLK_CFG_SHIFT;
 	writel(val, ctx->base + XSPDIF_CONTROL_REG);
 
 	return 0;
@@ -150,7 +162,7 @@ static int rx_stream_detect(struct snd_soc_dai *dai)
 {
 	int err;
 	struct spdif_dev_data *ctx = dev_get_drvdata(dai->dev);
-	unsigned long jiffies = msecs_to_jiffies(CH_STATUS_UPDATE_TIMEOUT);
+	unsigned long jiffies = msecs_to_jiffies(XSPDIF_CH_STS_UPDATE_TIMEOUT);
 
 	/* start capture only if stream is detected within 40ms timeout */
 	err = wait_event_interruptible_timeout(ctx->chsts_q,
@@ -177,7 +189,7 @@ static int xlnx_spdif_trigger(struct snd_pcm_substream *substream, int cmd,
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-		val |= XSPDIF_CORE_ENABLE_MASK;
+		val |= XSPDIF_CONTROL_ENABLE_MASK;
 		writel(val, ctx->base + XSPDIF_CONTROL_REG);
 		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
 			ret = rx_stream_detect(dai);
@@ -185,7 +197,7 @@ static int xlnx_spdif_trigger(struct snd_pcm_substream *substream, int cmd,
 	case SNDRV_PCM_TRIGGER_STOP:
 	case SNDRV_PCM_TRIGGER_SUSPEND:
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-		val &= ~XSPDIF_CORE_ENABLE_MASK;
+		val &= ~XSPDIF_CONTROL_ENABLE_MASK;
 		writel(val, ctx->base + XSPDIF_CONTROL_REG);
 		break;
 	default:
@@ -260,6 +272,18 @@ static int xlnx_spdif_probe(struct platform_device *pdev)
 		return ret;
 	}
 
+	ctx->aud_clk = devm_clk_get(dev, "aud_clk_i");
+	if (IS_ERR(ctx->aud_clk)) {
+		ret = PTR_ERR(ctx->aud_clk);
+		dev_err(dev, "failed to get aud_aclk(%d)\n", ret);
+		goto axi_clk_err;
+	}
+	ret = clk_prepare_enable(ctx->aud_clk);
+	if (ret) {
+		dev_err(dev, "failed to enable aud_aclk(%d)\n", ret);
+		goto axi_clk_err;
+	}
+
 	ctx->base = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(ctx->base)) {
 		ret = PTR_ERR(ctx->base);
@@ -292,12 +316,6 @@ static int xlnx_spdif_probe(struct platform_device *pdev)
 		dai_drv = &xlnx_spdif_rx_dai;
 	}
 
-	ret = of_property_read_u32(node, "xlnx,aud_clk_i", &ctx->aclk);
-	if (ret < 0) {
-		dev_err(dev, "cannot get aud_clk_i value\n");
-		goto clk_err;
-	}
-
 	dev_set_drvdata(dev, ctx);
 
 	ret = devm_snd_soc_register_component(dev, &xlnx_spdif_component,
@@ -307,10 +325,13 @@ static int xlnx_spdif_probe(struct platform_device *pdev)
 		goto clk_err;
 	}
 
-	writel(XSPDIF_SOFT_RESET_VALUE, ctx->base + XSPDIF_SOFT_RESET_REG);
+	writel(XSPDIF_SOFT_RESET_VAL, ctx->base + XSPDIF_SOFT_RESET_REG);
 	dev_info(dev, "%s DAI registered\n", dai_drv->name);
+	return 0;
 
 clk_err:
+	clk_disable_unprepare(ctx->aud_clk);
+axi_clk_err:
 	clk_disable_unprepare(ctx->axi_clk);
 	return ret;
 }
@@ -319,6 +340,7 @@ static int xlnx_spdif_remove(struct platform_device *pdev)
 {
 	struct spdif_dev_data *ctx = dev_get_drvdata(&pdev->dev);
 
+	clk_disable_unprepare(ctx->aud_clk);
 	clk_disable_unprepare(ctx->axi_clk);
 	return 0;
 }
-- 
2.31.1

