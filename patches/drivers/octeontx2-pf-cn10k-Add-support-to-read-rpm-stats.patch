From 4ba67f531d853d5018a6ee6a966cebc96a5abcda Mon Sep 17 00:00:00 2001
From: Hariprasad Kelam <hkelam@marvell.com>
Date: Mon, 16 Nov 2020 19:48:04 +0530
Subject: [PATCH 0936/1921] octeontx2-pf: cn10k: Add support to read rpm stats

This patch adds support to read receive/transmit counters supported
by RPM mac and display them as part of ethtool stats.

Change-Id: Ib308ec61b0556f0c480e540ebdb7ad3841afac20
Signed-off-by: Hariprasad Kelam <hkelam@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/40174
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 .../marvell/octeontx2/nic/otx2_common.c         | 17 ++++++++++++++++-
 .../marvell/octeontx2/nic/otx2_common.h         |  8 ++++++--
 .../marvell/octeontx2/nic/otx2_ethtool.c        | 15 ++++++++-------
 .../ethernet/marvell/octeontx2/nic/otx2_pf.c    | 12 ++++++++++++
 4 files changed, 42 insertions(+), 10 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.c
index 9595a11dcbea..717f19060444 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.c
@@ -52,7 +52,11 @@ void otx2_update_lmac_stats(struct otx2_nic *pfvf)
 		return;
 
 	mutex_lock(&pfvf->mbox.lock);
-	req = otx2_mbox_alloc_msg_cgx_stats(&pfvf->mbox);
+	if (pfvf->hw.mac_features & RVU_MAC_RPM)
+		req = otx2_mbox_alloc_msg_rpm_stats(&pfvf->mbox);
+	else
+		req = otx2_mbox_alloc_msg_cgx_stats(&pfvf->mbox);
+
 	if (!req) {
 		mutex_unlock(&pfvf->mbox.lock);
 		return;
@@ -1521,6 +1525,17 @@ void mbox_handler_cgx_stats(struct otx2_nic *pfvf,
 		pfvf->hw.cgx_tx_stats[id] = rsp->tx_stats[id];
 }
 
+void mbox_handler_rpm_stats(struct otx2_nic *pfvf,
+			    struct rpm_stats_rsp *rsp)
+{
+	int id;
+
+	for (id = 0; id < RPM_RX_STATS_COUNT; id++)
+		pfvf->hw.cgx_rx_stats[id] = rsp->rx_stats[id];
+	for (id = 0; id < RPM_TX_STATS_COUNT; id++)
+		pfvf->hw.cgx_tx_stats[id] = rsp->tx_stats[id];
+}
+
 void mbox_handler_cgx_fec_stats(struct otx2_nic *pfvf,
 				struct cgx_fec_stats_rsp *rsp)
 {
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h
index 2a629d96d5ce..d9ff7c188fc4 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h
@@ -198,13 +198,15 @@ struct otx2_hw {
 	/* Stats */
 	struct otx2_dev_stats	dev_stats;
 	struct otx2_drv_stats	drv_stats;
-	u64			cgx_rx_stats[CGX_RX_STATS_COUNT];
-	u64			cgx_tx_stats[CGX_TX_STATS_COUNT];
+	u64			cgx_rx_stats[RPM_RX_STATS_COUNT];
+	u64			cgx_tx_stats[RPM_TX_STATS_COUNT];
 	u64			cgx_fec_corr_blks;
 	u64			cgx_fec_uncorr_blks;
 	u8			cgx_links;  /* No. of CGX links present in HW */
 	u8			lbk_links;  /* No. of LBK links present in HW */
 	u8			tx_link;    /* Transmit channel link number */
+	u8			lmac_rx_stats_cnt;
+	u8			lmac_tx_stats_cnt;
 
 #define HW_TSO			BIT_ULL(0)
 #define CN10K_MBOX		BIT_ULL(1)
@@ -859,6 +861,8 @@ void mbox_handler_cgx_fec_stats(struct otx2_nic *pfvf,
 void otx2_set_fec_stats_count(struct otx2_nic *pfvf);
 void mbox_handler_nix_bp_enable(struct otx2_nic *pfvf,
 				struct nix_bp_cfg_rsp *rsp);
+void mbox_handler_rpm_stats(struct otx2_nic *pfvf,
+			    struct rpm_stats_rsp *rsp);
 
 /* Device stats APIs */
 void otx2_get_dev_stats(struct otx2_nic *pfvf);
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_ethtool.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_ethtool.c
index 9b4fe9e16ea3..6fb4552829db 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_ethtool.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_ethtool.c
@@ -145,12 +145,12 @@ static void otx2_get_strings(struct net_device *netdev, u32 sset, u8 *data)
 
 	otx2_get_qset_strings(pfvf, &data, 0);
 
-	for (stats = 0; stats < CGX_RX_STATS_COUNT; stats++) {
+	for (stats = 0; stats < pfvf->hw.lmac_rx_stats_cnt; stats++) {
 		sprintf(data, "%s_rxstat%d: ", mac_name, stats);
 		data += ETH_GSTRING_LEN;
 	}
 
-	for (stats = 0; stats < CGX_TX_STATS_COUNT; stats++) {
+	for (stats = 0; stats < pfvf->hw.lmac_tx_stats_cnt; stats++) {
 		sprintf(data, "%s_txstat%d: ", mac_name, stats);
 		data += ETH_GSTRING_LEN;
 	}
@@ -232,9 +232,9 @@ static void otx2_get_ethtool_stats(struct net_device *netdev,
 
 	otx2_get_qset_stats(pfvf, stats, &data);
 	otx2_update_lmac_stats(pfvf);
-	for (stat = 0; stat < CGX_RX_STATS_COUNT; stat++)
+	for (stat = 0; stat < pfvf->hw.lmac_rx_stats_cnt; stat++)
 		*(data++) = pfvf->hw.cgx_rx_stats[stat];
-	for (stat = 0; stat < CGX_TX_STATS_COUNT; stat++)
+	for (stat = 0; stat < pfvf->hw.lmac_tx_stats_cnt; stat++)
 		*(data++) = pfvf->hw.cgx_tx_stats[stat];
 	*(data++) = pfvf->reset_count;
 
@@ -285,13 +285,14 @@ static int otx2_get_sset_count(struct net_device *netdev, int sset)
 
 	if (!if_up || !pfvf->linfo.fec) {
 		return otx2_n_dev_stats + otx2_n_drv_stats + qstats_count +
-			CGX_RX_STATS_COUNT + CGX_TX_STATS_COUNT + 1;
+		       pfvf->hw.lmac_rx_stats_cnt + pfvf->hw.lmac_tx_stats_cnt
+		       + 1;
 	}
 	fec_stats_count = 2;
 	otx2_update_lmac_fec_stats(pfvf);
 	return otx2_n_dev_stats + otx2_n_drv_stats + qstats_count +
-		CGX_RX_STATS_COUNT + CGX_TX_STATS_COUNT + 1 +
-		fec_stats_count;
+	       pfvf->hw.lmac_rx_stats_cnt + pfvf->hw.lmac_tx_stats_cnt + 1 +
+	       fec_stats_count;
 }
 
 /* Get no of queues device supports and current queue count */
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c
index 4693189b691d..8e460f7c4374 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c
@@ -799,6 +799,9 @@ static void otx2_process_pfaf_mbox_msg(struct otx2_nic *pf,
 	case MBOX_MSG_CGX_FEC_STATS:
 		mbox_handler_cgx_fec_stats(pf, (struct cgx_fec_stats_rsp *)msg);
 		break;
+	case MBOX_MSG_RPM_STATS:
+		mbox_handler_rpm_stats(pf, (struct rpm_stats_rsp *)msg);
+		break;
 	default:
 		if (msg->rc)
 			dev_err(pf->dev,
@@ -1153,6 +1156,15 @@ int otx2_cgx_features_get(struct otx2_nic *pfvf)
 	rsp = (struct cgx_features_info_msg *)
 		     otx2_mbox_get_rsp(&pfvf->mbox.mbox, 0, &msg->hdr);
 	pfvf->hw.mac_features = rsp->lmac_features;
+
+	if (pfvf->hw.mac_features & RVU_MAC_RPM) {
+		pfvf->hw.lmac_rx_stats_cnt = RPM_RX_STATS_COUNT;
+		pfvf->hw.lmac_tx_stats_cnt = RPM_TX_STATS_COUNT;
+	} else {
+		pfvf->hw.lmac_rx_stats_cnt = CGX_RX_STATS_COUNT;
+		pfvf->hw.lmac_tx_stats_cnt = CGX_TX_STATS_COUNT;
+	}
+
 out:
 	mutex_unlock(&pfvf->mbox.lock);
 	return err;
-- 
2.31.1

