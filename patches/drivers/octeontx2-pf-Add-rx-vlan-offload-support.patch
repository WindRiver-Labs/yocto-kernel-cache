From 637e490f2cb9c3fe8de2cce15365eabb471bdba4 Mon Sep 17 00:00:00 2001
From: hariprasad <hkelam@marvell.com>
Date: Tue, 3 Sep 2019 15:28:45 +0530
Subject: [PATCH 348/767] octeontx2-pf: Add rx vlan offload support

commit f18e37bd1cf6ffe13eff7c78154e222eeb50c676 from
git@git.assembla.com:cavium/WindRiver.linux.git

Support vlan offload in receive path by configuring NIX
to strip outer vlan.

Change-Id: I3b6c6be28fe9f1804843b6cc30d18afd06d76ed5
Signed-off-by: hariprasad <hkelam@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/15967
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Tested-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../net/ethernet/marvell/octeontx2/af/mbox.h  |  12 ++
 .../ethernet/marvell/octeontx2/af/rvu_nix.c   |   4 +-
 .../marvell/octeontx2/nic/otx2_common.h       |   2 +
 .../marvell/octeontx2/nic/otx2_flows.c        | 116 +++++++++++++++++-
 .../ethernet/marvell/octeontx2/nic/otx2_pf.c  |  16 ++-
 .../ethernet/marvell/octeontx2/nic/otx2_vf.c  |   5 +-
 6 files changed, 148 insertions(+), 7 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/af/mbox.h b/drivers/net/ethernet/marvell/octeontx2/af/mbox.h
index cd26005c4a35..efe8b2afb7a8 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/mbox.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/mbox.h
@@ -651,6 +651,18 @@ enum nix_af_status {
 	NIX_AF_ERR_TX_VTAG_NOSPC    = -421,
 };
 
+/* For NIX RX vtag action  */
+enum nix_rx_vtag0_type {
+	NIX_AF_LFX_RX_VTAG_TYPE0, /* reserved for rx vlan offload */
+	NIX_AF_LFX_RX_VTAG_TYPE1,
+	NIX_AF_LFX_RX_VTAG_TYPE2,
+	NIX_AF_LFX_RX_VTAG_TYPE3,
+	NIX_AF_LFX_RX_VTAG_TYPE4,
+	NIX_AF_LFX_RX_VTAG_TYPE5,
+	NIX_AF_LFX_RX_VTAG_TYPE6,
+	NIX_AF_LFX_RX_VTAG_TYPE7,
+};
+
 /* For NIX LF context alloc and init */
 struct nix_lf_alloc_req {
 	struct mbox_msghdr hdr;
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c
index b99f9571697c..425bf12c0512 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c
@@ -1928,7 +1928,8 @@ static int nix_rx_vtag_cfg(struct rvu *rvu, int nixlf, int blkaddr,
 {
 	u64 regval = req->vtag_size;
 
-	if (req->rx.vtag_type > 7 || req->vtag_size > VTAGSIZE_T8)
+	if (req->rx.vtag_type > NIX_AF_LFX_RX_VTAG_TYPE7 ||
+	    req->vtag_size > VTAGSIZE_T8)
 		return -EINVAL;
 
 	if (req->rx.capture_vtag)
@@ -3943,4 +3944,3 @@ struct rvu *rvu, struct nix_inline_ipsec_lf_cfg *req, struct msg_rsp *rsp)
 
 	return 0;
 }
-
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h
index da0dc8e7b2d3..3a819104d46d 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h
@@ -247,6 +247,7 @@ struct otx2_nic {
 	u32                     ntuple_max_flows;
 #define OTX2_NTUPLE_FILTER_CAPABLE		0
 #define OTX2_UNICAST_FILTER_CAPABLE		1
+#define OTX2_RX_VLAN_OFFLOAD_CAPABLE		2
 	unsigned long           priv_flags;
 	u16			entry_list[NPC_MAX_NONCONTIG_ENTRIES];
 	struct list_head	flows;
@@ -624,6 +625,7 @@ int otx2_add_flow(struct otx2_nic *pfvf,
 int otx2_remove_flow(struct otx2_nic *pfvf, u32 location);
 int otx2_prepare_flow_request(struct ethtool_rx_flow_spec *fsp,
 			      struct npc_install_flow_req *req);
+int otx2_enable_rxvlan(struct otx2_nic *pf, bool enable);
 int otx2smqvf_probe(struct otx2_nic *vf);
 int otx2smqvf_remove(struct otx2_nic *vf);
 
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_flows.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_flows.c
index b94372977be2..78e9a851d594 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_flows.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_flows.c
@@ -13,10 +13,13 @@
 /* helper macros to support mcam flows */
 #define OTX2_MAX_NTUPLE_FLOWS	32
 #define OTX2_MAX_UNICAST_FLOWS	8
+#define OTX2_MAX_VLAN_FLOWS	1
 
 enum mcam_offset {
 	NTUPLE_OFFSET     = 0,
 	UNICAST_OFFSET    = NTUPLE_OFFSET  + OTX2_MAX_NTUPLE_FLOWS,
+	VLAN_OFFSET       = UNICAST_OFFSET + OTX2_MAX_UNICAST_FLOWS,
+	OTX2_MCAM_COUNT   = VLAN_OFFSET + OTX2_MAX_VLAN_FLOWS,
 };
 
 struct otx2_flow {
@@ -37,6 +40,7 @@ int otx2_mcam_flow_init(struct otx2_nic *pf)
 	/* support ntuple,mac filters */
 	otx2_nic_enable_feature(pf, OTX2_NTUPLE_FILTER_CAPABLE);
 	otx2_nic_enable_feature(pf, OTX2_UNICAST_FILTER_CAPABLE);
+	otx2_nic_enable_feature(pf, OTX2_RX_VLAN_OFFLOAD_CAPABLE);
 
 	pf->mac_table = devm_kzalloc(pf->dev, sizeof(struct otx2_mac_table)
 					* OTX2_MAX_UNICAST_FLOWS, GFP_KERNEL);
@@ -63,6 +67,8 @@ void otx2_mcam_flow_del(struct otx2_nic *pf)
 
 static int otx2_alloc_mcam_entries(struct otx2_nic *pfvf)
 {
+	netdev_features_t wanted = NETIF_F_HW_VLAN_STAG_RX |
+				   NETIF_F_HW_VLAN_CTAG_RX;
 	struct npc_mcam_alloc_entry_req *req;
 	struct npc_mcam_alloc_entry_rsp *rsp;
 	int i;
@@ -81,7 +87,7 @@ static int otx2_alloc_mcam_entries(struct otx2_nic *pfvf)
 	}
 
 	req->contig = false;
-	req->count = pfvf->ntuple_max_flows + OTX2_MAX_UNICAST_FLOWS;
+	req->count = OTX2_MCAM_COUNT;
 
 	/* Send message to AF */
 	if (otx2_sync_mbox_msg(&pfvf->mbox)) {
@@ -95,10 +101,15 @@ static int otx2_alloc_mcam_entries(struct otx2_nic *pfvf)
 	if (rsp->count != req->count) {
 		netdev_info(pfvf->netdev, "number of rules truncated to %d\n",
 			    rsp->count);
+		netdev_info(pfvf->netdev,
+			    "Disabling RX VLAN offload due to non-availability of MCAM space\n");
 		/* support only ntuples here */
 		pfvf->ntuple_max_flows = rsp->count;
 		pfvf->netdev->priv_flags &= ~IFF_UNICAST_FLT;
 		pfvf->priv_flags &= ~(BIT(OTX2_UNICAST_FILTER_CAPABLE));
+		pfvf->priv_flags &= ~(BIT(OTX2_RX_VLAN_OFFLOAD_CAPABLE));
+		pfvf->netdev->features &= ~wanted;
+		pfvf->netdev->hw_features &= ~wanted;
 	}
 
 	for (i = 0; i < rsp->count; i++)
@@ -495,3 +506,106 @@ int otx2_destroy_mcam_flows(struct otx2_nic *pfvf)
 
 	return 0;
 }
+
+static int otx2_install_rxvlan_offload_flow(struct otx2_nic *pfvf)
+{
+	struct npc_install_flow_req *req;
+	int err;
+
+	otx2_mbox_lock(&pfvf->mbox);
+	req = otx2_mbox_alloc_msg_npc_install_flow(&pfvf->mbox);
+	if (!req) {
+		otx2_mbox_unlock(&pfvf->mbox);
+		return -ENOMEM;
+	}
+
+	req->entry = pfvf->entry_list[VLAN_OFFSET];
+	req->intf = NIX_INTF_RX;
+	ether_addr_copy(req->packet.dmac, pfvf->netdev->dev_addr);
+	u64_to_ether_addr(0xffffffffffffull, req->mask.dmac);
+	req->channel = pfvf->rx_chan_base;
+	req->op = NIX_RX_ACTION_DEFAULT;
+	req->features = BIT_ULL(NPC_OUTER_VID) | BIT_ULL(NPC_DMAC);
+	req->vtag0_valid = true;
+	req->vtag0_type = NIX_AF_LFX_RX_VTAG_TYPE0;
+
+	/* Send message to AF */
+	err = otx2_sync_mbox_msg(&pfvf->mbox);
+	otx2_mbox_unlock(&pfvf->mbox);
+	return err;
+}
+
+static int otx2_delete_rxvlan_offload_flow(struct otx2_nic *pfvf)
+{
+	struct npc_delete_flow_req *req;
+	int err;
+
+	otx2_mbox_lock(&pfvf->mbox);
+	req = otx2_mbox_alloc_msg_npc_delete_flow(&pfvf->mbox);
+	if (!req) {
+		otx2_mbox_unlock(&pfvf->mbox);
+		return -ENOMEM;
+	}
+
+	req->entry = pfvf->entry_list[VLAN_OFFSET];
+	/* Send message to AF */
+	err = otx2_sync_mbox_msg(&pfvf->mbox);
+	otx2_mbox_unlock(&pfvf->mbox);
+	return err;
+}
+
+int otx2_enable_rxvlan(struct otx2_nic *pf, bool enable)
+{
+	struct nix_vtag_config *req;
+	struct mbox_msghdr *rsp_hdr;
+	int err;
+
+	if (!pf->entries_alloc) {
+		err = otx2_alloc_mcam_entries(pf);
+		if (err)
+			return err;
+	}
+
+	/* Dont have enough mcam entries */
+	if (!otx2_nic_is_feature_enabled(pf, OTX2_RX_VLAN_OFFLOAD_CAPABLE))
+		return -ENOMEM;
+
+	if (enable) {
+		err = otx2_install_rxvlan_offload_flow(pf);
+		if (err)
+			return err;
+	} else {
+		err = otx2_delete_rxvlan_offload_flow(pf);
+		if (err)
+			return err;
+	}
+
+	otx2_mbox_lock(&pf->mbox);
+	req = otx2_mbox_alloc_msg_nix_vtag_cfg(&pf->mbox);
+	if (!req) {
+		otx2_mbox_unlock(&pf->mbox);
+		return -ENOMEM;
+	}
+
+	/* config strip, capture and size */
+	req->vtag_size = VTAGSIZE_T4;
+	req->cfg_type = 1; /* rx vlan cfg */
+	req->rx.vtag_type = NIX_AF_LFX_RX_VTAG_TYPE0;
+	req->rx.strip_vtag = enable;
+	req->rx.capture_vtag = enable;
+
+	err = otx2_sync_mbox_msg(&pf->mbox);
+	if (err) {
+		otx2_mbox_unlock(&pf->mbox);
+		return err;
+	}
+
+	rsp_hdr = otx2_mbox_get_rsp(&pf->mbox.mbox, 0, &req->hdr);
+	if (IS_ERR(rsp_hdr)) {
+		otx2_mbox_unlock(&pf->mbox);
+		return PTR_ERR(rsp_hdr);
+	}
+
+	otx2_mbox_unlock(&pf->mbox);
+	return rsp_hdr->rc;
+}
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c
index c3e37d6a9a50..0e4e0bdd6580 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c
@@ -1578,6 +1578,9 @@ int otx2_open(struct net_device *netdev)
 	if (pf->linfo.link_up && !(pf->pcifunc & RVU_PFVF_FUNC_MASK))
 		otx2_handle_link_event(pf);
 
+	if (otx2_nic_is_feature_enabled(pf, OTX2_RX_VLAN_OFFLOAD_CAPABLE))
+		otx2_enable_rxvlan(pf, true);
+
 	/* When reinitializing enable time stamping if it is enabled before */
 	if (pf->hw_tx_tstamp) {
 		pf->hw_tx_tstamp = 0;
@@ -1747,6 +1750,10 @@ static int otx2_set_features(struct net_device *netdev,
 		return otx2_cgx_config_loopback(pf,
 						features & NETIF_F_LOOPBACK);
 
+	if ((changed & NETIF_F_HW_VLAN_CTAG_RX) && netif_running(netdev))
+		return otx2_enable_rxvlan(pf,
+					  features & NETIF_F_HW_VLAN_CTAG_RX);
+
 	if ((changed & NETIF_F_NTUPLE) && !ntuple)
 		otx2_destroy_ntuple_flows(pf);
 
@@ -2180,8 +2187,13 @@ static int otx2_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	netdev->features |= netdev->hw_features;
 	/* Support TSO on tag interface */
 	netdev->vlan_features |= netdev->features;
-	netdev->features  |= NETIF_F_HW_VLAN_CTAG_TX |
-			     NETIF_F_HW_VLAN_STAG_TX;
+
+	netdev->hw_features  |= NETIF_F_HW_VLAN_CTAG_TX |
+				NETIF_F_HW_VLAN_STAG_TX |
+				NETIF_F_HW_VLAN_CTAG_RX |
+				NETIF_F_HW_VLAN_STAG_RX;
+
+	netdev->features |= netdev->hw_features;
 
 	netdev->hw_features |= NETIF_F_LOOPBACK | NETIF_F_NTUPLE |
 			       NETIF_F_RXALL;
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_vf.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_vf.c
index f70333b51e16..efdaacff36fb 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_vf.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_vf.c
@@ -554,8 +554,9 @@ static int otx2vf_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	netdev->features = netdev->hw_features;
 	/* Support TSO on tag interface */
 	netdev->vlan_features |= netdev->features;
-	netdev->features  |= NETIF_F_HW_VLAN_CTAG_TX |
-			     NETIF_F_HW_VLAN_STAG_TX;
+	netdev->hw_features  |= NETIF_F_HW_VLAN_CTAG_TX |
+				NETIF_F_HW_VLAN_STAG_TX;
+	netdev->features |= netdev->hw_features;
 	netdev->watchdog_timeo = OTX2_TX_TIMEOUT;
 
 	netdev->netdev_ops = &otx2vf_netdev_ops;
-- 
2.31.1

