From 8195bcc665053414ff7452f2e765675df7b19b09 Mon Sep 17 00:00:00 2001
From: Linu Cherian <lcherian@marvell.com>
Date: Fri, 24 Jul 2020 00:34:12 +0530
Subject: [PATCH 0667/1921] coresight: Make sysFS functional on topolgies with
 per core sink

Coresight driver assumes sink is common across all the ETMs,
and tries to build a path between ETM and the first enabled
sink. This breaks implmentations that has per core sink.

For this, coresight_get_enabled_sink API is updated to give preference
to per core enabled sink when a source device is given as reference.

Change-Id: I180637c8d65b1c5a3cd2361e617f3efb8973a3db
Signed-off-by: Linu Cherian <lcherian@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/32602
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 .../hwtracing/coresight/coresight-etm-perf.c  |  2 +-
 drivers/hwtracing/coresight/coresight-priv.h  |  3 ++-
 drivers/hwtracing/coresight/coresight.c       | 23 +++++++++++++++++--
 3 files changed, 24 insertions(+), 4 deletions(-)

diff --git a/drivers/hwtracing/coresight/coresight-etm-perf.c b/drivers/hwtracing/coresight/coresight-etm-perf.c
index 9b0c5d719232..47b8acadba67 100644
--- a/drivers/hwtracing/coresight/coresight-etm-perf.c
+++ b/drivers/hwtracing/coresight/coresight-etm-perf.c
@@ -223,7 +223,7 @@ static void *etm_setup_aux(struct perf_event *event, void **pages,
 		id = (u32)event->attr.config2;
 		sink = coresight_get_sink_by_id(id);
 	} else {
-		sink = coresight_get_enabled_sink(true);
+		sink = coresight_get_enabled_sink(NULL, true);
 	}
 
 	if (!sink)
diff --git a/drivers/hwtracing/coresight/coresight-priv.h b/drivers/hwtracing/coresight/coresight-priv.h
index 56379d4a7ede..1294805f2bcb 100644
--- a/drivers/hwtracing/coresight/coresight-priv.h
+++ b/drivers/hwtracing/coresight/coresight-priv.h
@@ -149,7 +149,8 @@ static inline void coresight_write_reg_pair(void __iomem *addr, u64 val,
 void coresight_disable_path(struct list_head *path);
 int coresight_enable_path(struct list_head *path, u32 mode, void *sink_data);
 struct coresight_device *coresight_get_sink(struct list_head *path);
-struct coresight_device *coresight_get_enabled_sink(bool reset);
+struct coresight_device *
+coresight_get_enabled_sink(struct coresight_device *source, bool reset);
 struct coresight_device *coresight_get_sink_by_id(u32 id);
 struct list_head *coresight_build_path(struct coresight_device *csdev,
 				       struct coresight_device *sink);
diff --git a/drivers/hwtracing/coresight/coresight.c b/drivers/hwtracing/coresight/coresight.c
index 0bbce0d29158..50987f4b84a5 100644
--- a/drivers/hwtracing/coresight/coresight.c
+++ b/drivers/hwtracing/coresight/coresight.c
@@ -507,6 +507,10 @@ static int coresight_enabled_sink(struct device *dev, const void *data)
 
 /**
  * coresight_get_enabled_sink - returns the first enabled sink found on the bus
+ * In case the child port for the given source device is a per core sink,
+ * no bus search is done if the sink is in enabled state.
+ *
+ * @source: Coresight source device reference
  * @deactivate:	Whether the 'enable_sink' flag should be reset
  *
  * When operated from perf the deactivate parameter should be set to 'true'.
@@ -517,10 +521,25 @@ static int coresight_enabled_sink(struct device *dev, const void *data)
  * parameter should be set to 'false', hence mandating users to explicitly
  * clear the flag.
  */
-struct coresight_device *coresight_get_enabled_sink(bool deactivate)
+struct coresight_device *
+coresight_get_enabled_sink(struct coresight_device *source, bool deactivate)
 {
+	struct coresight_device *child;
 	struct device *dev = NULL;
 
+	if (source == NULL || source->pdata->nr_outport != 1)
+		goto skip_single_sink_check;
+
+	/* If the connected port is a sink with single trace source,
+	 * nothing to search further on the bus.
+	 */
+	child = source->pdata->conns[0].child_dev;
+	if (child->pdata->nr_inport == 1) {
+		if (coresight_enabled_sink(&child->dev, &deactivate))
+			return child;
+	}
+
+skip_single_sink_check:
 	dev = bus_find_device(&coresight_bustype, NULL, &deactivate,
 			      coresight_enabled_sink);
 
@@ -768,7 +787,7 @@ int coresight_enable(struct coresight_device *csdev)
 	 * Search for a valid sink for this session but don't reset the
 	 * "enable_sink" flag in sysFS.  Users get to do that explicitly.
 	 */
-	sink = coresight_get_enabled_sink(false);
+	sink = coresight_get_enabled_sink(csdev, false);
 	if (!sink) {
 		ret = -EINVAL;
 		goto out;
-- 
2.31.1

