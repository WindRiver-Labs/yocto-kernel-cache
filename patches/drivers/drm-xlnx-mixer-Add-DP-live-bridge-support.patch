From 9be37720feb675d37e82a12561cbc0073950ff6e Mon Sep 17 00:00:00 2001
From: Jianqiang Chen <jianqiang.chen@xilinx.com>
Date: Tue, 9 Mar 2021 12:36:46 -0800
Subject: [PATCH 1775/1852] drm: xlnx: mixer: Add DP live bridge support

commit cff346dbe1601b4bcf706441cc3f5055c6474b04 from
https://github.com/Xilinx/linux-xlnx.git

This patch adds support for connecting the mixer to PS DP live input. A
new device-tree entry, 'xlnx,disp-bridge', can be used to gain access to
the DP live bridge. Input format, video timing, and enabling is done
through the xlnx bridge functions.

Signed-off-by: Jianqiang Chen <jianqiang.chen@xilinx.com>
Signed-off-by: Dylan Yip <dylan.yip@xilinx.com>
Acked-by: Varunkumar Allagadapa <varunkumar.allagadapa@xilinx.com>
State: pending
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 drivers/gpu/drm/xlnx/xlnx_mixer.c | 90 ++++++++++++++++++++++++++++++-
 1 file changed, 88 insertions(+), 2 deletions(-)

diff --git a/drivers/gpu/drm/xlnx/xlnx_mixer.c b/drivers/gpu/drm/xlnx/xlnx_mixer.c
index a0931be832b9..c40018dd8760 100644
--- a/drivers/gpu/drm/xlnx/xlnx_mixer.c
+++ b/drivers/gpu/drm/xlnx/xlnx_mixer.c
@@ -460,6 +460,7 @@ struct xlnx_mix {
 	int dpms;
 	struct drm_pending_vblank_event *event;
 	struct xlnx_bridge *vtc_bridge;
+	struct xlnx_bridge *disp_bridge;
 };
 
 /**
@@ -514,6 +515,50 @@ static inline u32 reg_readl(void __iomem *base, int offset)
 	return readl(base + offset);
 }
 
+static u32 xlnx_mix_get_bus_fmt(struct xlnx_mix *mixer)
+{
+	struct xlnx_mix_layer_data *master;
+
+	master = &mixer->mixer_hw.layer_data[XVMIX_MASTER_LAYER_IDX];
+
+	switch (master->hw_config.vid_fmt) {
+	case DRM_FORMAT_BGR888:
+	case DRM_FORMAT_RGB888:
+	case DRM_FORMAT_XRGB8888:
+	case DRM_FORMAT_RGBA8888:
+	case DRM_FORMAT_ABGR8888:
+	case DRM_FORMAT_ARGB8888:
+	case DRM_FORMAT_XBGR8888:
+		return MEDIA_BUS_FMT_RBG888_1X24;
+	case DRM_FORMAT_XBGR2101010:
+		return MEDIA_BUS_FMT_RBG101010_1X30;
+	case DRM_FORMAT_YUYV:
+	case DRM_FORMAT_UYVY:
+	case DRM_FORMAT_NV16:
+		return MEDIA_BUS_FMT_UYVY8_1X16;
+	case DRM_FORMAT_AYUV:
+	case DRM_FORMAT_VUY888:
+	case DRM_FORMAT_XVUY8888:
+		return MEDIA_BUS_FMT_VUY8_1X24;
+	case DRM_FORMAT_NV12:
+		return MEDIA_BUS_FMT_VYYUYY8_1X24;
+	case DRM_FORMAT_Y8:
+		return MEDIA_BUS_FMT_Y8_1X8;
+	case DRM_FORMAT_Y10:
+		return MEDIA_BUS_FMT_Y10_1X10;
+	case DRM_FORMAT_XVUY2101010:
+		return MEDIA_BUS_FMT_VUY10_1X30;
+	case DRM_FORMAT_XV15:
+		return MEDIA_BUS_FMT_VYYUYY10_4X20;
+	case DRM_FORMAT_XV20:
+		return MEDIA_BUS_FMT_UYVY10_1X20;
+	default:
+		DRM_DEBUG_KMS("invalid layer format: %d\n",
+			      master->hw_config.vid_fmt);
+		return 0;
+	}
+}
+
 /**
  * xlnx_mix_intrpt_enable_done - Enables interrupts
  * @mixer: instance of mixer IP core
@@ -2232,6 +2277,26 @@ static int xlnx_mix_parse_dt_logo_data(struct device_node *node,
 	return 0;
 }
 
+static int xlnx_mix_dt_dp_bridge(struct device *dev, struct xlnx_mix *mixer)
+{
+	struct device_node *node, *vtc_node, *disp_node, *port;
+
+	node = dev->of_node;
+	/* Disp Bridge support */
+	disp_node = of_parse_phandle(node, "xlnx,disp-bridge", 0);
+	if (disp_node) {
+		mixer->disp_bridge = of_xlnx_bridge_get(disp_node);
+		if (!mixer->disp_bridge) {
+			dev_info(dev, "Didn't get disp bridge instance\n");
+			return -1;
+		}
+	} else {
+		dev_info(dev, "disp bridge property not present\n");
+		return -1;
+	}
+	return 0;
+}
+
 static int xlnx_mix_dt_parse(struct device *dev, struct xlnx_mix *mixer)
 {
 	struct xlnx_mix_plane *planes;
@@ -2625,6 +2690,9 @@ static void xlnx_mix_crtc_dpms(struct drm_crtc *base_crtc, int dpms)
 	int ret;
 	struct videomode vm;
 	struct drm_display_mode *mode = &base_crtc->mode;
+	struct drm_display_mode *adjusted_mode =
+					&base_crtc->state->adjusted_mode;
+	struct xlnx_mix_hw *mixer_hw = &mixer->mixer_hw;
 
 	DRM_DEBUG_KMS("dpms: %d\n", dpms);
 	if (mixer->dpms == dpms)
@@ -2648,6 +2716,16 @@ static void xlnx_mix_crtc_dpms(struct drm_crtc *base_crtc, int dpms)
 			xlnx_bridge_enable(mixer->vtc_bridge);
 		}
 
+		if (mixer->disp_bridge) {
+			drm_display_mode_to_videomode(adjusted_mode, &vm);
+			xlnx_bridge_set_input(mixer->disp_bridge,
+					      adjusted_mode->hdisplay,
+					      adjusted_mode->vdisplay,
+					      xlnx_mix_get_bus_fmt(mixer));
+			xlnx_bridge_set_timing(mixer->disp_bridge, &vm);
+			xlnx_bridge_enable(mixer->disp_bridge);
+		}
+
 		xlnx_mix_dpms(mixer, dpms);
 		xlnx_mix_plane_dpms(base_crtc->primary, dpms);
 		break;
@@ -2943,6 +3021,8 @@ static int xlnx_mix_bind(struct device *dev, struct device *master,
 	struct drm_device *drm = data;
 	u32 ret;
 
+	xlnx_mix_dt_dp_bridge(dev, mixer);
+
 	mixer->drm = drm;
 	ret = xlnx_mix_plane_create(dev, mixer);
 	if (ret)
@@ -3013,8 +3093,14 @@ static int xlnx_mix_remove(struct platform_device *pdev)
 
 	if (mixer->vtc_bridge)
 		of_xlnx_bridge_put(mixer->vtc_bridge);
-	xlnx_drm_pipeline_exit(mixer->master);
-	component_del(&pdev->dev, &xlnx_mix_component_ops);
+	if (mixer->disp_bridge) {
+		of_xlnx_bridge_put(mixer->disp_bridge);
+		xlnx_mix_crtc_atomic_disable(&mixer->crtc.crtc, NULL);
+		xlnx_drm_pipeline_exit(mixer->master);
+	} else {
+		xlnx_drm_pipeline_exit(mixer->master);
+		component_del(&pdev->dev, &xlnx_mix_component_ops);
+	}
 	return 0;
 }
 
-- 
2.31.1

