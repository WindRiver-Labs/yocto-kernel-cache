From c5195ca3308965e3824e7d631af3ce6b703318e4 Mon Sep 17 00:00:00 2001
From: Jakub Palider <jpalider@marvell.com>
Date: Sat, 10 Apr 2021 01:09:42 +0530
Subject: [PATCH 1420/1921] misc: bphy: Restore static resource allocation

Use statically defined data arrays.

This patch is a result of memory corruption observed on
non-fusion platforms when dynamic deallocation takes part
on exit call. The problem does not appear in this driver
but implicitely impacts resource management. To prevent
this data structures are predefined arrays now. This is
half step back - number of maximum active irqs is still
obtained from ATF at runtime to provide some flexibility.

Signed-off-by: Jakub Palider <jpalider@marvell.com>
Change-Id: I1193a84a633c33f3de37a16d1d072d500f9d3142
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/49882
Tested-by: Devapraba Muthumani <dmuthumani@marvell.com>
Reviewed-by: Devapraba Muthumani <dmuthumani@marvell.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 drivers/misc/otx_bphy_ctr.c | 50 ++++++++++++++++++-------------------
 1 file changed, 24 insertions(+), 26 deletions(-)

diff --git a/drivers/misc/otx_bphy_ctr.c b/drivers/misc/otx_bphy_ctr.c
index 3db28714de55..da3aa4d90062 100644
--- a/drivers/misc/otx_bphy_ctr.c
+++ b/drivers/misc/otx_bphy_ctr.c
@@ -22,6 +22,14 @@
 
 #define DEVICE_NAME	"otx-bphy-ctr"
 #define OTX_IOC_MAGIC	0xF3
+/* Old MAX_IRQ has been redefined - now it describes
+ * maximum supported number of interrupts rather than
+ * actual number on current platform. The latter is obtained
+ * from ATF and indicates current capabilities.
+ * This is a limitationm but complies with maximum number of
+ * interrupts' bitmask.
+ */
+#define MAX_IRQ		64
 
 static unsigned long bphy_max_irq;
 static unsigned long bphy_irq_bmask;
@@ -31,9 +39,9 @@ static struct cdev *otx_cdev;
 static dev_t otx_dev;
 static DEFINE_SPINLOCK(el3_inthandler_lock);
 static int in_use;
-static int *irq_installed;
-static struct thread_info **irq_installed_threads;
-static struct task_struct **irq_installed_tasks;
+static int irq_installed[MAX_IRQ];
+static struct thread_info *irq_installed_threads[MAX_IRQ];
+static struct task_struct *irq_installed_tasks[MAX_IRQ];
 
 /* SMC definitons */
 /* X1 - irq_num, X2 - sp, X3 - cpu, X4 - ttbr0 */
@@ -208,6 +216,19 @@ static void cleanup_el3_irqs(struct task_struct *task)
 
 static int otx_dev_open(struct inode *inode, struct file *fp)
 {
+	struct arm_smccc_res res;
+
+	arm_smccc_smc(OCTEONTX_GET_BPHY_PSM_IRQS_BITMASK, 0,
+		      0, 0, 0, 0, 0, 0, &res);
+	bphy_irq_bmask = res.a0;
+
+	arm_smccc_smc(OCTEONTX_GET_BPHY_PSM_MAX_IRQ, 0,
+		      0, 0, 0, 0, 0, 0, &res);
+	bphy_max_irq = res.a0;
+
+	if (bphy_max_irq > MAX_IRQ)
+		return -1;
+
 	in_use = 1;
 	return 0;
 }
@@ -275,27 +296,8 @@ static int __init otx_ctr_dev_init(void)
 		goto cleanup_handler_err;
 	}
 
-	arm_smccc_smc(OCTEONTX_GET_BPHY_PSM_MAX_IRQ, 0,
-		      0, 0, 0, 0, 0, 0, &res);
-	bphy_max_irq = res.a0;
-
-	irq_installed = kcalloc(bphy_max_irq, sizeof(int), GFP_KERNEL);
-	irq_installed_threads = (struct thread_info **)
-		kcalloc(bphy_max_irq, sizeof(struct thread_info *), GFP_KERNEL);
-	irq_installed_tasks = (struct task_struct **)
-		kcalloc(bphy_max_irq, sizeof(struct task_struct *), GFP_KERNEL);
-	if (!irq_installed || !irq_installed_threads || !irq_installed_tasks) {
-		err = -ENOMEM;
-		goto alloc_err;
-	}
-
 	return err;
 
-alloc_err:
-	kfree(irq_installed);
-	kfree(irq_installed_threads);
-	kfree(irq_installed_tasks);
-
 device_create_err:
 	class_destroy(otx_class);
 
@@ -318,10 +320,6 @@ static void __exit otx_ctr_dev_exit(void)
 	unregister_chrdev_region(otx_dev, 1);
 
 	task_cleanup_handler_remove(cleanup_el3_irqs);
-
-	kfree(irq_installed);
-	kfree(irq_installed_threads);
-	kfree(irq_installed_tasks);
 }
 
 module_init(otx_ctr_dev_init);
-- 
2.31.1

