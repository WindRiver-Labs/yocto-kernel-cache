From 323559a48cfce21442a134b87fc3a789bd2ec867 Mon Sep 17 00:00:00 2001
From: Wendy Liang <wendy.liang@xilinx.com>
Date: Mon, 31 Aug 2020 17:30:24 -0700
Subject: [PATCH 1543/1852] misc: xilinx-ai-engine: add ioctl to pass dmabuf fd
 to set shimdma bd

commit d3b792dbb21b9b7de4cbed8604721a32cd78dc8c from
https://github.com/Xilinx/linux-xlnx.git

Add ioctl to set SHIMDMA buffer descriptor with dmabuf file descriptor.
With this ioctl, we don't need to take care of the virtual address to
dma address conversion, and don't need to force userspace to mmap()
before using setting the SHIMDMA buffer descriptor.

Signed-off-by: Wendy Liang <wendy.liang@xilinx.com>
Reviewed-by: Hyun Kwon <hyun.kwon@xilinx.com>
State: pending
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 drivers/misc/xilinx-ai-engine/ai-engine-dma.c | 178 ++++++++++++++++--
 .../xilinx-ai-engine/ai-engine-internal.h     |   2 +
 .../misc/xilinx-ai-engine/ai-engine-part.c    |   2 +
 include/uapi/linux/xlnx-ai-engine.h           |  28 +++
 4 files changed, 196 insertions(+), 14 deletions(-)

diff --git a/drivers/misc/xilinx-ai-engine/ai-engine-dma.c b/drivers/misc/xilinx-ai-engine/ai-engine-dma.c
index 641bb62a413c..8f801d53bf5e 100644
--- a/drivers/misc/xilinx-ai-engine/ai-engine-dma.c
+++ b/drivers/misc/xilinx-ai-engine/ai-engine-dma.c
@@ -28,6 +28,30 @@ struct aie_dmabuf {
 	struct list_head node;
 };
 
+/**
+ * aie_part_find_dmabuf() - find a attached dmabuf
+ * @apart: AI engine partition
+ * @dmabuf: pointer to dmabuf
+ * @return: pointer to AI engine dmabuf struct of the found dmabuf, if dmabuf
+ *	    is not found, returns NULL.
+ *
+ * This function scans all the attached dmabufs to see the input dmabuf is
+ * in the list. if it is attached, return the corresponding struct aie_dmabuf
+ * pointer.
+ */
+static struct aie_dmabuf *
+aie_part_find_dmabuf(struct aie_partition *apart, struct dma_buf *dmabuf)
+{
+	struct aie_dmabuf *adbuf;
+
+	list_for_each_entry(adbuf, &apart->dbufs, node) {
+		if (dmabuf == adbuf->attach->dmabuf)
+			return adbuf;
+	}
+
+	return NULL;
+}
+
 /**
  * aie_part_find_dmabuf_from_file() - find a attached dmabuf from file
  * @apart: AI engine partition
@@ -46,7 +70,7 @@ aie_part_find_dmabuf_from_file(struct aie_partition *apart,
 	struct aie_dmabuf *adbuf;
 
 	list_for_each_entry(adbuf, &apart->dbufs, node) {
-		if (file ==  adbuf->attach->dmabuf->file)
+		if (file == adbuf->attach->dmabuf->file)
 			return adbuf;
 	}
 
@@ -69,7 +93,6 @@ static dma_addr_t aie_part_get_dmabuf_da(struct aie_partition *apart,
 	struct vm_area_struct *vma;
 	struct aie_dmabuf *adbuf;
 	unsigned long va_start, va_off;
-	dma_addr_t da;
 
 	va_start = (unsigned long)((uintptr_t)va);
 	if (!current->mm) {
@@ -104,8 +127,52 @@ static dma_addr_t aie_part_get_dmabuf_da(struct aie_partition *apart,
 		return 0;
 	}
 
-	da = sg_dma_address(adbuf->sgt->sgl) + va_off;
-	return da;
+	return sg_dma_address(adbuf->sgt->sgl) + va_off;
+}
+
+/**
+ * aie_part_get_dmabuf_da_from_off() - get DMA address from offset to a dmabuf
+ * @apart: AI engine partition
+ * @dmabuf_fd: dmabuf file descriptor
+ * @off: offset to the start of a dmabuf
+ * @len: memory length
+ * @return: dma address, or 0 if @off or @len is invalid, or if @dmabuf_fd is
+ *	    not attached.
+ *
+ * This function returns DMA address if has been mapped to a dmabuf which has
+ * been attached to the AI engine partition.
+ */
+static dma_addr_t
+aie_part_get_dmabuf_da_from_off(struct aie_partition *apart, int dmabuf_fd,
+				u64 off, size_t len)
+{
+	struct dma_buf *dbuf = dma_buf_get(dmabuf_fd);
+	struct aie_dmabuf *adbuf;
+
+	if (IS_ERR(dbuf)) {
+		dev_err(&apart->dev,
+			"failed to get dma address, not able to get dmabuf from %d.\n",
+			dmabuf_fd);
+		return 0;
+	}
+
+	adbuf = aie_part_find_dmabuf(apart, dbuf);
+	dma_buf_put(dbuf);
+	if (!adbuf) {
+		dev_err(&apart->dev,
+			"failed to get dma address, dmabuf %d not attached.\n",
+			dmabuf_fd);
+		return 0;
+	}
+
+	if (off >= dbuf->size || off + len >= dbuf->size) {
+		dev_err(&apart->dev,
+			"failed to get dma address from buf %d, off=0x%llx, len=0x%zx.\n",
+			dmabuf_fd, off, len);
+		return 0;
+	}
+
+	return sg_dma_address(adbuf->sgt->sgl) + off;
 }
 
 /**
@@ -338,7 +405,7 @@ long aie_part_attach_dmabuf_req(struct aie_partition *apart,
 		return ret;
 	}
 
-	adbuf = aie_part_find_dmabuf_from_file(apart, dbuf->file);
+	adbuf = aie_part_find_dmabuf(apart, dbuf);
 	if (!adbuf)
 		adbuf = aie_part_attach_dmabuf(apart, dbuf);
 	else
@@ -388,7 +455,7 @@ long aie_part_detach_dmabuf_req(struct aie_partition *apart,
 		return ret;
 	}
 
-	adbuf = aie_part_find_dmabuf_from_file(apart, dbuf->file);
+	adbuf = aie_part_find_dmabuf(apart, dbuf);
 	dma_buf_put(dbuf);
 	if (!adbuf) {
 		dev_err(&apart->dev, "failed to find dmabuf %d.\n", dmabuf_fd);
@@ -431,14 +498,9 @@ long aie_part_set_bd(struct aie_partition *apart, void __user *user_args)
 		return -EINVAL;
 	}
 
-	bd = kzalloc(shim_dma->bd_len, GFP_KERNEL);
-	if (!bd)
-		return -ENOMEM;
-
-	if (copy_from_user(bd, (void __user *)args.bd, shim_dma->bd_len)) {
-		kfree(bd);
-		return -EFAULT;
-	}
+	bd = memdup_user((void __user *)args.bd, shim_dma->bd_len);
+	if (IS_ERR(bd))
+		return PTR_ERR(bd);
 
 	regval = bd[shim_dma->buflen.regoff / sizeof(u32)];
 	buf_len = aie_get_reg_field(&shim_dma->buflen, regval);
@@ -485,3 +547,91 @@ long aie_part_set_bd(struct aie_partition *apart, void __user *user_args)
 	kfree(bd);
 	return ret;
 }
+
+/**
+ * aie_part_set_dmabuf_bd() - Set AI engine SHIM DMA dmabuf buffer descriptor
+ * @apart: AI engine partition
+ * @user_args: user AI engine dmabuf argument
+ *
+ * @return: 0 for success, negative value for failure
+ *
+ * This function set the user specified buffer descriptor into the SHIM DMA
+ * buffer descriptor. The buffer descriptor contained in the @user_args has the
+ * offset to the start of the buffer descriptor.
+ */
+long aie_part_set_dmabuf_bd(struct aie_partition *apart,
+			    void __user *user_args)
+{
+	struct aie_device *adev = apart->adev;
+	const struct aie_dma_attr *shim_dma = adev->shim_dma;
+	struct aie_dmabuf_bd_args args;
+	u32 *bd, *tmpbd, len, laddr, haddr, regval;
+	u64 off;
+	dma_addr_t addr;
+	int ret;
+
+	if (copy_from_user(&args, user_args, sizeof(args)))
+		return -EFAULT;
+
+	ret = aie_part_validate_bdloc(apart, args.loc, args.bd_id);
+	if (ret) {
+		dev_err(&apart->dev, "invalid SHIM DMA BD reg address.\n");
+		return -EINVAL;
+	}
+
+	bd = memdup_user((void __user *)args.bd, shim_dma->bd_len);
+	if (IS_ERR(bd))
+		return PTR_ERR(bd);
+
+	regval = bd[shim_dma->buflen.regoff / sizeof(u32)];
+	len = aie_get_reg_field(&shim_dma->buflen, regval);
+	if (!len) {
+		dev_err(&apart->dev, "no buf length from shim dma bd.\n");
+		kfree(bd);
+		return -EINVAL;
+	}
+
+	/* Get low 32bit address offset */
+	tmpbd = (u32 *)((char *)bd + shim_dma->laddr.regoff);
+	laddr = *tmpbd & shim_dma->laddr.mask;
+	/* Get high 32bit address offset */
+	tmpbd = (u32 *)((char *)bd + shim_dma->haddr.regoff);
+	haddr = *tmpbd & shim_dma->haddr.mask;
+	off = laddr | ((u64)haddr << 32);
+
+	ret = mutex_lock_interruptible(&apart->mlock);
+	if (ret) {
+		kfree(bd);
+		return ret;
+	}
+
+	/* Get device address from offset */
+	addr = aie_part_get_dmabuf_da_from_off(apart, args.buf_fd, off, len);
+	if (!addr) {
+		dev_err(&apart->dev, "invalid buffer 0x%llx, 0x%x.\n",
+			off, len);
+		mutex_unlock(&apart->mlock);
+		kfree(bd);
+		return -EINVAL;
+	}
+
+	/* Set low 32bit address */
+	laddr = lower_32_bits(addr);
+	tmpbd = (u32 *)((char *)bd + shim_dma->laddr.regoff);
+	*tmpbd &= ~shim_dma->laddr.mask;
+	*tmpbd |= aie_get_field_val(&shim_dma->laddr, laddr);
+
+	/* Set high 32bit address */
+	haddr = upper_32_bits(addr);
+	tmpbd = (u32 *)((char *)bd + shim_dma->haddr.regoff);
+	*tmpbd &= ~shim_dma->haddr.mask;
+	*tmpbd |= aie_get_field_val(&shim_dma->haddr, haddr);
+
+	ret = aie_part_set_shimdma_bd(apart, args.loc, args.bd_id, bd);
+	mutex_unlock(&apart->mlock);
+	if (ret)
+		dev_err(&apart->dev, "failed to set to shim dma bd.\n");
+
+	kfree(bd);
+	return ret;
+}
diff --git a/drivers/misc/xilinx-ai-engine/ai-engine-internal.h b/drivers/misc/xilinx-ai-engine/ai-engine-internal.h
index c06546f4bead..a168c541b116 100644
--- a/drivers/misc/xilinx-ai-engine/ai-engine-internal.h
+++ b/drivers/misc/xilinx-ai-engine/ai-engine-internal.h
@@ -366,6 +366,8 @@ long aie_part_attach_dmabuf_req(struct aie_partition *apart,
 long aie_part_detach_dmabuf_req(struct aie_partition *apart,
 				void __user *user_args);
 long aie_part_set_bd(struct aie_partition *apart, void __user *user_args);
+long aie_part_set_dmabuf_bd(struct aie_partition *apart,
+			    void __user *user_args);
 void aie_part_release_dmabufs(struct aie_partition *apart);
 
 int aie_part_scan_clk_state(struct aie_partition *apart);
diff --git a/drivers/misc/xilinx-ai-engine/ai-engine-part.c b/drivers/misc/xilinx-ai-engine/ai-engine-part.c
index 3e233ad9f7e4..78b14960ff48 100644
--- a/drivers/misc/xilinx-ai-engine/ai-engine-part.c
+++ b/drivers/misc/xilinx-ai-engine/ai-engine-part.c
@@ -421,6 +421,8 @@ static long aie_part_ioctl(struct file *fp, unsigned int cmd, unsigned long arg)
 		return aie_part_detach_dmabuf_req(apart, argp);
 	case AIE_SET_SHIMDMA_BD_IOCTL:
 		return aie_part_set_bd(apart, argp);
+	case AIE_SET_SHIMDMA_DMABUF_BD_IOCTL:
+		return aie_part_set_dmabuf_bd(apart, argp);
 	case AIE_REQUEST_TILES_IOCTL:
 		return aie_part_request_tiles_from_user(apart, argp);
 	case AIE_RELEASE_TILES_IOCTL:
diff --git a/include/uapi/linux/xlnx-ai-engine.h b/include/uapi/linux/xlnx-ai-engine.h
index 57c3ff38bc39..353fd617a010 100644
--- a/include/uapi/linux/xlnx-ai-engine.h
+++ b/include/uapi/linux/xlnx-ai-engine.h
@@ -145,6 +145,21 @@ struct aie_dma_bd_args {
 	__u32 bd_id;
 };
 
+/**
+ * struct aie_dmabuf_bd_args - AIE dmabuf buffer descriptor information
+ * @bd: DMA buffer descriptor, within the buffer descriptor, the address field
+ *	will be the offset to the start of the dmabuf
+ * @buf_fd: DMA buffer handler which is dmabuf file descriptor
+ * @loc: Tile location relative to the start of a partition
+ * @bd_id: buffer descriptor id
+ */
+struct aie_dmabuf_bd_args {
+	__u32 *bd;
+	struct aie_location loc;
+	int buf_fd;
+	__u32 bd_id;
+};
+
 /**
  * struct aie_tiles_array - AIE tiles array
  * @locs: tiles locations array
@@ -230,4 +245,17 @@ struct aie_tiles_array {
  */
 #define AIE_RELEASE_TILES_IOCTL		_IOW(AIE_IOCTL_BASE, 0xf, \
 					     struct aie_tiles_array)
+
+/**
+ * DOC: AIE_SET_SHIMDMA_DMABUF_BD_IOCTL - set buffer descriptor which contains
+ *					  dmabuf to SHIM DMA
+ *
+ * This ioctl is used to set the buffer descriptor to SHIM DMA. The
+ * aie_dmabuf_bd_args contains the dmabuf fd and the buffer descriptor contents.
+ * The address field in the buffer descriptor contents should be the offset to
+ * the start of the dmabuf.
+ */
+#define AIE_SET_SHIMDMA_DMABUF_BD_IOCTL	_IOW(AIE_IOCTL_BASE, 0x10, \
+					     struct aie_dmabuf_bd_args)
+
 #endif
-- 
2.31.1

