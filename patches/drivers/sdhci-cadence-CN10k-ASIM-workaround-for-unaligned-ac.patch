From 2259bcb61e5721854107b0c896676d2740ac68b1 Mon Sep 17 00:00:00 2001
From: Jayanthi A <jayanthi.annadurai@cavium.com>
Date: Thu, 4 Mar 2021 23:30:06 -0800
Subject: [PATCH 1288/1921] sdhci-cadence: CN10k ASIM workaround for unaligned
 access

Adding workaround for unaligned host controller register access.

Change-Id: I08e0781f98b531a3e82c70358ac2773a29cc3468
Signed-off-by: Jayanthi A <jayanthi.annadurai@cavium.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/44329
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 drivers/mmc/host/Kconfig         |   1 +
 drivers/mmc/host/sdhci-cadence.c | 130 ++++++++++++++++++++++++++++---
 drivers/mmc/host/sdhci.c         |  53 +++++++++++++
 3 files changed, 175 insertions(+), 9 deletions(-)

diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index 931770f17087..542084f657c0 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -203,6 +203,7 @@ config MMC_SDHCI_CADENCE
 	tristate "SDHCI support for the Cadence SD/SDIO/eMMC controller"
 	depends on MMC_SDHCI_PLTFM
 	depends on OF
+	select MMC_SDHCI_IO_ACCESSORS
 	help
 	  This selects the Cadence SD/SDIO/eMMC driver.
 
diff --git a/drivers/mmc/host/sdhci-cadence.c b/drivers/mmc/host/sdhci-cadence.c
index 369328ad4257..22bea7fa872c 100644
--- a/drivers/mmc/host/sdhci-cadence.c
+++ b/drivers/mmc/host/sdhci-cadence.c
@@ -15,6 +15,8 @@
 
 #include "sdhci-pltfm.h"
 
+#define CN10K_ASIM	1
+
 #define SDHCI_CDNS_HRS04			0x10		/* PHY access port */
 /* SD 4.0 Controller HRS - Host Register Set (specific to Cadence) */
 #define SDHCI_CDNS_SD4_HRS04_ACK		BIT(26)
@@ -401,6 +403,106 @@ static void (*(init_timings[]))(struct sdhci_cdns_sd6_phy_timings*, int) = {
 	&init_emmc_ddr, &init_emmc_hs200, &init_emmc_hs400
 };
 
+#ifdef CONFIG_MMC_SDHCI_IO_ACCESSORS
+static u32 sdhci_cdns_sd6_readl(struct sdhci_host *host, int reg)
+{
+	return readl(host->ioaddr + reg);
+}
+
+static void sdhci_cdns_sd6_writel(struct sdhci_host *host, u32 val, int reg)
+{
+	writel(val, host->ioaddr + reg);
+}
+
+static u16 sdhci_cdns_sd6_readw(struct sdhci_host *host, int reg)
+{
+	u32 val, regoff;
+
+	regoff = reg & ~3;
+
+	val = readl(host->ioaddr + regoff);
+	if ((reg & 0x3) == 0)
+		return (val & 0xFFFF);
+	else
+		return ((val >> 16) & 0xFFFF);
+}
+
+static void sdhci_cdns_sd6_writew(struct sdhci_host *host, u16 val, int reg)
+{
+#ifdef CN10K_ASIM
+
+	u32 regval, regoff;
+
+	regoff = reg & ~3;
+	regval = readl(host->ioaddr + regoff);
+
+	if ((reg & 3) == 0) {
+		regval &= ~0xFFFF;
+		regval |= val;
+	} else {
+		regval &= ~(0xFFFF << 16);
+		regval |= (val << 16);
+	}
+	writel(regval, host->ioaddr + regoff);
+#else
+	writew(val, host->ioaddr + reg);
+#endif
+}
+
+static u8 sdhci_cdns_sd6_readb(struct sdhci_host *host, int reg)
+{
+	u32 val, regoff;
+
+	regoff = reg & ~3;
+
+	val = readl(host->ioaddr + regoff);
+	switch (reg & 3) {
+	case 0:
+		return (val & 0xFF);
+	case 1:
+		return ((val >> 8) & 0xFF);
+	case 2:
+		return ((val >> 16) & 0xFF);
+	case 3:
+		return ((val >> 24) & 0xFF);
+	}
+	return 0;
+}
+
+static void sdhci_cdns_sd6_writeb(struct sdhci_host *host, u8 val, int reg)
+{
+#ifdef CN10K_ASIM
+
+	u32 regval, regoff;
+
+	regoff = reg & ~3;
+	regval = readl(host->ioaddr + regoff);
+
+	switch (reg & 3) {
+	case 0:
+		regval &= ~0xFF;
+		regval |= val;
+		break;
+	case 1:
+		regval &= ~(0xFF << 8);
+		regval |= (val << 8);
+		break;
+	case 2:
+		regval &= ~(0xFF << 16);
+		regval |= (val << 16);
+		break;
+	case 3:
+		regval &= ~(0xFF << 24);
+		regval |= (val << 24);
+		break;
+	}
+	writel(regval, host->ioaddr + regoff);
+#else
+	writeb(val, host->ioaddr + reg);
+#endif
+}
+#endif
+
 static int sdhci_cdns_sd6_phy_clock_validate(struct sdhci_cdns_sd6_phy *phy)
 {
 	int status = 0;
@@ -948,11 +1050,12 @@ static int sdhci_cdns_sd6_phy_init(struct sdhci_cdns_priv *priv)
 		reg &= ~SDHCI_CDNS_HRS09_EXTENDED_RD_MODE;
 
 	reg |= SDHCI_CDNS_HRS09_RDDATA_EN | SDHCI_CDNS_HRS09_RDCMD_EN;
-	writel(reg, priv->hrs_addr + SDHCI_CDNS_HRS09);
+	writel(0x1800c, priv->hrs_addr + SDHCI_CDNS_HRS09);
+	// FIXME J writel(reg, priv->hrs_addr + SDHCI_CDNS_HRS09);
 
 	reg = 0x0;
-	reg = FIELD_PREP(SDHCI_CDNS_HRS10_HCSDCLKADJ,
-			 phy->settings.sdhc_hcsdclkadj);
+	reg = FIELD_PREP(SDHCI_CDNS_HRS10_HCSDCLKADJ, 0x6);
+			// FIXME J phy->settings.sdhc_hcsdclkadj);
 	writel(reg, priv->hrs_addr + SDHCI_CDNS_HRS10);
 
 	reg = 0x0;
@@ -1058,8 +1161,7 @@ static void sdhci_cdns_set_uhs_signaling(struct sdhci_host *host,
 		mode = SDHCI_CDNS_HRS06_MODE_SD;
 		break;
 	default:
-		mode = SDHCI_CDNS_HRS06_MODE_LEGACY; //SDHCI_CDNS_HRS06_MODE_MMC_HS200;
-		//mode = SDHCI_CDNS_HRS06_MODE_LEGACY;
+		mode = SDHCI_CDNS_HRS06_MODE_LEGACY;
 		break;
 	}
 
@@ -1157,7 +1259,6 @@ static u32 sdhci_cdns_sd6_get_mode(struct sdhci_host *host,
 		mode = SDHCI_CDNS_HRS06_MODE_SD;
 		break;
 	default:
-		//mode = SDHCI_CDNS_HRS06_MODE_SD;
 		mode = SDHCI_CDNS_HRS06_MODE_LEGACY;
 		break;
 	}
@@ -1191,8 +1292,12 @@ static void sdhci_cdns_sd6_set_clock(struct sdhci_host *host,
 	struct sdhci_cdns_priv *priv = sdhci_cdns_priv(host);
 	struct sdhci_cdns_sd6_phy *phy = priv->phy;
 
+#ifdef CN10K_ASIM
+	return;
+#endif
+
 	phy->mode = sdhci_cdns_sd6_get_mode(host, host->mmc->ios.timing);
-	phy->t_sdclk = 2500000; //DIV_ROUND_DOWN_ULL(1e12, clock);
+	phy->t_sdclk = DIV_ROUND_DOWN_ULL(1e12, clock);
 
 	dev_info(mmc_dev(host->mmc), "%s %d %d\n", __func__, phy->mode, clock);
 
@@ -1202,7 +1307,6 @@ static void sdhci_cdns_sd6_set_clock(struct sdhci_host *host,
 	if (sdhci_cdns_sd6_phy_init(priv))
 		dev_info(mmc_dev(host->mmc), "%s: phy init failed\n", __func__);
 
-
 	// TODO rozwazyc dll reset przed set clock i wyjscie z resetu za
 	// set clock
 	sdhci_set_clock(host, clock);
@@ -1268,7 +1372,7 @@ static int sdhci_cdns_sd6_phy_probe(struct platform_device *pdev,
 		return ret;
 
 	phy->d.delay_element_org = phy->d.delay_element;
-	phy->mode = SDHCI_CDNS_HRS06_MODE_SD;
+	phy->mode = SDHCI_CDNS_HRS06_MODE_LEGACY;
 	phy->t_sdclk = 1000000 / 50;
 
 	priv->phy = phy;
@@ -1362,6 +1466,14 @@ static const struct sdhci_ops sdhci_cdns_sd4_ops = {
 };
 
 static const struct sdhci_ops sdhci_cdns_sd6_ops = {
+#ifdef CONFIG_MMC_SDHCI_IO_ACCESSORS
+	.read_l = sdhci_cdns_sd6_readl,
+	.write_l = sdhci_cdns_sd6_writel,
+	.read_w = sdhci_cdns_sd6_readw,
+	.write_w = sdhci_cdns_sd6_writew,
+	.read_b = sdhci_cdns_sd6_readb,
+	.write_b = sdhci_cdns_sd6_writeb,
+#endif
 	.set_clock = sdhci_cdns_sd6_set_clock,
 	.get_timeout_clock = sdhci_cdns_get_timeout_clock,
 	.set_bus_width = sdhci_set_bus_width,
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index b59612d030d3..faab0f7b3c0d 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -41,8 +41,13 @@
 #define SDHCI_DUMP(f, x...) \
 	pr_err("%s: " DRIVER_NAME ": " f, mmc_hostname(host->mmc), ## x)
 
+#define CN10K_ASIM_WORKAROUND	1
 #define MAX_TUNING_LOOP 40
 
+#ifdef CN10K_ASIM_WORKAROUND
+static int trfr_mode;
+#endif
+
 static unsigned int debug_quirks = 0;
 static unsigned int debug_quirks2;
 
@@ -1190,8 +1195,13 @@ static inline void sdhci_auto_cmd_select(struct sdhci_host *host,
 		*mode |= SDHCI_TRNS_AUTO_CMD23;
 }
 
+#ifdef CN10K_ASIM_WORKAROUND
+static u16 sdhci_set_transfer_mode(struct sdhci_host *host,
+	struct mmc_command *cmd)
+#else
 static void sdhci_set_transfer_mode(struct sdhci_host *host,
 	struct mmc_command *cmd)
+#endif
 {
 	u16 mode = 0;
 	struct mmc_data *data = cmd->data;
@@ -1201,14 +1211,28 @@ static void sdhci_set_transfer_mode(struct sdhci_host *host,
 			SDHCI_QUIRK2_CLEAR_TRANSFERMODE_REG_BEFORE_CMD) {
 			/* must not clear SDHCI_TRANSFER_MODE when tuning */
 			if (cmd->opcode != MMC_SEND_TUNING_BLOCK_HS200)
+#ifdef CN10K_ASIM_WORKAROUND
+				mode = 0;
+#else
 				sdhci_writew(host, 0x0, SDHCI_TRANSFER_MODE);
+#endif
 		} else {
 		/* clear Auto CMD settings for no data CMDs */
 			mode = sdhci_readw(host, SDHCI_TRANSFER_MODE);
+#ifdef CN10K_ASIM_WORKAROUND
+			mode = 0;
+#else
+			mode = (mode & ~(SDHCI_TRNS_AUTO_CMD12 |
+				SDHCI_TRNS_AUTO_CMD23));
 			sdhci_writew(host, mode & ~(SDHCI_TRNS_AUTO_CMD12 |
 				SDHCI_TRNS_AUTO_CMD23), SDHCI_TRANSFER_MODE);
+#endif
 		}
+#ifdef CN10K_ASIM_WORKAROUND
+		return mode;
+#else
 		return;
+#endif
 	}
 
 	WARN_ON(!host->data);
@@ -1228,7 +1252,11 @@ static void sdhci_set_transfer_mode(struct sdhci_host *host,
 	if (host->flags & SDHCI_REQ_USE_DMA)
 		mode |= SDHCI_TRNS_DMA;
 
+#ifdef CN10K_ASIM_WORKAROUND
+	return mode;
+#else
 	sdhci_writew(host, mode, SDHCI_TRANSFER_MODE);
+#endif
 }
 
 static bool sdhci_needs_reset(struct sdhci_host *host, struct mmc_request *mrq)
@@ -1349,6 +1377,9 @@ void sdhci_send_command(struct sdhci_host *host, struct mmc_command *cmd)
 	int flags;
 	u32 mask;
 	unsigned long timeout;
+#ifdef CN10K_ASIM_WORKAROUND
+	u32 mode, cmdreg32;
+#endif
 
 	WARN_ON(host->cmd);
 
@@ -1394,7 +1425,11 @@ void sdhci_send_command(struct sdhci_host *host, struct mmc_command *cmd)
 
 	sdhci_writel(host, cmd->arg, SDHCI_ARGUMENT);
 
+#ifdef CN10K_ASIM_WORKAROUND
+	mode = sdhci_set_transfer_mode(host, cmd);
+#else
 	sdhci_set_transfer_mode(host, cmd);
+#endif
 
 	if ((cmd->flags & MMC_RSP_136) && (cmd->flags & MMC_RSP_BUSY)) {
 		pr_err("%s: Unsupported response type!\n",
@@ -1430,9 +1465,20 @@ void sdhci_send_command(struct sdhci_host *host, struct mmc_command *cmd)
 		timeout += DIV_ROUND_UP(cmd->busy_timeout, 1000) * HZ + HZ;
 	else
 		timeout += 10 * HZ;
+
 	sdhci_mod_timer(host, cmd->mrq, timeout);
 
+#ifdef CN10K_ASIM_WORKAROUND
+	if (trfr_mode) {
+		cmdreg32 = SDHCI_TRNS_READ | mode | (SDHCI_MAKE_CMD(cmd->opcode, flags) << 16);
+		trfr_mode = 0;
+	} else {
+		cmdreg32 = mode | (SDHCI_MAKE_CMD(cmd->opcode, flags) << 16);
+	}
+	sdhci_writel(host, cmdreg32, SDHCI_TRANSFER_MODE);
+#else
 	sdhci_writew(host, SDHCI_MAKE_CMD(cmd->opcode, flags), SDHCI_COMMAND);
+#endif
 }
 EXPORT_SYMBOL_GPL(sdhci_send_command);
 
@@ -2361,8 +2407,12 @@ void sdhci_send_tuning(struct sdhci_host *host, u32 opcode)
 	 * This also takes care of setting DMA Enable and Multi Block
 	 * Select in the same register to 0.
 	 */
+#ifndef CN10K_ASIM_WORKAROUND
 	sdhci_writew(host, SDHCI_TRNS_READ, SDHCI_TRANSFER_MODE);
 
+#else
+	trfr_mode = SDHCI_TRNS_READ;
+#endif
 	sdhci_send_command(host, &cmd);
 
 	host->cmd = NULL;
@@ -2384,6 +2434,9 @@ static int __sdhci_execute_tuning(struct sdhci_host *host, u32 opcode)
 {
 	int i;
 
+#ifndef CN10K_ASIM_WORKAROUND
+	return 0;
+#endif
 	/*
 	 * Issue opcode repeatedly till Execute Tuning is set to 0 or the number
 	 * of loops reaches tuning loop count.
-- 
2.31.1

