From ba5018fff80fd1c90254b040539c8800e63fd72e Mon Sep 17 00:00:00 2001
From: Bharat Kumar Gogada <bharat.kumar.gogada@xilinx.com>
Date: Mon, 13 Jan 2020 15:26:33 +0530
Subject: [PATCH 0837/1852] PCI: XDMA PL PCIe: Add support MSI DECODE mode

commit 5b4ea9e5a49889c167a7ee6aa233918706754531 from
https://github.com/Xilinx/linux-xlnx.git

The XDMA IP now support MSI decode mode along with existing
MSI FIFO mode.
In both FIFO and DECODE mode 64 MSI's are supported.
The new DECODE mode uses three GIC IRQ lines, one for legacy
and error, two for lower and upper 32 MSI.

Signed-off-by: Bharat Kumar Gogada <bharat.kumar.gogada@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
State: not-upstreamable
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 drivers/pci/controller/pcie-xdma-pl.c | 149 +++++++++++++++++++++++---
 1 file changed, 134 insertions(+), 15 deletions(-)

diff --git a/drivers/pci/controller/pcie-xdma-pl.c b/drivers/pci/controller/pcie-xdma-pl.c
index d523f7c08508..bf81c92e11d2 100644
--- a/drivers/pci/controller/pcie-xdma-pl.c
+++ b/drivers/pci/controller/pcie-xdma-pl.c
@@ -20,8 +20,10 @@
 #include <linux/of_irq.h>
 #include <linux/pci.h>
 #include <linux/platform_device.h>
+#include <linux/irqchip/chained_irq.h>
 
 /* Register definitions */
+#define XILINX_PCIE_REG_VSEC		0x0000012c
 #define XILINX_PCIE_REG_BIR		0x00000130
 #define XILINX_PCIE_REG_IDR		0x00000138
 #define XILINX_PCIE_REG_IMR		0x0000013c
@@ -34,6 +36,10 @@
 #define XILINX_PCIE_REG_RPIFR2		0x0000015c
 #define XILINX_PCIE_REG_IDRN            0x00000160
 #define XILINX_PCIE_REG_IDRN_MASK       0x00000164
+#define XILINX_PCIE_REG_MSI_LOW		0x00000170
+#define XILINX_PCIE_REG_MSI_HI		0x00000174
+#define XILINX_PCIE_REG_MSI_LOW_MASK	0x00000178
+#define XILINX_PCIE_REG_MSI_HI_MASK	0x0000017c
 
 /* Interrupt registers definitions */
 #define XILINX_PCIE_INTR_LINK_DOWN	BIT(0)
@@ -71,6 +77,9 @@
 #define XILINX_PCIE_RPIFR1_ALL_MASK	0xFFFFFFFF
 #define XILINX_PCIE_RPIFR1_INTR_SHIFT	27
 #define XILINX_PCIE_IDRN_SHIFT          16
+#define XILINX_PCIE_VSEC_REV_MASK	GENMASK(19, 16)
+#define XILINX_PCIE_VSEC_REV_SHIFT	16
+#define XILINX_PCIE_FIFO_SHIFT		5
 
 /* Bridge Info Register definitions */
 #define XILINX_PCIE_BIR_ECAM_SZ_MASK	GENMASK(18, 16)
@@ -90,15 +99,22 @@
 #define ECAM_DEV_NUM_SHIFT		12
 
 /* Number of MSI IRQs */
-#define XILINX_NUM_MSI_IRQS		32
+#define XILINX_NUM_MSI_IRQS		64
 #define INTX_NUM                        4
 
+enum msi_mode {
+	MSI_DECD_MODE = 1,
+	MSI_FIFO_MODE,
+};
+
 struct xilinx_msi {
 	struct irq_domain *msi_domain;
 	unsigned long *bitmap;
 	struct irq_domain *dev_domain;
 	struct mutex lock;		/* protect bitmap variable */
 	unsigned long msi_pages;
+	int irq_msi0;
+	int irq_msi1;
 };
 
 /**
@@ -110,6 +126,8 @@ struct xilinx_msi {
  * @leg_domain: Legacy IRQ domain pointer
  * @resources: Bus Resources
  * @msi: MSI information
+ * @irq_misc: Legacy and error interrupt number
+ * @msi_mode: MSI mode
  */
 struct xilinx_pcie_port {
 	void __iomem *reg_base;
@@ -119,6 +137,8 @@ struct xilinx_pcie_port {
 	struct irq_domain *leg_domain;
 	struct list_head resources;
 	struct xilinx_msi msi;
+	int irq_misc;
+	u8 msi_mode;
 };
 
 static inline u32 pcie_read(struct xilinx_pcie_port *port, u32 reg)
@@ -246,6 +266,48 @@ static const struct irq_domain_ops intx_domain_ops = {
 	.xlate = pci_irqd_intx_xlate,
 };
 
+static void xilinx_pcie_handle_msi_irq(struct xilinx_pcie_port *port,
+				       u32 status_reg)
+{
+	struct xilinx_msi *msi;
+	unsigned long status;
+	u32 bit;
+	u32 virq;
+
+	msi = &port->msi;
+
+	while ((status = pcie_read(port, status_reg)) != 0) {
+		for_each_set_bit(bit, &status, 32) {
+			pcie_write(port, 1 << bit, status_reg);
+			if (status_reg == XILINX_PCIE_REG_MSI_HI)
+				bit = bit + 32;
+			virq = irq_find_mapping(msi->dev_domain, bit);
+			if (virq)
+				generic_handle_irq(virq);
+		}
+	}
+}
+
+static void xilinx_pcie_msi_handler_high(struct irq_desc *desc)
+{
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+	struct xilinx_pcie_port *port = irq_desc_get_handler_data(desc);
+
+	chained_irq_enter(chip, desc);
+	xilinx_pcie_handle_msi_irq(port, XILINX_PCIE_REG_MSI_HI);
+	chained_irq_exit(chip, desc);
+}
+
+static void xilinx_pcie_msi_handler_low(struct irq_desc *desc)
+{
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+	struct xilinx_pcie_port *port = irq_desc_get_handler_data(desc);
+
+	chained_irq_enter(chip, desc);
+	xilinx_pcie_handle_msi_irq(port, XILINX_PCIE_REG_MSI_LOW);
+	chained_irq_exit(chip, desc);
+}
+
 /**
  * xilinx_pcie_intr_handler - Interrupt Service Handler
  * @irq: IRQ number
@@ -307,7 +369,8 @@ static irqreturn_t xilinx_pcie_intr_handler(int irq, void *data)
 							    bit));
 	}
 
-	if (status & XILINX_PCIE_INTR_MSI) {
+	if (port->msi_mode == MSI_FIFO_MODE &&
+	    (status & XILINX_PCIE_INTR_MSI)) {
 		/* MSI Interrupt */
 		val = pcie_read(port, XILINX_PCIE_REG_RPIFR1);
 
@@ -544,7 +607,12 @@ static void xilinx_pcie_init_port(struct xilinx_pcie_port *port)
 	/* Enable all interrupts */
 	pcie_write(port, XILINX_PCIE_IMR_ALL_MASK, XILINX_PCIE_REG_IMR);
 	pcie_write(port, XILINX_PCIE_IDRN_MASK, XILINX_PCIE_REG_IDRN_MASK);
-
+	if (port->msi_mode == MSI_DECD_MODE) {
+		pcie_write(port, XILINX_PCIE_IDR_ALL_MASK,
+			   XILINX_PCIE_REG_MSI_LOW_MASK);
+		pcie_write(port, XILINX_PCIE_IDR_ALL_MASK,
+			   XILINX_PCIE_REG_MSI_HI_MASK);
+	}
 	/* Enable the Bridge enable bit */
 	pcie_write(port, pcie_read(port, XILINX_PCIE_REG_RPSC) |
 			 XILINX_PCIE_REG_RPSC_BEN,
@@ -561,9 +629,10 @@ static int xilinx_pcie_parse_dt(struct xilinx_pcie_port *port)
 {
 	struct device *dev = port->dev;
 	struct device_node *node = dev->of_node;
+	struct platform_device *pdev = to_platform_device(dev);
 	struct resource regs;
 	const char *type;
-	int err;
+	int err, mode_val, val;
 
 	type = of_get_property(node, "device_type", NULL);
 	if (!type || strcmp(type, "pci")) {
@@ -581,19 +650,69 @@ static int xilinx_pcie_parse_dt(struct xilinx_pcie_port *port)
 	if (IS_ERR(port->reg_base))
 		return PTR_ERR(port->reg_base);
 
-	port->irq = irq_of_parse_and_map(node, 0);
-	if (port->irq <= 0) {
-		dev_err(dev, "Unable to find IRQ line\n");
-		err = -ENODEV;
-		return err;
+	val = pcie_read(port, XILINX_PCIE_REG_BIR);
+	val = (val >> XILINX_PCIE_FIFO_SHIFT) & MSI_DECD_MODE;
+	mode_val = pcie_read(port, XILINX_PCIE_REG_VSEC) &
+			XILINX_PCIE_VSEC_REV_MASK;
+	mode_val = mode_val >> XILINX_PCIE_VSEC_REV_SHIFT;
+	if (mode_val && !val) {
+		port->msi_mode = MSI_DECD_MODE;
+		dev_info(dev, "Using MSI Decode mode\n");
+	} else {
+		port->msi_mode = MSI_FIFO_MODE;
+		dev_info(dev, "Using MSI FIFO mode\n");
 	}
 
-	err = devm_request_irq(dev, port->irq, xilinx_pcie_intr_handler,
-			       IRQF_SHARED | IRQF_NO_THREAD,
-			       "xilinx-pcie", port);
-	if (err) {
-		dev_err(dev, "unable to request irq %d\n", port->irq);
-		return err;
+	if (port->msi_mode == MSI_DECD_MODE) {
+		port->irq_misc = platform_get_irq_byname(pdev, "misc");
+		if (port->irq_misc <= 0) {
+			dev_err(dev, "Unable to find misc IRQ line\n");
+			return port->irq_misc;
+		}
+		err = devm_request_irq(dev, port->irq_misc,
+				       xilinx_pcie_intr_handler,
+				       IRQF_SHARED | IRQF_NO_THREAD,
+				       "xilinx-pcie", port);
+		if (err) {
+			dev_err(dev, "unable to request misc IRQ line %d\n",
+				port->irq);
+			return err;
+		}
+
+		port->msi.irq_msi0 = platform_get_irq_byname(pdev, "msi0");
+		if (port->msi.irq_msi0 <= 0) {
+			dev_err(dev, "Unable to find msi0 IRQ line\n");
+			return port->msi.irq_msi0;
+		}
+
+		irq_set_chained_handler_and_data(port->msi.irq_msi0,
+						 xilinx_pcie_msi_handler_low,
+						 port);
+
+		port->msi.irq_msi1 = platform_get_irq_byname(pdev, "msi1");
+		if (port->msi.irq_msi1 <= 0) {
+			dev_err(dev, "Unable to find msi1 IRQ line\n");
+			return port->msi.irq_msi1;
+		}
+
+		irq_set_chained_handler_and_data(port->msi.irq_msi1,
+						 xilinx_pcie_msi_handler_high,
+						 port);
+
+	} else if (port->msi_mode == MSI_FIFO_MODE) {
+		port->irq = irq_of_parse_and_map(node, 0);
+		if (!port->irq) {
+			dev_err(dev, "Unable to find IRQ line\n");
+			return -ENXIO;
+		}
+
+		err = devm_request_irq(dev, port->irq, xilinx_pcie_intr_handler,
+				       IRQF_SHARED | IRQF_NO_THREAD,
+				       "xilinx-pcie", port);
+		if (err) {
+			dev_err(dev, "unable to request irq %d\n", port->irq);
+			return err;
+		}
 	}
 
 	return 0;
-- 
2.31.1

