From ff934ca0b8b4f4625eabb2c25db0c99f055c77e2 Mon Sep 17 00:00:00 2001
From: Subbaraya Sundeep <sbhatta@marvell.com>
Date: Fri, 16 Oct 2020 20:38:58 +0530
Subject: [PATCH 663/767] octeontx2-af: Do not shift more than data type size

Right or Left shifting a data type by a shift amount
greater than or equal to size of the data type
results in undefined behavior. Hence avoid it.
Also the argument 'type' of function npc_set_kws
is called with enum header_fields and
enum key_fields hence do not use
enum key_fields as argument.

Change-Id: I637028017c3a92f97d299d37cf0dd0e441c1d882
Signed-off-by: Subbaraya Sundeep <sbhatta@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/38174
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Integrated-by: Abhishek Paliwal <paliwal.abhishek@windriver.com>
---
 .../marvell/octeontx2/af/rvu_npc_fs.c         | 33 +++++++++++--------
 1 file changed, 19 insertions(+), 14 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc_fs.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc_fs.c
index 8956d98a69a5..12f739778dc8 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc_fs.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc_fs.c
@@ -45,7 +45,7 @@ const char *npc_get_field_name(u8 hdr)
 /* Compute keyword masks and figure out the number of keywords a field
  * spans in the key.
  */
-static void npc_set_kw_masks(struct npc_mcam *mcam, enum key_fields type,
+static void npc_set_kw_masks(struct npc_mcam *mcam, u8 type,
 			     u8 nr_bits, int start_kwi, int offset, u8 intf)
 {
 	struct npc_key_field *field = &mcam->rx_key_fields[type];
@@ -66,7 +66,8 @@ static void npc_set_kw_masks(struct npc_mcam *mcam, enum key_fields type,
 		/* one KW only */
 		if (start_kwi > max_kwi)
 			return;
-		field->kw_mask[start_kwi] |= (BIT_ULL(nr_bits) - 1) << offset;
+		field->kw_mask[start_kwi] |= GENMASK_ULL(nr_bits - 1, 0)
+					     << offset;
 		field->nr_kws = 1;
 	} else if (offset + nr_bits > 64 &&
 		   offset + nr_bits <= 128) {
@@ -75,11 +76,11 @@ static void npc_set_kw_masks(struct npc_mcam *mcam, enum key_fields type,
 			return;
 		/* first KW mask */
 		bits_in_kw = 64 - offset;
-		field->kw_mask[start_kwi] |= (BIT_ULL(bits_in_kw) - 1)
-						<< offset;
+		field->kw_mask[start_kwi] |= GENMASK_ULL(bits_in_kw - 1, 0)
+					     << offset;
 		/* second KW mask i.e. mask for rest of bits */
 		bits_in_kw = nr_bits + offset - 64;
-		field->kw_mask[start_kwi + 1] |= BIT_ULL(bits_in_kw) - 1;
+		field->kw_mask[start_kwi + 1] |= GENMASK_ULL(bits_in_kw - 1, 0);
 		field->nr_kws = 2;
 	} else {
 		/* three KWs */
@@ -87,13 +88,13 @@ static void npc_set_kw_masks(struct npc_mcam *mcam, enum key_fields type,
 			return;
 		/* first KW mask */
 		bits_in_kw = 64 - offset;
-		field->kw_mask[start_kwi] |= (BIT_ULL(bits_in_kw) - 1)
-						<< offset;
+		field->kw_mask[start_kwi] |= GENMASK_ULL(bits_in_kw - 1, 0)
+					     << offset;
 		/* second KW mask */
 		field->kw_mask[start_kwi + 1] = ~0ULL;
 		/* third KW mask i.e. mask for rest of bits */
 		bits_in_kw = nr_bits + offset - 128;
-		field->kw_mask[start_kwi + 2] |= BIT_ULL(bits_in_kw) - 1;
+		field->kw_mask[start_kwi + 2] |= GENMASK_ULL(bits_in_kw - 1, 0);
 		field->nr_kws = 3;
 	}
 }
@@ -629,11 +630,13 @@ static void npc_update_entry(struct rvu *rvu, enum key_fields type,
 		/* place remaining bits of key value in kw[x + 1] */
 		if (field->nr_kws == 2) {
 			/* update entry value */
-			kw2 = (val_lo >> (64 - shift)) | (val_hi << shift);
+			kw2 = shift ? val_lo >> (64 - shift) : 0;
+			kw2 |= (val_hi << shift);
 			kw2 &= field->kw_mask[i + 1];
 			dummy.kw[i + 1] = kw2;
 			/* update entry mask */
-			kw2 = (mask_lo >> (64 - shift)) | (mask_hi << shift);
+			kw2 = shift ? mask_lo >> (64 - shift) : 0;
+			kw2 |= (mask_hi << shift);
 			kw2 &= field->kw_mask[i + 1];
 			dummy.kw_mask[i + 1] = kw2;
 			break;
@@ -641,16 +644,18 @@ static void npc_update_entry(struct rvu *rvu, enum key_fields type,
 		/* place remaining bits of key value in kw[x + 1], kw[x + 2] */
 		if (field->nr_kws == 3) {
 			/* update entry value */
-			kw2 = (val_lo >> (64 - shift)) | (val_hi << shift);
+			kw2 = shift ? val_lo >> (64 - shift) : 0;
+			kw2 |= (val_hi << shift);
 			kw2 &= field->kw_mask[i + 1];
-			kw3 = (val_hi >> (64 - shift));
+			kw3 = shift ? val_hi >> (64 - shift) : 0;
 			kw3 &= field->kw_mask[i + 2];
 			dummy.kw[i + 1] = kw2;
 			dummy.kw[i + 2] = kw3;
 			/* update entry mask */
-			kw2 = (mask_lo >> (64 - shift)) | (mask_hi << shift);
+			kw2 = shift ? mask_lo >> (64 - shift) : 0;
+			kw2 |= (mask_hi << shift);
 			kw2 &= field->kw_mask[i + 1];
-			kw3 = (mask_hi >> (64 - shift));
+			kw3 = shift ? mask_hi >> (64 - shift) : 0;
 			kw3 &= field->kw_mask[i + 2];
 			dummy.kw_mask[i + 1] = kw2;
 			dummy.kw_mask[i + 2] = kw3;
-- 
2.31.1

