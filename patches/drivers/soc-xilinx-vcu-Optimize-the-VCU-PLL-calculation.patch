From 7f66134397d73179399eefe0a0caa97c04c31585 Mon Sep 17 00:00:00 2001
From: Dhaval Shah <dhaval.shah@xilinx.com>
Date: Mon, 13 Jan 2020 00:20:46 -0800
Subject: [PATCH 0808/1852] soc: xilinx: vcu: Optimize the VCU PLL calculation.

commit 857c60dc3f2bbe63a5d8c97700920ab644a92dfc from
https://github.com/Xilinx/linux-xlnx.git

Calculate the maximum and minimum possible FBDIV
values so that number of iteration can be reduce to
calculate FBDIV and divisor for the provided clock
information.

Signed-off-by: Dhaval Shah <dhaval.shah@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
Signed-off-by: Rohit Visavalia <rohit.visavalia@xilinx.com>
State: not-upstreamable
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 drivers/soc/xilinx/xlnx_vcu.c | 54 ++++++++++++++++++++---------------
 1 file changed, 31 insertions(+), 23 deletions(-)

diff --git a/drivers/soc/xilinx/xlnx_vcu.c b/drivers/soc/xilinx/xlnx_vcu.c
index d7808a09a11c..0451d9fc2d5b 100644
--- a/drivers/soc/xilinx/xlnx_vcu.c
+++ b/drivers/soc/xilinx/xlnx_vcu.c
@@ -352,6 +352,7 @@ static int xvcu_set_vcu_pll_info(struct xvcu_device *xvcu)
 	u32 divisor_mcu, divisor_core, fvco;
 	u32 clkoutdiv, vcu_pll_ctrl, pll_clk;
 	u32 cfg_val, mod, ctrl;
+	u32 fbdiv_max, fbdiv_min;
 	int ret, i;
 	const struct xvcu_pll_cfg *found = NULL;
 
@@ -382,6 +383,15 @@ static int xvcu_set_vcu_pll_info(struct xvcu_device *xvcu)
 
 	refclk = clk_get_rate(xvcu->pll_ref);
 
+	/* Calculate max and min possible FBDIV value */
+	fbdiv_max = FVCO_MAX / refclk;
+	if (fbdiv_max >= ARRAY_SIZE(xvcu_pll_cfg))
+		fbdiv_max = ARRAY_SIZE(xvcu_pll_cfg) - 1;
+
+	fbdiv_min = DIV_ROUND_UP(FVCO_MIN, refclk);
+	dev_dbg(xvcu->dev, "Maximum possible fbdiv value is %u\n", fbdiv_max);
+	dev_dbg(xvcu->dev, "Minimum possible fbdiv value is %u\n", fbdiv_min);
+
 	/*
 	 * The divide-by-2 should be always enabled (==1)
 	 * to meet the timing in the design.
@@ -395,32 +405,30 @@ static int xvcu_set_vcu_pll_info(struct xvcu_device *xvcu)
 		return -EINVAL;
 	}
 
-	for (i = ARRAY_SIZE(xvcu_pll_cfg) - 1; i >= 0; i--) {
+	for (i = fbdiv_max; i >= fbdiv_min; i--) {
 		const struct xvcu_pll_cfg *cfg = &xvcu_pll_cfg[i];
 
 		fvco = cfg->fbdiv * refclk;
-		if (fvco >= FVCO_MIN && fvco <= FVCO_MAX) {
-			pll_clk = fvco / VCU_PLL_DIV2;
-			if (fvco % VCU_PLL_DIV2 != 0)
-				pll_clk++;
-			mod = pll_clk % coreclk;
-			if (mod < LIMIT) {
-				divisor_core = pll_clk / coreclk;
-			} else if (coreclk - mod < LIMIT) {
-				divisor_core = pll_clk / coreclk;
-				divisor_core++;
-			} else {
-				continue;
-			}
-			if (divisor_core >= DIVISOR_MIN &&
-			    divisor_core <= DIVISOR_MAX) {
-				found = cfg;
-				divisor_mcu = pll_clk / mcuclk;
-				mod = pll_clk % mcuclk;
-				if (mod != 0)
-					divisor_mcu++;
-				break;
-			}
+		pll_clk = fvco / VCU_PLL_DIV2;
+		if (fvco % VCU_PLL_DIV2 != 0)
+			pll_clk++;
+		mod = pll_clk % coreclk;
+		if (mod < LIMIT) {
+			divisor_core = pll_clk / coreclk;
+		} else if (coreclk - mod < LIMIT) {
+			divisor_core = pll_clk / coreclk;
+			divisor_core++;
+		} else {
+			continue;
+		}
+		if (divisor_core >= DIVISOR_MIN &&
+		    divisor_core <= DIVISOR_MAX) {
+			found = cfg;
+			divisor_mcu = pll_clk / mcuclk;
+			mod = pll_clk % mcuclk;
+			if (mod != 0)
+				divisor_mcu++;
+			break;
 		}
 	}
 
-- 
2.31.1

