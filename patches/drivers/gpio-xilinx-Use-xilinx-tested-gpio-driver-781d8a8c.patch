From 22ed565158818419c89435ec20780f99d3173de3 Mon Sep 17 00:00:00 2001
From: Yaliang Wang <Yaliang.Wang@windriver.com>
Date: Tue, 29 Jun 2021 20:38:45 +0800
Subject: [PATCH 1336/1851] gpio: xilinx: Use xilinx tested gpio driver

commit af0c19b6f15388c554317280433100fd9f3d7d0a from
https://github.com/Xilinx/linux-xlnx.git

Upstream commit <af0c19b> "gpio: xilinx: Use xilinx tested gpio driver"
hints the author have given up all modifications and decide to use a
reliable tested driver. So just checking out to that point, get the file
and replace the old one.

Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 drivers/gpio/gpio-xilinx.c | 703 +++++++++++++++++++++----------------
 1 file changed, 391 insertions(+), 312 deletions(-)

diff --git a/drivers/gpio/gpio-xilinx.c b/drivers/gpio/gpio-xilinx.c
index bc02da5a006d..4d5adc255866 100644
--- a/drivers/gpio/gpio-xilinx.c
+++ b/drivers/gpio/gpio-xilinx.c
@@ -1,8 +1,15 @@
-// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Xilinx gpio driver for xps/axi_gpio IP.
  *
  * Copyright 2008 - 2013 Xilinx, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
 #include <linux/bitops.h>
@@ -10,31 +17,32 @@
 #include <linux/errno.h>
 #include <linux/module.h>
 #include <linux/of_device.h>
-#include <linux/of_platform.h>
-#include <linux/io.h>
-#include <linux/gpio/driver.h>
-#include <linux/slab.h>
-#include <linux/pm_runtime.h>
-#include <linux/clk.h>
 #include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/of_gpio.h>
 #include <linux/interrupt.h>
+#include <linux/io.h>
 #include <linux/irq.h>
 #include <linux/irqchip/chained_irq.h>
 #include <linux/irqdomain.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+#include <linux/pm_runtime.h>
+#include <linux/clk.h>
 
 /* Register Offset Definitions */
-#define XGPIO_DATA_OFFSET   (0x0)	/* Data register  */
-#define XGPIO_TRI_OFFSET    (0x4)	/* I/O direction register  */
+#define XGPIO_DATA_OFFSET	0x0 /* Data register */
+#define XGPIO_TRI_OFFSET	0x4 /* I/O direction register */
+#define XGPIO_GIER_OFFSET	0x11c /* Global Interrupt Enable */
+#define XGPIO_GIER_IE		BIT(31)
 
-#define XGPIO_CHANNEL_OFFSET	0x8
+#define XGPIO_IPISR_OFFSET	0x120 /* IP Interrupt Status */
+#define XGPIO_IPIER_OFFSET	0x128 /* IP Interrupt Enable */
 
-#define XGPIO_GIER_OFFSET      0x11c /* Global Interrupt Enable */
-#define XGPIO_GIER_IE          BIT(31)
-#define XGPIO_IPISR_OFFSET     0x120 /* IP Interrupt Status */
-#define XGPIO_IPIER_OFFSET     0x128 /* IP Interrupt Enable */
+#define XGPIO_CHANNEL_OFFSET	0x8
 
 /* Read/Write access to the GPIO registers */
-#if defined(CONFIG_ARCH_ZYNQ) || defined(CONFIG_X86) || defined(CONFIG_ARM64)
+#if defined(CONFIG_ARCH_ZYNQ) || defined(CONFIG_ARM64)
 # define xgpio_readreg(offset)		readl(offset)
 # define xgpio_writereg(offset, val)	writel(val, offset)
 #else
@@ -44,55 +52,32 @@
 
 /**
  * struct xgpio_instance - Stores information about GPIO device
- * @gc: GPIO chip
- * @regs: register block
- * @gpio_width: GPIO width for every channel
+ * @mmchip: OF GPIO chip for memory mapped banks
+ * @mmchip_dual: Pointer to the OF dual gpio chip
  * @gpio_state: GPIO state shadow register
  * @gpio_dir: GPIO direction shadow register
- * @gpio_lock: Lock used for synchronization
- * @clk: clock resource for this driver
+ * @offset: GPIO channel offset
  * @irq_base: GPIO channel irq base address
  * @irq_enable: GPIO irq enable/disable bitfield
+ * @no_init: No intitialisation at probe
+ * @gpio_lock: Lock used for synchronization
  * @irq_domain: irq_domain of the controller
+ * @clk: clock resource for this driver
  */
-
 struct xgpio_instance {
-	struct gpio_chip gc;
-	void __iomem *regs;
-	unsigned int gpio_width[2];
-	u32 gpio_state[2];
-	u32 gpio_dir[2];
-	spinlock_t gpio_lock[2];	/* For serializing operations */
-	struct clk *clk;
+	struct of_mm_gpio_chip mmchip;
+	struct of_mm_gpio_chip *mmchip_dual;
+	u32 gpio_state;
+	u32 gpio_dir;
+	u32 offset;
 	int irq_base;
 	u32 irq_enable;
+	bool no_init;
+	spinlock_t gpio_lock;
 	struct irq_domain *irq_domain;
+	struct clk *clk;
 };
 
-static inline int xgpio_index(struct xgpio_instance *chip, int gpio)
-{
-	if (gpio >= chip->gpio_width[0])
-		return 1;
-
-	return 0;
-}
-
-static inline int xgpio_regoffset(struct xgpio_instance *chip, int gpio)
-{
-	if (xgpio_index(chip, gpio))
-		return XGPIO_CHANNEL_OFFSET;
-
-	return 0;
-}
-
-static inline int xgpio_offset(struct xgpio_instance *chip, int gpio)
-{
-	if (xgpio_index(chip, gpio))
-		return gpio - chip->gpio_width[0];
-
-	return gpio;
-}
-
 /**
  * xgpio_get - Read the specified signal of the GPIO device.
  * @gc:     Pointer to gpio_chip device structure.
@@ -106,13 +91,13 @@ static inline int xgpio_offset(struct xgpio_instance *chip, int gpio)
  */
 static int xgpio_get(struct gpio_chip *gc, unsigned int gpio)
 {
-	struct xgpio_instance *chip = gpiochip_get_data(gc);
-	u32 val;
+	struct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);
+	struct xgpio_instance *chip =
+	    container_of(mm_gc, struct xgpio_instance, mmchip);
 
-	val = xgpio_readreg(chip->regs + XGPIO_DATA_OFFSET +
-			    xgpio_regoffset(chip, gpio));
+	void __iomem *regs = mm_gc->regs + chip->offset;
 
-	return !!(val & BIT(xgpio_offset(chip, gpio)));
+	return !!(xgpio_readreg(regs + XGPIO_DATA_OFFSET) & BIT(gpio));
 }
 
 /**
@@ -127,22 +112,23 @@ static int xgpio_get(struct gpio_chip *gc, unsigned int gpio)
 static void xgpio_set(struct gpio_chip *gc, unsigned int gpio, int val)
 {
 	unsigned long flags;
-	struct xgpio_instance *chip = gpiochip_get_data(gc);
-	int index =  xgpio_index(chip, gpio);
-	int offset =  xgpio_offset(chip, gpio);
+	struct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);
+	struct xgpio_instance *chip =
+	    container_of(mm_gc, struct xgpio_instance, mmchip);
+	void __iomem *regs = mm_gc->regs;
 
-	spin_lock_irqsave(&chip->gpio_lock[index], flags);
+	spin_lock_irqsave(&chip->gpio_lock, flags);
 
 	/* Write to GPIO signal and set its direction to output */
 	if (val)
-		chip->gpio_state[index] |= BIT(offset);
+		chip->gpio_state |= BIT(gpio);
 	else
-		chip->gpio_state[index] &= ~BIT(offset);
+		chip->gpio_state &= ~BIT(gpio);
 
-	xgpio_writereg(chip->regs + XGPIO_DATA_OFFSET +
-		       xgpio_regoffset(chip, gpio), chip->gpio_state[index]);
+	xgpio_writereg(regs + chip->offset + XGPIO_DATA_OFFSET,
+							 chip->gpio_state);
 
-	spin_unlock_irqrestore(&chip->gpio_lock[index], flags);
+	spin_unlock_irqrestore(&chip->gpio_lock, flags);
 }
 
 /**
@@ -158,38 +144,30 @@ static void xgpio_set_multiple(struct gpio_chip *gc, unsigned long *mask,
 			       unsigned long *bits)
 {
 	unsigned long flags;
-	struct xgpio_instance *chip = gpiochip_get_data(gc);
-	int index = xgpio_index(chip, 0);
-	int offset, i;
+	struct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);
+	struct xgpio_instance *chip =
+	    container_of(mm_gc, struct xgpio_instance, mmchip);
+	void __iomem *regs = mm_gc->regs;
+	int i;
 
-	spin_lock_irqsave(&chip->gpio_lock[index], flags);
+	spin_lock_irqsave(&chip->gpio_lock, flags);
 
 	/* Write to GPIO signals */
 	for (i = 0; i < gc->ngpio; i++) {
 		if (*mask == 0)
 			break;
-		/* Once finished with an index write it out to the register */
-		if (index !=  xgpio_index(chip, i)) {
-			xgpio_writereg(chip->regs + XGPIO_DATA_OFFSET +
-				       index * XGPIO_CHANNEL_OFFSET,
-				       chip->gpio_state[index]);
-			spin_unlock_irqrestore(&chip->gpio_lock[index], flags);
-			index =  xgpio_index(chip, i);
-			spin_lock_irqsave(&chip->gpio_lock[index], flags);
-		}
 		if (__test_and_clear_bit(i, mask)) {
-			offset =  xgpio_offset(chip, i);
 			if (test_bit(i, bits))
-				chip->gpio_state[index] |= BIT(offset);
+				chip->gpio_state |= BIT(i);
 			else
-				chip->gpio_state[index] &= ~BIT(offset);
+				chip->gpio_state &= ~BIT(i);
 		}
 	}
 
-	xgpio_writereg(chip->regs + XGPIO_DATA_OFFSET +
-		       index * XGPIO_CHANNEL_OFFSET, chip->gpio_state[index]);
+	xgpio_writereg(regs + chip->offset + XGPIO_DATA_OFFSET,
+		       chip->gpio_state);
 
-	spin_unlock_irqrestore(&chip->gpio_lock[index], flags);
+	spin_unlock_irqrestore(&chip->gpio_lock, flags);
 }
 
 /**
@@ -197,6 +175,8 @@ static void xgpio_set_multiple(struct gpio_chip *gc, unsigned long *mask,
  * @gc:     Pointer to gpio_chip device structure.
  * @gpio:   GPIO signal number.
  *
+ * This function sets the direction of specified GPIO signal as input.
+ *
  * Return:
  * 0 - if direction of GPIO signals is set as input
  * otherwise it returns negative error value.
@@ -204,18 +184,18 @@ static void xgpio_set_multiple(struct gpio_chip *gc, unsigned long *mask,
 static int xgpio_dir_in(struct gpio_chip *gc, unsigned int gpio)
 {
 	unsigned long flags;
-	struct xgpio_instance *chip = gpiochip_get_data(gc);
-	int index =  xgpio_index(chip, gpio);
-	int offset =  xgpio_offset(chip, gpio);
+	struct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);
+	struct xgpio_instance *chip =
+	    container_of(mm_gc, struct xgpio_instance, mmchip);
+	void __iomem *regs = mm_gc->regs;
 
-	spin_lock_irqsave(&chip->gpio_lock[index], flags);
+	spin_lock_irqsave(&chip->gpio_lock, flags);
 
 	/* Set the GPIO bit in shadow register and set direction as input */
-	chip->gpio_dir[index] |= BIT(offset);
-	xgpio_writereg(chip->regs + XGPIO_TRI_OFFSET +
-		       xgpio_regoffset(chip, gpio), chip->gpio_dir[index]);
+	chip->gpio_dir |= BIT(gpio);
+	xgpio_writereg(regs + chip->offset + XGPIO_TRI_OFFSET, chip->gpio_dir);
 
-	spin_unlock_irqrestore(&chip->gpio_lock[index], flags);
+	spin_unlock_irqrestore(&chip->gpio_lock, flags);
 
 	return 0;
 }
@@ -235,149 +215,107 @@ static int xgpio_dir_in(struct gpio_chip *gc, unsigned int gpio)
 static int xgpio_dir_out(struct gpio_chip *gc, unsigned int gpio, int val)
 {
 	unsigned long flags;
-	struct xgpio_instance *chip = gpiochip_get_data(gc);
-	int index =  xgpio_index(chip, gpio);
-	int offset =  xgpio_offset(chip, gpio);
+	struct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);
+	struct xgpio_instance *chip =
+	    container_of(mm_gc, struct xgpio_instance, mmchip);
+	void __iomem *regs = mm_gc->regs;
 
-	spin_lock_irqsave(&chip->gpio_lock[index], flags);
+	spin_lock_irqsave(&chip->gpio_lock, flags);
 
 	/* Write state of GPIO signal */
 	if (val)
-		chip->gpio_state[index] |= BIT(offset);
+		chip->gpio_state |= BIT(gpio);
 	else
-		chip->gpio_state[index] &= ~BIT(offset);
-	xgpio_writereg(chip->regs + XGPIO_DATA_OFFSET +
-			xgpio_regoffset(chip, gpio), chip->gpio_state[index]);
+		chip->gpio_state &= ~BIT(gpio);
+	xgpio_writereg(regs + chip->offset + XGPIO_DATA_OFFSET,
+		       chip->gpio_state);
 
 	/* Clear the GPIO bit in shadow register and set direction as output */
-	chip->gpio_dir[index] &= ~BIT(offset);
-	xgpio_writereg(chip->regs + XGPIO_TRI_OFFSET +
-			xgpio_regoffset(chip, gpio), chip->gpio_dir[index]);
+	chip->gpio_dir &= ~BIT(gpio);
+	xgpio_writereg(regs + chip->offset + XGPIO_TRI_OFFSET, chip->gpio_dir);
 
-	spin_unlock_irqrestore(&chip->gpio_lock[index], flags);
+	spin_unlock_irqrestore(&chip->gpio_lock, flags);
 
 	return 0;
 }
 
 /**
  * xgpio_save_regs - Set initial values of GPIO pins
- * @chip: Pointer to GPIO instance
+ * @mm_gc: Pointer to memory mapped GPIO chip structure
  */
-static void xgpio_save_regs(struct xgpio_instance *chip)
-{
-	xgpio_writereg(chip->regs + XGPIO_DATA_OFFSET,	chip->gpio_state[0]);
-	xgpio_writereg(chip->regs + XGPIO_TRI_OFFSET, chip->gpio_dir[0]);
-
-	if (!chip->gpio_width[1])
-		return;
-
-	xgpio_writereg(chip->regs + XGPIO_DATA_OFFSET + XGPIO_CHANNEL_OFFSET,
-		       chip->gpio_state[1]);
-	xgpio_writereg(chip->regs + XGPIO_TRI_OFFSET + XGPIO_CHANNEL_OFFSET,
-		       chip->gpio_dir[1]);
-}
-
-static int xgpio_request(struct gpio_chip *chip, unsigned int offset)
-{
-	int ret = pm_runtime_get_sync(chip->parent);
-
-	/*
-	 * If the device is already active pm_runtime_get() will return 1 on
-	 * success, but gpio_request still needs to return 0.
-	 */
-	return ret < 0 ? ret : 0;
-}
-
-static void xgpio_free(struct gpio_chip *chip, unsigned int offset)
-{
-	pm_runtime_put(chip->parent);
-}
-
-static int __maybe_unused xgpio_suspend(struct device *dev)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-	int irq = platform_get_irq(pdev, 0);
-	struct irq_data *data = irq_get_irq_data(irq);
-
-	if (!irqd_is_wakeup_set(data))
-		return pm_runtime_force_suspend(dev);
-
-	return 0;
-}
-
-static int __maybe_unused xgpio_resume(struct device *dev)
+static void xgpio_save_regs(struct of_mm_gpio_chip *mm_gc)
 {
-	struct platform_device *pdev = to_platform_device(dev);
-	int irq = platform_get_irq(pdev, 0);
-	struct irq_data *data = irq_get_irq_data(irq);
-
-	if (!irqd_is_wakeup_set(data))
-		return pm_runtime_force_resume(dev);
-
-	return 0;
+	struct xgpio_instance *chip =
+	    container_of(mm_gc, struct xgpio_instance, mmchip);
+	if (chip->no_init) {
+		chip->gpio_state = xgpio_readreg(mm_gc->regs +
+						 XGPIO_DATA_OFFSET);
+		chip->gpio_dir = xgpio_readreg(mm_gc->regs + XGPIO_TRI_OFFSET);
+	} else {
+		xgpio_writereg(mm_gc->regs + chip->offset + XGPIO_DATA_OFFSET,
+			       chip->gpio_state);
+		xgpio_writereg(mm_gc->regs + chip->offset + XGPIO_TRI_OFFSET,
+			       chip->gpio_dir);
+	}
 }
 
-static int __maybe_unused xgpio_runtime_suspend(struct device *dev)
+/**
+ * xgpio_xlate - Translate gpio_spec to the GPIO number and flags
+ * @gc: Pointer to gpio_chip device structure.
+ * @gpiospec:  gpio specifier as found in the device tree
+ * @flags: A flags pointer based on binding
+ *
+ * Return:
+ * irq number otherwise -EINVAL
+ */
+static int xgpio_xlate(struct gpio_chip *gc,
+		       const struct of_phandle_args *gpiospec, u32 *flags)
 {
-	struct platform_device *pdev = to_platform_device(dev);
-	struct xgpio_instance *gpio = platform_get_drvdata(pdev);
+	struct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);
+	struct xgpio_instance *chip = container_of(mm_gc, struct xgpio_instance,
+						   mmchip);
+	if (gc->of_gpio_n_cells == 3 && flags)
+		*flags = gpiospec->args[2];
 
-	clk_disable(gpio->clk);
-
-	return 0;
-}
-
-static int __maybe_unused xgpio_runtime_resume(struct device *dev)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-	struct xgpio_instance *gpio = platform_get_drvdata(pdev);
+	if (gpiospec->args[1] == chip->offset)
+		return gpiospec->args[0];
 
-	return clk_enable(gpio->clk);
+	return -EINVAL;
 }
 
-static const struct dev_pm_ops xgpio_dev_pm_ops = {
-	SET_SYSTEM_SLEEP_PM_OPS(xgpio_suspend, xgpio_resume)
-	SET_RUNTIME_PM_OPS(xgpio_runtime_suspend,
-			   xgpio_runtime_resume, NULL)
-};
-
 /**
- * xgpiops_irq_mask - Write the specified signal of the GPIO device.
+ * xgpio_irq_mask - Write the specified signal of the GPIO device.
  * @irq_data: per irq and chip data passed down to chip functions
  */
 static void xgpio_irq_mask(struct irq_data *irq_data)
 {
 	unsigned long flags;
 	struct xgpio_instance *chip = irq_data_get_irq_chip_data(irq_data);
+	struct of_mm_gpio_chip *mm_gc = &chip->mmchip;
 	u32 offset = irq_data->irq - chip->irq_base;
 	u32 temp;
-	s32 val;
-	int index = xgpio_index(chip, 0);
 
 	pr_debug("%s: Disable %d irq, irq_enable_mask 0x%x\n",
-		 __func__, offset, chip->irq_enable);
+		__func__, offset, chip->irq_enable);
 
-	spin_lock_irqsave(&chip->gpio_lock[index], flags);
+	spin_lock_irqsave(&chip->gpio_lock, flags);
 
 	chip->irq_enable &= ~BIT(offset);
 
 	if (!chip->irq_enable) {
 		/* Enable per channel interrupt */
-		temp = xgpio_readreg(chip->regs + XGPIO_IPIER_OFFSET);
-		val = offset - chip->gpio_width[0] + 1;
-		if (val > 0)
-			temp &= 1;
-		else
-			temp &= 2;
-		xgpio_writereg(chip->regs + XGPIO_IPIER_OFFSET, temp);
+		temp = xgpio_readreg(mm_gc->regs + XGPIO_IPIER_OFFSET);
+		temp &= chip->offset / XGPIO_CHANNEL_OFFSET + 1;
+		xgpio_writereg(mm_gc->regs + XGPIO_IPIER_OFFSET, temp);
 
 		/* Disable global interrupt if channel interrupts are unused */
-		temp = xgpio_readreg(chip->regs + XGPIO_IPIER_OFFSET);
+		temp = xgpio_readreg(mm_gc->regs + XGPIO_IPIER_OFFSET);
 		if (!temp)
-			xgpio_writereg(chip->regs + XGPIO_GIER_OFFSET,
+			xgpio_writereg(mm_gc->regs + XGPIO_GIER_OFFSET,
 				       ~XGPIO_GIER_IE);
+
 	}
-	spin_unlock_irqrestore(&chip->gpio_lock[index], flags);
+	spin_unlock_irqrestore(&chip->gpio_lock, flags);
 }
 
 /**
@@ -388,36 +326,32 @@ static void xgpio_irq_unmask(struct irq_data *irq_data)
 {
 	unsigned long flags;
 	struct xgpio_instance *chip = irq_data_get_irq_chip_data(irq_data);
+	struct of_mm_gpio_chip *mm_gc = &chip->mmchip;
 	u32 offset = irq_data->irq - chip->irq_base;
 	u32 temp;
-	s32 val;
-	int index = xgpio_index(chip, 0);
 
 	pr_debug("%s: Enable %d irq, irq_enable_mask 0x%x\n",
-		 __func__, offset, chip->irq_enable);
+		__func__, offset, chip->irq_enable);
 
 	/* Setup pin as input */
-	xgpio_dir_in(&chip->gc, offset);
+	xgpio_dir_in(&mm_gc->gc, offset);
 
-	spin_lock_irqsave(&chip->gpio_lock[index], flags);
+	spin_lock_irqsave(&chip->gpio_lock, flags);
 
 	chip->irq_enable |= BIT(offset);
 
 	if (chip->irq_enable) {
+
 		/* Enable per channel interrupt */
-		temp = xgpio_readreg(chip->regs + XGPIO_IPIER_OFFSET);
-		val = offset - (chip->gpio_width[0] - 1);
-		if (val > 0)
-			temp |= 2;
-		else
-			temp |= 1;
-		xgpio_writereg(chip->regs + XGPIO_IPIER_OFFSET, temp);
+		temp = xgpio_readreg(mm_gc->regs + XGPIO_IPIER_OFFSET);
+		temp |= chip->offset / XGPIO_CHANNEL_OFFSET + 1;
+		xgpio_writereg(mm_gc->regs + XGPIO_IPIER_OFFSET, temp);
 
 		/* Enable global interrupts */
-		xgpio_writereg(chip->regs + XGPIO_GIER_OFFSET, XGPIO_GIER_IE);
+		xgpio_writereg(mm_gc->regs + XGPIO_GIER_OFFSET, XGPIO_GIER_IE);
 	}
 
-	spin_unlock_irqrestore(&chip->gpio_lock[index], flags);
+	spin_unlock_irqrestore(&chip->gpio_lock, flags);
 }
 
 /**
@@ -439,10 +373,10 @@ static int xgpio_set_irq_type(struct irq_data *irq_data, unsigned int type)
 
 /* irq chip descriptor */
 static struct irq_chip xgpio_irqchip = {
-	.name           = "xgpio",
-	.irq_mask       = xgpio_irq_mask,
-	.irq_unmask     = xgpio_irq_unmask,
-	.irq_set_type   = xgpio_set_irq_type,
+	.name		= "xgpio",
+	.irq_mask	= xgpio_irq_mask,
+	.irq_unmask	= xgpio_irq_unmask,
+	.irq_set_type	= xgpio_set_irq_type,
 };
 
 /**
@@ -455,7 +389,9 @@ static struct irq_chip xgpio_irqchip = {
  */
 static int xgpio_to_irq(struct gpio_chip *gc, unsigned int offset)
 {
-	struct xgpio_instance *chip = gpiochip_get_data(gc);
+	struct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);
+	struct xgpio_instance *chip = container_of(mm_gc, struct xgpio_instance,
+						   mmchip);
 
 	return irq_find_mapping(chip->irq_domain, offset);
 }
@@ -467,29 +403,26 @@ static int xgpio_to_irq(struct gpio_chip *gc, unsigned int offset)
 static void xgpio_irqhandler(struct irq_desc *desc)
 {
 	unsigned int irq = irq_desc_get_irq(desc);
+
 	struct xgpio_instance *chip = (struct xgpio_instance *)
-		irq_get_handler_data(irq);
+						irq_get_handler_data(irq);
+	struct of_mm_gpio_chip *mm_gc = &chip->mmchip;
 	struct irq_chip *irqchip = irq_desc_get_chip(desc);
-	u32 offset, status, channel = 1;
+	int offset;
 	unsigned long val;
 
 	chained_irq_enter(irqchip, desc);
 
-	val = xgpio_readreg(chip->regs);
-	if (!val) {
-		channel = 2;
-		val = xgpio_readreg(chip->regs + XGPIO_CHANNEL_OFFSET);
-		val = val << chip->gpio_width[0];
-	}
-
+	val = xgpio_readreg(mm_gc->regs + chip->offset);
 	/* Only rising edge is supported */
 	val &= chip->irq_enable;
-	for_each_set_bit(offset, &val, chip->gc.ngpio) {
+
+	for_each_set_bit(offset, &val, chip->mmchip.gc.ngpio) {
 		generic_handle_irq(chip->irq_base + offset);
 	}
 
-	status = xgpio_readreg(chip->regs + XGPIO_IPISR_OFFSET);
-	xgpio_writereg(chip->regs + XGPIO_IPISR_OFFSET, channel);
+	xgpio_writereg(mm_gc->regs + XGPIO_IPISR_OFFSET,
+		       chip->offset / XGPIO_CHANNEL_OFFSET + 1);
 
 	chained_irq_exit(irqchip, desc);
 }
@@ -509,6 +442,7 @@ static int xgpio_irq_setup(struct device_node *np, struct xgpio_instance *chip)
 {
 	u32 pin_num;
 	struct resource res;
+
 	int ret = of_irq_to_resource(np, 0, &res);
 
 	if (ret <= 0) {
@@ -516,26 +450,28 @@ static int xgpio_irq_setup(struct device_node *np, struct xgpio_instance *chip)
 		return 0;
 	}
 
-	chip->gc.to_irq = xgpio_to_irq;
-	chip->irq_base = irq_alloc_descs(-1, 0, chip->gc.ngpio, 0);
+	chip->mmchip.gc.to_irq = xgpio_to_irq;
+
+	chip->irq_base = irq_alloc_descs(-1, 1, chip->mmchip.gc.ngpio, 0);
 	if (chip->irq_base < 0) {
 		pr_err("Couldn't allocate IRQ numbers\n");
 		return -1;
 	}
-	chip->irq_domain = irq_domain_add_legacy(np, chip->gc.ngpio,
+	chip->irq_domain = irq_domain_add_legacy(np, chip->mmchip.gc.ngpio,
 						 chip->irq_base, 0,
 						 &irq_domain_simple_ops, NULL);
+
 	/*
 	 * set the irq chip, handler and irq chip data for callbacks for
 	 * each pin
 	 */
-	for (pin_num = 0; pin_num < chip->gc.ngpio; pin_num++) {
+	for (pin_num = 0; pin_num < chip->mmchip.gc.ngpio; pin_num++) {
 		u32 gpio_irq = irq_find_mapping(chip->irq_domain, pin_num);
 
 		irq_set_lockdep_class(gpio_irq, &gpio_lock_class,
 				      &gpio_request_class);
 		pr_debug("IRQ Base: %d, Pin %d = IRQ %d\n",
-			 chip->irq_base, pin_num, gpio_irq);
+			chip->irq_base,	pin_num, gpio_irq);
 		irq_set_chip_and_handler(gpio_irq, &xgpio_irqchip,
 					 handle_simple_irq);
 		irq_set_chip_data(gpio_irq, (void *)chip);
@@ -546,85 +482,171 @@ static int xgpio_irq_setup(struct device_node *np, struct xgpio_instance *chip)
 	return 0;
 }
 
+static int xgpio_request(struct gpio_chip *chip, unsigned int offset)
+{
+	int ret = pm_runtime_get_sync(chip->parent);
+
+	/*
+	 * If the device is already active pm_runtime_get() will return 1 on
+	 * success, but gpio_request still needs to return 0.
+	 */
+	return ret < 0 ? ret : 0;
+}
+
+static void xgpio_free(struct gpio_chip *chip, unsigned int offset)
+{
+	pm_runtime_put(chip->parent);
+}
+
+static int __maybe_unused xgpio_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	int irq;
+	struct irq_data *data;
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq <= 0) {
+		dev_dbg(dev, "failed to get IRQ\n");
+		return 0;
+	}
+
+	data = irq_get_irq_data(irq);
+	if (!irqd_is_wakeup_set(data))
+		return pm_runtime_force_suspend(dev);
+
+	return 0;
+}
+
+static int __maybe_unused xgpio_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	int irq;
+	struct irq_data *data;
+
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq <= 0) {
+		dev_dbg(dev, "failed to get IRQ\n");
+		return 0;
+	}
+
+	data = irq_get_irq_data(irq);
+	if (!irqd_is_wakeup_set(data))
+		return pm_runtime_force_resume(dev);
+
+	return 0;
+}
+
+static int __maybe_unused xgpio_runtime_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct xgpio_instance *gpio = platform_get_drvdata(pdev);
+
+	clk_disable(gpio->clk);
+
+	return 0;
+}
+
+static int __maybe_unused xgpio_runtime_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct xgpio_instance *gpio = platform_get_drvdata(pdev);
+
+	return clk_enable(gpio->clk);
+}
+
+static const struct dev_pm_ops xgpio_dev_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(xgpio_suspend, xgpio_resume)
+	SET_RUNTIME_PM_OPS(xgpio_runtime_suspend,
+			xgpio_runtime_resume, NULL)
+};
+
 /**
- * xgpio_of_probe - Probe method for the GPIO device.
+ * xgpio_remove - Remove method for the GPIO device.
  * @pdev: pointer to the platform device
  *
+ * This function remove gpiochips and frees all the allocated resources.
+ *
+ * Return: 0 always
+ */
+static int xgpio_remove(struct platform_device *pdev)
+{
+	struct xgpio_instance *chip = platform_get_drvdata(pdev);
+
+	of_mm_gpiochip_remove(&chip->mmchip);
+	if (chip->mmchip_dual)
+		of_mm_gpiochip_remove(chip->mmchip_dual);
+	if (!pm_runtime_suspended(&pdev->dev))
+		clk_disable(chip->clk);
+	clk_unprepare(chip->clk);
+	pm_runtime_disable(&pdev->dev);
+
+	return 0;
+}
+
+/**
+ * xgpio_of_probe - Probe method for the GPIO device.
+ * @pdev:       platform device instance
+ *
+ * This function probes the GPIO device in the device tree. It initializes the
+ * driver data structure.
+ *
  * Return:
  * It returns 0, if the driver is bound to the GPIO device, or
  * a negative value if there is an error.
  */
-static int xgpio_probe(struct platform_device *pdev)
+static int xgpio_of_probe(struct platform_device *pdev)
 {
-	struct xgpio_instance *chip;
-	int status = 0;
 	struct device_node *np = pdev->dev.of_node;
-	u32 is_dual;
+	struct xgpio_instance *chip, *chip_dual;
+	int status = 0;
+	const u32 *tree_info;
+	u32 ngpio;
+	u32 cells = 2;
 
 	chip = devm_kzalloc(&pdev->dev, sizeof(*chip), GFP_KERNEL);
 	if (!chip)
 		return -ENOMEM;
 
-	platform_set_drvdata(pdev, chip);
-
 	/* Update GPIO state shadow register with default value */
-	of_property_read_u32(np, "xlnx,dout-default", &chip->gpio_state[0]);
+	of_property_read_u32(np, "xlnx,dout-default", &chip->gpio_state);
+
+	/* By default, all pins are inputs */
+	chip->gpio_dir = 0xFFFFFFFF;
 
 	/* Update GPIO direction shadow register with default value */
-	if (of_property_read_u32(np, "xlnx,tri-default", &chip->gpio_dir[0]))
-		chip->gpio_dir[0] = 0xFFFFFFFF;
+	of_property_read_u32(np, "xlnx,tri-default", &chip->gpio_dir);
+
+	chip->no_init = of_property_read_bool(np, "xlnx,no-init");
+
+	/* Update cells with gpio-cells value */
+	of_property_read_u32(np, "#gpio-cells", &cells);
 
 	/*
 	 * Check device node and parent device node for device width
 	 * and assume default width of 32
 	 */
-	if (of_property_read_u32(np, "xlnx,gpio-width", &chip->gpio_width[0]))
-		chip->gpio_width[0] = 32;
+	if (of_property_read_u32(np, "xlnx,gpio-width", &ngpio))
+		ngpio = 32;
+	chip->mmchip.gc.ngpio = (u16)ngpio;
+
+	spin_lock_init(&chip->gpio_lock);
+
+	chip->mmchip.gc.parent = &pdev->dev;
+	chip->mmchip.gc.owner = THIS_MODULE;
+	chip->mmchip.gc.of_xlate = xgpio_xlate;
+	chip->mmchip.gc.of_gpio_n_cells = cells;
+	chip->mmchip.gc.direction_input = xgpio_dir_in;
+	chip->mmchip.gc.direction_output = xgpio_dir_out;
+	chip->mmchip.gc.get = xgpio_get;
+	chip->mmchip.gc.set = xgpio_set;
+	chip->mmchip.gc.request = xgpio_request;
+	chip->mmchip.gc.free = xgpio_free;
+	chip->mmchip.gc.set_multiple = xgpio_set_multiple;
+
+	chip->mmchip.save_regs = xgpio_save_regs;
 
-	spin_lock_init(&chip->gpio_lock[0]);
-
-	if (of_property_read_u32(np, "xlnx,is-dual", &is_dual))
-		is_dual = 0;
-
-	if (is_dual) {
-		/* Update GPIO state shadow register with default value */
-		of_property_read_u32(np, "xlnx,dout-default-2",
-				     &chip->gpio_state[1]);
-
-		/* Update GPIO direction shadow register with default value */
-		if (of_property_read_u32(np, "xlnx,tri-default-2",
-					 &chip->gpio_dir[1]))
-			chip->gpio_dir[1] = 0xFFFFFFFF;
-
-		/*
-		 * Check device node and parent device node for device width
-		 * and assume default width of 32
-		 */
-		if (of_property_read_u32(np, "xlnx,gpio2-width",
-					 &chip->gpio_width[1]))
-			chip->gpio_width[1] = 32;
-
-		spin_lock_init(&chip->gpio_lock[1]);
-	}
-
-	chip->gc.base = -1;
-	chip->gc.ngpio = chip->gpio_width[0] + chip->gpio_width[1];
-	chip->gc.parent = &pdev->dev;
-	chip->gc.direction_input = xgpio_dir_in;
-	chip->gc.direction_output = xgpio_dir_out;
-	chip->gc.get = xgpio_get;
-	chip->gc.set = xgpio_set;
-	chip->gc.request = xgpio_request;
-	chip->gc.free = xgpio_free;
-	chip->gc.set_multiple = xgpio_set_multiple;
-
-	chip->gc.label = dev_name(&pdev->dev);
-
-	chip->regs = devm_platform_ioremap_resource(pdev, 0);
-	if (IS_ERR(chip->regs)) {
-		dev_err(&pdev->dev, "failed to ioremap memory resource\n");
-		return PTR_ERR(chip->regs);
-	}
+	platform_set_drvdata(pdev, chip);
 
 	chip->clk = devm_clk_get(&pdev->dev, "s_axi_aclk");
 	if (IS_ERR(chip->clk)) {
@@ -633,28 +655,29 @@ static int xgpio_probe(struct platform_device *pdev)
 				dev_err(&pdev->dev, "Input clock not found\n");
 			return PTR_ERR(chip->clk);
 		}
+
 		/*
 		 * Clock framework support is optional, continue on
 		 * anyways if we don't find a matching clock.
 		 */
 		chip->clk = NULL;
 	}
+
 	status = clk_prepare_enable(chip->clk);
 	if (status < 0) {
 		dev_err(&pdev->dev, "Failed to prepare clk\n");
 		return status;
 	}
-	pm_runtime_enable(&pdev->dev);
-	status = pm_runtime_get_sync(&pdev->dev);
-	if (status < 0)
-		goto err_unprepare_clk;
 
-	xgpio_save_regs(chip);
+	pm_runtime_set_active(&pdev->dev);
+	pm_runtime_enable(&pdev->dev);
 
-	status = devm_gpiochip_add_data(&pdev->dev, &chip->gc, chip);
+	/* Call the OF gpio helper to setup and register the GPIO device */
+	status = of_mm_gpiochip_add(np, &chip->mmchip);
 	if (status) {
-		dev_err(&pdev->dev, "failed to add GPIO chip\n");
-		goto err_pm_put;
+		pr_err("%pOF: error in probe function with status %d\n",
+		       np, status);
+		goto err_unprepare_clk;
 	}
 
 	status = xgpio_irq_setup(np, chip);
@@ -663,16 +686,83 @@ static int xgpio_probe(struct platform_device *pdev)
 		       np->full_name, status);
 		goto err_pm_put;
 	}
+
 	pr_info("XGpio: %s: registered, base is %d\n", np->full_name,
-		chip->gc.base);
+							chip->mmchip.gc.base);
+
+	tree_info = of_get_property(np, "xlnx,is-dual", NULL);
+	if (tree_info && be32_to_cpup(tree_info)) {
+		chip_dual = devm_kzalloc(&pdev->dev, sizeof(*chip_dual),
+					 GFP_KERNEL);
+		if (!chip_dual)
+			goto err_pm_put;
+
+		/* Add dual channel offset */
+		chip_dual->offset = XGPIO_CHANNEL_OFFSET;
+
+		/* Update GPIO state shadow register with default value */
+		of_property_read_u32(np, "xlnx,dout-default-2",
+				     &chip_dual->gpio_state);
+
+		/* By default, all pins are inputs */
+		chip_dual->gpio_dir = 0xFFFFFFFF;
+
+		/* Update GPIO direction shadow register with default value */
+		of_property_read_u32(np, "xlnx,tri-default-2",
+				     &chip_dual->gpio_dir);
+
+		/*
+		 * Check device node and parent device node for device width
+		 * and assume default width of 32
+		 */
+		if (of_property_read_u32(np, "xlnx,gpio2-width", &ngpio))
+			ngpio = 32;
+		chip_dual->mmchip.gc.ngpio = (u16)ngpio;
+
+		spin_lock_init(&chip_dual->gpio_lock);
+
+		chip_dual->mmchip.gc.parent = &pdev->dev;
+		chip_dual->mmchip.gc.owner = THIS_MODULE;
+		chip_dual->mmchip.gc.of_xlate = xgpio_xlate;
+		chip_dual->mmchip.gc.of_gpio_n_cells = cells;
+		chip_dual->mmchip.gc.direction_input = xgpio_dir_in;
+		chip_dual->mmchip.gc.direction_output = xgpio_dir_out;
+		chip_dual->mmchip.gc.get = xgpio_get;
+		chip_dual->mmchip.gc.set = xgpio_set;
+		chip_dual->mmchip.gc.request = xgpio_request;
+		chip_dual->mmchip.gc.free = xgpio_free;
+		chip_dual->mmchip.gc.set_multiple = xgpio_set_multiple;
+
+		chip_dual->mmchip.save_regs = xgpio_save_regs;
+
+		chip->mmchip_dual = &chip_dual->mmchip;
+
+		status = xgpio_irq_setup(np, chip_dual);
+		if (status) {
+			pr_err("%s: GPIO IRQ initialization failed %d\n",
+			      np->full_name, status);
+			goto err_pm_put;
+		}
+
+		/* Call the OF gpio helper to setup and register the GPIO dev */
+		status = of_mm_gpiochip_add(np, &chip_dual->mmchip);
+		if (status) {
+			pr_err("%s: error in probe function with status %d\n",
+			       np->full_name, status);
+			goto err_pm_put;
+		}
+		pr_info("XGpio: %s: dual channel registered, base is %d\n",
+			np->full_name, chip_dual->mmchip.gc.base);
+	}
 
 	pm_runtime_put(&pdev->dev);
 	return 0;
+
 err_pm_put:
 	pm_runtime_put(&pdev->dev);
 err_unprepare_clk:
 	pm_runtime_disable(&pdev->dev);
-	clk_unprepare(chip->clk);
+	clk_disable_unprepare(chip->clk);
 	return status;
 }
 
@@ -680,30 +770,19 @@ static const struct of_device_id xgpio_of_match[] = {
 	{ .compatible = "xlnx,xps-gpio-1.00.a", },
 	{ /* end of list */ },
 };
-
 MODULE_DEVICE_TABLE(of, xgpio_of_match);
 
-static struct platform_driver xgpio_plat_driver = {
-	.probe		= xgpio_probe,
-	.driver		= {
-			.name = "gpio-xilinx",
-			.of_match_table	= xgpio_of_match,
-			.pm = &xgpio_dev_pm_ops,
+static struct platform_driver xilinx_gpio_driver = {
+	.probe = xgpio_of_probe,
+	.remove = xgpio_remove,
+	.driver = {
+		.name = "xilinx-gpio",
+		.of_match_table = xgpio_of_match,
+		.pm = &xgpio_dev_pm_ops,
 	},
 };
 
-static int __init xgpio_init(void)
-{
-	return platform_driver_register(&xgpio_plat_driver);
-}
-
-subsys_initcall(xgpio_init);
-
-static void __exit xgpio_exit(void)
-{
-	platform_driver_unregister(&xgpio_plat_driver);
-}
-module_exit(xgpio_exit);
+module_platform_driver(xilinx_gpio_driver);
 
 MODULE_AUTHOR("Xilinx, Inc.");
 MODULE_DESCRIPTION("Xilinx GPIO driver");
-- 
2.31.1

