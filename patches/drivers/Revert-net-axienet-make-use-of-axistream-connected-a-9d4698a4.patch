From 732e825e6da969cb0cdd495dea2a36068c11ec9d Mon Sep 17 00:00:00 2001
From: Radhey Shyam Pandey <radhey.shyam.pandey@xilinx.com>
Date: Fri, 24 Jan 2020 20:52:13 +0530
Subject: [PATCH 1034/1851] Revert "net: axienet: make use of
 axistream-connected attribute optional"

commit beded2a669e0da22b14d83fb73590bca148b9885 from
https://github.com/Xilinx/linux-xlnx.git

This reverts commit 28ef9ebdb64c6f45079d8be45ab47bd0c62d078c.
Supporting all resources(dma, mcdma, fifo, endpoint nodes) in the
ethernet node is not feasible in the current axiethernet driver
design. For now, revert this to integrate subsequent rebase commits.

Signed-off-by: Radhey Shyam Pandey <radhey.shyam.pandey@xilinx.com>
State: not-upstreamable
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 .../net/ethernet/xilinx/xilinx_axienet_main.c | 43 +++++++------------
 1 file changed, 15 insertions(+), 28 deletions(-)

diff --git a/drivers/net/ethernet/xilinx/xilinx_axienet_main.c b/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
index 676006f32f91..1b15949bf89d 100644
--- a/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
+++ b/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
@@ -1652,7 +1652,7 @@ static int axienet_probe(struct platform_device *pdev)
 	struct axienet_local *lp;
 	struct net_device *ndev;
 	const void *mac_addr;
-	struct resource *ethres;
+	struct resource *ethres, dmares;
 	u32 value;
 
 	ndev = alloc_etherdev(sizeof(*lp));
@@ -1770,40 +1770,27 @@ static int axienet_probe(struct platform_device *pdev)
 
 	/* Find the DMA node, map the DMA registers, and decode the DMA IRQs */
 	np = of_parse_phandle(pdev->dev.of_node, "axistream-connected", 0);
-	if (np) {
-		struct resource dmares;
-
-		ret = of_address_to_resource(np, 0, &dmares);
-		if (ret) {
-			dev_err(&pdev->dev,
-				"unable to get DMA resource\n");
-			of_node_put(np);
-			goto free_netdev;
-		}
-		lp->dma_regs = devm_ioremap_resource(&pdev->dev,
-						     &dmares);
-		lp->rx_irq = irq_of_parse_and_map(np, 1);
-		lp->tx_irq = irq_of_parse_and_map(np, 0);
+	if (!np) {
+		dev_err(&pdev->dev, "could not find DMA node\n");
+		ret = -ENODEV;
+		goto free_netdev;
+	}
+	ret = of_address_to_resource(np, 0, &dmares);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to get DMA resource\n");
 		of_node_put(np);
-		lp->eth_irq = platform_get_irq(pdev, 0);
-	} else {
-		/* Check for these resources directly on the Ethernet node. */
-		struct resource *res = platform_get_resource(pdev,
-							     IORESOURCE_MEM, 1);
-		if (!res) {
-			dev_err(&pdev->dev, "unable to get DMA memory resource\n");
-			goto free_netdev;
-		}
-		lp->dma_regs = devm_ioremap_resource(&pdev->dev, res);
-		lp->rx_irq = platform_get_irq(pdev, 1);
-		lp->tx_irq = platform_get_irq(pdev, 0);
-		lp->eth_irq = platform_get_irq(pdev, 2);
+		goto free_netdev;
 	}
+	lp->dma_regs = devm_ioremap_resource(&pdev->dev, &dmares);
 	if (IS_ERR(lp->dma_regs)) {
 		dev_err(&pdev->dev, "could not map DMA regs\n");
 		ret = PTR_ERR(lp->dma_regs);
 		goto free_netdev;
 	}
+	lp->rx_irq = irq_of_parse_and_map(np, 1);
+	lp->tx_irq = irq_of_parse_and_map(np, 0);
+	lp->eth_irq = irq_of_parse_and_map(np, 2);
+	of_node_put(np);
 	if ((lp->rx_irq <= 0) || (lp->tx_irq <= 0)) {
 		dev_err(&pdev->dev, "could not determine irqs\n");
 		ret = -ENOMEM;
-- 
2.31.1

