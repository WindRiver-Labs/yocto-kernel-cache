From 8d8bcc8208315521ac0b2b7c4583b03d6c6990c6 Mon Sep 17 00:00:00 2001
From: Vishal Sagar <vishal.sagar@xilinx.com>
Date: Fri, 23 Oct 2020 05:08:37 -0700
Subject: [PATCH 1723/1851] v4l: xilinx: m2m: Fix kernel crash for link
 creation to video entity

commit 74694e0c4b711efb2ed02e4d973837273be8e584 from
https://github.com/Xilinx/linux-xlnx.git

This patch fixes the below kernel crash.

[    8.921579] xilinx-mem2mem amba_pl@0:video_m2m: mem2mem device
registered
[    8.928646] xilinx-mem2mem amba_pl@0:video_m2m: Entity type for
entity a0100000.v_proc_ss was not initialized!
[    8.938679] Unable to handle kernel NULL pointer dereference at
virtual address 0000000000000000
[    8.947464] Mem abort info:
[    8.950253]   ESR = 0x96000045
[    8.953305]   EC = 0x25: DABT (current EL), IL = 32 bits
[    8.958615]   SET = 0, FnV = 0
[    8.961660]   EA = 0, S1PTW = 0
[    8.964788] Data abort info:
[    8.967658]   ISV = 0, ISS = 0x00000045
[    8.971488]   CM = 0, WnR = 1
[    8.974448] [0000000000000000] user address but active_mm is swapper
[    8.980797] Internal error: Oops: 96000045 [#1] SMP
[    8.985668] Modules linked in:
[    8.988717] CPU: 3 PID: 58 Comm: kworker/3:1 Not tainted
5.4.0-00191-g259740c195d4 #85
[    8.996625] Hardware name: ZynqMP ZCU102 Rev1.0 (DT)
[    9.001588] Workqueue: events deferred_probe_work_func
[    9.006721] pstate: 40000005 (nZcv daif -PAN -UAO)
[    9.011506] pc : media_create_pad_link+0xf0/0x188
[    9.016199] lr : media_create_pad_link+0xd0/0x188
[    9.020894] sp : ffffffc0112bb9d0
[    9.024201] x29: ffffffc0112bb9d0 x28: ffffff8006870080
[    9.029505] x27: ffffff806fafe548 x26: ffffff806cdfc0d0
[    9.034809] x25: 0000000000000038 x24: ffffffc010ebc548
[    9.040113] x23: 0000000000000001 x22: 0000000000000000
[    9.045417] x21: ffffff800683a980 x20: ffffff8006870080
[    9.050721] x19: ffffff806cdfc080 x18: 0000000000000010
[    9.056025] x17: ffffff806d401508 x16: ffffff806d401528
[    9.061329] x15: ffffffffffffffff x14: ffffff0000000000
[    9.066633] x13: ffffffffffffffff x12: 0000000000000028
[    9.071937] x11: 0101010101010101 x10: 7f7f7f7f7f7f7f7f
[    9.077241] x9 : 0000000000000000 x8 : ffffff800683a900
[    9.082545] x7 : 0000000000000000 x6 : 000000000000003f
[    9.087849] x5 : 0000000000000040 x4 : 0000000000000001
[    9.093153] x3 : ffffff800683a8a0 x2 : ffffff800683a880
[    9.098457] x1 : 0000000000000002 x0 : 0000000000000000
[    9.103761] Call trace:
[    9.106202]  media_create_pad_link+0xf0/0x188
[    9.110553]  xvip_graph_notify_complete+0x2e0/0x528
[    9.115425]  v4l2_async_notifier_try_complete.part.0+0x44/0x60
[    9.121248]  v4l2_async_register_subdev+0xf4/0x1b0
[    9.126030]  xscaler_probe+0x5a8/0x8d8
[    9.129771]  platform_drv_probe+0x50/0xa0
[    9.133772]  really_probe+0xd8/0x2f8
[    9.137340]  driver_probe_device+0x54/0xe8
[    9.141429]  __device_attach_driver+0x80/0xb8
[    9.145780]  bus_for_each_drv+0x74/0xc0
[    9.149606]  __device_attach+0xdc/0x138
[    9.153434]  device_initial_probe+0x10/0x18
[    9.157610]  bus_probe_device+0x90/0x98
[    9.161438]  deferred_probe_work_func+0x6c/0xa0
[    9.165962]  process_one_work+0x1c4/0x338
[    9.169963]  worker_thread+0x260/0x488
[    9.173705]  kthread+0x120/0x128
[    9.176926]  ret_from_fork+0x10/0x18
[    9.180496] Code: f9402e60 a902005a 52800041 f9002e63 (f9000003)
[    9.186579] ---[ end trace 80ce257d3f6f8213 ]---

This is caused because the media entity for the m2m video device is not
registered correctly in newer kernels due to a check in
video_register_media_controller() called from video_device_register().

This is fixed by adding the registration code to the driver. Using m2m
framework is not feasible as it would lead to a different media pipeline
where media source and sink are different elements and only one
processing element entity is allowed between them.

New framework
m2m source -> processing element -> m2m sink

Our pipeline

video entity ----> vpss scaler
             <----

Add xvideo_register_media_controller() to fix media entity registration.

Signed-off-by: Vishal Sagar <vishal.sagar@xilinx.com>
Reviewed-by: Hyun Kwon <hyun.kwon@xilinx.com>
State: pending
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 drivers/media/platform/xilinx/xilinx-m2m.c | 111 +++++++++++++++++++++
 1 file changed, 111 insertions(+)

diff --git a/drivers/media/platform/xilinx/xilinx-m2m.c b/drivers/media/platform/xilinx/xilinx-m2m.c
index 29464d6a60e9..944d563a544f 100644
--- a/drivers/media/platform/xilinx/xilinx-m2m.c
+++ b/drivers/media/platform/xilinx/xilinx-m2m.c
@@ -1442,6 +1442,109 @@ static const struct v4l2_m2m_ops xvip_m2m_ops = {
 	.job_abort	= xvip_m2m_job_abort,
 };
 
+/*
+ * This function is taken from the framework
+ * video_register_media_controller() function
+ */
+static int xvideo_register_media_controller(struct video_device *vdev)
+{
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	u32 intf_type;
+	int ret;
+
+	/*
+	 * Modified this by removing the condition for VFL_DIR_M2M
+	 * to ensure that the video entity is created.
+	 */
+	if (!vdev->v4l2_dev->mdev)
+		return 0;
+
+	vdev->entity.obj_type = MEDIA_ENTITY_TYPE_VIDEO_DEVICE;
+	vdev->entity.function = MEDIA_ENT_F_UNKNOWN;
+
+	switch (vdev->vfl_type) {
+	case VFL_TYPE_GRABBER:
+		intf_type = MEDIA_INTF_T_V4L_VIDEO;
+		vdev->entity.function = MEDIA_ENT_F_IO_V4L;
+		break;
+	case VFL_TYPE_VBI:
+		intf_type = MEDIA_INTF_T_V4L_VBI;
+		vdev->entity.function = MEDIA_ENT_F_IO_VBI;
+		break;
+	case VFL_TYPE_SDR:
+		intf_type = MEDIA_INTF_T_V4L_SWRADIO;
+		vdev->entity.function = MEDIA_ENT_F_IO_SWRADIO;
+		break;
+	case VFL_TYPE_TOUCH:
+		intf_type = MEDIA_INTF_T_V4L_TOUCH;
+		vdev->entity.function = MEDIA_ENT_F_IO_V4L;
+		break;
+	case VFL_TYPE_RADIO:
+		intf_type = MEDIA_INTF_T_V4L_RADIO;
+		/*
+		 * Radio doesn't have an entity at the V4L2 side to represent
+		 * radio input or output. Instead, the audio input/output goes
+		 * via either physical wires or ALSA.
+		 */
+		break;
+	case VFL_TYPE_SUBDEV:
+		intf_type = MEDIA_INTF_T_V4L_SUBDEV;
+		/* Entity will be created via v4l2_device_register_subdev() */
+		break;
+	default:
+		return 0;
+	}
+
+	if (vdev->entity.function != MEDIA_ENT_F_UNKNOWN) {
+		vdev->entity.name = vdev->name;
+
+		/* Needed just for backward compatibility with legacy MC API */
+		vdev->entity.info.dev.major = VIDEO_MAJOR;
+		vdev->entity.info.dev.minor = vdev->minor;
+
+		ret = media_device_register_entity(vdev->v4l2_dev->mdev,
+						   &vdev->entity);
+		if (ret < 0) {
+			pr_warn("%s: media_device_register_entity failed\n",
+				__func__);
+			return ret;
+		}
+	}
+
+	vdev->intf_devnode = media_devnode_create(vdev->v4l2_dev->mdev,
+						  intf_type,
+						  0, VIDEO_MAJOR,
+						  vdev->minor);
+	if (!vdev->intf_devnode) {
+		media_device_unregister_entity(&vdev->entity);
+		return -ENOMEM;
+	}
+
+	if (vdev->entity.function != MEDIA_ENT_F_UNKNOWN) {
+		struct media_link *link;
+
+		link = media_create_intf_link(&vdev->entity,
+					      &vdev->intf_devnode->intf,
+					      MEDIA_LNK_FL_ENABLED |
+					      MEDIA_LNK_FL_IMMUTABLE);
+		if (!link) {
+			media_devnode_remove(vdev->intf_devnode);
+			media_device_unregister_entity(&vdev->entity);
+			return -ENOMEM;
+		}
+	}
+
+	/* FIXME: how to create the other interface links? */
+
+#endif
+	/* This is added from __video_register_device() */
+
+	/* Part 6: Activate this minor. The char device can now be used. */
+	set_bit(V4L2_FL_REGISTERED, &vdev->flags);
+
+	return 0;
+}
+
 static int xvip_m2m_dma_init(struct xvip_m2m_dma *dma)
 {
 	struct xvip_m2m_dev *xdev;
@@ -1519,9 +1622,17 @@ static int xvip_m2m_dma_init(struct xvip_m2m_dma *dma)
 		goto tx_rx;
 	}
 
+	ret = xvideo_register_media_controller(&dma->video);
+	if (ret < 0) {
+		dev_err(xdev->dev, "Failed to register media controller\n");
+		goto unreg_video;
+	}
+
 	video_set_drvdata(&dma->video, dma->xdev);
 	return 0;
 
+unreg_video:
+	video_unregister_device(&dma->video);
 tx_rx:
 	dma_release_channel(dma->chan_rx);
 tx:
-- 
2.31.1

