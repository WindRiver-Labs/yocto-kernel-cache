From b00a2e77e61ea94e12a711c2654a45412ed64f4b Mon Sep 17 00:00:00 2001
From: Vasyl Gomonovych <vgomonovych@marvell.com>
Date: Tue, 8 Jun 2021 05:47:17 -0700
Subject: [PATCH 1624/1921] GHES: support HEST/BERT in ACPI/DT systems

The Generic Hardware Error Source (GHES) allows for
non-standard errors to be reported to the system
(please refer to the ACPI specification).

The standard GHES driver requires the presence of
ACPI tables, and accompanying kernel ACPI support.
CN10K is commonly used in embedded context
with Device Tree and UEFI. Add support for DT and ACPI.

Add support for GHES through a platform driver,
using data from the Device Tree to construct the
required ACPI table (Hardware Error Source Table,
or HEST) and (Boot Error Record Table or BERT).
In ACPI based system use ACPI firmware tables.

The Boot Error Record Table (BERT) allows for the
reporting of [fatal] firmware errors which occurred
in a previous Linux boot.  Due to the severity of
the error[s], the firmware could have chosen to
reset the system directly without informing the
kernel.  BERT allows these errors to be reported
on a subsequent Linux boot.

For more information about BERT, please refer to ACPI
Specification version 6.0, section 18.3.1.

MRVL-EINJ: edac: RAS error-injection

Use SMC OCTEONTX_EDAC to inject ECC errors to DRAM & cache.
This provides an SMC error injection interface, for verifying
OcteonTX2's RAS/EDAC handling.
For example, injecting DRAM ECC single-bit error
at 8MB, and reading it back in EL3 ...
    # edac=/sys/module/otx2_einj/parameters/smc_params
    # echo 3,0x800000,0x300 >$edac
will cause ATF to inject error, field EL3 interrupt reporting it,
log that in the sdei-ghes area monitored by mrvl-ghes driver,
which passes details to generic edac_ghes driver, which logs
the following via syslog (which may display in /var/log/kern.log,
or elsewhere, depending on syslog configuration)

Signed-off-by: Vasyl Gomonovych <vgomonovych@marvell.com>
Change-Id: Ib454eea792f6c9e490b9c652f3db395a78485235
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/54049
Reviewed-by: Chandrakala Chavva <cchavva@marvell.com>
Reviewed-by: Sunil Kovvuri Goutham <sgoutham@marvell.com>
Tested-by: Sunil Kovvuri Goutham <sgoutham@marvell.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 .../bindings/edac/marvell-sdei-ghes.txt       | 110 +++
 drivers/acpi/apei/bert.c                      |  65 +-
 drivers/acpi/apei/ghes.c                      |  66 +-
 drivers/acpi/apei/hest.c                      |  14 +-
 drivers/soc/marvell/Kconfig                   |  45 +
 drivers/soc/marvell/Makefile                  |   1 +
 drivers/soc/marvell/cn10k-ghes/Makefile       |  10 +
 drivers/soc/marvell/cn10k-ghes/mrvl-einj.c    | 170 ++++
 .../soc/marvell/cn10k-ghes/mrvl-ghes-bert.c   | 420 +++++++++
 .../soc/marvell/cn10k-ghes/mrvl-ghes-bert.h   |  35 +
 .../soc/marvell/cn10k-ghes/mrvl-sdei-ghes.c   | 819 ++++++++++++++++++
 .../soc/marvell/cn10k-ghes/mrvl-sdei-ghes.h   |  82 ++
 include/acpi/apei.h                           |   4 +
 13 files changed, 1815 insertions(+), 26 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/edac/marvell-sdei-ghes.txt
 create mode 100644 drivers/soc/marvell/cn10k-ghes/Makefile
 create mode 100644 drivers/soc/marvell/cn10k-ghes/mrvl-einj.c
 create mode 100644 drivers/soc/marvell/cn10k-ghes/mrvl-ghes-bert.c
 create mode 100644 drivers/soc/marvell/cn10k-ghes/mrvl-ghes-bert.h
 create mode 100644 drivers/soc/marvell/cn10k-ghes/mrvl-sdei-ghes.c
 create mode 100644 drivers/soc/marvell/cn10k-ghes/mrvl-sdei-ghes.h

diff --git a/Documentation/devicetree/bindings/edac/marvell-sdei-ghes.txt b/Documentation/devicetree/bindings/edac/marvell-sdei-ghes.txt
new file mode 100644
index 000000000000..b25034c8a263
--- /dev/null
+++ b/Documentation/devicetree/bindings/edac/marvell-sdei-ghes.txt
@@ -0,0 +1,110 @@
+* Marvell OcteonTX SOC sdei-ghes, bed-bert nodes
+
+The sdei-ghes and bed-bert nodes are defined to describe resources to the
+sdei-ghes module.
+
+Abstract
+--------
+
+The Generic Hardware Error Source (GHES) allows for non-standard errors to be
+reported to the system (please refer to the ACPI specification).
+
+The standard GHES driver requires the presence of ACPI tables, and accompanying
+kernel ACPI support, which is not available to systems utilizing Device Tree.
+
+The OcteonTX2 sdei-ghes module provides the required Hardware Error Source Table
+(HEST) to the kernel, allowing the GHES driver to load.  This module also
+provides the Boot Error Record Table (BERT) to the kernel, which allows for
+reporting of fatal RAS errors to Linux on a subsequent boot.
+
+Additionally, this module presents GHES devices to the system, which allows
+the firmware (ATF) to report RAS errors.
+
+The following error sources are supported:
+
+  MDC    - OcteonTX Memory Diagnostic Controller
+  MCC    - OcteonTX Memory Common Controller
+  LMC    - OcteonTX Local Memory DDR4 Controller
+  BERT   - A virtual device which records fatal errors from any of the above
+           into system preserved memory.
+           NOTE: this is located in the 'bed-bert' node.
+
+Device Tree sdei-ghes binding
+-----------------------------
+
+Required properties:
+- compatible	: Shall be "marvell,sdei-ghes".
+
+Required properties for mdc subnode:
+- reg		: Shall contain three entries, one for each of:
+		  - GHES Error Status Address (ACPI 4.0a, sec 17.3.2.6)
+		  - GHES Error Status Block   (ACPI 4.0a, sec 17.3.2.6.1)
+		  - ring buffer for communication with firmware
+
+- event-id	: SDEI event ID for receiving firmware notifications
+
+Example
+-------
+
+sdei-ghes {
+	compatible = "marvell,sdei-ghes";
+	#address-cells = <2>;
+	#size-cells = <1>;
+	memory-region = <&ghes_hest_reserved>;
+	ranges = <0x0 0x00000000 0x0 0x7f020000 0x00100>,
+		 <0x0 0x00000100 0x0 0x7f020100 0x00700>,
+		 <0x0 0x00000800 0x0 0x7f020800 0x08000>;
+	mdc@0 {
+		reg = <0x0 0x00000000 0x008>,
+		      <0x0 0x00000100 0x100>,
+		      <0x0 0x00000800 0x800>;
+		event-id = <0x40000000>;
+	};
+	mcc@8 {
+		reg = <0x0 0x00000008 0x008>,
+		      <0x0 0x00000200 0x100>,
+		      <0x0 0x00001000 0x800>;
+		event-id = <0x40000001>;
+	};
+	lmc@10 {
+		reg = <0x0 0x00000010 0x008>,
+		      <0x0 0x00000300 0x100>,
+		      <0x0 0x00001800 0x800>;
+		event-id = <0x40000002>;
+	};
+};
+
+Device Tree bed-bert binding
+-----------------------------
+
+Required properties:
+- compatible	: Shall be "marvell,bed-bert".
+
+Required properties for bert subnode:
+- reg		: Shall contain three entries, one for each of:
+		  - GHES Error Status Address (ACPI 4.0a, sec 17.3.2.6)
+		  - GHES Error Status Block   (ACPI 4.0a, sec 17.3.2.6.1)
+		  - ring buffer for communication with firmware
+
+Example
+-------
+
+/* Boot Error Data / BERT support */
+bed-bert {
+	compatible = "marvell,bed-bert";
+	#address-cells = <2>;
+	#size-cells = <2>;
+	memory-region = <&ghes_bert_reserved>;
+	/*
+	 * Range placeholders; these are set dynamically by
+	 * firmware to match 'reg' in 'ghes_bert_reserved'.
+	 */
+	ranges = <0x0 0x0 0x0 0x0 0x0 0x0>,
+		 <0x0 0x0 0x0 0x0 0x0 0x0>,
+		 <0x0 0x0 0x0 0x0 0x0 0x0>;
+	bert {
+		reg = <0x0 0x00000000 0x0 0x008>,
+		      <0x0 0x00000100 0x0 0x100>,
+		      <0x0 0x00000200 0x0 0x800>;
+	};
+};
\ No newline at end of file
diff --git a/drivers/acpi/apei/bert.c b/drivers/acpi/apei/bert.c
index 1155fb9dcc3a..9368f8a0fff7 100644
--- a/drivers/acpi/apei/bert.c
+++ b/drivers/acpi/apei/bert.c
@@ -24,6 +24,7 @@
 #include <linux/init.h>
 #include <linux/acpi.h>
 #include <linux/io.h>
+#include <linux/of.h>
 
 #include "apei-internal.h"
 
@@ -32,6 +33,26 @@
 
 static int bert_disable;
 
+static struct acpi_table_bert *__read_mostly bert_tab;
+
+/*
+ * Checks device tree for support of bed-bert [driver].
+ * This driver supports BERT in the absence of ACPI.
+ * on entry:
+ *     void
+ * returns:
+ *     true if bed-bert support found in Device Tree else false
+ */
+static bool bed_bert_present_dt(void)
+{
+	struct device_node *np;
+
+	np = of_find_node_by_name(NULL, "bed-bert");
+	of_node_put(np);
+
+	return !!np;
+}
+
 static void __init bert_print_all(struct acpi_bert_region *region,
 				  unsigned int region_len)
 {
@@ -81,10 +102,10 @@ static int __init setup_bert_disable(char *str)
 }
 __setup("bert_disable", setup_bert_disable);
 
-static int __init bert_check_table(struct acpi_table_bert *bert_tab)
+static int __init bert_check_table(struct acpi_table_bert *bert)
 {
-	if (bert_tab->header.length < sizeof(struct acpi_table_bert) ||
-	    bert_tab->region_length < sizeof(struct acpi_bert_region))
+	if (bert->header.length < sizeof(struct acpi_table_bert) ||
+	    bert->region_length < sizeof(struct acpi_bert_region))
 		return -EINVAL;
 
 	return 0;
@@ -94,12 +115,12 @@ static int __init bert_init(void)
 {
 	struct apei_resources bert_resources;
 	struct acpi_bert_region *boot_error_region;
-	struct acpi_table_bert *bert_tab;
 	unsigned int region_len;
 	acpi_status status;
 	int rc = 0;
 
-	if (acpi_disabled)
+	/* permit BERT initialization if either ACPI or GHES_BERT is present */
+	if (acpi_disabled && !bed_bert_present_dt())
 		return 0;
 
 	if (bert_disable) {
@@ -107,7 +128,12 @@ static int __init bert_init(void)
 		return 0;
 	}
 
-	status = acpi_get_table(ACPI_SIG_BERT, 0, (struct acpi_table_header **)&bert_tab);
+	/* BERT table may have been initialized by bert_table_set() */
+	if (bert_tab)
+		status = AE_OK;
+	else
+		status = acpi_get_table(ACPI_SIG_BERT, 0,
+					(struct acpi_table_header **)&bert_tab);
 	if (status == AE_NOT_FOUND)
 		return 0;
 
@@ -124,13 +150,15 @@ static int __init bert_init(void)
 
 	region_len = bert_tab->region_length;
 	apei_resources_init(&bert_resources);
-	rc = apei_resources_add(&bert_resources, bert_tab->address,
-				region_len, true);
-	if (rc)
-		return rc;
-	rc = apei_resources_request(&bert_resources, "APEI BERT");
-	if (rc)
-		goto out_fini;
+	if (!acpi_disabled) {
+		rc = apei_resources_add(&bert_resources, bert_tab->address,
+					region_len, true);
+		if (rc)
+			return rc;
+		rc = apei_resources_request(&bert_resources, "APEI BERT");
+		if (rc)
+			goto out_fini;
+	}
 	boot_error_region = ioremap_cache(bert_tab->address, region_len);
 	if (boot_error_region) {
 		bert_print_all(boot_error_region, region_len);
@@ -139,11 +167,20 @@ static int __init bert_init(void)
 		rc = -ENOMEM;
 	}
 
-	apei_resources_release(&bert_resources);
+	if (!acpi_disabled)
+		apei_resources_release(&bert_resources);
 out_fini:
 	apei_resources_fini(&bert_resources);
 
 	return rc;
 }
 
+/*
+ * This allows the BERT to be initialized externally, in the absence of ACPI.
+ */
+void __init bert_table_set(struct acpi_table_bert *table)
+{
+	bert_tab = table;
+}
+
 late_initcall(bert_init);
diff --git a/drivers/acpi/apei/ghes.c b/drivers/acpi/apei/ghes.c
index 3760b5ebf1a6..218854636e3e 100644
--- a/drivers/acpi/apei/ghes.c
+++ b/drivers/acpi/apei/ghes.c
@@ -40,6 +40,7 @@
 #include <linux/sched/clock.h>
 #include <linux/uuid.h>
 #include <linux/ras.h>
+#include <linux/of.h>
 
 #include <acpi/actbl1.h>
 #include <acpi/ghes.h>
@@ -130,6 +131,24 @@ static atomic_t ghes_estatus_cache_alloced;
 
 static int ghes_panic_timeout __read_mostly = 30;
 
+
+/*
+ * Checks device tree for support of sdei-ghes [driver].
+ * This driver supports GHES in the absence of ACPI.
+ * on entry:
+ *     void
+ * returns:
+ *     true if sdei-ghes support found in Device Tree else false
+ */
+static bool sdei_ghes_present_dt(void)
+{
+	struct device_node *np;
+
+	np = of_find_node_by_name(NULL, "sdei-ghes");
+	of_node_put(np);
+	return !!np;
+}
+
 static void __iomem *ghes_map(u64 pfn, enum fixed_addresses fixmap_idx)
 {
 	phys_addr_t paddr;
@@ -224,6 +243,20 @@ static struct ghes *ghes_new(struct acpi_hest_generic *generic)
 		return ERR_PTR(-ENOMEM);
 
 	ghes->generic = generic;
+
+	/* If sdei-ghes is present (via device tree), ACPI mappings are not
+	 * available and will be relegated to 'early_mem_remap()'. However, any
+	 * such outstanding 'early' mappings will be detected as leaks during
+	 * late kernel initialization - see 'check_early_ioremap_leak()'.
+	 * Since this mapping is a 'sanity check' only (the mapping isn't used),
+	 * skip this step to avoid it being detected as an [errant] leak.
+	 * Notes:
+	 *   * the presence of the Device Tree disables ACPI
+	 *   * the status register is actually mapped at run-time, when accessed
+	 */
+	if (sdei_ghes_present_dt())
+		goto skip_map_status;
+
 	if (is_hest_type_generic_v2(ghes)) {
 		rc = map_gen_v2(ghes);
 		if (rc)
@@ -233,6 +266,8 @@ static struct ghes *ghes_new(struct acpi_hest_generic *generic)
 	rc = apei_map_generic_address(&generic->error_status_address);
 	if (rc)
 		goto err_unmap_read_ack_addr;
+
+skip_map_status:
 	error_block_length = generic->error_block_length;
 	if (error_block_length > GHES_ESTATUS_MAX_SIZE) {
 		pr_warning(FW_WARN GHES_PFX
@@ -250,6 +285,9 @@ static struct ghes *ghes_new(struct acpi_hest_generic *generic)
 	return ghes;
 
 err_unmap_status_addr:
+	/* if sdei-ghes is present, status was not mapped - skip the UNmap */
+	if (sdei_ghes_present_dt())
+		goto err_free;
 	apei_unmap_generic_address(&generic->error_status_address);
 err_unmap_read_ack_addr:
 	if (is_hest_type_generic_v2(ghes))
@@ -262,6 +300,9 @@ static struct ghes *ghes_new(struct acpi_hest_generic *generic)
 static void ghes_fini(struct ghes *ghes)
 {
 	kfree(ghes->estatus);
+	/* if sdei-ghes is present, status was not mapped - skip the UNmap */
+	if (sdei_ghes_present_dt())
+		return;
 	apei_unmap_generic_address(&ghes->generic->error_status_address);
 	if (is_hest_type_generic_v2(ghes))
 		unmap_gen_v2(ghes);
@@ -1181,7 +1222,7 @@ static int ghes_probe(struct platform_device *ghes_dev)
 
 	switch (generic->notify.type) {
 	case ACPI_HEST_NOTIFY_POLLED:
-		timer_setup(&ghes->timer, ghes_poll_func, TIMER_DEFERRABLE);
+		timer_setup(&ghes->timer, ghes_poll_func, 0);
 		ghes_add_timer(ghes);
 		break;
 	case ACPI_HEST_NOTIFY_EXTERNAL:
@@ -1313,7 +1354,8 @@ static int __init ghes_init(void)
 {
 	int rc;
 
-	if (acpi_disabled)
+	/* permit GHES initialization if either ACPI or SDEI_GHES is present */
+	if (acpi_disabled && !sdei_ghes_present_dt())
 		return -ENODEV;
 
 	switch (hest_disable) {
@@ -1337,15 +1379,17 @@ static int __init ghes_init(void)
 	if (rc)
 		goto err;
 
-	rc = apei_osc_setup();
-	if (rc == 0 && osc_sb_apei_support_acked)
-		pr_info(GHES_PFX "APEI firmware first mode is enabled by APEI bit and WHEA _OSC.\n");
-	else if (rc == 0 && !osc_sb_apei_support_acked)
-		pr_info(GHES_PFX "APEI firmware first mode is enabled by WHEA _OSC.\n");
-	else if (rc && osc_sb_apei_support_acked)
-		pr_info(GHES_PFX "APEI firmware first mode is enabled by APEI bit.\n");
-	else
-		pr_info(GHES_PFX "Failed to enable APEI firmware first mode.\n");
+	if (!acpi_disabled) {
+		rc = apei_osc_setup();
+		if (rc == 0 && osc_sb_apei_support_acked)
+			pr_info(GHES_PFX "APEI firmware first mode is enabled by APEI bit and WHEA _OSC.\n");
+		else if (rc == 0 && !osc_sb_apei_support_acked)
+			pr_info(GHES_PFX "APEI firmware first mode is enabled by WHEA _OSC.\n");
+		else if (rc && osc_sb_apei_support_acked)
+			pr_info(GHES_PFX "APEI firmware first mode is enabled by APEI bit.\n");
+		else
+			pr_info(GHES_PFX "Failed to enable APEI firmware first mode.\n");
+	}
 
 	return 0;
 err:
diff --git a/drivers/acpi/apei/hest.c b/drivers/acpi/apei/hest.c
index 267bdbf6a7bf..781132e1df3c 100644
--- a/drivers/acpi/apei/hest.c
+++ b/drivers/acpi/apei/hest.c
@@ -235,7 +235,10 @@ void __init acpi_hest_init(void)
 		return;
 	}
 
-	status = acpi_get_table(ACPI_SIG_HEST, 0,
+	if (hest_tab)
+		status = AE_OK;
+	else
+		status = acpi_get_table(ACPI_SIG_HEST, 0,
 				(struct acpi_table_header **)&hest_tab);
 	if (status == AE_NOT_FOUND) {
 		hest_disable = HEST_NOT_FOUND;
@@ -267,3 +270,12 @@ void __init acpi_hest_init(void)
 err:
 	hest_disable = HEST_DISABLED;
 }
+
+
+/*
+ * This allows the HEST to be initialized externally, in the absence of ACPI.
+ */
+void __init hest_table_set(struct acpi_table_hest *table)
+{
+	hest_tab = table;
+}
diff --git a/drivers/soc/marvell/Kconfig b/drivers/soc/marvell/Kconfig
index b28919cb6abc..56e2f88a3260 100644
--- a/drivers/soc/marvell/Kconfig
+++ b/drivers/soc/marvell/Kconfig
@@ -185,4 +185,49 @@ config MARVELL_CN10K_SWUP
 	    -> TIM Version check
 	    -> TIM Hash verification
 
+config MARVELL_SDEI_GHES
+	bool "Marvell Generic Hardware Error Source (GHES) support"
+	select ARM_SDE_INTERFACE
+	select ACPI_APEI
+	select ACPI_APEI_GHES
+	select CRASH_DUMP
+	help
+	  Select this option to enable support for RAS Generic Hardware Error
+	  Source (GHES) reporting.
+	  This will allow RAS errors that are detected by the Marvell to
+	  be reported using kernel logging.
+
+config MARVELL_SDEI_GHES_DEBUG
+	bool "Marvell Generic Hardware Error Source (GHES) verbose debug msgs"
+	depends on MARVELL_SDEI_GHES
+	default n
+	help
+	  Say Y here if you want the Marvell GHES support to
+	  write verbose debug messages to the system log.  Select this
+	  if you are having a problem with the Marvell GHES support
+	  and want to see more details.
+	  If you are unsure about this, say N here.
+
+config MARVELL_GHES_BERT
+	bool "Marvell GHES Boot Error Record Table (BERT) support"
+	depends on MARVELL_SDEI_GHES
+	default y
+	help
+	  Select this option to enable reporting of fatal Marvell GHES
+	  errors on subsequent Linux boot.  Normally, fatal errors will
+	  reset the system.  Enabling support here will allow such errors
+	  to be reported when Linux is started again.
+
+config MARVELL_EINJ
+	tristate "Marvell EDAC ECC Injection"
+	depends on MARVELL_SDEI_GHES
+	help
+	  Provides support for error injection to MARVELL
+	  memory controllers (LMC) and cache blocks.
+	  This facilitates testing of the memory controller RAS features and
+	  is intended to be used by test personnel when conducting system tests.
+
+	  To compile this as a module, choose M here. The module will be
+	  called mrvl-einj.
+	  Unless testing, say N here.
 endmenu
diff --git a/drivers/soc/marvell/Makefile b/drivers/soc/marvell/Makefile
index 754f4b0563f9..831f5699afc8 100644
--- a/drivers/soc/marvell/Makefile
+++ b/drivers/soc/marvell/Makefile
@@ -13,3 +13,4 @@ obj-$(CONFIG_MVMDIO_UIO) += mvmdio_uio.o
 obj-$(CONFIG_MRVL_PHY_DIAGNOSTICS) += phy_diag.o
 obj-$(CONFIG_MARVELL_CN10K_MAC_MGMT) += marvell_mac_mgmt.o
 obj-$(CONFIG_MARVELL_CN10K_RPRAM) += cn10k-rpram.o
+obj-$(CONFIG_MARVELL_SDEI_GHES) += cn10k-ghes/
diff --git a/drivers/soc/marvell/cn10k-ghes/Makefile b/drivers/soc/marvell/cn10k-ghes/Makefile
new file mode 100644
index 000000000000..fb44f533fd69
--- /dev/null
+++ b/drivers/soc/marvell/cn10k-ghes/Makefile
@@ -0,0 +1,10 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for Marvell's OcteonTX2 SDEI/GHES device driver
+#
+
+obj-$(CONFIG_MARVELL_SDEI_GHES) += mrvl_sdei_ghes.o
+mrvl_sdei_ghes-$(CONFIG_MARVELL_GHES_BERT) += mrvl-ghes-bert.o
+mrvl_sdei_ghes-y += mrvl-sdei-ghes.o
+
+obj-$(CONFIG_MARVELL_EINJ) += mrvl-einj.o
diff --git a/drivers/soc/marvell/cn10k-ghes/mrvl-einj.c b/drivers/soc/marvell/cn10k-ghes/mrvl-einj.c
new file mode 100644
index 000000000000..bcaf8acfe9d0
--- /dev/null
+++ b/drivers/soc/marvell/cn10k-ghes/mrvl-einj.c
@@ -0,0 +1,170 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * OcteonTX2 memory controller ECC injection
+ * Copyright Marvell Technologies. (C) 2019-2020. All rights reserved.
+ */
+
+#include <linux/module.h>
+#include <linux/pci.h>
+
+#ifdef CONFIG_MARVELL_SDEI_GHES_DEBUG
+#  define dbgmsg(...) pr_info(__VA_ARGS__)
+#else
+#  define dbgmsg(...) (void)(__VA_ARGS__)
+#endif // CONFIG_OCTEONTX2_SDEI_GHES_DEBUG
+
+/*
+ * All DRAM/cache controller hardware is handled by ATF on these platforms
+ * and not visible to Non-Secure OS kernel.
+ * The EDAC functions are passed to ATF by OCTEONTX_EDAC SMC, which performs
+ * injection and reporting, and copies log stream back to kernel for reporting
+ * detail in syslog.
+ *
+ * This is minimal SMC stub approach, minimally providing hooks for usermode
+ * error-injection tools, to exercise either the legacy EDAC code of pre-4.18,
+ * or the standard SDEI/GHES RAS handling possible in newer kernels.
+ * It knows nothing of either, just asks ATF to corrupt memory.
+ * This allows LMC/etc details to be hidden from EL2, all RAS/EDAC
+ * work going to ATF/EL3 for security.
+ *
+ * For further details, see:
+ *  ATF's docs/plat/marvell/marvell_ras.txt
+ *  include/plat/marvell/octeontx/otx2/plat_ras.h
+ */
+
+#define OCTEONTX_EDAC                   0xc2000c0b
+/* x1 is one of the following ... */
+#define OCTEONTX_EDAC_VER	0	/* report version */
+#define OCTEONTX_EDAC_INJECT	3	/* x2=addr x3=flags _F_xxx below */
+#define OCTEONTX_EDAC_MDC_CONST	4	/* read CAVM_MDC_CONST */
+#define OCTEONTX_EDAC_MDC_RW	5	/* read/write MDC */
+#define OCTEONTX_EDAC_MDC_ROM	6	/* read MDC_RAS_ROM x2=addr */
+
+#define OCTEONTX_EDAC_F_BITMASK	0x007 /* single bit to corrupt */
+#define OCTEONTX_EDAC_F_MULTI	0x008 /* corrupt multiple bits */
+#define OCTEONTX_EDAC_F_CLEVEL	0x070 /* cache level to corrupt (L0 == DRAM) */
+#define OCTEONTX_EDAC_F_ICACHE	0x080 /* Icache, not Dcache */
+#define OCTEONTX_EDAC_F_REREAD	0x100 /* read-back in EL3 */
+#define OCTEONTX_EDAC_F_PHYS	0x200 /* target is EL3-physical, not EL012 */
+
+#include <linux/arm-smccc.h>
+
+/*
+ * Module parameters are used here instead of debugfs because debugfs requires
+ * a kernel configuration option to be enabled, which potentially requires
+ * a configuration change and kernel rebuild.
+ * The use of error injection via this module is meant to be available at all
+ * times (when the module is loaded) and should not require a special kernel.
+ */
+static u64 smc_params[7];
+static u64 smc_result;
+static int smc_argc;
+
+/* an easily recognized value for logs */
+static const u64 test_val = 0x5555555555555555;
+
+/* target address for please-corrupt-EL1/EL2 I-cache/DRAM */
+static u64 ecc_test_target_fn(void)
+{
+	return test_val;
+}
+
+static int otx2_edac_smc(void)
+{
+	/* target address for please-corrupt-EL1/EL2 D-cache/DRAM: */
+	u64 ecc_test_target_data = test_val;
+	struct arm_smccc_res res;
+	bool test_read = false;
+	bool test_call = false;
+	u64 *a = smc_params;
+
+	/*
+	 * Replace magic ECC-injection addresses:
+	 * special ECC-injection addresses 0-3/4-7 are substituted by
+	 * EL0-3 code as instr/data targets at that execution level.
+	 * Any 0/4 addresses will have already been substituted
+	 * by EL0 test harness, here we substitute EL1/EL2 targets.
+	 * While 3/7 are replaced by ATF with its own test objects,
+	 * we remind it to reread in its own context.
+	 */
+	if (a[0] == OCTEONTX_EDAC_INJECT) {
+		a[2] &= ~OCTEONTX_EDAC_F_REREAD;
+		switch (a[1]) {
+		case 1 ... 2:	/* EL0..EL2 D-space target */
+			a[1] = (u64)&ecc_test_target_data;
+			test_read = true;
+			break;	/* EL0..EL2 I-space target */
+		case 5 ... 6:
+			a[1] = (u64)ecc_test_target_fn;
+			test_call = true;
+			break;
+		case 3: /* EL3 targets */
+		case 7:
+			a[2] |= OCTEONTX_EDAC_F_REREAD;
+			break;
+		}
+	}
+
+	arm_smccc_smc(OCTEONTX_EDAC, a[0], a[1], a[2], /* x1-x3 */
+		a[3], a[4], a[5], a[6], &res); /* x4-x7, result */
+	dbgmsg("%s: OCTEONTX_EDAC(%llx, %llx, %llx, %llx) -> e?%ld\n",
+		__func__, a[0], a[1], a[2], a[3], res.a0);
+
+	if (test_read && ecc_test_target_data != test_val)
+		dbgmsg("%s test_read mismatch\n", __func__);
+	if (test_call && ecc_test_target_fn() != test_val)
+		dbgmsg("%s test_call mismatch\n", __func__);
+
+	return res.a0;
+}
+
+static int smc_params_set(const char *_str, const struct kernel_param *kp)
+{
+	/* as with param_array_set(), temporarily overwrites string */
+	char *str = (char *)_str;
+	int rc;
+
+	trace_printk("%s: %s\n", __func__, str);
+
+	if (!str)
+		return -EINVAL;
+
+	smc_result = -EBUSY;
+
+	for (smc_argc = 0; smc_argc < 7 && *str; smc_argc++) {
+		int len = strcspn(str, ",");
+		char *nxt = len ? str + len + 1 : "";
+
+		if (len)
+			str[len] = '\0';
+		rc = kstrtoull(str, 0, &smc_params[smc_argc]);
+
+		dbgmsg("%s: (%s/%s) smc_params[%d]=%llx e?%d\n", __func__, str, nxt,
+				smc_argc, smc_params[smc_argc], rc);
+		if (len)
+			str[len] = ',';
+		str = nxt;
+		dbgmsg("%s: smc_params[%d]=%llx\n",
+			__func__, smc_argc, smc_params[smc_argc]);
+	}
+	smc_result = otx2_edac_smc();
+	dbgmsg("%s: result: %llx\n", __func__, smc_result);
+	return 0;
+}
+
+static int smc_params_get(char *buffer, const struct kernel_param *kp)
+{
+	return sprintf(buffer, "%lld\n", smc_result);
+}
+
+static const struct kernel_param_ops smc_params_ops = {
+	.set = smc_params_set,
+	.get = smc_params_get,
+};
+
+module_param_cb(smc_params, &smc_params_ops, smc_params, 0644);
+MODULE_PARM_DESC(smc_params, "call/return  values for OCTEONTX_EDAC SMC");
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Marvell Semiconductor");
+MODULE_DESCRIPTION("OcteonTX2 ECC injector stub");
diff --git a/drivers/soc/marvell/cn10k-ghes/mrvl-ghes-bert.c b/drivers/soc/marvell/cn10k-ghes/mrvl-ghes-bert.c
new file mode 100644
index 000000000000..f778731f2c42
--- /dev/null
+++ b/drivers/soc/marvell/cn10k-ghes/mrvl-ghes-bert.c
@@ -0,0 +1,420 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Marvell CN10K Generic Hardware Error Source
+ * Boot Error Data (BED) ACPI BERT & DT
+ *
+ * Copyright (C) 2021 Marvell.
+ */
+
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/of_address.h>
+#include <linux/arm_sdei.h>
+#include <linux/uuid.h>
+#include <linux/acpi.h>
+#include <acpi/apei.h>
+#include <linux/pci.h>
+#include <linux/crash_dump.h>
+#include "mrvl-ghes-bert.h"
+#include "mrvl-sdei-ghes.h"
+
+#define DRV_NAME	"bed-bert"
+
+#define initerrmsg(fmt, ...) pr_err(DRV_NAME ":" fmt, __VA_ARGS__)
+#ifdef CONFIG_MARVELL_SDEI_GHES_DEBUG
+#  define initdbgmsg(fmt, ...) pr_info(DRV_NAME ":" fmt, __VA_ARGS__)
+#  define dbgmsg(dev, ...) dev_info((dev), __VA_ARGS__)
+#else
+#  define initdbgmsg(fmt, ...) (void)(fmt)
+#  define dbgmsg(dev, ...) (void)(dev)
+#endif // CONFIG_MARVELL_SDEI_GHES_DEBUG
+
+#define BERT_TBL_OEM_ID	"OTX2    "
+#define BERT_OEM_ID     "MRVL  "
+
+static u32 bert_is_iomap __initdata;
+
+#ifdef CONFIG_OF
+static const struct of_device_id bed_bert_of_match[] = {
+	{ .compatible = "marvell,bed-bert", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, bed_bert_of_match);
+#endif
+
+#ifdef CONFIG_ACPI
+static const struct acpi_device_id bed_bert_acpi_match[] = {
+	{ "BERT0001", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(acpi, bed_bert_acpi_match);
+#endif
+
+static int __init ghes_bed_acpi_match_resource(struct platform_device *pdev,
+		struct mrvl_bed_source *bsrc)
+{
+	struct resource *res;
+
+	initdbgmsg("%s: entry\n", __func__);
+
+	// Error Block Ring
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 2);
+	if (!res) {
+		initerrmsg("%s ACPI unable get ring block\n", __func__);
+		return -ENOENT;
+	}
+	initdbgmsg("%s Status Ring %s [%llx - %llx, %lx, %lx]\n", __func__,
+			res->name, res->start, res->end, res->flags, res->desc);
+	bsrc->block_pa = res->start;
+	bsrc->block_sz = resource_size(res);
+	initdbgmsg("BERT RING: 0x%llx/0x%llx\n", bsrc->block_pa, bsrc->block_sz);
+
+	return 0;
+}
+
+static int __init ghes_bed_of_match_resource(struct mrvl_bed_source *bsrc)
+{
+	struct device_node *of_node;
+	struct device_node *child_node;
+	const __be32 *res;
+	u64 size;
+	u64 base;
+
+	initdbgmsg("%s: entry\n", __func__);
+
+	of_node = of_find_matching_node_and_match(NULL, bed_bert_of_match, NULL);
+	if (!of_node) {
+		initerrmsg("BERT initialization no dev node %p\n", of_node);
+		return -ENODEV;
+	}
+
+	child_node = of_get_next_available_child(of_node, NULL);
+	if (!child_node) {
+		initerrmsg("BERT initialization no child node %p\n", child_node);
+		return -ENODEV;
+	}
+
+	res = of_get_address(child_node, 2, &size, NULL);
+	if (!res)
+		goto err;
+
+	base = of_translate_address(child_node, res);
+	if (base == OF_BAD_ADDR)
+		goto err;
+
+	bsrc->block_pa = (phys_addr_t)base;
+	bsrc->block_sz = (phys_addr_t)size;
+
+	initdbgmsg("BERT: 0x%llx/0x%llx\n", bsrc->block_pa, bsrc->block_sz);
+
+	return 0;
+
+err:
+	initerrmsg("%s BERT unable get/translate address block\n", __func__);
+	return -ENODEV;
+}
+
+static int __init ghes_bed_map_resource(struct mrvl_bed_source *bsrc)
+{
+	if (pfn_valid(PHYS_PFN(bsrc->block_pa))) {
+		bsrc->block_va = phys_to_virt(bsrc->block_pa);
+		bert_is_iomap = 0;
+		initdbgmsg("%s BERT translate block\n", __func__);
+	} else {
+		if (!request_mem_region(bsrc->block_pa, bsrc->block_sz, "BERT")) {
+			initerrmsg("Failure BERT request 0x%llx\n", bsrc->block_pa);
+			return -ENODEV;
+		}
+		bsrc->block_va = ioremap(bsrc->block_pa, bsrc->block_sz);
+		if (!bsrc->block_va) {
+			initerrmsg("%s Unable to map Boot Error Data\n", __func__);
+			release_mem_region(bsrc->block_pa, bsrc->block_sz);
+			return -ENODEV;
+		}
+		bert_is_iomap = 1;
+		initdbgmsg("%s BERT iomap block\n", __func__);
+	}
+	initdbgmsg("%s BERT Ring block VA=%p\n", __func__, bsrc->block_va);
+
+	return 0;
+}
+
+static int __init ghes_bed_count_error(struct mrvl_bed_source *bsrc)
+{
+	struct mrvl_ghes_err_ring *ring;
+	size_t error_cnt = 0;
+
+	ring = bsrc->block_va;
+
+	if (!ring->size) {
+		initerrmsg("%s BERT support disabled by firmware\n", __func__);
+		return 0;
+	}
+
+	if (ring->head >= ring->tail)
+		error_cnt = ring->head - ring->tail;
+	else
+		error_cnt = ring->size - (ring->tail - ring->head);
+
+	bsrc->error_cnt = error_cnt;
+
+	initdbgmsg("BED mem @ %llx (%llx PA), %llu B, error entries %ld\n",
+		   (long long)bsrc->block_va, bsrc->block_pa,
+		   (long long)bsrc->block_sz, error_cnt);
+
+	return error_cnt;
+}
+
+static int __init ghes_bed_adjust_bert_layout(struct mrvl_bed_source *bsrc)
+{
+	struct mrvl_ghes_err_ring *ring;
+	size_t ring_len;
+	size_t bert_len;
+
+	ring = bsrc->block_va;
+
+	/*
+	 * The memory block contains the boot error data ring; beyond the ring
+	 * is room for the BERT.  Calculate size of BERT area.
+	 * Note: the ring structure definition already contains one entry,
+	 * so subtract one from the 'size' member.
+	 * [1] error ring descriptor
+	 * [2] error records
+	 *		[*] cper_sec_mem_err_old
+	 *		[*] ...
+	 * [3] BERT
+	 */
+	ring_len = sizeof(struct mrvl_ghes_err_ring) +
+			(sizeof(struct mrvl_ghes_err_record) * (ring->size - 1));
+
+	ring_len = roundup(ring_len, 8);
+
+	if (ring_len > bsrc->block_sz) {
+		initerrmsg("Insufficient memory for ring (0x%lx / 0x%lx)\n",
+		       (long)ring_len, (long)bsrc->block_sz);
+		return -EFAULT;
+	}
+
+	bsrc->bert_pa = bsrc->block_pa + ring_len;
+	bsrc->bert_va = bsrc->block_va + ring_len;
+	bsrc->bert_sz = bsrc->block_sz - ring_len;
+
+	initdbgmsg("Ring @ 0x%llx/0x%lx Bert @ 0x%llx/0x%llx\n",
+			bsrc->block_pa, ring_len, bsrc->bert_pa, bsrc->bert_sz);
+
+	bert_len = sizeof(struct acpi_table_bert) +
+			sizeof(struct bed_bert_mem_entry) * bsrc->error_cnt;
+
+	if (bert_len > bsrc->bert_sz) {
+		initerrmsg("Insufficient memory for BERT data (0x%lx / 0x%lx)\n",
+		       (long)bert_len, (long)bsrc->bert_sz);
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+static int __init ghes_bed_fetch_errors(struct mrvl_bed_source *bsrc)
+{
+	struct acpi_table_bert *bert_tbl;
+	struct acpi_bert_region *bert_esb;
+	struct bed_bert_mem_entry *bert_entries;
+	struct mrvl_ghes_err_ring *ring;
+	struct acpi_hest_generic_data *hest_gen_data;
+	struct bed_bert_mem_entry *bert_mem_entry;
+	struct acpi_hest_generic_status *estatus;
+	struct cper_sec_mem_err_old *mem_err;
+	struct mrvl_ghes_err_record *err_rec;
+	u8 *p;
+	u8 sum = 0;
+	u32 idx = 0;
+
+	initdbgmsg("%s: entry\n", __func__);
+
+	ring = bsrc->block_va;
+
+	bert_tbl = kzalloc(bsrc->bert_sz, GFP_KERNEL);
+
+	if (!bert_tbl) {
+		initerrmsg("Unable to allocate BERT data (0x%llx B)\n", bsrc->bert_sz);
+		return -ENOMEM;
+	}
+
+	bert_esb = (struct acpi_bert_region *)(bert_tbl + 1);
+
+	bert_entries = (struct bed_bert_mem_entry *)bert_esb;
+
+	strncpy(bert_tbl->header.signature, ACPI_SIG_BERT,
+			  sizeof(bert_tbl->header.signature));
+	bert_tbl->header.length = sizeof(*bert_tbl);
+	bert_tbl->header.revision = 1;
+	bert_tbl->header.oem_revision = 1;
+	strncpy(bert_tbl->header.oem_id, BERT_OEM_ID,
+		sizeof(bert_tbl->header.oem_id));
+	strncpy(bert_tbl->header.oem_table_id, BERT_TBL_OEM_ID,
+		sizeof(bert_tbl->header.oem_table_id));
+	strncpy(bert_tbl->header.asl_compiler_id, BERT_OEM_ID,
+		sizeof(bert_tbl->header.asl_compiler_id));
+	bert_tbl->header.asl_compiler_revision = 1;
+
+	p = (u8 *)&bert_tbl->header;
+	while (p < (u8 *)(&bert_tbl->header + 1))
+		sum += *p, p++;
+	bert_tbl->header.checksum -= sum;
+
+	bert_tbl->region_length = (bsrc->error_cnt * sizeof(*bert_entries));
+	bert_tbl->address = bsrc->bert_pa + ((void *)bert_esb - (void *)bert_tbl);
+
+	initdbgmsg("BERT: 0x%llx(0x%p)\n", bsrc->bert_pa, bsrc->bert_va);
+
+	for (idx = 0; idx < bsrc->error_cnt; idx++) {
+		err_rec = &ring->records[ring->tail];
+
+		bert_mem_entry = &bert_entries[idx];
+
+		estatus = &bert_mem_entry->estatus.hest;
+
+		estatus->raw_data_length = 0;
+		estatus->raw_data_offset = 0;
+		estatus->data_length = sizeof(bert_mem_entry->gen_data);
+		estatus->error_severity = err_rec->severity;
+
+		hest_gen_data = &bert_mem_entry->gen_data;
+
+		hest_gen_data->revision = 0x201; /* ACPI 4.x */
+		if (err_rec->fru_text[0]) {
+			hest_gen_data->validation_bits = ACPI_HEST_GEN_VALID_FRU_STRING;
+			strncpy(hest_gen_data->fru_text, err_rec->fru_text,
+				sizeof(hest_gen_data->fru_text));
+		}
+
+		hest_gen_data->error_severity = estatus->error_severity;
+		memcpy((guid_t *)hest_gen_data->section_type,
+		       &CPER_SEC_PLATFORM_MEM, sizeof(guid_t));
+
+		hest_gen_data->error_data_length = sizeof(*mem_err);
+		estatus->data_length += hest_gen_data->error_data_length;
+
+		mem_err = &bert_mem_entry->mem_err;
+
+		memcpy(mem_err, &err_rec->u.mcc, sizeof(*mem_err));
+
+		/*
+		 * This simply needs the entry count to be non-zero.
+		 * Set entry count to one (see ACPI_HEST_ERROR_ENTRY_COUNT).
+		 */
+		estatus->block_status = (1 << 4); /* i.e. one entry */
+
+		if (++ring->tail >= ring->size)
+			ring->tail = 0;
+	}
+
+	memcpy(bsrc->bert_va, bert_tbl, bsrc->bert_sz);
+	kfree(bert_tbl);
+
+	return 0;
+}
+
+/*
+ * Boot Error Data probe BERT ring
+ */
+static int __init ghes_bert_probe(struct platform_device *pdev)
+{
+	struct mrvl_bed_source bed_src;
+	struct device *dev = &pdev->dev;
+	int ret = -ENODEV;
+
+	initdbgmsg("%s: entry\n", __func__);
+
+#ifdef CONFIG_CRASH_DUMP
+	if (is_kdump_kernel())
+#else
+	#pragma message "CONFIG_CRASH_DUMP setting is required for this module"
+	if (true)
+#endif
+		return ret;
+
+	if (has_acpi_companion(dev)) {
+		initdbgmsg("%s ACPI\n", __func__);
+		ret = ghes_bed_acpi_match_resource(pdev, &bed_src);
+	} else {
+		initdbgmsg("%s Device Tree\n", __func__);
+		ret = ghes_bed_of_match_resource(&bed_src);
+	}
+	if (ret)
+		goto exit0;
+
+	ret = ghes_bed_map_resource(&bed_src);
+	if (ret) {
+		initerrmsg("%s Unable map BERT resource\n", __func__);
+		goto exit0;
+	}
+
+	ret = ghes_bed_count_error(&bed_src);
+	if (ret <= 0) {
+		initerrmsg("%s No BERT errors\n", __func__);
+		goto exit1;
+	}
+
+	ret = ghes_bed_adjust_bert_layout(&bed_src);
+	if (ret) {
+		initerrmsg("%s Unable remap BERT layout\n", __func__);
+		goto exit1;
+	}
+
+	ret = ghes_bed_fetch_errors(&bed_src);
+	if (ret) {
+		initerrmsg("%s Unable setup BERT\n", __func__);
+		goto exit1;
+	}
+
+	if (!has_acpi_companion(dev))
+		bert_table_set(bed_src.bert_va);
+
+exit1:
+	if (bert_is_iomap && has_acpi_companion(dev)) {
+		initdbgmsg("%s BERT iounmap\n", __func__);
+		iounmap(bed_src.block_va);
+		release_mem_region(bed_src.block_pa, bed_src.block_sz);
+	}
+	initdbgmsg("%s BERT setup done.\n", __func__);
+
+	return ret;
+
+exit0:
+	initerrmsg("%s BERT setup failure %d\n", __func__, ret);
+
+	return ret;
+}
+
+static const struct platform_device_id ghes_bert_pdev_match[] = {
+	{ .name = DRV_NAME, },
+	{},
+};
+MODULE_DEVICE_TABLE(platform, ghes_bert_pdev_match);
+
+static struct platform_driver ghes_bert_drv __initdata = {
+	.driver = {
+		.name             = DRV_NAME,
+		.of_match_table   = bed_bert_of_match,
+		.acpi_match_table = ACPI_PTR(bed_bert_acpi_match),
+	},
+	.probe    = ghes_bert_probe,
+	.id_table = ghes_bert_pdev_match,
+};
+
+static int __init ghes_bert_init(void)
+{
+	platform_driver_probe(&ghes_bert_drv, ghes_bert_probe);
+	return 0;
+}
+
+module_init(ghes_bert_init);
+
+MODULE_DESCRIPTION("OcteonTX2 GHES BERT Module");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DRV_NAME);
+
diff --git a/drivers/soc/marvell/cn10k-ghes/mrvl-ghes-bert.h b/drivers/soc/marvell/cn10k-ghes/mrvl-ghes-bert.h
new file mode 100644
index 000000000000..410e2084cc7b
--- /dev/null
+++ b/drivers/soc/marvell/cn10k-ghes/mrvl-ghes-bert.h
@@ -0,0 +1,35 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Marvell CN10K Generic Hardware Error Source
+ * Boot Error Data (BED) ACPI BERT & DT
+ *
+ * Copyright (C) 2021 Marvell.
+ */
+
+#ifndef __MRVL_GHES_BERT_H__
+#define __MRVL_GHES_BERT_H__
+
+/*
+ * Boot Error Data Source
+ */
+struct mrvl_bed_source {
+	phys_addr_t          block_pa;
+	u64                  block_sz;
+	void __iomem         *block_va;
+	phys_addr_t          bert_pa;
+	u64                  bert_sz;
+	void                 *bert_va;
+	u32                  error_cnt;
+};
+
+struct bed_bert_mem_entry {
+	union {
+		/* These are identical; both are listed here for clarity */
+		struct acpi_hest_generic_status hest;
+		struct acpi_bert_region         bert;
+	} estatus;
+	struct acpi_hest_generic_data   gen_data;
+	struct cper_sec_mem_err_old     mem_err;
+} __packed;
+
+#endif //__MRVL_GHES_BERT_H__
diff --git a/drivers/soc/marvell/cn10k-ghes/mrvl-sdei-ghes.c b/drivers/soc/marvell/cn10k-ghes/mrvl-sdei-ghes.c
new file mode 100644
index 000000000000..5cc8d8e38ac7
--- /dev/null
+++ b/drivers/soc/marvell/cn10k-ghes/mrvl-sdei-ghes.c
@@ -0,0 +1,819 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Marvell CN10K Generic Hardware Error Source[s] (GHES)
+ * GHES ACPI HEST & DT
+ *
+ * Copyright (C) 2021 Marvell.
+ */
+
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/of_address.h>
+#include <linux/arm_sdei.h>
+#include <linux/uuid.h>
+#include <linux/acpi.h>
+#include <acpi/apei.h>
+#include <linux/pci.h>
+#include <linux/crash_dump.h>
+#include "mrvl-sdei-ghes.h"
+
+#define DRV_NAME       "sdei-ghes"
+
+#define initerrmsg(fmt, ...) pr_err(DRV_NAME ":" fmt, __VA_ARGS__)
+#ifdef CONFIG_OCTEONTX2_SDEI_GHES_DEBUG
+#  define initdbgmsg(fmt, ...) pr_info(DRV_NAME ":" fmt, __VA_ARGS__)
+#  define dbgmsg(dev, ...) dev_info((dev), __VA_ARGS__)
+#else
+#  define initdbgmsg(fmt, ...) (void)(fmt)
+#  define dbgmsg(dev, ...) (void)(dev)
+#endif // CONFIG_OCTEONTX2_SDEI_GHES_DEBUG
+
+#define MRVL_HEST_OEM_ID "MRVL  "
+#define HEST_TBL_OEM_ID	"OTX2    "
+
+
+#ifdef CONFIG_OF
+static const struct of_device_id sdei_ghes_of_match[] = {
+	{ .compatible = "marvell,sdei-ghes", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, sdei_ghes_of_match);
+#endif
+
+#ifdef CONFIG_ACPI
+static const struct acpi_device_id sdei_ghes_acpi_match[] = {
+	{ "GHES0001", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(acpi, sdei_ghes_acpi_match);
+#endif
+
+static const char * const sdei_ghes_mrvl[] = {"mdc", "mcc", "lmc"};
+
+#define PCI_VENDOR_ID_CAVIUM            0x177d
+#define PCI_DEVICE_ID_OCTEONTX2_LMC     0xa022
+#define PCI_DEVICE_ID_OCTEONTX2_MCC     0xa070
+#define PCI_DEVICE_ID_OCTEONTX2_MDC     0xa073
+
+static const struct pci_device_id sdei_ghes_mrvl_pci_tbl[] = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, PCI_DEVICE_ID_OCTEONTX2_LMC) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, PCI_DEVICE_ID_OCTEONTX2_MCC) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, PCI_DEVICE_ID_OCTEONTX2_MDC) },
+	{ 0, },
+};
+
+/* SDEI event notification callback. */
+static int sdei_ghes_callback(u32 event_id, struct pt_regs *regs, void *arg)
+{
+	struct acpi_hest_generic_status *esb;
+	struct acpi_hest_generic_data *esb_data;
+	struct cper_sec_mem_err_old *esb_err;
+	struct mrvl_ghes_err_record *ring_rec;
+	struct mrvl_sdei_ghes_drv *ghes_drv;
+	struct mrvl_ghes_source *gsrc;
+	u32 head, tail;
+	size_t i;
+
+	initdbgmsg("%s event id 0x%x\n", __func__, event_id);
+
+	ghes_drv = arg;
+
+	for (i = 0; i < ghes_drv->source_count; i++) {
+		gsrc = &ghes_drv->source_list[i];
+
+		if (gsrc->esa_va && *gsrc->esa_va != gsrc->esb_pa) {
+			initdbgmsg("%s ACPI ESB address 0x%llx 0x%llx\n",
+					__func__, *gsrc->esa_va, gsrc->esb_pa);
+			*gsrc->esa_va = gsrc->esb_pa;
+		} else
+			initdbgmsg("%s no need patch address\n", __func__);
+
+		initdbgmsg("%s is match event id 0x%x\n", __func__, gsrc->id);
+
+		if (gsrc->id != event_id)
+			continue;
+
+		initdbgmsg("%s matching event id 0x%x\n", __func__, gsrc->id);
+
+		head = gsrc->ring->head;
+		tail = gsrc->ring->tail;
+
+		/*Ensure that head updated*/
+		rmb();
+
+		if (head == tail) {
+			initerrmsg("ghes 0x%x ring is empty, head=%d, size=%d\n",
+					event_id, head, gsrc->ring->size);
+			break;
+		}
+
+		/*
+		 * Error Records Ring an array of records
+		 */
+		ring_rec = &gsrc->ring->records[tail];
+
+		/*
+		 * Error Status Block memory layout:
+		 * [1] acpi_hest_generic_status
+		 * [2] acpi_hest_generic_data
+		 * [3] cper_sec_mem_er_old
+		 */
+		esb = gsrc->esb_va;
+		esb_data = (struct acpi_hest_generic_data *)(esb + 1);
+		esb_err = (struct cper_sec_mem_err_old *)(esb_data + 1);
+
+		initdbgmsg("%s esb=%p, esb_data=%p, esb_err=%p\n", __func__,
+				esb, esb_data, esb_err);
+
+		// Error Status
+		esb->raw_data_length = 0;
+		esb->data_length =
+				sizeof(*esb_data) +
+				sizeof(struct cper_sec_mem_err_old);
+		esb->error_severity = ring_rec->severity;
+
+		// Error Generic Data
+		memset(esb_data, 0, sizeof(*esb_data));
+		esb_data->revision = 0x201; /* ACPI 4.x */
+		if (ring_rec->fru_text[0]) {
+			esb_data->validation_bits = ACPI_HEST_GEN_VALID_FRU_STRING;
+			strncpy(esb_data->fru_text, ring_rec->fru_text,
+				sizeof(esb_data->fru_text));
+		}
+		esb_data->error_severity = esb->error_severity;
+		guid_copy((guid_t *)esb_data->section_type, &CPER_SEC_PLATFORM_MEM);
+		esb_data->error_data_length = sizeof(struct cper_sec_mem_err_old);
+
+		initdbgmsg("%s err_sev=%x,\n", __func__,
+				ring_rec->severity);
+
+		// Error Record
+		memcpy(esb_err, &ring_rec->u.mcc, sizeof(*esb_err));
+
+		/* Ensure that error status (esb) is committed to memory prior to
+		 * setting block_status.
+		 */
+		wmb();
+
+		/*
+		 * This simply needs the entry count to be non-zero.
+		 * Set entry count to one (see ACPI_HEST_ERROR_ENTRY_COUNT).
+		 */
+		esb->block_status = (1 << 4); /* i.e. one entry */
+
+		if (++tail >= gsrc->ring->size)
+			tail = 0;
+		gsrc->ring->tail = tail;
+		break;
+	}
+
+	if (i == ghes_drv->source_count)
+		initerrmsg("%s no source event id match\n", __func__);
+
+	return 0;
+}
+
+
+/*
+ * Enable MSIX at the device level (MSIX_CAPABILITIES Header).
+ *
+ * NOTE: We SHOULD be able to use PCCPVF_XXX_VSEC_SCTL[MSIX_SEC_EN]
+ * to enable our SECURE IRQs, but for errata PCC-34263...
+ */
+static void dev_enable_msix(struct pci_dev *pdev)
+{
+	u16 ctrl;
+
+	if ((pdev->msi_enabled) || (pdev->msix_enabled)) {
+		initerrmsg("MSI(%d) or MSIX(%d) already enabled\n",
+				pdev->msi_enabled, pdev->msix_enabled);
+		return;
+	}
+
+	/* enable MSIX delivery for this device; we handle [secure] MSIX ints */
+	pdev->msix_cap = pci_find_capability(pdev, PCI_CAP_ID_MSIX);
+	if (pdev->msix_cap) {
+		pci_read_config_word(pdev, pdev->msix_cap + PCI_MSIX_FLAGS, &ctrl);
+		ctrl |= PCI_MSIX_FLAGS_ENABLE;
+		pci_write_config_word(pdev, pdev->msix_cap + PCI_MSIX_FLAGS, ctrl);
+
+		initdbgmsg("Set MSI-X Enable for PCI dev %04d:%02d.%d\n",
+			   pdev->bus->number, PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));
+	} else {
+		initerrmsg("PCI dev %04d:%02d.%d missing MSIX capabilities\n",
+			   pdev->bus->number, PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));
+	}
+}
+
+/* Enable MSIX for devices whose [secure] IRQ's we control.
+ * These IRQs have been initialized by ATF.
+ * This is required due to an errata against
+ * PCCPVF_XXX_VSEC_SCTL[MSIX_SEC_EN].
+ */
+static void sdei_ghes_msix_init(void)
+{
+	const struct pci_device_id *pdevid;
+	struct pci_dev *pdev;
+	size_t i;
+
+	initdbgmsg("%s: entry\n", __func__);
+
+	for (i = 0; i < ARRAY_SIZE(sdei_ghes_mrvl_pci_tbl); i++) {
+		pdevid = &sdei_ghes_mrvl_pci_tbl[i];
+		pdev = NULL;
+
+		while ((pdev = pci_get_device(pdevid->vendor, pdevid->device, pdev)))
+			dev_enable_msix(pdev);
+	}
+}
+
+/* Main initialization function for ghes_drv device instance. */
+static int sdei_ghes_driver_init(struct platform_device *pdev)
+{
+	struct mrvl_sdei_ghes_drv *ghes_drv;
+	struct device *dev = &pdev->dev;
+	struct mrvl_ghes_source *gsrc;
+	size_t i;
+	int ret = 0;
+
+	initdbgmsg("%s: entry\n", __func__);
+
+	ghes_drv = platform_get_drvdata(pdev);
+
+	for (i = 0; i < ghes_drv->source_count; i++) {
+		gsrc = &ghes_drv->source_list[i];
+
+		ret = sdei_event_register(gsrc->id, sdei_ghes_callback, ghes_drv);
+		if (ret < 0) {
+			dev_err(dev, "Error %d registering gsrc 0x%x (%s)\n",
+				ret, gsrc->id, gsrc->name);
+			break;
+		}
+
+		ret = sdei_event_enable(gsrc->id);
+		if (ret < 0) {
+			dev_err(dev, "Error %d enabling gsrc 0x%x (%s)\n",
+				ret, gsrc->id, gsrc->name);
+			break;
+		}
+
+		initdbgmsg("Register GHES 0x%x (%s) [%llx, %llx, %llx, %llx]\n",
+				gsrc->id, gsrc->name, (long long)gsrc->esa_pa,
+				(long long)gsrc->esa_va,
+				(long long)gsrc->esb_va, (long long)gsrc->ring);
+	}
+
+	if (i != ghes_drv->source_count)
+		return -ENODEV;
+
+	dev_info(dev, "Registered & enabled %ld GHES\n", ghes_drv->source_count);
+
+	return 0;
+}
+
+/* Main de-initialization function for ghes_drv device instance. */
+static int sdei_ghes_driver_deinit(struct platform_device *pdev)
+{
+	struct mrvl_sdei_ghes_drv *ghes_drv;
+	struct device *dev = &pdev->dev;
+	struct mrvl_ghes_source *gsrc;
+	int ret, i;
+
+	ghes_drv = platform_get_drvdata(pdev);
+
+	for (i = 0; i < ghes_drv->source_count; i++) {
+		gsrc = &ghes_drv->source_list[i];
+
+		ret = sdei_event_disable(gsrc->id);
+		if (ret < 0)
+			dev_err(dev, "Error %d disabling SDEI gsrc 0x%x (%s)\n",
+				ret, gsrc->id, gsrc->name);
+
+		ret = sdei_event_unregister(gsrc->id);
+		if (ret < 0)
+			dev_err(dev, "Error %d unregistering SDEI gsrc 0x%x (%s)\n",
+				ret, gsrc->id, gsrc->name);
+	}
+
+	return 0;
+}
+
+/*
+ * For ACPI, the Error Status address must be present in the
+ * memory map.  If not present, ACPI can generate an exception
+ * when trying to map it (see apei_read/acpi_os_read_memory()).
+ * For this reason, if the Error Status Address is NOT present
+ * we allocate one here (the firmware doesn't actually write
+ * to this block; THIS driver does so, in response to SDEI
+ * notifications).
+ */
+static int sdei_ghes_adjust_error_status_block(struct page **pg,
+		struct mrvl_sdei_ghes_drv *ghes_drv)
+{
+	struct mrvl_ghes_source *gsrc;
+	phys_addr_t pg_pa;
+	void *pg_va;
+	int i;
+
+	initdbgmsg("%s: entry\n", __func__);
+
+	if (!pg)
+		return -EFAULT;
+
+	gsrc = &ghes_drv->source_list[0];
+
+	if (pfn_valid(PHYS_PFN(gsrc->esa_pa)))
+		return 0;
+
+	*pg = alloc_page(GFP_KERNEL);
+	if (!*pg) {
+		pr_err("Unable to allocate error status block\n");
+		return -ENOMEM;
+	}
+
+	pg_pa = PFN_PHYS(page_to_pfn(*pg));
+	pg_va = page_address(*pg);
+
+	initdbgmsg("! Allocated Error Status Address %p (%llx)\n",
+			pg_va, (unsigned long long)pg_pa);
+
+	for (i = 0; i < ghes_drv->source_count; i++) {
+		gsrc = &ghes_drv->source_list[i];
+
+		gsrc->esa_pa  = pg_pa + (gsrc->esa_pa & ~PAGE_MASK);
+		gsrc->esb_pa  = pg_pa + (gsrc->esb_pa & ~PAGE_MASK);
+		gsrc->ring_pa = pg_pa + (gsrc->ring_pa & ~PAGE_MASK);
+	}
+
+	return 0;
+}
+
+static int __init sdei_ghes_of_match_resource(struct platform_device *pdev)
+{
+	struct device_node *of_node;
+	struct device_node *child_node;
+	struct mrvl_sdei_ghes_drv *ghes_drv;
+	struct mrvl_ghes_source *gsrc;
+	struct device *dev;
+	const __be32 *res;
+	u64 size;
+	u64 base;
+	const u32 *id;
+	size_t i = 0;
+
+	initdbgmsg("%s: entry\n", __func__);
+
+	dev = &pdev->dev;
+	ghes_drv = platform_get_drvdata(pdev);
+	of_node = of_find_matching_node(NULL, sdei_ghes_of_match);
+
+	if (!of_node) {
+		dev_err(dev, "ghes no matching node.\n");
+		return -ENODEV;
+	}
+
+	for_each_available_child_of_node(of_node, child_node) {
+		if (i >= ghes_drv->source_count) {
+			dev_err(dev, "ghes resource allocation overflow %ld.\n", i);
+			return -EFAULT;
+		}
+
+		gsrc = &ghes_drv->source_list[i];
+
+		// Name
+		strncpy(gsrc->name, child_node->name, sizeof(gsrc->name) - 1);
+
+		// Error Status Address
+		res = of_get_address(child_node, 0, NULL, NULL);
+		if (!res) {
+			dev_err(dev, "ghes cannot get esa addr %ld.\n", i);
+			return -EINVAL;
+		}
+		base = of_translate_address(child_node, res);
+		if (base == OF_BAD_ADDR) {
+			dev_err(dev, "ghes cannot map esa addr %ld.\n", i);
+			return -EINVAL;
+		}
+		gsrc->esa_pa = (phys_addr_t)base;
+
+		// Error Status Block
+		res = of_get_address(child_node, 1, &size, NULL);
+		if (!res) {
+			dev_err(dev, "ghes cannot get esb addr %ld.\n", i);
+			return -EINVAL;
+		}
+		base = of_translate_address(child_node, res);
+		if (base == OF_BAD_ADDR) {
+			dev_err(dev, "ghes cannot map esb addr %ld.\n", i);
+			return -EINVAL;
+		}
+		gsrc->esb_pa = (phys_addr_t)base;
+		gsrc->esb_sz = (size_t)size;
+
+		// Error Ring
+		res = of_get_address(child_node, 2, &size, NULL);
+		if (!res) {
+			dev_err(dev, "ghes cannot get ring addr %ld.\n", i);
+			return -EINVAL;
+		}
+		base = of_translate_address(child_node, res);
+		if (base == OF_BAD_ADDR) {
+			dev_err(dev, "ghes cannot map ring addr %ld.", i);
+			return -EINVAL;
+		}
+		gsrc->ring_pa = (phys_addr_t)base;
+		gsrc->ring_sz = (size_t)size;
+
+		// Event ID
+		id = of_get_property(child_node, "event-id", NULL);
+		if (!id) {
+			dev_err(dev, "ghes cannot map event id %ld.", i);
+			return -EINVAL;
+		}
+		gsrc->id = be32_to_cpu(*id);
+
+		initdbgmsg("GHES: %s 0x%llx/0x%llx/0x%llx, ID:0x%x)\n", gsrc->name,
+				gsrc->esa_pa, gsrc->esb_pa, gsrc->ring_pa, gsrc->id);
+
+		i++;
+	}
+
+	return 0;
+}
+
+static int __init sdei_ghes_acpi_match_resource(struct platform_device *pdev)
+{
+	struct mrvl_sdei_ghes_drv *ghes_drv;
+	struct mrvl_ghes_source *gsrc;
+	struct resource *res;
+	struct device *dev;
+	size_t i = 0;
+	size_t idx = 0;
+
+	dev = &pdev->dev;
+	ghes_drv = platform_get_drvdata(pdev);
+
+	initdbgmsg("%s: entry\n", __func__);
+
+	for (i = 0; i < ghes_drv->source_count; i++) {
+		gsrc = &ghes_drv->source_list[i];
+
+		strncpy(gsrc->name, sdei_ghes_mrvl[i], strlen(sdei_ghes_mrvl[i]));
+
+		// Error Status Address
+		res = platform_get_resource(pdev, IORESOURCE_MEM, idx);
+		if (!res) {
+			dev_err(dev, "%s ACPI warn get gsrc=%ld idx=%ld\n", __func__, i, idx);
+			return -ENOENT;
+		}
+		initdbgmsg("%s Status Address %s [%llx - %llx, %lx, %lx]\n", __func__,
+				res->name, res->start, res->end, res->flags, res->desc);
+		gsrc->esa_pa = res->start;
+		idx++;
+
+		// Error Status Block Buffer
+		res = platform_get_resource(pdev, IORESOURCE_MEM, idx);
+		if (!res) {
+			dev_err(dev, "%s ACPI warn get gsrc=%ld idx=%ld\n", __func__, i, idx);
+			return -ENOENT;
+		}
+		initdbgmsg("%s Status Block %s [%llx - %llx, %lx, %lx]\n", __func__,
+				res->name, res->start, res->end, res->flags, res->desc);
+		gsrc->esb_pa = res->start;
+		gsrc->esb_sz = resource_size(res);
+		idx++;
+
+		// Error Blocks Ring
+		res = platform_get_resource(pdev, IORESOURCE_MEM, idx);
+		if (!res) {
+			dev_err(dev, "%s ACPI warn get gsrc=%ld idx=%ld\n", __func__, i, idx);
+			return -ENOENT;
+		}
+		initdbgmsg("%s Status Ring %s [%llx - %llx, %lx, %lx]\n", __func__,
+				res->name, res->start, res->end, res->flags, res->desc);
+		gsrc->ring_pa = res->start;
+		gsrc->ring_sz = resource_size(res);
+		idx++;
+
+		// Event ID
+		res = platform_get_resource(pdev, IORESOURCE_MEM, idx);
+		if (!res) {
+			dev_err(dev, "%s ACPI warn get gsrc=%ld idx=%ld\n", __func__, i, idx);
+			return -ENOENT;
+		}
+		initdbgmsg("%s Event ID %s [%llx - %llx, %lx, %lx]\n", __func__,
+				res->name, res->start, res->end, res->flags, res->desc);
+		gsrc->id = res->start;
+		idx++;
+
+		initdbgmsg("GHES: %s 0x%llx/0x%llx/0x%llx, ID:0x%x)\n", gsrc->name,
+				gsrc->esa_pa, gsrc->esb_pa, gsrc->ring_pa, gsrc->id);
+	}
+
+	return 0;
+}
+
+static int  sdei_ghes_map_resource(struct mrvl_sdei_ghes_drv *ghes_drv)
+{
+	struct mrvl_ghes_source *gsrc;
+	size_t i;
+
+	initdbgmsg("%s: entry\n", __func__);
+
+	for (i = 0; i < ghes_drv->source_count; i++) {
+		gsrc = &ghes_drv->source_list[i];
+
+		if (pfn_valid(PHYS_PFN(gsrc->esa_pa)))
+			gsrc->esa_va = phys_to_virt(gsrc->esa_pa);
+
+		if (pfn_valid(PHYS_PFN(gsrc->esb_pa)))
+			gsrc->esb_va = phys_to_virt(gsrc->esb_pa);
+
+		if (pfn_valid(PHYS_PFN(gsrc->ring_pa)))
+			gsrc->ring = phys_to_virt(gsrc->ring_pa);
+
+		initdbgmsg("0x%p/0x%p/0x%p\n", gsrc->esa_va, gsrc->esb_va, gsrc->ring);
+
+		if (gsrc->esa_va && gsrc->esb_va && gsrc->ring)
+			continue;
+
+		if (!gsrc->esa_va)
+			gsrc->esa_va = ioremap(gsrc->esa_pa, sizeof(gsrc->esa_va));
+
+		if (!gsrc->esb_va)
+			gsrc->esb_va = ioremap(gsrc->esb_pa, gsrc->esb_sz);
+
+		if (!gsrc->ring)
+			gsrc->ring = ioremap(gsrc->ring_pa, gsrc->ring_sz);
+
+		initdbgmsg("0x%p/0x%p/0x%p\n", gsrc->esa_va, gsrc->esb_va, gsrc->ring);
+
+		if (!gsrc->esa_va || !gsrc->esb_va || !gsrc->ring)
+			goto err;
+	}
+
+	return 0;
+
+err:
+	initerrmsg("%s Unable to map error block.\n", __func__);
+	while (i >= 0) {
+		gsrc = &ghes_drv->source_list[i];
+		iounmap(gsrc->esa_va);
+		iounmap(gsrc->esb_va);
+		iounmap(gsrc->ring);
+		i--;
+	}
+
+	return -EFAULT;
+}
+
+static void  sdei_ghes_init_source(struct mrvl_sdei_ghes_drv *ghes_drv)
+{
+	struct mrvl_ghes_source *gsrc;
+	size_t i;
+
+	for (i = 0; i < ghes_drv->source_count; i++) {
+		gsrc = &ghes_drv->source_list[i];
+
+		gsrc->esb_va->block_status = 0;
+
+		*gsrc->esa_va = gsrc->esb_pa;
+	}
+}
+
+static void  sdei_ghes_count_source(struct mrvl_sdei_ghes_drv *ghes_drv)
+{
+	size_t count;
+
+	count = ARRAY_SIZE(sdei_ghes_mrvl_pci_tbl) - 1;
+	ghes_drv->source_count = count;
+	initdbgmsg("%s: %ld\n", __func__, count);
+}
+
+static int  sdei_ghes_alloc_source(struct device *dev,
+		struct mrvl_sdei_ghes_drv *ghes_drv)
+{
+	size_t size = 0;
+
+	initdbgmsg("%s()\n", __func__);
+
+	size = ghes_drv->source_count * sizeof(struct mrvl_ghes_source);
+
+	ghes_drv->source_list = devm_kzalloc(dev, size, GFP_KERNEL);
+	if (!ghes_drv->source_list)
+		return -ENOMEM;
+
+	return 0;
+}
+
+static void * __init sdei_ghes_of_alloc_hest(struct device *dev,
+		struct mrvl_sdei_ghes_drv *ghes_drv)
+{
+	struct mrvl_ghes_source *gsrc;
+	unsigned int size;
+	struct acpi_table_hest *hest;
+	struct acpi_table_header *hdr;
+	struct acpi_hest_generic *hest_gen;
+	size_t i;
+	u8 *p;
+	u8 sum = 0;
+
+	initdbgmsg("%s: entry\n", __func__);
+
+	size = sizeof(struct acpi_table_hest) +
+			ghes_drv->source_count * sizeof(struct acpi_hest_generic);
+
+	hest = kzalloc(size, GFP_KERNEL);
+	if (!hest)
+		return NULL;
+
+	hest_gen = (struct acpi_hest_generic *)(hest + 1);
+
+	hdr = &hest->header;
+	strncpy(hdr->signature, ACPI_SIG_HEST, sizeof(hdr->signature));
+	hdr->length = size;
+	hdr->revision = 1;
+	strncpy(hdr->oem_id, MRVL_HEST_OEM_ID, sizeof(hdr->oem_id));
+	strncpy(hdr->oem_table_id, HEST_TBL_OEM_ID, sizeof(hdr->oem_table_id));
+	hdr->oem_revision = 1;
+	strncpy(hdr->asl_compiler_id, MRVL_HEST_OEM_ID, sizeof(hdr->asl_compiler_id));
+	hdr->asl_compiler_revision = 1;
+	p = (u8 *)hdr;
+	while (p < (u8 *)(hdr + 1))
+		sum += *p, p++;
+	hdr->checksum -= sum;
+	hest->error_source_count = ghes_drv->source_count;
+
+	for (i = 0; i < hest->error_source_count; i++, hest_gen++) {
+		gsrc = &ghes_drv->source_list[i];
+
+		hest_gen->header.type = ACPI_HEST_TYPE_GENERIC_ERROR;
+		hest_gen->header.source_id = i;
+		hest_gen->related_source_id = i;
+		hest_gen->reserved = 0;
+		hest_gen->enabled = 1;
+		hest_gen->records_to_preallocate = 1;
+		hest_gen->max_sections_per_record = 1;
+		hest_gen->max_raw_data_length = 0;
+
+		hest_gen->error_status_address.space_id = ACPI_ADR_SPACE_SYSTEM_MEMORY;
+		hest_gen->error_status_address.bit_width = 64;
+		hest_gen->error_status_address.bit_offset = 0;
+		hest_gen->error_status_address.access_width = 4;
+		hest_gen->error_status_address.address = gsrc->esa_pa;
+		hest_gen->notify.type = ACPI_HEST_NOTIFY_POLLED;
+		hest_gen->notify.length = sizeof(struct acpi_hest_notify);
+		hest_gen->notify.config_write_enable = 0;
+		hest_gen->notify.poll_interval = 1000; /* i.e. 1 sec */
+		hest_gen->notify.vector = gsrc->id;
+		hest_gen->notify.error_threshold_value = 1;
+		hest_gen->notify.error_threshold_window = 1;
+		hest_gen->error_block_length =
+				sizeof(struct acpi_hest_generic_status) +
+				sizeof(struct acpi_hest_generic_data) +
+				sizeof(struct cper_sec_mem_err_old);
+	}
+
+	hest_table_set(hest);
+
+	acpi_hest_init();
+	dbgmsg(dev, "%s: registering HEST\n", __func__);
+
+	return hest;
+}
+
+static int __init sdei_ghes_probe(struct platform_device *pdev)
+{
+	struct mrvl_sdei_ghes_drv *ghes_drv = NULL;
+	struct device *dev = &pdev->dev;
+	struct page *pg = NULL;
+	struct acpi_table_hest *hest = NULL;
+	const struct acpi_device_id *acpi_id = NULL;
+	int ret = -ENODEV;
+
+#ifdef CONFIG_CRASH_DUMP
+	if (is_kdump_kernel())
+#else
+	#pragma message "CONFIG_CRASH_DUMP setting is required for this module"
+	if (true)
+#endif
+		return ret;
+
+	initdbgmsg("%s: entry\n", __func__);
+
+	ghes_drv = devm_kzalloc(dev, sizeof(struct mrvl_sdei_ghes_drv), GFP_KERNEL);
+	if (!ghes_drv)
+		return -ENOMEM;
+
+	sdei_ghes_count_source(ghes_drv);
+
+	ret = sdei_ghes_alloc_source(dev, ghes_drv);
+	if (ret)
+		goto exit0;
+
+	platform_set_drvdata(pdev, ghes_drv);
+
+	if (has_acpi_companion(dev)) {
+		dbgmsg(dev, "%s ACPI\n", __func__);
+		acpi_id = acpi_match_device(dev->driver->acpi_match_table, dev);
+		ret = sdei_ghes_acpi_match_resource(pdev);
+	} else {
+		dbgmsg(dev, "%s DeviceTree\n", __func__);
+		ret = sdei_ghes_of_match_resource(pdev);
+	}
+	if (ret)
+		goto exit1;
+
+	ret = sdei_ghes_adjust_error_status_block(&pg, ghes_drv);
+	if (ret) {
+		dev_err(dev, "Unable adjust status block.\n");
+		goto exit1;
+	}
+
+	ret = sdei_ghes_map_resource(ghes_drv);
+	if (ret) {
+		dev_err(dev, "Unable map resource.\n");
+		goto exit2;
+	}
+
+	sdei_ghes_init_source(ghes_drv);
+
+	if (!has_acpi_companion(dev)) {
+		hest = sdei_ghes_of_alloc_hest(dev, ghes_drv);
+		if (!hest) {
+			dev_err(dev, "Unable allocate HEST.\n");
+			goto exit2;
+		}
+	}
+
+	sdei_ghes_msix_init();
+
+	ret = sdei_ghes_driver_init(pdev);
+	if (ret)
+		goto exit3;
+
+	return 0;
+
+exit3:
+	dev_err(dev, "Error initializing SDEI GHES support.\n");
+	sdei_ghes_driver_deinit(pdev);
+	kfree(hest);
+exit2:
+	if (pg)
+		__free_page(pg);
+exit1:
+	devm_kfree(dev, ghes_drv->source_list);
+exit0:
+	devm_kfree(dev, ghes_drv);
+
+	return -ENODEV;
+}
+
+static int sdei_ghes_remove(struct platform_device *pdev)
+{
+	struct mrvl_sdei_ghes_drv *ghes_drv;
+	struct device *dev = &pdev->dev;
+
+	ghes_drv = platform_get_drvdata(pdev);
+
+	dbgmsg(dev, "%s: entry\n", __func__);
+
+	sdei_ghes_driver_deinit(pdev);
+
+	devm_kfree(dev, ghes_drv->source_list);
+
+	devm_kfree(dev, ghes_drv);
+
+	return 0;
+}
+
+static void sdei_ghes_shutdown(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+
+	dbgmsg(dev, "%s: entry\n", __func__);
+}
+
+static const struct platform_device_id sdei_ghes_pdev_match[] = {
+	{ .name = DRV_NAME, },
+	{},
+};
+MODULE_DEVICE_TABLE(platform, sdei_ghes_pdev_match);
+
+static struct platform_driver sdei_ghes_drv_probe = {
+	.driver = {
+		.name             = DRV_NAME,
+		.of_match_table   = sdei_ghes_of_match,
+		.acpi_match_table = ACPI_PTR(sdei_ghes_acpi_match),
+	},
+	.probe    = sdei_ghes_probe,
+	.remove   = sdei_ghes_remove,
+	.shutdown = sdei_ghes_shutdown,
+	.id_table = sdei_ghes_pdev_match,
+};
+module_platform_driver(sdei_ghes_drv_probe);
+
+MODULE_DESCRIPTION("OcteonTX2 SDEI GHES Driver");
diff --git a/drivers/soc/marvell/cn10k-ghes/mrvl-sdei-ghes.h b/drivers/soc/marvell/cn10k-ghes/mrvl-sdei-ghes.h
new file mode 100644
index 000000000000..d31c4eddfd6c
--- /dev/null
+++ b/drivers/soc/marvell/cn10k-ghes/mrvl-sdei-ghes.h
@@ -0,0 +1,82 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Marvell CN10K Generic Hardware Error Source[s] (GHES)
+ * GHES ACPI HEST & DT
+ *
+ * Copyright (C) 2021 Marvell.
+ */
+
+#ifndef __MRVL_SDEI_GHES_H__
+#define __MRVL_SDEI_GHES_H__
+
+#define SDEI_GHES_EVENT_NAME_MAX_CHARS 16
+/*
+ * Describes an error source per ACPI 18.3.2.6 (Generic Hardware Error Source).
+ * This produces GHES-compliant error records from data forwarded by the [ATF]
+ * firmware.
+ * There exists one of these for each error source.
+ *
+ * @name:               event source name mdc/mcc/lmc
+ * @id:                 event id
+ * @esa_pa              physical address of Error Status Address register/iomem
+ * @esa_va:             mapped pointer to Error Status Address point on Error Status Block
+ * @esb_pa:             phys address of Error Status Block follow Error Status Data
+ * @esb_va:             mapped pointer to Error Status Block
+ * @ring_pa:            physical address of Ring of Error Status Blocks
+ * @ring:               mapped pointer to Ring of Error Status Blocks
+ * @ring_sz:            ring buffer size
+ */
+struct mrvl_ghes_source {
+	char                            name[SDEI_GHES_EVENT_NAME_MAX_CHARS];
+	phys_addr_t                     esa_pa;
+	phys_addr_t                     esb_pa;
+	phys_addr_t                     ring_pa;
+	phys_addr_t                     *esa_va;
+	struct acpi_hest_generic_status *esb_va;
+	struct mrvl_ghes_err_ring       *ring;
+	size_t                          ring_sz;
+	size_t                          esb_sz;
+	u32                             id;
+};
+
+/**
+ * struct mrvl_sdei_ghes_drv: driver state
+ *
+ * @of_node:                  associated device tree node
+ * @source_list:              list of [SDEI] producers
+ *                            (1 for each error source)
+ * @source_count:             count of [SDEI] producers
+ *                            (size of @source_list)
+ */
+struct mrvl_sdei_ghes_drv {
+	struct device_node                   *of_node;  //remove TODO:
+	struct mrvl_ghes_source              *source_list;
+	size_t                               source_count;
+};
+
+#define MRVL_GHES_ERR_REC_FRU_TEXT_LEN 32
+/* This is shared with ATF */
+struct mrvl_ghes_err_record {
+	union {
+		struct cper_sec_mem_err_old  mcc;
+		struct cper_sec_mem_err_old  mdc;
+		struct cper_sec_mem_err_old  lmc;
+		struct cper_arm_err_info     ap; /* application processor */
+	} u;
+	uint32_t severity; /* CPER_SEV_xxx */
+	char fru_text[MRVL_GHES_ERR_REC_FRU_TEXT_LEN];
+};
+
+/* This is shared with ATF */
+struct mrvl_ghes_err_ring {
+	/* The head resides in DRAM & can be updated by ATF (i.e. firmware).
+	 * See Documentation/process/volatile-considered-harmful.rst, line 92.
+	 */
+	uint32_t volatile head;
+	uint32_t          tail;
+	uint32_t          size;       /* ring size */
+	/* ring of records */
+	struct mrvl_ghes_err_record records[1] __aligned(8);
+};
+
+#endif // __MRVL_SDEI_GHES_H__
diff --git a/include/acpi/apei.h b/include/acpi/apei.h
index 680f80960c3d..2a64def09bbf 100644
--- a/include/acpi/apei.h
+++ b/include/acpi/apei.h
@@ -33,8 +33,12 @@ extern bool ghes_disable;
 
 #ifdef CONFIG_ACPI_APEI
 void __init acpi_hest_init(void);
+void __init hest_table_set(struct acpi_table_hest *table);
+void __init bert_table_set(struct acpi_table_bert *table);
 #else
 static inline void acpi_hest_init(void) { return; }
+static inline void hest_table_set(struct acpi_table_hest *table) { return; }
+static inline void bert_table_set(struct acpi_table_bert *table) { return; }
 #endif
 
 typedef int (*apei_hest_func_t)(struct acpi_hest_header *hest_hdr, void *data);
-- 
2.31.1

