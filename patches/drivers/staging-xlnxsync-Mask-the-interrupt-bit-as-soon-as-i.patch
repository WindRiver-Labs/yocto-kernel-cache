From 8fbac6743d9da0db5b9834f517409b1bc5062752 Mon Sep 17 00:00:00 2001
From: Devarsh Thakkar <devarsh.thakkar@xilinx.com>
Date: Tue, 6 Oct 2020 09:38:06 -0700
Subject: [PATCH 1706/1852] staging: xlnxsync: Mask the interrupt bit as soon
 as interrupt occurs

commit d3aea98f47db2c647db06c33a5425a16bd33d5a0 from
https://github.com/Xilinx/linux-xlnx.git

As per the new SyncIp RTL, for any of the error interrupts the interrupt
pin stays asserted until the error get resolved. But it depends upon
the application on how and when this error get resolved. So to avoid
continouous interrupts in case of this error scenario, we mask that
particular interrupt as soon as it occur and wake up the poll thread
with the error information as per existing logic.

After receiving the poll event, application can get the channel status
and error context, and it can then unmask the particular interrupt
when it has recovered from the error.

Also in case if error is frame specific and not recovered while
processing the frame, then also application should unmask it after
that frame processing is done so that it can get error status for
new frame.

Signed-off-by: Devarsh Thakkar <devarsh.thakkar@xilinx.com>
Reviewed-by: Hyun Kwon <hyun.kwon@xilinx.com>
State: pending
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 drivers/staging/xlnxsync/xlnxsync.c | 30 +++++++++++++++++++++++------
 1 file changed, 24 insertions(+), 6 deletions(-)

diff --git a/drivers/staging/xlnxsync/xlnxsync.c b/drivers/staging/xlnxsync/xlnxsync.c
index fa56350e2b66..992c314ff867 100644
--- a/drivers/staging/xlnxsync/xlnxsync.c
+++ b/drivers/staging/xlnxsync/xlnxsync.c
@@ -1029,6 +1029,7 @@ static irqreturn_t xlnxsync_irq_handler(int irq, void *data)
 {
 	struct xlnxsync_device *xlnxsync = (struct xlnxsync_device *)data;
 	u32 val;
+	u32 intr_mask_val = 0;
 	struct xlnxsync_channel *chan;
 
 	/*
@@ -1041,18 +1042,30 @@ static irqreturn_t xlnxsync_irq_handler(int irq, void *data)
 
 		val = xlnxsync_read(xlnxsync, chan->id, XLNXSYNC_ISR_REG);
 
-		if (val & XLNXSYNC_ISR_PROD_SYNC_FAIL_MASK)
+		if (val & XLNXSYNC_ISR_PROD_SYNC_FAIL_MASK) {
 			chan->prod_sync_err = true;
-		if (val & XLNXSYNC_ISR_PROD_WDG_ERR_MASK)
+			intr_mask_val |= XLNXSYNC_IMR_PROD_SYNC_FAIL_MASK;
+		}
+		if (val & XLNXSYNC_ISR_PROD_WDG_ERR_MASK) {
 			chan->prod_wdg_err = true;
-		if (val & XLNXSYNC_ISR_LDIFF)
+			intr_mask_val |= XLNXSYNC_IMR_PROD_WDG_ERR_MASK;
+		}
+		if (val & XLNXSYNC_ISR_LDIFF) {
 			chan->ldiff_err = true;
-		if (val & XLNXSYNC_ISR_CDIFF)
+			intr_mask_val |= XLNXSYNC_IMR_LDIFF;
+		}
+		if (val & XLNXSYNC_ISR_CDIFF) {
 			chan->cdiff_err = true;
-		if (val & XLNXSYNC_ISR_CONS_SYNC_FAIL_MASK)
+			intr_mask_val |= XLNXSYNC_IMR_CDIFF;
+		}
+		if (val & XLNXSYNC_ISR_CONS_SYNC_FAIL_MASK) {
 			chan->cons_sync_err = true;
-		if (val & XLNXSYNC_ISR_CONS_WDG_ERR_MASK)
+			intr_mask_val |= XLNXSYNC_IMR_CONS_SYNC_FAIL_MASK;
+		}
+		if (val & XLNXSYNC_ISR_CONS_WDG_ERR_MASK) {
 			chan->cons_wdg_err = true;
+			intr_mask_val |= XLNXSYNC_IMR_CONS_WDG_ERR_MASK;
+		}
 		if (chan->prod_sync_err || chan->prod_wdg_err ||
 		    chan->ldiff_err || chan->cdiff_err ||
 		    chan->cons_sync_err || chan->cons_wdg_err)
@@ -1094,6 +1107,11 @@ static irqreturn_t xlnxsync_irq_handler(int irq, void *data)
 			}
 		}
 
+		/* Mask corresponding interrupts */
+		if (intr_mask_val)
+			xlnxsync_set(xlnxsync, chan->id, XLNXSYNC_IMR_REG,
+				     intr_mask_val);
+
 		if (chan->err_event) {
 			dev_dbg(xlnxsync->dev, "%s : error occurred at channel->id = %d\n",
 				__func__, chan->id);
-- 
2.31.1

