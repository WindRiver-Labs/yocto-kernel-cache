From fdf898d99728c5d9257534a9dd2be85d280a1113 Mon Sep 17 00:00:00 2001
From: Sai Krishna Potthuri <lakshmi.sai.krishna.potthuri@xilinx.com>
Date: Tue, 25 Feb 2020 20:21:34 +0530
Subject: [PATCH 1247/1851] mtd: cadence-quadspi: Added support for master DLL
 mode

commit ef05290561bc4e47dbed512c02d3fef2a6a37d2d from
https://github.com/Xilinx/linux-xlnx.git

This patch adds support for master DLL mode and updates the
tuning algorithm required for both DLL bypass mode and master
DLL mode.

Signed-off-by: Sai Krishna Potthuri <lakshmi.sai.krishna.potthuri@xilinx.com>
State: pending
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 drivers/mtd/spi-nor/cadence-quadspi.c | 171 ++++++++++++++++++++------
 1 file changed, 135 insertions(+), 36 deletions(-)

diff --git a/drivers/mtd/spi-nor/cadence-quadspi.c b/drivers/mtd/spi-nor/cadence-quadspi.c
index a574f7bfec7d..ea47f7772441 100644
--- a/drivers/mtd/spi-nor/cadence-quadspi.c
+++ b/drivers/mtd/spi-nor/cadence-quadspi.c
@@ -102,6 +102,7 @@ struct cqspi_st {
 	bool			extra_dummy;
 	u8			access_mode;
 	bool			unalined_byte_cnt;
+	u8			dll_mode;
 	int (*indirect_read_dma)(struct spi_nor *nor, u_char *rxbuf,
 				 loff_t from_addr, size_t n_rx);
 	int (*flash_reset)(struct cqspi_st *cqspi, u8 reset_type);
@@ -215,6 +216,7 @@ struct cqspi_driver_platdata {
 
 #define CQSPI_REG_IRQSTATUS			0x40
 #define CQSPI_REG_IRQMASK			0x44
+#define CQSPI_REG_ECO				0x48
 
 #define CQSPI_REG_INDIRECTRD			0x60
 #define CQSPI_REG_INDIRECTRD_START_MASK		BIT(0)
@@ -262,6 +264,12 @@ struct cqspi_driver_platdata {
 #define CQSPI_REG_PHY_CONFIG			0xB4
 #define CQSPI_REG_PHY_CONFIG_RESYNC_FLD_MASK	0x80000000
 #define CQSPI_REG_PHY_CONFIG_RESET_FLD_MASK	0x40000000
+#define CQSPI_REG_PHY_CONFIG_TX_DLL_DLY_LSB	16
+
+#define CQSPI_REG_PHY_MASTER_CTRL		0xB8
+#define CQSPI_REG_DLL_LOWER			0xBC
+#define CQSPI_REG_DLL_LOWER_LPBK_LOCK_MASK	0x8000
+#define CQSPI_REG_DLL_LOWER_DLL_LOCK_MASK	0x1
 
 #define CQSPI_REG_DMA_SRC_ADDR			0x1000
 #define CQSPI_REG_DMA_DST_ADDR			0x1800
@@ -310,6 +318,15 @@ struct cqspi_driver_platdata {
 
 #define RESET_OSPI		0xc10402e
 #define DEV_OSPI		0x1822402a
+
+#define SILICON_VER_MASK	0xFF
+#define SILICON_VER_1		0x10
+#define CQSPI_DLL_MODE_MASTER	0
+#define CQSPI_DLL_MODE_BYPASS	1
+#define TAP_GRAN_SEL_MIN_FREQ	120000000
+#define CQSPI_TX_TAP_MASTER	0x19
+#define CQSPI_MAX_DLL_TAPS	128
+
 static int cqspi_wait_for_bit(void __iomem *reg, const u32 mask, bool clr)
 {
 	u32 val;
@@ -1475,30 +1492,82 @@ static int cqspi_setdlldelay(struct spi_nor *nor)
 	u8 windowsize;
 	u8 dummy_incr;
 	u8 dummy_flag = 0;
+	u8 count;
+	u8 opcode = CQSPI_READ_ID;
 
 	max_tap = ((TERA_MACRO / cqspi->master_ref_clk_hz) / 160);
+	if (cqspi->dll_mode == CQSPI_DLL_MODE_MASTER) {
+		/* Drive DLL reset bit to low */
+		writel(0, cqspi->iobase + CQSPI_REG_PHY_CONFIG);
+
+		/* Set initial delay value */
+		writel(0x4, cqspi->iobase + CQSPI_REG_PHY_MASTER_CTRL);
+
+		/* Set DLL reset bit */
+		writel(CQSPI_REG_PHY_CONFIG_RESET_FLD_MASK,
+		       cqspi->iobase + CQSPI_REG_PHY_CONFIG);
+
+		/* Check for loopback lock */
+		ret = cqspi_wait_for_bit(cqspi->iobase + CQSPI_REG_DLL_LOWER,
+					 CQSPI_REG_DLL_LOWER_LPBK_LOCK_MASK, 0);
+		if (ret) {
+			dev_err(nor->dev,
+				"Loopback lock bit error (%i)\n", ret);
+			return ret;
+		}
+
+		/* Re-synchronize slave DLLs */
+		writel(CQSPI_REG_PHY_CONFIG_RESET_FLD_MASK,
+		       cqspi->iobase + CQSPI_REG_PHY_CONFIG);
+		writel(CQSPI_REG_PHY_CONFIG_RESET_FLD_MASK |
+		       CQSPI_REG_PHY_CONFIG_RESYNC_FLD_MASK,
+		       cqspi->iobase + CQSPI_REG_PHY_CONFIG);
+
+		txtap = CQSPI_TX_TAP_MASTER <<
+			CQSPI_REG_PHY_CONFIG_TX_DLL_DLY_LSB;
+		max_tap = CQSPI_MAX_DLL_TAPS;
+	}
+
+	cqspi->extra_dummy = false;
 	for (dummy_incr = 0; dummy_incr <= 1; dummy_incr++) {
 		if (dummy_incr)
 			cqspi->extra_dummy = true;
 		for (i = 0; i <= max_tap; i++) {
-			writel((txtap | i), cqspi->iobase +
-			       CQSPI_REG_PHY_CONFIG);
+			writel((txtap | i |
+			       CQSPI_REG_PHY_CONFIG_RESET_FLD_MASK),
+			       cqspi->iobase + CQSPI_REG_PHY_CONFIG);
 			writel((CQSPI_REG_PHY_CONFIG_RESYNC_FLD_MASK | txtap |
-			       i), cqspi->iobase + CQSPI_REG_PHY_CONFIG);
-			ret = nor->read_reg(nor, CQSPI_READ_ID, id,
-					    CQSPI_READ_ID_LEN);
-			if (ret < 0) {
-				dev_err(nor->dev,
-					"error %d reading JEDEC ID\n", ret);
-				return ret;
+			       i | CQSPI_REG_PHY_CONFIG_RESET_FLD_MASK),
+			       cqspi->iobase + CQSPI_REG_PHY_CONFIG);
+			if (cqspi->dll_mode == CQSPI_DLL_MODE_MASTER) {
+				ret = cqspi_wait_for_bit(cqspi->iobase +
+							 CQSPI_REG_DLL_LOWER,
+					CQSPI_REG_DLL_LOWER_DLL_LOCK_MASK, 0);
+				if (ret)
+					return ret;
 			}
-			id_matched = true;
-			for (j = 0; j < CQSPI_READ_ID_LEN; j++) {
-				if (nor->device_id[j] != id[j]) {
-					id_matched = false;
-					break;
+			count = 0;
+			do {
+				count += 1;
+				ret = cqspi_set_protocol(nor, 0);
+				if (!ret)
+					ret = cqspi_command_read(nor, &opcode,
+						1, id, CQSPI_READ_ID_LEN);
+				if (ret < 0) {
+					dev_err(nor->dev,
+						"error %d reading JEDEC ID\n",
+						ret);
+					return ret;
 				}
-			}
+				id_matched = true;
+				for (j = 0; j < CQSPI_READ_ID_LEN; j++) {
+					if (nor->device_id[j] != id[j]) {
+						id_matched = false;
+						break;
+					}
+				}
+			} while (id_matched && (count <= 10));
+
 			if (id_matched) {
 				if (!rxtapfound) {
 					min_rxtap = i;
@@ -1517,6 +1586,7 @@ static int cqspi_setdlldelay(struct spi_nor *nor)
 						avg_rxtap = (max_rxtap +
 								min_rxtap) / 2;
 					}
+					i = max_tap;
 					rxtapfound = false;
 				}
 			}
@@ -1532,9 +1602,17 @@ static int cqspi_setdlldelay(struct spi_nor *nor)
 	if (max_windowsize < 3)
 		return -EINVAL;
 
-	writel((txtap | avg_rxtap), cqspi->iobase + CQSPI_REG_PHY_CONFIG);
-	writel((CQSPI_REG_PHY_CONFIG_RESYNC_FLD_MASK | txtap | avg_rxtap),
+	writel((txtap | avg_rxtap | CQSPI_REG_PHY_CONFIG_RESET_FLD_MASK),
 	       cqspi->iobase + CQSPI_REG_PHY_CONFIG);
+	writel((CQSPI_REG_PHY_CONFIG_RESYNC_FLD_MASK | txtap | avg_rxtap |
+	       CQSPI_REG_PHY_CONFIG_RESET_FLD_MASK),
+	       cqspi->iobase + CQSPI_REG_PHY_CONFIG);
+	if (cqspi->dll_mode == CQSPI_DLL_MODE_MASTER) {
+		ret = cqspi_wait_for_bit(cqspi->iobase + CQSPI_REG_DLL_LOWER,
+					 CQSPI_REG_DLL_LOWER_DLL_LOCK_MASK, 0);
+		if (ret)
+			return ret;
+	}
 
 	return 0;
 }
@@ -1700,32 +1778,39 @@ static int cqspi_versal_indirect_read_dma(struct spi_nor *nor, u_char *rxbuf,
 		cqspi_wait_idle(cqspi);
 		reg = readl(cqspi->iobase + CQSPI_REG_PHY_CONFIG);
 
-		/* Issue controller reset */
-		cqspi->eemi_ops->reset_assert(RESET_OSPI,
-					      PM_RESET_ACTION_ASSERT);
+		if (cqspi->dll_mode != CQSPI_DLL_MODE_MASTER) {
+			/* Issue controller reset */
+			cqspi->eemi_ops->reset_assert(RESET_OSPI,
+						      PM_RESET_ACTION_ASSERT);
+		}
 		cqspi->eemi_ops->ioctl(DEV_OSPI, IOCTL_OSPI_MUX_SELECT,
 				       PM_OSPI_MUX_SEL_DMA, 0, NULL);
 		cqspi->access_mode = CQSPI_DMA_MODE;
-		cqspi->eemi_ops->reset_assert(RESET_OSPI,
-					      PM_RESET_ACTION_RELEASE);
+		if (cqspi->dll_mode != CQSPI_DLL_MODE_MASTER) {
+			cqspi->eemi_ops->reset_assert(RESET_OSPI,
+						      PM_RESET_ACTION_RELEASE);
+		}
+		cqspi_wait_idle(cqspi);
+		if (cqspi->dll_mode != CQSPI_DLL_MODE_MASTER) {
+			cqspi_controller_init(cqspi);
+			cqspi->current_cs = -1;
+			cqspi->sclk = 0;
 
-		cqspi_controller_init(cqspi);
-		cqspi->current_cs = -1;
-		cqspi->sclk = 0;
+			ret = cqspi_set_protocol(nor, 1);
+			if (ret)
+				return ret;
 
-		ret = cqspi_set_protocol(nor, 1);
-		if (ret)
-			return ret;
+			if (cqspi->edge_mode == CQSPI_EDGE_MODE_DDR) {
+				cqspi_setup_ddrmode(nor);
+				writel(CQSPI_REG_PHY_CONFIG_RESYNC_FLD_MASK |
+				       reg, cqspi->iobase +
+				       CQSPI_REG_PHY_CONFIG);
+			}
 
-		if (cqspi->edge_mode == CQSPI_EDGE_MODE_DDR) {
-			cqspi_setup_ddrmode(nor);
-			writel(CQSPI_REG_PHY_CONFIG_RESYNC_FLD_MASK | reg,
-			       cqspi->iobase + CQSPI_REG_PHY_CONFIG);
+			ret = cqspi_read_setup(nor);
+			if (ret)
+				return ret;
 		}
-
-		ret = cqspi_read_setup(nor);
-		if (ret)
-			return ret;
 	}
 
 	reg = readl(cqspi->iobase + CQSPI_REG_CONFIG);
@@ -1939,6 +2024,8 @@ static int cqspi_probe(struct platform_device *pdev)
 	const struct cqspi_driver_platdata *ddata;
 	int ret;
 	int irq;
+	u32 idcode;
+	u32 version;
 
 	cqspi = devm_kzalloc(dev, sizeof(*cqspi), GFP_KERNEL);
 	if (!cqspi)
@@ -2042,6 +2129,18 @@ static int cqspi_probe(struct platform_device *pdev)
 				cqspi_versal_indirect_read_dma;
 		cqspi->flash_reset = cqspi_versal_flash_reset;
 		cqspi->access_mode = CQSPI_DMA_MODE;
+		cqspi->dll_mode = CQSPI_DLL_MODE_BYPASS;
+
+		ret = cqspi->eemi_ops->get_chipid(&idcode, &version);
+		if (ret < 0) {
+			dev_err(dev, "Cannot get chipid is %d\n", ret);
+			goto probe_clk_failed;
+		}
+		if ((version & SILICON_VER_MASK) != SILICON_VER_1) {
+			cqspi->dll_mode = CQSPI_DLL_MODE_MASTER;
+			if (cqspi->master_ref_clk_hz >= TAP_GRAN_SEL_MIN_FREQ)
+				writel(0x1, cqspi->iobase + CQSPI_REG_ECO);
+		}
 	}
 
 	ret = devm_request_irq(dev, irq, cqspi_irq_handler, 0,
-- 
2.31.1

