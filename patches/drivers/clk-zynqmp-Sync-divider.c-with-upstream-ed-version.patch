From cdd535ce1234db8e1bc06d0fbf01b5debc620c99 Mon Sep 17 00:00:00 2001
From: Tejas Patel <tejas.patel@xilinx.com>
Date: Thu, 20 Feb 2020 04:39:31 -0800
Subject: [PATCH 1239/1852] clk: zynqmp: Sync divider.c with upstream'ed
 version

commit d08f955d3d042dde436511e3885fdba3b8e1e6ac from
https://github.com/Xilinx/linux-xlnx.git

This patch sync zynqmp/divider.c with upstream'ed version.
This patch includes below changes as per upstream comments.
- Add a helper function for retrieving the max divisor
- Use u16 for max divisor since, max divisor value would be 0xFFFF
- Use proper function name for zynqmp_compute_divider()

Signed-off-by: Tejas Patel <tejas.patel@xilinx.com>
Link: https://lkml.kernel.org/r/1575527759-26452-6-git-send-email-rajan.vaja@xilinx.com
State: upstream (e942171bbb762977afaa1eb24a312c3bd56386a5)
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 drivers/clk/zynqmp/divider.c | 67 ++++++++++++++++++++++--------------
 1 file changed, 41 insertions(+), 26 deletions(-)

diff --git a/drivers/clk/zynqmp/divider.c b/drivers/clk/zynqmp/divider.c
index 3fe857f8db5d..d22b6abc5529 100644
--- a/drivers/clk/zynqmp/divider.c
+++ b/drivers/clk/zynqmp/divider.c
@@ -2,7 +2,7 @@
 /*
  * Zynq UltraScale+ MPSoC Divider support
  *
- *  Copyright (C) 2016-2019 Xilinx
+ *  Copyright (C) 2016-2020 Xilinx
  *
  * Adjustable divider clock implementation
  */
@@ -42,7 +42,7 @@ struct zynqmp_clk_divider {
 	bool is_frac;
 	u32 clk_id;
 	u32 div_type;
-	u32 max_div;
+	u16 max_div;
 };
 
 static inline int zynqmp_divider_get_val(unsigned long parent_rate,
@@ -53,7 +53,7 @@ static inline int zynqmp_divider_get_val(unsigned long parent_rate,
 
 	if (flags & CLK_DIVIDER_POWER_OF_TWO) {
 		up = DIV_ROUND_UP_ULL((u64)parent_rate, rate);
-		down = parent_rate / rate;
+		down = DIV_ROUND_DOWN_ULL((u64)parent_rate, rate);
 
 		up = __roundup_pow_of_two(up);
 		down = __rounddown_pow_of_two(down);
@@ -110,17 +110,16 @@ static unsigned long zynqmp_clk_divider_recalc_rate(struct clk_hw *hw,
 	return DIV_ROUND_UP_ULL(parent_rate, value);
 }
 
-static void zynqmp_compute_divider(struct clk_hw *hw,
-				   unsigned long rate,
-				   unsigned long parent_rate,
-				   u32 max_div,
-				   int *bestdiv)
+static void zynqmp_get_divider2_val(struct clk_hw *hw,
+				    unsigned long rate,
+				    unsigned long parent_rate,
+				    struct zynqmp_clk_divider *divider,
+				    int *bestdiv)
 {
 	int div1;
 	int div2;
 	long error = LONG_MAX;
 	struct clk_hw *parent_hw = clk_hw_get_parent(hw);
-	struct zynqmp_clk_divider *divider = to_zynqmp_clk_divider(hw);
 	struct zynqmp_clk_divider *pdivider = to_zynqmp_clk_divider(parent_hw);
 
 	if (!pdivider)
@@ -128,7 +127,7 @@ static void zynqmp_compute_divider(struct clk_hw *hw,
 
 	*bestdiv = 1;
 	for (div1 = 1; div1 <= pdivider->max_div;) {
-		for (div2 = 1; div2 <= max_div;) {
+		for (div2 = 1; div2 <= divider->max_div;) {
 			long new_error = ((parent_rate / div1) / div2) - rate;
 
 			if (abs(new_error) < abs(error)) {
@@ -194,8 +193,7 @@ static long zynqmp_clk_divider_round_rate(struct clk_hw *hw,
 	 */
 	if (div_type == TYPE_DIV2 &&
 	    (clk_hw_get_flags(hw) & CLK_SET_RATE_PARENT)) {
-		zynqmp_compute_divider(hw, rate, *prate,
-				       divider->max_div, &bestdiv);
+		zynqmp_get_divider2_val(hw, rate, *prate, divider, &bestdiv);
 	}
 
 	if ((clk_hw_get_flags(hw) & CLK_SET_RATE_PARENT) && divider->is_frac)
@@ -253,6 +251,35 @@ static const struct clk_ops zynqmp_clk_divider_ops = {
 	.set_rate = zynqmp_clk_divider_set_rate,
 };
 
+/**
+ * zynqmp_clk_get_max_divisor() - Get maximum supported divisor from firmware.
+ * @clk_id:		Id of clock
+ * @type:		Divider type
+ *
+ * Return: Maximum divisor of a clock if query data is successful
+ *	   U16_MAX in case of query data is not success
+ */
+u32 zynqmp_clk_get_max_divisor(u32 clk_id, u32 type)
+{
+	const struct zynqmp_eemi_ops *eemi_ops = zynqmp_pm_get_eemi_ops();
+	struct zynqmp_pm_query_data qdata = {0};
+	u32 ret_payload[PAYLOAD_ARG_CNT];
+	int ret;
+
+	qdata.qid = PM_QID_CLOCK_GET_MAX_DIVISOR;
+	qdata.arg1 = clk_id;
+	qdata.arg2 = type;
+	ret = eemi_ops->query_data(qdata, ret_payload);
+	/*
+	 * To maintain backward compatibility return maximum possible value
+	 * (0xFFFF) if query for max divisor is not successful.
+	 */
+	if (ret)
+		return U16_MAX;
+
+	return ret_payload[1];
+}
+
 /**
  * zynqmp_clk_register_divider() - Register a divider clock
  * @name:		Name of this clock
@@ -273,9 +300,6 @@ struct clk_hw *zynqmp_clk_register_divider(const char *name,
 	struct clk_hw *hw;
 	struct clk_init_data init;
 	int ret;
-	const struct zynqmp_eemi_ops *eemi_ops = zynqmp_pm_get_eemi_ops();
-	struct zynqmp_pm_query_data qdata = {0};
-	u32 ret_payload[PAYLOAD_ARG_CNT];
 
 	/* allocate the divider */
 	div = kzalloc(sizeof(*div), GFP_KERNEL);
@@ -299,18 +323,9 @@ struct clk_hw *zynqmp_clk_register_divider(const char *name,
 
 	/*
 	 * To achieve best possible rate, maximum limit of divider is required
-	 * while computation. Get maximum supported divisor from firmware. To
-	 * maintain backward compatibility assign maximum possible value(0xFFFF)
-	 * if query for max divisor is not successful.
+	 * while computation.
 	 */
-	qdata.qid = PM_QID_CLOCK_GET_MAX_DIVISOR;
-	qdata.arg1 = clk_id;
-	qdata.arg2 = nodes->type;
-	ret = eemi_ops->query_data(qdata, ret_payload);
-	if (ret)
-		div->max_div = 0XFFFF;
-	else
-		div->max_div = ret_payload[1];
+	div->max_div = zynqmp_clk_get_max_divisor(clk_id, nodes->type);
 
 	hw = &div->hw;
 	ret = clk_hw_register(NULL, hw);
-- 
2.31.1

