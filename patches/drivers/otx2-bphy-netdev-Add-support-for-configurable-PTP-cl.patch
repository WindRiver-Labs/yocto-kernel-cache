From 8f054a123dc7c0ed4c7fd766a171df58baa3dc2e Mon Sep 17 00:00:00 2001
From: Naveen Mamindlapalli <naveenm@marvell.com>
Date: Fri, 10 Jul 2020 16:06:39 +0530
Subject: [PATCH 592/767] otx2-bphy-netdev: Add support for configurable PTP
 clock rate

commit a35d79185361b3078860eabb99446a2b165269c7 from
git@git.assembla.com:cavium/WindRiver.linux.git

This patch adds support for configuring the PTP clock rate via
ioctl that is used by PTP timestamp algorithm. The default
PTP clock rate used is 0.95GHz.

Change-Id: I5a5fa7e52b208070a116a730e5d192a5c5afdbf1
Signed-off-by: Naveen Mamindlapalli <naveenm@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/31818
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../marvell/octeontx2/bphy/otx2_bphy.h        |  3 ++-
 .../marvell/octeontx2/bphy/otx2_bphy_main.c   | 16 ++++++++++++-
 .../marvell/octeontx2/bphy/otx2_rfoe.c        |  9 +++++--
 .../marvell/octeontx2/bphy/otx2_rfoe.h        | 24 +++++++++++++++++--
 4 files changed, 46 insertions(+), 6 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_bphy.h b/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_bphy.h
index 1ad0182f45d9..6143e2e3d75c 100644
--- a/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_bphy.h
+++ b/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_bphy.h
@@ -42,7 +42,8 @@ extern void __iomem *cpri_reg_base;
 #define OTX2_RFOE_IOCTL_ODP_DEINIT      _IO(OTX2_RFOE_IOCTL_BASE, 0x02)
 #define OTX2_RFOE_IOCTL_RX_IND_CFG	_IOWR(OTX2_RFOE_IOCTL_BASE, 0x03, \
 					      struct otx2_rfoe_rx_ind_cfg)
-#define OTX2_RFOE_IOCTL_PTP_OFFSET	_IO(OTX2_RFOE_IOCTL_BASE, 0x04)
+#define OTX2_RFOE_IOCTL_PTP_OFFSET	_IOW(OTX2_RFOE_IOCTL_BASE, 0x04, \
+					    struct ptp_clk_cfg)
 #define OTX2_RFOE_IOCTL_SEC_BCN_OFFSET	_IOW(OTX2_RFOE_IOCTL_BASE, 0x05, \
 					     struct bcn_sec_offset_cfg)
 #define OTX2_RFOE_IOCTL_MODE_CPRI	_IOW(OTX2_RFOE_IOCTL_BASE, 0x06, \
diff --git a/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_bphy_main.c b/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_bphy_main.c
index 7a32295efc75..9846a11c234c 100644
--- a/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_bphy_main.c
+++ b/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_bphy_main.c
@@ -225,8 +225,9 @@ static long otx2_bphy_cdev_ioctl(struct file *filp, unsigned int cmd,
 	{
 		u64 bcn_n1, bcn_n2, bcn_n1_ns, bcn_n2_ps, ptp0_ns, regval;
 		struct otx2_rfoe_drv_ctx *drv_ctx = NULL;
-		struct ptp_bcn_off_cfg *ptp_cfg;
 		struct otx2_rfoe_ndev_priv *priv;
+		struct ptp_bcn_off_cfg *ptp_cfg;
+		struct ptp_clk_cfg clk_cfg;
 		struct net_device *netdev;
 		struct ptp_bcn_ref ref;
 		int idx;
@@ -236,6 +237,17 @@ static long otx2_bphy_cdev_ioctl(struct file *filp, unsigned int cmd,
 			ret = -EBUSY;
 			goto out;
 		}
+		if (copy_from_user(&clk_cfg, (void __user *)arg,
+				   sizeof(struct ptp_clk_cfg))) {
+			dev_err(cdev->dev, "copy from user fault\n");
+			ret = -EFAULT;
+			goto out;
+		}
+		if (!(clk_cfg.clk_freq_ghz && clk_cfg.clk_freq_div)) {
+			dev_err(cdev->dev, "Invalid ptp clk parameters\n");
+			ret = -EINVAL;
+			goto out;
+		}
 		for (idx = 0; idx < RFOE_MAX_INTF; idx++) {
 			drv_ctx = &rfoe_drv_ctx[idx];
 			if (drv_ctx->valid)
@@ -249,6 +261,8 @@ static long otx2_bphy_cdev_ioctl(struct file *filp, unsigned int cmd,
 		netdev = drv_ctx->netdev;
 		priv = netdev_priv(netdev);
 		ptp_cfg = priv->ptp_cfg;
+		ptp_cfg->clk_cfg.clk_freq_ghz = clk_cfg.clk_freq_ghz;
+		ptp_cfg->clk_cfg.clk_freq_div = clk_cfg.clk_freq_div;
 		/* capture ptp and bcn timestamp using BCN_CAPTURE_CFG */
 		writeq((CAPT_EN | CAPT_TRIG_SW),
 		       priv->bcn_reg_base + BCN_CAPTURE_CFG);
diff --git a/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_rfoe.c b/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_rfoe.c
index 763dfa15e90e..9d4aba4b254c 100644
--- a/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_rfoe.c
+++ b/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_rfoe.c
@@ -154,6 +154,7 @@ static void otx2_rfoe_calc_ptp_ts(struct otx2_rfoe_ndev_priv *priv,
 {
 	u64 ptp_diff_nsec, ptp_diff_psec;
 	struct ptp_bcn_off_cfg *ptp_cfg;
+	struct ptp_clk_cfg *clk_cfg;
 	struct ptp_bcn_ref *ref;
 	unsigned long flags;
 	u64 timestamp = *ts;
@@ -161,6 +162,7 @@ static void otx2_rfoe_calc_ptp_ts(struct otx2_rfoe_ndev_priv *priv,
 	ptp_cfg = priv->ptp_cfg;
 	if (!ptp_cfg->use_ptp_alg)
 		return;
+	clk_cfg = &ptp_cfg->clk_cfg;
 
 	spin_lock_irqsave(&ptp_cfg->lock, flags);
 
@@ -171,7 +173,7 @@ static void otx2_rfoe_calc_ptp_ts(struct otx2_rfoe_ndev_priv *priv,
 
 	/* calculate ptp timestamp diff in pico sec */
 	ptp_diff_psec = ((timestamp - ref->ptp0_ns) * PICO_SEC_PER_NSEC *
-			 PTP_CLK_FREQ_MULT_GHZ) / PTP_CLK_FREQ_DIV_GHZ;
+			 clk_cfg->clk_freq_div) / clk_cfg->clk_freq_ghz;
 	ptp_diff_nsec = (ptp_diff_psec + ref->bcn0_n2_ps + 500) /
 			PICO_SEC_PER_NSEC;
 	timestamp = ref->bcn0_n1_ns - priv->sec_bcn_offset + ptp_diff_nsec;
@@ -185,6 +187,7 @@ static void otx2_rfoe_ptp_offset_timer(struct timer_list *t)
 {
 	struct ptp_bcn_off_cfg *ptp_cfg = from_timer(ptp_cfg, t, ptp_timer);
 	u64 mio_ptp_ts, ptp_ts_diff, ptp_diff_nsec, ptp_diff_psec;
+	struct ptp_clk_cfg *clk_cfg = &ptp_cfg->clk_cfg;
 	unsigned long flags;
 
 	spin_lock_irqsave(&ptp_cfg->lock, flags);
@@ -195,7 +198,7 @@ static void otx2_rfoe_ptp_offset_timer(struct timer_list *t)
 	mio_ptp_ts = readq(ptp_reg_base + MIO_PTP_CLOCK_HI);
 	ptp_ts_diff = mio_ptp_ts - ptp_cfg->new_ref.ptp0_ns;
 	ptp_diff_psec = (ptp_ts_diff * PICO_SEC_PER_NSEC *
-			 PTP_CLK_FREQ_MULT_GHZ) / PTP_CLK_FREQ_DIV_GHZ;
+			 clk_cfg->clk_freq_div) / clk_cfg->clk_freq_ghz;
 	ptp_diff_nsec = ptp_diff_psec / PICO_SEC_PER_NSEC;
 	ptp_cfg->new_ref.ptp0_ns += ptp_ts_diff;
 	ptp_cfg->new_ref.bcn0_n1_ns += ptp_diff_nsec;
@@ -1183,6 +1186,8 @@ int otx2_rfoe_parse_and_init_intf(struct otx2_bphy_cdev_priv *cdev,
 	if (!ptp_cfg)
 		return -ENOMEM;
 	timer_setup(&ptp_cfg->ptp_timer, otx2_rfoe_ptp_offset_timer, 0);
+	ptp_cfg->clk_cfg.clk_freq_ghz = PTP_CLK_FREQ_GHZ;
+	ptp_cfg->clk_cfg.clk_freq_div = PTP_CLK_FREQ_DIV;
 	spin_lock_init(&ptp_cfg->lock);
 
 	for (i = 0; i < MAX_RFOE_INTF; i++) {
diff --git a/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_rfoe.h b/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_rfoe.h
index ffffc3ca3395..b2d075452dec 100644
--- a/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_rfoe.h
+++ b/drivers/net/ethernet/marvell/octeontx2/bphy/otx2_rfoe.h
@@ -79,8 +79,8 @@
  * value at anytime. Added timer to adjust the PTP and BCN base values
  * periodically to fix the overflow issue.
  */
-#define PTP_CLK_FREQ_DIV_GHZ		1536	/* freq_div = Clock MHz x 10 */
-#define PTP_CLK_FREQ_MULT_GHZ		10000	/* freq(Ghz) = freq_div/10000 */
+#define PTP_CLK_FREQ_GHZ		95	/* Clock freq GHz dividend */
+#define PTP_CLK_FREQ_DIV		100	/* Clock freq GHz divisor */
 #define PTP_OFF_RESAMPLE_THRESH		1800	/* resample period in seconds */
 #define PICO_SEC_PER_NSEC		1000	/* pico seconds per nano sec */
 #define UTC_GPS_EPOCH_DIFF		315964819UL /* UTC - GPS epoch secs */
@@ -200,6 +200,25 @@ struct otx2_rfoe_stats {
 	spinlock_t lock;
 };
 
+/* PTP clk freq in GHz represented as integer numbers.
+ * This information is passed to netdev by the ODP BPHY
+ * application via ioctl. The values are used in PTP
+ * timestamp calculation algorithm.
+ *
+ * For 950MHz PTP clock =0.95GHz, the values are:
+ *     clk_freq_ghz = 95
+ *     clk_freq_div = 100
+ *
+ * For 153.6MHz PTP clock =0.1536GHz, the values are:
+ *     clk_freq_ghz = 1536
+ *     clk_freq_div = 10000
+ *
+ */
+struct ptp_clk_cfg {
+	int clk_freq_ghz;	/* ptp clk freq */
+	int clk_freq_div;	/* ptp clk divisor */
+};
+
 struct bcn_sec_offset_cfg {
 	u8				rfoe_num;
 	u8				lmac_id;
@@ -215,6 +234,7 @@ struct ptp_bcn_ref {
 struct ptp_bcn_off_cfg {
 	struct ptp_bcn_ref		old_ref;
 	struct ptp_bcn_ref		new_ref;
+	struct ptp_clk_cfg		clk_cfg;
 	struct timer_list		ptp_timer;
 	int				use_ptp_alg;
 	/* protection lock for updating ref */
-- 
2.31.1

