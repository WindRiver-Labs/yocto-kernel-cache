From c2e54408e01e6501aff5fabb886d9ff0061b7f58 Mon Sep 17 00:00:00 2001
From: Hariprasad Kelam <hkelam@marvell.com>
Date: Fri, 5 Mar 2021 10:14:13 +0530
Subject: [PATCH 06/17] net: thunderx: Modify BGX driver probe

commit 15d97aa96b20cd9a46a3ff9f5729481440cf9888 from
git@git.assembla.com:cavium/WindRiver.linux.git

current design is that, BGX driver probe fails in case
of failure in finding of phy device associated with
any one of lmac. Which results in all lmacs connected that
BGX wont be available to NIC driver.

This patch changes the probe of BGX device such that only
lmacs failed in discovering phy device will be released and
other lmacs will be available to NIC driver usage.

With this changes
        - Lmacs which are not associated with phy device wont be
          enabled and bgx lmac count is updated accordingly

Change-Id: I43851391cbdc8dceeb140dd5e042f6a6e3227ec1
Signed-off-by: Hariprasad Kelam <hkelam@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/47229
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Integrated-by: Abhishek Paliwal <paliwal.abhishek@windriver.com>
---
 drivers/net/ethernet/cavium/thunder/nic_main.c    |  5 ++-
 drivers/net/ethernet/cavium/thunder/thunder_bgx.c | 49 +++++++++++++----------
 drivers/net/ethernet/cavium/thunder/thunder_bgx.h |  1 +
 3 files changed, 32 insertions(+), 23 deletions(-)

diff --git a/drivers/net/ethernet/cavium/thunder/nic_main.c b/drivers/net/ethernet/cavium/thunder/nic_main.c
index 9361f96..bc8c84b 100644
--- a/drivers/net/ethernet/cavium/thunder/nic_main.c
+++ b/drivers/net/ethernet/cavium/thunder/nic_main.c
@@ -318,6 +318,7 @@ static void nic_set_lmac_vf_mapping(struct nicpf *nic)
 {
 	unsigned bgx_map = bgx_get_map(nic->node);
 	int bgx, next_bgx_lmac = 0;
+	unsigned long lmac_bmap;
 	int lmac, lmac_cnt = 0;
 	u64 lmac_credit;
 
@@ -327,7 +328,9 @@ static void nic_set_lmac_vf_mapping(struct nicpf *nic)
 		if (!(bgx_map & (1 << bgx)))
 			continue;
 		lmac_cnt = bgx_get_lmac_count(nic->node, bgx);
-		for (lmac = 0; lmac < lmac_cnt; lmac++)
+		lmac_bmap = bgx_get_lmac_bmap(nic->node, bgx);
+
+		for_each_set_bit(lmac, &lmac_bmap, MAX_LMAC_PER_BGX)
 			nic->vf_lmac_map[next_bgx_lmac++] =
 						NIC_SET_VF_LMAC_MAP(bgx, lmac);
 		nic->num_vf_en += lmac_cnt;
diff --git a/drivers/net/ethernet/cavium/thunder/thunder_bgx.c b/drivers/net/ethernet/cavium/thunder/thunder_bgx.c
index 7c691b0..8cc7673 100644
--- a/drivers/net/ethernet/cavium/thunder/thunder_bgx.c
+++ b/drivers/net/ethernet/cavium/thunder/thunder_bgx.c
@@ -74,6 +74,7 @@ struct bgx {
 	struct pci_dev		*pdev;
 	bool                    is_dlm;
 	bool                    is_rgx;
+	unsigned long		lmac_bmap; /* bitmap of enabled lmacs */
 };
 
 static struct bgx *bgx_vnic[MAX_BGX_THUNDER];
@@ -196,12 +197,24 @@ int bgx_get_lmac_count(int node, int bgx_idx)
 
 	bgx = get_bgx(node, bgx_idx);
 	if (bgx)
-		return bgx->lmac_count;
+		return hweight64(bgx->lmac_bmap);
 
 	return 0;
 }
 EXPORT_SYMBOL(bgx_get_lmac_count);
 
+unsigned long bgx_get_lmac_bmap(int node, int bgx_idx)
+{
+	struct bgx *bgx;
+
+	bgx = get_bgx(node, bgx_idx);
+	if (bgx)
+		return bgx->lmac_bmap;
+
+	return 0;
+}
+EXPORT_SYMBOL(bgx_get_lmac_bmap);
+
 /* Returns the current link status of LMAC */
 void bgx_get_lmac_link_state(int node, int bgx_idx, int lmacid, void *status)
 {
@@ -1195,7 +1208,7 @@ static void bgx_init_hw(struct bgx *bgx)
 		dev_err(&bgx->pdev->dev, "BGX%d BIST failed\n", bgx->bgx_id);
 
 	/* Set lmac type and lane2serdes mapping */
-	for (i = 0; i < bgx->lmac_count; i++) {
+	for_each_set_bit(i, &bgx->lmac_bmap, MAX_LMAC_PER_BGX) {
 		lmac = &bgx->lmac[i];
 		bgx_reg_write(bgx, i, BGX_CMRX_CFG,
 			      (lmac->lmac_type << 8) | lmac->lane_to_sds);
@@ -1207,7 +1220,7 @@ static void bgx_init_hw(struct bgx *bgx)
 	bgx_reg_write(bgx, 0, BGX_CMR_RX_LMACS, bgx->lmac_count);
 
 	/* Set the backpressure AND mask */
-	for (i = 0; i < bgx->lmac_count; i++)
+	for_each_set_bit(i, &bgx->lmac_bmap, MAX_LMAC_PER_BGX)
 		bgx_reg_modify(bgx, 0, BGX_CMR_CHAN_MSK_AND,
 			       ((1ULL << MAX_BGX_CHANS_PER_LMAC) - 1) <<
 			       (i * MAX_BGX_CHANS_PER_LMAC));
@@ -1470,6 +1483,7 @@ static int bgx_init_of_phy(struct bgx *bgx)
 {
 	struct fwnode_handle *fwn;
 	struct device_node *node = NULL;
+	bool phy_reset;
 	u8 lmac = 0;
 
 	device_for_each_child_node(&bgx->pdev->dev, fwn) {
@@ -1477,6 +1491,7 @@ static int bgx_init_of_phy(struct bgx *bgx)
 		struct device_node *phy_np;
 		const char *mac;
 
+		phy_reset = false;
 		/* Should always be an OF node.  But if it is not, we
 		 * cannot handle it, so exit the loop.
 		 */
@@ -1501,10 +1516,12 @@ static int bgx_init_of_phy(struct bgx *bgx)
 			/* Wait until the phy drivers are available */
 			pd = of_phy_find_device(phy_np);
 			if (!pd)
-				goto defer;
+				phy_reset = true;
 			bgx->lmac[lmac].phydev = pd;
 		}
 
+		if (!phy_reset)
+			set_bit(bgx->lmac[lmac].lmacid, &bgx->lmac_bmap);
 		lmac++;
 		if (lmac == bgx->max_lmac) {
 			of_node_put(node);
@@ -1512,20 +1529,6 @@ static int bgx_init_of_phy(struct bgx *bgx)
 		}
 	}
 	return 0;
-
-defer:
-	/* We are bailing out, try not to leak device reference counts
-	 * for phy devices we may have already found.
-	 */
-	while (lmac) {
-		if (bgx->lmac[lmac].phydev) {
-			put_device(&bgx->lmac[lmac].phydev->mdio.dev);
-			bgx->lmac[lmac].phydev = NULL;
-		}
-		lmac--;
-	}
-	of_node_put(node);
-	return -EPROBE_DEFER;
 }
 
 #else
@@ -1650,8 +1653,10 @@ static int bgx_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	bgx_get_qlm_mode(bgx);
 
-	err = bgx_init_phy(bgx);
-	if (err)
+	bgx_init_phy(bgx);
+
+	/* Fail case where no lmac is enabled */
+	if (!bgx->lmac_bmap)
 		goto err_enable;
 
 	bgx_init_hw(bgx);
@@ -1659,7 +1664,7 @@ static int bgx_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	bgx_register_intr(pdev);
 
 	/* Enable all LMACs */
-	for (lmac = 0; lmac < bgx->lmac_count; lmac++) {
+	for_each_set_bit(lmac, &bgx->lmac_bmap, MAX_LMAC_PER_BGX) {
 		err = bgx_lmac_enable(bgx, lmac);
 		if (err) {
 			dev_err(dev, "BGX%d failed to enable lmac%d\n",
@@ -1689,7 +1694,7 @@ static void bgx_remove(struct pci_dev *pdev)
 	u8 lmac;
 
 	/* Disable all LMACs */
-	for (lmac = 0; lmac < bgx->lmac_count; lmac++)
+	for_each_set_bit(lmac, &bgx->lmac_bmap, MAX_LMAC_PER_BGX)
 		bgx_lmac_disable(bgx, lmac);
 
 	pci_free_irq(pdev, GMPX_GMI_TX_INT, bgx);
diff --git a/drivers/net/ethernet/cavium/thunder/thunder_bgx.h b/drivers/net/ethernet/cavium/thunder/thunder_bgx.h
index cdea493..38732c5 100644
--- a/drivers/net/ethernet/cavium/thunder/thunder_bgx.h
+++ b/drivers/net/ethernet/cavium/thunder/thunder_bgx.h
@@ -240,6 +240,7 @@ void bgx_lmac_internal_loopback(int node, int bgx_idx,
 u64 bgx_get_tx_stats(int node, int bgx_idx, int lmac, int idx);
 #define BGX_RX_STATS_COUNT 11
 #define BGX_TX_STATS_COUNT 18
+unsigned long bgx_get_lmac_bmap(int node, int bgx);
 
 struct bgx_stats {
 	u64 rx_stats[BGX_RX_STATS_COUNT];
-- 
1.9.1

