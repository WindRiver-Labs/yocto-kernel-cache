From e8e8749ce08bdd0f06cc09f4455a40cb209e97a7 Mon Sep 17 00:00:00 2001
From: Sujeet Baranwal <sbaranwal@marvell.com>
Date: Tue, 12 Nov 2019 13:39:21 -0800
Subject: [PATCH 435/767] clk: control device clock frequency using sysfs

commit 13a12b271796962d75aba8b017a6c002820d3f56 from
git@git.assembla.com:cavium/WindRiver.linux.git

Scmi provides means in its clock protocol to get or set
device clocks controlled by SCP. sysfs nodes are exposed
for user to make amends to desired frequencies.

Caution is that these commands shall be executed by root
process only else poses security hazards as changing clock
frequencies are not recommended in user space.

Bug: IPBUSW-2243

Change-Id: I395d2494d9cad6a1401102b17b8113c46de08b9a
Signed-off-by: Sujeet Baranwal <sbaranwal@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/18610
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/clk/clk-scmi.c            |  10 +++
 drivers/clk/clk.c                 | 115 +++++++++++++++++++++++++++++-
 drivers/firmware/arm_scmi/clock.c |  17 +++++
 include/linux/clk-provider.h      |   1 +
 include/linux/scmi_protocol.h     |   2 +
 5 files changed, 144 insertions(+), 1 deletion(-)

diff --git a/drivers/clk/clk-scmi.c b/drivers/clk/clk-scmi.c
index a2287c770d5c..5ae834b638d5 100644
--- a/drivers/clk/clk-scmi.c
+++ b/drivers/clk/clk-scmi.c
@@ -86,6 +86,15 @@ static void scmi_clk_disable(struct clk_hw *hw)
 	clk->handle->clk_ops->disable(clk->handle, clk->id);
 }
 
+static int scmi_get_available_rates(struct clk_hw *hw, u64 *rate)
+{
+	struct scmi_clk *clk = to_scmi_clk(hw);
+
+	return clk->handle->clk_ops->available_rates(clk->handle,
+							 clk->id, rate);
+}
+
+
 static const struct clk_ops scmi_clk_ops = {
 	.recalc_rate = scmi_clk_recalc_rate,
 	.round_rate = scmi_clk_round_rate,
@@ -98,6 +107,7 @@ static const struct clk_ops scmi_clk_ops = {
 	 */
 	.prepare = scmi_clk_enable,
 	.unprepare = scmi_clk_disable,
+	.get_available_rates = scmi_get_available_rates,
 };
 
 static int scmi_clk_ops_init(struct device *dev, struct scmi_clk *sclk)
diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 77d1d3894f8d..c9da09d6b06b 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -21,6 +21,7 @@
 #include <linux/pm_runtime.h>
 #include <linux/sched.h>
 #include <linux/clkdev.h>
+#include <linux/uaccess.h>
 
 #include "clk.h"
 
@@ -3079,6 +3080,116 @@ static int clk_duty_cycle_show(struct seq_file *s, void *data)
 }
 DEFINE_SHOW_ATTRIBUTE(clk_duty_cycle);
 
+static ssize_t clock_freq_get(struct file *file, char __user *user_buf,
+				size_t count, loff_t *ppos)
+{
+	char buf[32];
+	unsigned int len;
+	struct clk_core *core = file->f_inode->i_private;
+	u32 clk_cur_frq = clk_core_get_rate(core);
+
+	len = snprintf(buf, sizeof(buf), "%u\n", clk_cur_frq);
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static ssize_t clock_freq_set(struct file *file,
+		const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	char buf[32];
+	ssize_t len;
+	struct clk_core *core = file->f_inode->i_private;
+	u32 new_clk_frq;
+	/* No parent */
+	unsigned long parent_rate = 0;
+
+	len = min(count, sizeof(buf) - 1);
+	if (copy_from_user(buf, user_buf, len))
+		return -EFAULT;
+
+	/* Make the buffer a valid string that we can not overrun */
+	buf[len] = '\0';
+	if (kstrtouint(buf, 0, &new_clk_frq))
+		return -EINVAL;
+
+	core->ops->set_rate(core->hw, new_clk_frq, parent_rate);
+	return count;
+}
+
+static int clock_freq_dummy(struct seq_file *s, void *unused)
+{
+	return 0;
+}
+
+static int clock_freq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, clock_freq_dummy,
+		inode->i_private);
+}
+
+/* File operations for reading or setting various device clock frequencies */
+static const struct file_operations clock_freq_fops = {
+	.open           = clock_freq_open,
+	.read           = clock_freq_get,
+	.write		= clock_freq_set,
+	.llseek         = seq_lseek,
+	.release        = single_release,
+};
+
+int clk_core_get_available_rate(struct clk_core *core, u64 *rates)
+{
+	if (core->ops->get_available_rates)
+		return core->ops->get_available_rates(core->hw, rates);
+	return 0;
+}
+
+static ssize_t available_clock_freq_get(struct file *file,
+		char __user *user_buf, size_t count, loff_t *ppos)
+{
+	char buf[256];
+	u64 rates_buf[16];
+	u32 index = 0, i;
+	int no_of_freqs;
+
+	struct clk_core *core = file->f_inode->i_private;
+
+	no_of_freqs = clk_core_get_available_rate(core, rates_buf);
+
+	/* No freq found */
+	if (no_of_freqs <= 0 || no_of_freqs > 16) {
+		pr_err("Fails to get available frequencies\n");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < no_of_freqs; i++)
+		index += snprintf(&buf[index],
+				sizeof(buf), "%llu ", rates_buf[i]);
+
+	index += snprintf(&buf[index], sizeof(buf), "\n");
+	return simple_read_from_buffer(user_buf, count, ppos, buf, index);
+}
+
+static int available_clock_freq_dummy(struct seq_file *s, void *unused)
+{
+	return 0;
+}
+
+static int available_clock_freq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, available_clock_freq_dummy,
+		inode->i_private);
+}
+
+/*
+ * File operations for reading all valid possible frequencies the device
+ * clock could support.
+ */
+static const struct file_operations available_clock_freq_fops = {
+	.open           = available_clock_freq_open,
+	.read           = available_clock_freq_get,
+	.llseek         = seq_lseek,
+	.release        = single_release,
+};
+
 static void clk_debug_create_one(struct clk_core *core, struct dentry *pdentry)
 {
 	struct dentry *root;
@@ -3089,7 +3200,9 @@ static void clk_debug_create_one(struct clk_core *core, struct dentry *pdentry)
 	root = debugfs_create_dir(core->name, pdentry);
 	core->dentry = root;
 
-	debugfs_create_ulong("clk_rate", 0444, root, &core->rate);
+	debugfs_create_file("clk_rate", 0644, root, core, &clock_freq_fops);
+	debugfs_create_file("clk_available_freq", 0444, root, core,
+						&available_clock_freq_fops);
 	debugfs_create_ulong("clk_accuracy", 0444, root, &core->accuracy);
 	debugfs_create_u32("clk_phase", 0444, root, &core->phase);
 	debugfs_create_file("clk_flags", 0444, root, core, &clk_flags_fops);
diff --git a/drivers/firmware/arm_scmi/clock.c b/drivers/firmware/arm_scmi/clock.c
index 30fc04e28431..d5404539694c 100644
--- a/drivers/firmware/arm_scmi/clock.c
+++ b/drivers/firmware/arm_scmi/clock.c
@@ -190,6 +190,22 @@ scmi_clock_describe_rates_get(const struct scmi_handle *handle, u32 clk_id,
 	return ret;
 }
 
+static int scmi_clock_available_rates(const struct scmi_handle *handle,
+					u32 clk_id, u64 *rates)
+{
+	struct clock_info *cinfo = handle->clk_priv;
+	struct scmi_clock_info *clk = cinfo->clk + clk_id;
+
+	if (!rates)
+		return -EINVAL;
+
+	/* Copy all the rates into user specified buffer */
+	memcpy(rates, &clk->list.rates[0],
+			clk->list.num_rates * sizeof(rates));
+
+	return clk->list.num_rates;
+}
+
 static int
 scmi_clock_rate_get(const struct scmi_handle *handle, u32 clk_id, u64 *value)
 {
@@ -297,6 +313,7 @@ static struct scmi_clk_ops clk_ops = {
 	.rate_set = scmi_clock_rate_set,
 	.enable = scmi_clock_enable,
 	.disable = scmi_clock_disable,
+	.available_rates = scmi_clock_available_rates,
 };
 
 static int scmi_clock_protocol_init(struct scmi_handle *handle)
diff --git a/include/linux/clk-provider.h b/include/linux/clk-provider.h
index bb6118f79784..513e9a37c1a9 100644
--- a/include/linux/clk-provider.h
+++ b/include/linux/clk-provider.h
@@ -247,6 +247,7 @@ struct clk_ops {
 					  struct clk_duty *duty);
 	void		(*init)(struct clk_hw *hw);
 	void		(*debug_init)(struct clk_hw *hw, struct dentry *dentry);
+	int		(*get_available_rates)(struct clk_hw *hw, u64 *rate);
 };
 
 /**
diff --git a/include/linux/scmi_protocol.h b/include/linux/scmi_protocol.h
index 3105055c00a7..623549b4cdef 100644
--- a/include/linux/scmi_protocol.h
+++ b/include/linux/scmi_protocol.h
@@ -74,6 +74,8 @@ struct scmi_clk_ops {
 			u32 config, u64 rate);
 	int (*enable)(const struct scmi_handle *handle, u32 clk_id);
 	int (*disable)(const struct scmi_handle *handle, u32 clk_id);
+	int (*available_rates)(const struct scmi_handle *handle, u32 clk_id,
+			       u64 *rates);
 };
 
 /**
-- 
2.31.1

