From e303753b238243edfb5d98f84da70dbc41bacd5b Mon Sep 17 00:00:00 2001
From: Kiran Kumar K <kirankumark@marvell.com>
Date: Thu, 20 Jun 2019 14:35:58 +0530
Subject: [PATCH 0207/1921] octeontx2-af: align rss flow alg with npc profile

With new npc_profile we can extract the UDP data and other tunnel data
independently.
This patch cleans up the RSS flow alg config to align
with this.
So, values of these following mbox key types will change.

NIX_FLOW_KEY_TYPE_INNR_IPV4     BIT(12)
NIX_FLOW_KEY_TYPE_INNR_IPV6     BIT(13)
NIX_FLOW_KEY_TYPE_INNR_TCP      BIT(14)
NIX_FLOW_KEY_TYPE_INNR_UDP      BIT(15)
NIX_FLOW_KEY_TYPE_INNR_SCTP     BIT(16)
NIX_FLOW_KEY_TYPE_INNR_ETH_DMAC BIT(17)

Change-Id: I94de3aaf0389304b92590f24fe57e0121850f986
Signed-off-by: Kiran Kumar K <kirankumark@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/11320
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Tested-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 .../net/ethernet/marvell/octeontx2/af/mbox.h  | 15 ++--
 .../ethernet/marvell/octeontx2/af/rvu_nix.c   | 78 +++++--------------
 2 files changed, 26 insertions(+), 67 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/af/mbox.h b/drivers/net/ethernet/marvell/octeontx2/af/mbox.h
index 1eca3396b484..a3ce571582dd 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/mbox.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/mbox.h
@@ -818,15 +818,12 @@ struct nix_rss_flowkey_cfg {
 #define NIX_FLOW_KEY_TYPE_ETH_DMAC BIT(9)
 #define NIX_FLOW_KEY_TYPE_IPV6_EXT BIT(10)
 #define NIX_FLOW_KEY_TYPE_GTPU       BIT(11)
-#define NIX_FLOW_KEY_TYPE_UDP_VXLAN  BIT(12)
-#define NIX_FLOW_KEY_TYPE_UDP_GENEVE BIT(13)
-#define NIX_FLOW_KEY_TYPE_UDP_GTPU   BIT(14)
-#define NIX_FLOW_KEY_TYPE_INNR_IPV4     BIT(15)
-#define NIX_FLOW_KEY_TYPE_INNR_IPV6     BIT(16)
-#define NIX_FLOW_KEY_TYPE_INNR_TCP      BIT(17)
-#define NIX_FLOW_KEY_TYPE_INNR_UDP      BIT(18)
-#define NIX_FLOW_KEY_TYPE_INNR_SCTP     BIT(19)
-#define NIX_FLOW_KEY_TYPE_INNR_ETH_DMAC BIT(20)
+#define NIX_FLOW_KEY_TYPE_INNR_IPV4     BIT(12)
+#define NIX_FLOW_KEY_TYPE_INNR_IPV6     BIT(13)
+#define NIX_FLOW_KEY_TYPE_INNR_TCP      BIT(14)
+#define NIX_FLOW_KEY_TYPE_INNR_UDP      BIT(15)
+#define NIX_FLOW_KEY_TYPE_INNR_SCTP     BIT(16)
+#define NIX_FLOW_KEY_TYPE_INNR_ETH_DMAC BIT(17)
 	u32	flowkey_cfg; /* Flowkey types selected */
 	u8	group;       /* RSS context or group */
 };
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c
index 353694a0ab2d..bf2dc8cd3c68 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c
@@ -2534,7 +2534,6 @@ static int set_flowkey_fields(struct nix_rx_flowkey_alg *alg, u32 flow_cfg)
 	struct nix_rx_flowkey_alg *field;
 	struct nix_rx_flowkey_alg tmp;
 	u32 key_type, valid_key;
-	u8 udp_tu_data;
 
 	if (!alg)
 		return -EINVAL;
@@ -2563,7 +2562,6 @@ static int set_flowkey_fields(struct nix_rx_flowkey_alg *alg, u32 flow_cfg)
 
 	keyoff_marker = 0; max_key_off = 0; group_member = 0;
 	nr_field = 0; key_off = 0; field_marker = 1;
-	udp_tu_data = 0;
 	field = &tmp; max_bit_pos = fls(flow_cfg);
 	for (idx = 0;
 	     idx < max_bit_pos && nr_field < FIELDS_PER_ALG &&
@@ -2664,32 +2662,39 @@ static int set_flowkey_fields(struct nix_rx_flowkey_alg *alg, u32 flow_cfg)
 			break;
 		case NIX_FLOW_KEY_TYPE_NVGRE:
 			field->lid = NPC_LID_LD;
+			field->hdr_offset = 4; /* VSID offset */
 			field->bytesm1 = 2;
+			field->ltype_match = NPC_LT_LD_GRE;
 			field->ltype_mask = 0xF;
-			keyoff_marker = false;
-			if (valid_key) {
-				field->hdr_offset = 4; /* VSID offset */
-				field->ltype_match = NPC_LT_LD_GRE;
-			}
 			break;
 		case NIX_FLOW_KEY_TYPE_VXLAN:
 		case NIX_FLOW_KEY_TYPE_GENEVE:
 			field->lid = NPC_LID_LE;
 			field->bytesm1 = 2;
+			field->hdr_offset = 4;
 			field->ltype_mask = 0xF;
+			field_marker = false;
 			keyoff_marker = false;
+
 			if (key_type == NIX_FLOW_KEY_TYPE_VXLAN && valid_key) {
-				field->hdr_offset = 4;
-				field->ltype_match = NPC_LT_LE_VXLAN;
+				field->ltype_match |= NPC_LT_LE_VXLAN;
+				group_member = true;
 			}
 
 			if (key_type == NIX_FLOW_KEY_TYPE_GENEVE && valid_key) {
-				field->hdr_offset = 4;
-				field->ltype_match = NPC_LT_LE_GENEVE;
+				field->ltype_match |= NPC_LT_LE_GENEVE;
+				group_member = true;
 			}
 
-			if (key_type == NIX_FLOW_KEY_TYPE_GENEVE)
-				keyoff_marker = true;
+			if (key_type == NIX_FLOW_KEY_TYPE_GENEVE) {
+				if (group_member) {
+					field->ltype_mask = ~field->ltype_match;
+					field_marker = true;
+					keyoff_marker = true;
+					valid_key = true;
+					group_member = false;
+				}
+			}
 			break;
 		case NIX_FLOW_KEY_TYPE_ETH_DMAC:
 		case NIX_FLOW_KEY_TYPE_INNR_ETH_DMAC:
@@ -2712,54 +2717,11 @@ static int set_flowkey_fields(struct nix_rx_flowkey_alg *alg, u32 flow_cfg)
 			break;
 		case NIX_FLOW_KEY_TYPE_GTPU:
 			field->lid = NPC_LID_LE;
-			field->hdr_offset = 0; /* UDP data */
-			field->bytesm1 = 3; /* 4 bytes VNI*/
+			field->hdr_offset = 4;
+			field->bytesm1 = 3; /* 4 bytes TID*/
 			field->ltype_match = NPC_LT_LE_GTPU;
 			field->ltype_mask = 0xF;
 			break;
-		case NIX_FLOW_KEY_TYPE_UDP_VXLAN:
-		case NIX_FLOW_KEY_TYPE_UDP_GENEVE:
-			field->lid = NPC_LID_LE;
-			field->hdr_offset = 0; /* UDP data */
-			field->bytesm1 = 3; /* 4 bytes SPORT +  DPORT*/
-			field->ltype_mask = 0xF;
-			field_marker = false;
-			keyoff_marker = false;
-			BUILD_BUG_ON(NPC_LT_LE_VXLAN != 1);
-			BUILD_BUG_ON(NPC_LT_LE_GENEVE != 2);
-			/* Only VXLAN enabled */
-			if (key_type == NIX_FLOW_KEY_TYPE_UDP_VXLAN &&
-			    valid_key) {
-				field->ltype_match |= NPC_LT_LE_VXLAN;
-				udp_tu_data |= (1 << 0);
-			}
-
-			/* Only GENEVE enabled */
-			if (key_type == NIX_FLOW_KEY_TYPE_UDP_GENEVE &&
-			    valid_key) {
-				field->ltype_match |= NPC_LT_LE_GENEVE;
-				udp_tu_data |= (1 << 1);
-			}
-
-			if (key_type == NIX_FLOW_KEY_TYPE_UDP_GENEVE) {
-				valid_key = true;
-				field_marker = true;
-				keyoff_marker = true;
-				/* Both VXLAN and GENEVE enabled, just
-				 * update the ltype mask to match both
-				 * VXLAN and GENEVE
-				 */
-				if (udp_tu_data == 0x3)
-					field->ltype_mask = 0xE;
-			}
-			break;
-		case NIX_FLOW_KEY_TYPE_UDP_GTPU:
-			field->lid = NPC_LID_LD;
-			field->hdr_offset = 0; /* UDP data */
-			field->bytesm1 = 3; /* 4 bytes SPORT +  DPORT*/
-			field->ltype_match = NPC_LT_LD_UDP;
-			field->ltype_mask = 0xF;
-			break;
 		}
 		field->ena = 1;
 
-- 
2.31.1

