From 6c7ace129b566d95136fa71573dea60393e9ad50 Mon Sep 17 00:00:00 2001
From: Vishal Sagar <vishal.sagar@xilinx.com>
Date: Fri, 13 Dec 2019 02:31:40 -0800
Subject: [PATCH 0687/1852] v4l: xilinx: sdirxss: Add YUV444 10 bpc support

commit 95d145051617ad41f3597c647fa92bec0c996193 from
https://github.com/Xilinx/linux-xlnx.git

This patch enables the YUV444 format in the Native SDI bridge when the
color format in the received ST352 packet is YUV 444.

Setting this bit in case of YUV422/420 source and keeping this bit
cleared in case of YUV444 source will lead to video corruption.

Signed-off-by: Vishal Sagar <vishal.sagar@xilinx.com>
Reviewed-by: Hyun Kwon <hyun.kwon@xilinx.com>
State: pending
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 .../media/platform/xilinx/xilinx-sdirxss.c    | 21 +++++++++++++++----
 1 file changed, 17 insertions(+), 4 deletions(-)

diff --git a/drivers/media/platform/xilinx/xilinx-sdirxss.c b/drivers/media/platform/xilinx/xilinx-sdirxss.c
index 4af98631a1e9..c72a6c093d9b 100644
--- a/drivers/media/platform/xilinx/xilinx-sdirxss.c
+++ b/drivers/media/platform/xilinx/xilinx-sdirxss.c
@@ -79,6 +79,9 @@
 #define XSDIRX_RST_CTRL_RST_EDH_ERRCNT_MASK		BIT(3)
 #define XSDIRX_RST_CTRL_SDIRX_BRIDGE_ENB_MASK		BIT(8)
 #define XSDIRX_RST_CTRL_VIDIN_AXI4S_MOD_ENB_MASK	BIT(9)
+#define XSDIRX_RST_CTRL_BRIDGE_CH_FMT_OFFSET		10
+#define XSDIRX_RST_CTRL_BRIDGE_CH_FMT_MASK		GENMASK(12, 10)
+#define XSDIRX_RST_CTRL_BRIDGE_CH_FMT_YUV444		1
 
 #define XSDIRX_MDL_CTRL_FRM_EN_MASK		BIT(4)
 #define XSDIRX_MDL_CTRL_MODE_DET_EN_MASK	BIT(5)
@@ -242,6 +245,7 @@
 #define XST352_BYTE3_COLOR_FORMAT_MASK		GENMASK(19, 16)
 #define XST352_BYTE3_COLOR_FORMAT_OFFSET	16
 #define XST352_BYTE3_COLOR_FORMAT_422		0x0
+#define XST352_BYTE3_COLOR_FORMAT_YUV444	0x1
 #define XST352_BYTE3_COLOR_FORMAT_420		0x3
 
 /**
@@ -642,12 +646,18 @@ static inline void xsdirx_clearintr(struct xsdirxss_core *core, u32 mask)
 static void xsdirx_vid_bridge_control(struct xsdirxss_core *core,
 				      bool enable)
 {
+	struct xsdirxss_state *state =
+		container_of(core, struct xsdirxss_state, core);
+	u32 mask = XSDIRX_RST_CTRL_SDIRX_BRIDGE_ENB_MASK;
+
+	if (state->format.code == MEDIA_BUS_FMT_VUY10_1X30)
+		mask |= (XSDIRX_RST_CTRL_BRIDGE_CH_FMT_YUV444 <<
+			 XSDIRX_RST_CTRL_BRIDGE_CH_FMT_OFFSET);
+
 	if (enable)
-		xsdirxss_set(core, XSDIRX_RST_CTRL_REG,
-			     XSDIRX_RST_CTRL_SDIRX_BRIDGE_ENB_MASK);
+		xsdirxss_set(core, XSDIRX_RST_CTRL_REG, mask);
 	else
-		xsdirxss_clr(core, XSDIRX_RST_CTRL_REG,
-			     XSDIRX_RST_CTRL_SDIRX_BRIDGE_ENB_MASK);
+		xsdirxss_clr(core, XSDIRX_RST_CTRL_REG, mask);
 }
 
 static void xsdirx_axis4_bridge_control(struct xsdirxss_core *core,
@@ -960,6 +970,9 @@ static int xsdirx_get_stream_properties(struct xsdirxss_state *state)
 	case XST352_BYTE3_COLOR_FORMAT_422:
 		format->code = MEDIA_BUS_FMT_UYVY10_1X20;
 		break;
+	case XST352_BYTE3_COLOR_FORMAT_YUV444:
+		format->code = MEDIA_BUS_FMT_VUY10_1X30;
+		break;
 	default:
 		dev_err(core->dev, "Unsupported color format : %d\n", sampling);
 		return -EINVAL;
-- 
2.31.1

