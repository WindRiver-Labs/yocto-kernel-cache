From a3d2cdbe8847d65932c353ca73ec6a6766e03545 Mon Sep 17 00:00:00 2001
From: Hariprasad Kelam <hkelam@marvell.com>
Date: Fri, 21 Feb 2020 10:51:24 +0530
Subject: [PATCH 0369/1921] octeontx2-af: Update dmac field in vf vlan rule

VF vlan rule works by match vlan and DMAC in incoming traffic.
VF request for MAC address from AF in VF probe process.
this patch adds support to  update assigned MAC address in
VF VLAN rule upon receiving nix_lf_start_rx mbox request.

minor changes
*pf_set_vfs_cfg update this flag only incase of PF installing for its VF
*update both default_mac/mac_address if PF changes its VF mac address
*use pf2cgxlmac_map instead pfvf->cgx_lmac as cgx_lmac is only valid if
 interface is initilized

Change-Id: I187110bd6ea09f7967b0853f7100efe095bdbcd6
Signed-off-by: Hariprasad Kelam <hkelam@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/23661
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 .../net/ethernet/marvell/octeontx2/af/npc.h   |  1 +
 .../net/ethernet/marvell/octeontx2/af/rvu.h   |  3 ++
 .../ethernet/marvell/octeontx2/af/rvu_npc.c   |  8 ++--
 .../marvell/octeontx2/af/rvu_npc_fs.c         | 48 +++++++++++++++++--
 4 files changed, 52 insertions(+), 8 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/af/npc.h b/drivers/net/ethernet/marvell/octeontx2/af/npc.h
index 2da1af8e06c7..d2390db686c9 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/npc.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/npc.h
@@ -450,6 +450,7 @@ struct rvu_npc_mcam_rule {
 	bool has_cntr;
 	u8 default_rule;
 	bool enable;
+	bool vfvlan_cfg;
 };
 
 #endif /* NPC_H */
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu.h b/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
index a3f569a563fa..35fdd17b805e 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
@@ -691,6 +691,9 @@ int npc_get_bank(struct npc_mcam *mcam, int index);
 void npc_mcam_enable_flows(struct rvu *rvu, u16 target);
 void npc_enable_mcam_entry(struct rvu *rvu, struct npc_mcam *mcam,
 			   int blkaddr, int index, bool enable);
+void npc_read_mcam_entry(struct rvu *rvu, struct npc_mcam *mcam,
+			 int blkaddr, u16 src,
+			 struct mcam_entry *entry, u8 *intf, u8 *ena);
 
 /* CPT APIs */
 int rvu_cpt_init(struct rvu *rvu);
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc.c
index ebeab6988c8e..b71eafd707a6 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc.c
@@ -417,9 +417,9 @@ static void npc_config_mcam_entry(struct rvu *rvu, struct npc_mcam *mcam,
 		npc_enable_mcam_entry(rvu, mcam, blkaddr, actindex, true);
 }
 
-static void npc_read_mcam_entry(struct rvu *rvu, struct npc_mcam *mcam,
-				int blkaddr, u16 src,
-				struct mcam_entry *entry, u8 *intf, u8 *ena)
+void npc_read_mcam_entry(struct rvu *rvu, struct npc_mcam *mcam,
+			 int blkaddr, u16 src,
+			 struct mcam_entry *entry, u8 *intf, u8 *ena)
 {
 	int sbank = npc_get_bank(mcam, src);
 	int bank, kw = 0;
@@ -2651,7 +2651,7 @@ int rvu_npc_set_parse_mode(struct rvu *rvu, u16 pcifunc, u64 mode, u8 dir,
 		/* rx pkind set req valid only for cgx mapped PFs */
 		if (!is_cgx_config_permitted(rvu, pcifunc))
 			return 0;
-		rvu_get_cgx_lmac_id(pfvf->cgx_lmac, &cgx_id, &lmac_id);
+		rvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_id, &lmac_id);
 
 		rc = cgx_set_pkind(rvu_cgx_pdata(cgx_id, rvu),
 				   lmac_id, rxpkind);
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc_fs.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc_fs.c
index 784a13729eaa..987d69a9e47c 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc_fs.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc_fs.c
@@ -653,9 +653,14 @@ static void npc_update_entry(struct rvu *rvu, enum key_fields type,
 		}
 	}
 	/* dummy is ready with values and masks for given key
-	 * field now update input entry with those
+	 * field now clear and update input entry with those
 	 */
 	for (i = 0; i < NPC_MAX_KWS_IN_KEY; i++) {
+		if (!field->kw_mask[i])
+			continue;
+		entry->kw[i] &= ~field->kw_mask[i];
+		entry->kw_mask[i] &= ~field->kw_mask[i];
+
 		entry->kw[i] |= dummy.kw[i];
 		entry->kw_mask[i] |= dummy.kw_mask[i];
 	}
@@ -978,8 +983,13 @@ static int npc_install_flow(struct rvu *rvu, int blkaddr, u16 target,
 		pfvf->def_rule = rule;
 
 	/* VF's MAC address is being changed via PF  */
-	if (pf_set_vfs_mac)
+	if (pf_set_vfs_mac) {
 		ether_addr_copy(pfvf->default_mac, req->packet.dmac);
+		ether_addr_copy(pfvf->mac_addr, req->packet.dmac);
+	}
+
+	if (pfvf->pf_set_vf_cfg && req->vtag0_type == NIX_AF_LFX_RX_VTAG_TYPE7)
+		rule->vfvlan_cfg = true;
 
 	return 0;
 }
@@ -1030,14 +1040,15 @@ int rvu_mbox_handler_npc_install_flow(struct rvu *rvu,
 
 	pfvf = rvu_get_pfvf(rvu, target);
 
-	if (!from_vf && req->vf)
+	/* PF installing for its VF */
+	if (req->hdr.pcifunc && !from_vf && req->vf)
 		pfvf->pf_set_vf_cfg = 1;
 
 	/* update req destination mac addr */
 	if ((req->features & BIT_ULL(NPC_DMAC)) &&
 	    req->intf == NIX_INTF_RX &&
 	    is_zero_ether_addr(req->packet.dmac)) {
-		ether_addr_copy(req->packet.dmac, pfvf->default_mac);
+		ether_addr_copy(req->packet.dmac, pfvf->mac_addr);
 		u64_to_ether_addr(0xffffffffffffull, req->mask.dmac);
 	}
 
@@ -1136,6 +1147,32 @@ int rvu_mbox_handler_npc_delete_flow(struct rvu *rvu,
 	return 0;
 }
 
+static int npc_update_dmac_value(struct rvu *rvu, int npcblkaddr,
+				 struct rvu_npc_mcam_rule *rule,
+				 struct rvu_pfvf *pfvf)
+{
+	struct npc_mcam_write_entry_req write_req = { 0 };
+	struct mcam_entry *entry = &write_req.entry_data;
+	struct npc_mcam *mcam = &rvu->hw->mcam;
+	struct npc_mcam_read_entry_rsp wrsp;
+	struct msg_rsp rsp;
+
+	ether_addr_copy(rule->packet.dmac, pfvf->mac_addr);
+
+	npc_read_mcam_entry(rvu, mcam, npcblkaddr, rule->entry,
+			    entry, &wrsp.intf,
+			    &wrsp.enable);
+
+	npc_update_entry(rvu, NPC_DMAC, entry,
+			 ether_addr_to_u64(pfvf->mac_addr), 0,
+			 0xffffffffffffull, 0, wrsp.intf);
+
+	write_req.hdr.pcifunc = rule->owner;
+	write_req.entry = rule->entry;
+
+	return rvu_mbox_handler_npc_mcam_write_entry(rvu, &write_req, &rsp);
+}
+
 void npc_mcam_enable_flows(struct rvu *rvu, u16 target)
 {
 	struct rvu_pfvf *pfvf = rvu_get_pfvf(rvu, target);
@@ -1162,6 +1199,9 @@ void npc_mcam_enable_flows(struct rvu *rvu, u16 target)
 				continue;
 			}
 
+			if (rule->vfvlan_cfg)
+				npc_update_dmac_value(rvu, blkaddr, rule, pfvf);
+
 			if (rule->rx_action.op == NIX_RX_ACTION_DEFAULT) {
 				if (!pfvf->def_rule)
 					continue;
-- 
2.31.1

