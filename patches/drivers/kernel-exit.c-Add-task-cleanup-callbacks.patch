From 07cfc81a4b6f3c2dc240d940210d2280cf10c010 Mon Sep 17 00:00:00 2001
From: Alex Belits <abelits@marvell.com>
Date: Thu, 9 May 2019 17:21:20 -0700
Subject: [PATCH 166/767] kernel/exit.c: Add task cleanup callbacks

commit abb23ef2b3a046ff6b3149213effd7f718fc2df0 from
git@git.assembla.com:cavium/WindRiver.linux.git

Change-Id: Ib1b916c7093013aca761792c6cb0afe7f4bd7113
Signed-off-by: Alex Belits <abelits@marvell.com>
Signed-off-by: Sujeet Baranwal <sbaranwal@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/8806
Tested-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Reviewed-by: Chandrakala Chavva <cchavva@marvell.com>
Reviewed-by: Sujeet Kumar Baranwal <Sujeet.Baranwal@cavium.com>
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 arch/arm64/Kconfig     |  8 +++++
 include/linux/kernel.h |  6 ++++
 kernel/exit.c          | 66 ++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 80 insertions(+)

diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
index cf5f1dafcf74..0bac1e830464 100644
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@ -682,6 +682,14 @@ config FUJITSU_ERRATUM_010001
 
 endmenu
 
+config MRVL_OCTEONTX_EL0_INTR
+	bool "Handle interrupts in EL0 via EL3"
+	default y
+	help
+	  Handle certain interrupts in EL0 with the help of EL3 firmware to achieve
+	  low latency and also not break task isolation.
+	  Generally implemented and tested on OcteonTx and its successive
+	  generation CPUs.
 
 choice
 	prompt "Page size"
diff --git a/include/linux/kernel.h b/include/linux/kernel.h
index 0c9bc231107f..5ef7e9ecb650 100644
--- a/include/linux/kernel.h
+++ b/include/linux/kernel.h
@@ -305,6 +305,12 @@ extern int oops_may_print(void);
 void do_exit(long error_code) __noreturn;
 void complete_and_exit(struct completion *, long) __noreturn;
 
+#ifdef CONFIG_MRVL_OCTEONTX_EL0_INTR
+struct task_struct;
+int task_cleanup_handler_add(void (*handler)(struct task_struct *));
+int task_cleanup_handler_remove(void (*handler)(struct task_struct *));
+#endif
+
 #ifdef CONFIG_ARCH_HAS_REFCOUNT
 void refcount_error_report(struct pt_regs *regs, const char *err);
 #else
diff --git a/kernel/exit.c b/kernel/exit.c
index a75b6a7f458a..235cf6825593 100644
--- a/kernel/exit.c
+++ b/kernel/exit.c
@@ -772,6 +772,68 @@ static void check_stack_usage(void)
 static inline void check_stack_usage(void) {}
 #endif
 
+#ifdef CONFIG_MRVL_OCTEONTX_EL0_INTR
+struct task_cleanup_handler {
+	void (*handler)(struct task_struct *);
+	struct list_head list;
+};
+
+static DEFINE_MUTEX(task_cleanup_handlers_mutex);
+static LIST_HEAD(task_cleanup_handlers);
+
+int task_cleanup_handler_add(void (*handler)(struct task_struct *))
+{
+	struct task_cleanup_handler *newhandler;
+
+	newhandler = (struct task_cleanup_handler *)
+		kmalloc(sizeof(struct task_cleanup_handler), GFP_KERNEL);
+	if (newhandler == NULL)
+		return -1;
+	newhandler->handler = handler;
+	mutex_lock(&task_cleanup_handlers_mutex);
+	list_add(&newhandler->list, &task_cleanup_handlers);
+	mutex_unlock(&task_cleanup_handlers_mutex);
+	return 0;
+}
+EXPORT_SYMBOL(task_cleanup_handler_add);
+
+int task_cleanup_handler_remove(void (*handler)(struct task_struct *))
+{
+	struct list_head *pos, *tmppos;
+	struct task_cleanup_handler *curr_task_cleanup_handler;
+	int retval = -1;
+
+	mutex_lock(&task_cleanup_handlers_mutex);
+	list_for_each_safe(pos, tmppos, &task_cleanup_handlers)	{
+		curr_task_cleanup_handler
+			= list_entry(pos, struct task_cleanup_handler, list);
+		if (curr_task_cleanup_handler->handler == handler) {
+			list_del(pos);
+			kfree(curr_task_cleanup_handler);
+			retval = 0;
+		}
+	}
+	mutex_unlock(&task_cleanup_handlers_mutex);
+	return retval;
+}
+EXPORT_SYMBOL(task_cleanup_handler_remove);
+
+static void task_cleanup_handlers_call(struct task_struct *task)
+{
+	struct list_head *pos;
+	struct task_cleanup_handler *curr_task_cleanup_handler;
+
+	mutex_lock(&task_cleanup_handlers_mutex);
+	list_for_each(pos, &task_cleanup_handlers) {
+		curr_task_cleanup_handler =
+			list_entry(pos, struct task_cleanup_handler, list);
+		if (curr_task_cleanup_handler->handler != NULL)
+			curr_task_cleanup_handler->handler(task);
+	}
+	mutex_unlock(&task_cleanup_handlers_mutex);
+}
+#endif
+
 void __noreturn do_exit(long code)
 {
 	struct task_struct *tsk = current;
@@ -861,6 +923,10 @@ void __noreturn do_exit(long code)
 	tsk->exit_code = code;
 	taskstats_exit(tsk, group_dead);
 
+#ifdef CONFIG_MRVL_OCTEONTX_EL0_INTR
+	task_cleanup_handlers_call(tsk);
+#endif
+
 	exit_mm();
 
 	if (group_dead)
-- 
2.31.1

