From 8b400b0a4c052856f5a04d06c724fb534f2b4f9a Mon Sep 17 00:00:00 2001
From: Rakesh Babu <rsaladi2@marvell.com>
Date: Wed, 22 Jul 2020 15:28:27 +0530
Subject: [PATCH 608/767] octeontx2-af: Fix max 16 CGX LMACs limit

commit e6d90f879fa2edf72e3835f183f69785974889b7 from
git@git.assembla.com:cavium/WindRiver.linux.git

CN98xx supports upto 20 CGX LMAC ports. 'cgxlmac2pf_map' being 16 bit
limits the number of CGX LMACs to 16. This patch fixes this limit.

Signed-off-by: Rakesh Babu <rsaladi2@marvell.com>
Change-Id: I1fd818cf4674a51c64920dd2103d4807f5493958
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/32611
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/net/ethernet/marvell/octeontx2/af/rvu.h     |  2 +-
 drivers/net/ethernet/marvell/octeontx2/af/rvu_cgx.c | 10 ++++++----
 2 files changed, 7 insertions(+), 5 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu.h b/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
index ca6c546e1188..fb09ad6083fe 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
@@ -485,7 +485,7 @@ struct rvu {
 	u8			cgx_mapped_pfs;
 	u8			cgx_cnt_max;	 /* CGX port count max */
 	u8			*pf2cgxlmac_map; /* pf to cgx_lmac map */
-	u16			*cgxlmac2pf_map; /* bitmap of mapped pfs for
+	u64			*cgxlmac2pf_map; /* bitmap of mapped pfs for
 						  * every cgx lmac port
 						  */
 	unsigned long		pf_notify_bmap; /* Flags for PF notification */
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_cgx.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_cgx.c
index 3b0d2ea12c89..04369705a77d 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_cgx.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_cgx.c
@@ -41,7 +41,7 @@ MBOX_UP_CGX_MESSAGES
 #undef M
 
 /* Returns bitmap of mapped PFs */
-static inline u16 cgxlmac_to_pfmap(struct rvu *rvu, u8 cgx_id, u8 lmac_id)
+static inline u64 cgxlmac_to_pfmap(struct rvu *rvu, u8 cgx_id, u8 lmac_id)
 {
 	return rvu->cgxlmac2pf_map[CGX_OFFSET(cgx_id) + lmac_id];
 }
@@ -56,7 +56,8 @@ static inline int cgxlmac_to_pf(struct rvu *rvu, int cgx_id, int lmac_id)
 	if (!pfmap)
 		return -ENODEV;
 	else
-		return find_first_bit(&pfmap, 16);
+		return find_first_bit(&pfmap,
+				      rvu->cgx_cnt_max * MAX_LMAC_PER_CGX);
 }
 
 static inline u8 cgxlmac_id_to_bmap(u8 cgx_id, u8 lmac_id)
@@ -114,7 +115,7 @@ static int rvu_map_cgx_lmac_pf(struct rvu *rvu)
 
 	/* Reverse map table */
 	rvu->cgxlmac2pf_map = devm_kzalloc(rvu->dev,
-				  cgx_cnt_max * MAX_LMAC_PER_CGX * sizeof(u16),
+				  cgx_cnt_max * MAX_LMAC_PER_CGX * sizeof(u64),
 				  GFP_KERNEL);
 	if (!rvu->cgxlmac2pf_map)
 		return -ENOMEM;
@@ -196,7 +197,8 @@ static void cgx_notify_pfs(struct cgx_link_event *event, struct rvu *rvu)
 	pfmap = cgxlmac_to_pfmap(rvu, event->cgx_id, event->lmac_id);
 
 	do {
-		pfid = find_first_bit(&pfmap, 16);
+		pfid = find_first_bit(&pfmap,
+				      rvu->cgx_cnt_max * MAX_LMAC_PER_CGX);
 		clear_bit(pfid, &pfmap);
 
 		/* check if notification is enabled */
-- 
2.31.1

