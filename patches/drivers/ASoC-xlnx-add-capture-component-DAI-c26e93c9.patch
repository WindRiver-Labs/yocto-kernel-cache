From 32195b61ad32f5f19b44562457ec8e85332d25f8 Mon Sep 17 00:00:00 2001
From: Maruthi Srinivas Bayyavarapu <maruthi.srinivas.bayyavarapu@xilinx.com>
Date: Thu, 26 Jul 2018 19:43:09 +0530
Subject: [PATCH 0108/1851] ASoC: xlnx: add capture component DAI

commit 94998b45ec80d110bba8c47a5b91a3d6604f6621 from
https://github.com/Xilinx/linux-xlnx.git

Audio IP when configured to work in extract mode, provides capture
functionality. This patch supports it by registering a caputure
component DAI with ALSA.

Signed-off-by: Maruthi Srinivas Bayyavarapu <maruthi.srinivas.bayyavarapu@xilinx.com>
Reviewed-by: Hyun Kwon <hyun.kwon@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
State: pending
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 sound/soc/xilinx/xlnx_sdi_audio.c | 416 +++++++++++++++++++++++++++++-
 1 file changed, 414 insertions(+), 2 deletions(-)

diff --git a/sound/soc/xilinx/xlnx_sdi_audio.c b/sound/soc/xilinx/xlnx_sdi_audio.c
index c467abb5d321..a50c32c7c0a0 100644
--- a/sound/soc/xilinx/xlnx_sdi_audio.c
+++ b/sound/soc/xilinx/xlnx_sdi_audio.c
@@ -11,6 +11,8 @@
 #include <linux/module.h>
 #include <linux/of_platform.h>
 #include <linux/platform_device.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
 
 #define DRIVER_NAME "xlnx-sdi-audio"
 
@@ -105,10 +107,73 @@ enum IP_MODE {
 	EXTRACT,
 };
 
+/**
+ * enum sdi_audio_samplerate - audio sampling rate
+ * @XSDIAUD_SAMPRATE0:	48 KHz
+ * @XSDIAUD_SAMPRATE1:	44.1 KHz
+ * @XSDIAUD_SAMPRATE2:	32 KHz
+ */
+enum sdi_audio_samplerate {
+	XSDIAUD_SAMPRATE0,
+	XSDIAUD_SAMPRATE1,
+	XSDIAUD_SAMPRATE2
+};
+
+/**
+ * enum sdi_audio_samplesize - bits per sample
+ * @XSDIAUD_SAMPSIZE0:	20 Bit Audio Sample
+ * @XSDIAUD_SAMPSIZE1:	24 Bit Audio Sample
+ */
+enum sdi_audio_samplesize {
+	XSDIAUD_SAMPSIZE0,
+	XSDIAUD_SAMPSIZE1
+};
+
+enum audio_group {
+	XSDIAUD_GROUP_0 = 0,
+	XSDIAUD_GROUP_1,
+	XSDIAUD_GROUP_2,
+	XSDIAUD_GROUP_1_2,
+	XSDIAUD_GROUP_3,
+	XSDIAUD_GROUP_1_3,
+	XSDIAUD_GROUP_2_3,
+	XSDIAUD_GROUP_1_2_3,
+	XSDIAUD_GROUP_4,
+	XSDIAUD_GROUP_1_4,
+	XSDIAUD_GROUP_2_4,
+	XSDIAUD_GROUP_1_2_4,
+	XSDIAUD_GROUP_3_4,
+	XSDIAUD_GROUP_1_3_4,
+	XSDIAUD_GROUP_2_3_4,
+	XSDIAUD_GROUP_ALL,
+	XSDIAUD_NUM_CHANNELS
+};
+
+enum audio_group_num {
+	XSDIAUD_GROUP1 = 1,
+	XSDIAUD_GROUP2,
+	XSDIAUD_GROUP3,
+	XSDIAUD_GROUP4
+};
+
+/**
+ * struct audio_params - audio stream parameters
+ * @srate: sampling rate
+ * @sig_bits: significant bits in container
+ * @channels: number of channels
+ */
+struct audio_params {
+	u32 srate;
+	u32 sig_bits;
+	u32 channels;
+};
+
 struct dev_ctx {
 	enum IP_MODE mode;
 	void __iomem *base;
 	struct device *dev;
+	struct audio_params *params;
+	struct snd_pcm_substream *stream;
 };
 
 static void audio_enable(void __iomem *aud_base)
@@ -146,11 +211,332 @@ static void audio_reset_core(void __iomem *aud_base, bool reset)
 	}
 }
 
+static void audio_rx_irq_enable(void __iomem *aud_base, bool enable)
+{
+	u32 val;
+
+	val = readl(aud_base + XSDIAUD_INT_EN_REG_OFFSET);
+	if (enable)
+		val |= XSDIAUD_INT_EN_GRP_CHG_MASK;
+	else
+		val &= ~XSDIAUD_INT_EN_GRP_CHG_MASK;
+
+	writel(val, aud_base + XSDIAUD_INT_EN_REG_OFFSET);
+}
+
+/*
+ * Audio channels is received in groups. Each group can hold max 4 channels.
+ * Number of channels and the group in which they are present in Rx stream,
+ * is detected earlier to this call. This function need to mark the group
+ * again with the number of active channels. If channels exceed 4,
+ * next consecutive group is marked.
+ */
+static void audio_set_channels(void __iomem *aud_base,
+			       enum audio_group group_num, u16 num_ch)
+{
+	u32 i, offset, val, num_grp;
+
+	writel(num_ch, aud_base + XSDIAUD_AXIS_CHCOUNT_REG_OFFSET);
+
+	num_grp = num_ch / 4;
+	group_num = group_num - 1;
+
+	for (i = 0; i < num_grp; i++) {
+		offset = XSDIAUD_MUX1_OR_DMUX1_CNTRL_REG_OFFSET + (4 * i);
+		val = readl(aud_base + offset);
+		val &= ~XSDIAUD_EMD_MUX_CNT_GS_MASK;
+		val |= group_num;
+		group_num = group_num + 1;
+		writel(val, aud_base + offset);
+	}
+}
+
+static irqreturn_t xtract_irq_handler(int irq, void *dev_id)
+{
+	u16 num_ch;
+	u32 val, audio_groups;
+
+	struct dev_ctx *ctx = dev_id;
+
+	val = readl(ctx->base + XSDIAUD_INT_STS_REG_OFFSET);
+	val &= XSDIAUD_INT_EN_GRP_CHG_MASK;
+	if (!val)
+		return IRQ_NONE;
+
+	/* TODO: handle other interrupt types */
+	writel(XSDIAUD_INT_EN_GRP_CHG_MASK,
+	       ctx->base + XSDIAUD_INT_STS_REG_OFFSET);
+
+	audio_reset_core(ctx->base, true);
+
+	val = readl(ctx->base + XSDIAUD_EXT_CNTRL_PKTSTAT_REG_OFFSET);
+	val = val & XSDIAUD_EXT_PKTST_AC_MASK;
+	num_ch = hweight32(val);
+
+	val = readl(ctx->base + XSDIAUD_AUD_CNTRL_REG_OFFSET);
+	val |= XSDIAUD_EXT_AUD_CNT_CP_EN_MASK;
+	writel(val, ctx->base + XSDIAUD_AUD_CNTRL_REG_OFFSET);
+
+	audio_groups = readl(ctx->base + XSDIAUD_GRP_PRES_REG_OFFSET);
+	audio_groups &= XSDIAUD_GRP_PRESNT_MASK;
+
+	audio_reset_core(ctx->base, false);
+	dev_info(ctx->dev, "detected audio groups = %d num channels = %d\n",
+		 audio_groups, num_ch);
+	if (num_ch > 2)
+		dev_info(ctx->dev,
+			 "Receiving more channels, but only 2 are extracted\n");
+
+	/* TODO: support more channels later, currently only 2 */
+	audio_set_channels(ctx->base, XSDIAUD_GROUP1, 2);
+	return IRQ_HANDLED;
+}
+
+static struct audio_params *parse_professional_format(u32 reg1_val,
+						      u32 reg2_val)
+{
+	u32 padded, val;
+	struct audio_params *params;
+
+	params = kzalloc(sizeof(*params), GFP_KERNEL);
+	if (!params)
+		return NULL;
+
+	val = (reg1_val & PROF_SAMPLERATE_MASK) >> PROF_SAMPLERATE_SHIFT;
+	switch (val) {
+	case PROF_SAMPLERATE_44100:
+		params->srate = 44100;
+		break;
+	case PROF_SAMPLERATE_48000:
+		params->srate = 48000;
+		break;
+	case PROF_SAMPLERATE_32000:
+		params->srate = 32000;
+		break;
+	case PROF_SAMPLERATE_UNDEFINED:
+	default:
+		/* not indicated */
+		kfree(params);
+		return NULL;
+	}
+
+	val = (reg1_val & PROF_CHANNEL_COUNT_MASK) >> PROF_CHANNEL_COUNT_SHIFT;
+	switch (val) {
+	case PROF_CHANNELS_UNDEFINED:
+	case PROF_STEREO_CHANNELS:
+	case PROF_TWO_CHANNELS:
+		params->channels = 2;
+		break;
+	default:
+		/* TODO: handle more channels in future*/
+		kfree(params);
+		return NULL;
+	}
+
+	val = (reg1_val & PROF_MAX_BITDEPTH_MASK) >> PROF_MAX_BITDEPTH_SHIFT;
+	switch (val) {
+	case PROF_MAX_BITDEPTH_UNDEFINED:
+	case PROF_MAX_BITDEPTH_20:
+		padded = 0;
+		break;
+	case PROF_MAX_BITDEPTH_24:
+		padded = 4;
+		break;
+	default:
+		/* user defined values are not supported */
+		kfree(params);
+		return NULL;
+	}
+
+	val = (reg1_val & PROF_BITDEPTH_MASK) >> PROF_BITDEPTH_SHIFT;
+	switch (val) {
+	case 1:
+		params->sig_bits = 16 + padded;
+		break;
+	case 2:
+		params->sig_bits = 18 + padded;
+		break;
+	case 4:
+		params->sig_bits = 19 + padded;
+		break;
+	case 5:
+		params->sig_bits = 20 + padded;
+		break;
+	case 6:
+		params->sig_bits = 17 + padded;
+		break;
+	case 0:
+	default:
+		kfree(params);
+		return NULL;
+	}
+
+	return params;
+}
+
+static struct audio_params *parse_consumer_format(u32 reg1_val, u32 reg2_val)
+{
+	u32 padded, val;
+	struct audio_params *params;
+
+	params = kzalloc(sizeof(*params), GFP_KERNEL);
+	if (!params)
+		return NULL;
+
+	val = (reg1_val & CON_SAMPLE_RATE_MASK) >> CON_SAMPLE_RATE_SHIFT;
+	switch (val) {
+	case CON_SAMPLERATE_44100:
+		params->srate = 44100;
+		break;
+	case CON_SAMPLERATE_48000:
+		params->srate = 48000;
+		break;
+	case CON_SAMPLERATE_32000:
+		params->srate = 32000;
+		break;
+	default:
+		kfree(params);
+		return NULL;
+	}
+
+	val = (reg1_val & CON_CHANNEL_COUNT_MASK) >> CON_CHANNEL_COUNT_SHIFT;
+	params->channels = val;
+
+	if (reg2_val & CON_MAX_BITDEPTH_MASK)
+		padded = 4;
+	else
+		padded = 0;
+
+	val = (reg2_val & CON_BITDEPTH_MASK) >> CON_BITDEPTH_SHIFT;
+	switch (val) {
+	case 1:
+		params->sig_bits = 16 + padded;
+		break;
+	case 2:
+		params->sig_bits = 18 + padded;
+		break;
+	case 4:
+		params->sig_bits = 19 + padded;
+		break;
+	case 5:
+		params->sig_bits = 20 + padded;
+		break;
+	case 6:
+		params->sig_bits = 17 + padded;
+		break;
+	case 0:
+	default:
+		kfree(params);
+		return NULL;
+	}
+
+	return params;
+}
+
+static int xlnx_sdi_rx_pcm_startup(struct snd_pcm_substream *substream,
+				   struct snd_soc_dai *dai)
+{
+	int err;
+	u32 reg1_val, reg2_val;
+
+	struct snd_pcm_runtime *rtd = substream->runtime;
+	struct dev_ctx *ctx = dev_get_drvdata(dai->dev);
+	void __iomem *base = ctx->base;
+
+	reg1_val = readl(base + XSDIAUD_EXT_CH_STAT0_REG_OFFSET);
+	reg2_val = readl(base + XSDIAUD_EXT_CH_STAT0_REG_OFFSET + 4);
+	if (reg1_val & AES_FORMAT_MASK)
+		ctx->params = parse_professional_format(reg1_val, reg2_val);
+	else
+		ctx->params = parse_consumer_format(reg1_val, reg2_val);
+
+	if (!ctx->params)
+		return -EINVAL;
+
+	dev_info(ctx->dev,
+		 "Audio properties: srate %d sig_bits = %d channels = %d\n",
+		ctx->params->srate, ctx->params->sig_bits,
+		ctx->params->channels);
+
+	err = snd_pcm_hw_constraint_minmax(rtd, SNDRV_PCM_HW_PARAM_RATE,
+					   ctx->params->srate,
+					   ctx->params->srate);
+
+	if (err < 0) {
+		dev_err(ctx->dev, "failed to constrain samplerate to %dHz\n",
+			ctx->params->srate);
+		kfree(ctx->params);
+		return err;
+	}
+
+	/*
+	 * During record, after AES bits(8) are removed, pcm is at max 24bits.
+	 * Out of 24 bits, sig_bits represent valid number of audio bits from
+	 * input stream.
+	 */
+	err = snd_pcm_hw_constraint_msbits(rtd, 0, 24, ctx->params->sig_bits);
+
+	if (err < 0) {
+		dev_err(ctx->dev,
+			"failed to constrain 'bits per sample' %d bits\n",
+			ctx->params->sig_bits);
+		kfree(ctx->params);
+		return err;
+	}
+
+	err = snd_pcm_hw_constraint_minmax(rtd, SNDRV_PCM_HW_PARAM_CHANNELS,
+					   ctx->params->channels,
+					   ctx->params->channels);
+	if (err < 0) {
+		dev_err(ctx->dev,
+			"failed to constrain channel count to %d\n",
+			ctx->params->channels);
+		kfree(ctx->params);
+		return err;
+	}
+
+	dev_info(ctx->dev, " sdi rx audio enabled\n");
+	return 0;
+}
+
+static void xlnx_sdi_rx_pcm_shutdown(struct snd_pcm_substream *substream,
+				     struct snd_soc_dai *dai)
+{
+	struct dev_ctx *ctx = dev_get_drvdata(dai->dev);
+
+	kfree(ctx->params);
+	dev_info(dai->dev, " sdi rx audio disabled\n");
+}
+
+static const struct snd_soc_component_driver xlnx_sdi_component = {
+	.name = "xlnx-sdi-dai-component",
+};
+
+static const struct snd_soc_dai_ops xlnx_sdi_rx_dai_ops = {
+	.startup = xlnx_sdi_rx_pcm_startup,
+	.shutdown = xlnx_sdi_rx_pcm_shutdown,
+};
+
+static struct snd_soc_dai_driver xlnx_sdi_rx_dai = {
+	.name = "xlnx_sdi_rx",
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |
+			SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S24_LE,
+	},
+	.ops = &xlnx_sdi_rx_dai_ops,
+};
+
 static int xlnx_sdi_audio_probe(struct platform_device *pdev)
 {
 	u32 val;
+	int ret;
 	struct dev_ctx *ctx;
 	struct resource *res;
+	struct snd_soc_dai_driver *snd_dai;
 
 	ctx = devm_kzalloc(&pdev->dev, sizeof(struct dev_ctx), GFP_KERNEL);
 	if (!ctx)
@@ -171,10 +557,32 @@ static int xlnx_sdi_audio_probe(struct platform_device *pdev)
 	ctx->dev = &pdev->dev;
 
 	val = readl(ctx->base + XSDIAUD_GUI_PARAM_REG_OFFSET);
-	if (val & BIT(6))
+	if (val & BIT(6)) {
 		ctx->mode = EXTRACT;
-	else
+		res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+		if (!res) {
+			dev_err(&pdev->dev, "No IRQ resource found\n");
+			return -ENODEV;
+		}
+		ret = devm_request_irq(&pdev->dev, res->start,
+				       xtract_irq_handler,
+				       0, "XLNX_SDI_AUDIO_XTRACT", ctx);
+		if (ret) {
+			dev_err(&pdev->dev, "extract irq request failed\n");
+			return -ENODEV;
+		}
+
+		snd_dai = &xlnx_sdi_rx_dai;
+	} else {
 		ctx->mode = EMBED;
+	}
+
+	ret = devm_snd_soc_register_component(&pdev->dev, &xlnx_sdi_component,
+					      snd_dai, 1);
+	if (ret) {
+		dev_err(&pdev->dev, "couldn't register codec DAI\n");
+		return ret;
+	}
 
 	dev_set_drvdata(&pdev->dev, ctx);
 
@@ -182,6 +590,10 @@ static int xlnx_sdi_audio_probe(struct platform_device *pdev)
 	audio_reset_core(ctx->base, false);
 	audio_enable(ctx->base);
 
+	if (ctx->mode == EXTRACT)
+		audio_rx_irq_enable(ctx->base, true);
+
+	dev_info(&pdev->dev, "xlnx sdi codec dai component registered\n");
 	return 0;
 }
 
-- 
2.31.1

