From 98ed8d9bc33c8121be2328eb6687c6ef8af7c511 Mon Sep 17 00:00:00 2001
From: Kevin Hao <haokexin@gmail.com>
Date: Mon, 14 Oct 2019 16:50:40 +0800
Subject: [PATCH 338/767] pci: octeontx2: Use a more lightweight API to get the
 root bus

In the current code, the API pci_get_domain_bus_and_slot() is used to
get the root bus. But we would get the below call trace on rt kernel
due to the spin_lock is used in the klist.
  BUG: sleeping function called from invalid context at kernel/locking/rtmutex.c:968
  in_atomic(): 1, irqs_disabled(): 128, pid: 1, name: swapper/0
  3 locks held by swapper/0/1:
   #0: (____ptrval____) (per_cpu_ptr(&bh_lock.lock, cpu)){....}, at: __device_driver_lock+0x34/0x60
   #1: (____ptrval____) (pci_lock){....}, at: pci_bus_write_config_word+0x40/0xa8
   #2: (____ptrval____) (&k->k_lock){+.+.}, at: klist_next+0x24/0x110
  irq event stamp: 1293008
  hardirqs last  enabled at (1293007): [<ffff000010a3dd48>] _raw_spin_unlock_irqrestore+0xa8/0xb8
  hardirqs last disabled at (1293008): [<ffff000010a3daa0>] _raw_spin_lock_irqsave+0x38/0x80
  softirqs last  enabled at (1032902): [<ffff00001090bd74>] raw_unhash_sk+0x74/0xb0
  softirqs last disabled at (1032891): [<ffff00001090bd00>] raw_unhash_sk+0x0/0xb0
  Preemption disabled at:
  [<ffff00001059a198>] pci_bus_write_config_word+0x40/0xa8
  CPU: 8 PID: 1 Comm: swapper/0 Not tainted 5.2.20-rt9-yocto-preempt-rt+ #12
  Hardware name: Marvell OcteonTX CN96XX board (DT)
  Call trace:
   dump_backtrace+0x0/0x140
   show_stack+0x24/0x30
   dump_stack+0xbc/0x104
   ___might_sleep+0x16c/0x1d0
   rt_spin_lock+0x64/0x78
   klist_next+0x24/0x110
   bus_find_device+0x70/0xe0
   pci_get_dev_by_id+0x60/0x88
   pci_get_domain_bus_and_slot+0x5c/0xb0
   octeontx2_pem_config_write+0x84/0x3e0
   pci_bus_write_config_word+0x64/0xa8
   pci_write_config_word+0x44/0x68
   pci_setup_device+0x214/0x718
   pci_scan_single_device+0xb4/0xf8
   pci_scan_slot+0x44/0x108
   pci_scan_child_bus_extend+0x58/0x290
   pci_scan_bridge_extend+0x350/0x4f8
   pci_scan_child_bus_extend+0x1e4/0x290
   pci_scan_root_bus_bridge+0x60/0xd0
   pci_host_probe+0x20/0xb8
   pci_host_common_probe+0xf4/0x1f0
   octeontx2_pem_probe+0x2c/0x38
   platform_drv_probe+0x58/0xa8
   really_probe+0xe0/0x288
   driver_probe_device+0x5c/0xf0
   device_driver_attach+0x74/0x80
   __driver_attach+0x64/0xe0
   bus_for_each_dev+0x84/0xd8
   driver_attach+0x30/0x40
   bus_add_driver+0x190/0x1f0
   driver_register+0x64/0x110
   __platform_driver_register+0x54/0x60
   octeontx2_pem_driver_init+0x20/0x28
   do_one_initcall+0xa8/0x468
   kernel_init_freeable+0x514/0x5b8
   kernel_init+0x18/0x108
   ret_from_fork+0x10/0x1c

Actually we can use a more lightweight API to get the rootbus without
acquiring any lock, then fix this issue.

Signed-off-by: Kevin Hao <haokexin@gmail.com>
Signed-off-by: Bruce Ashfield <bruce.ashfield@gmail.com>
---
 drivers/pci/controller/pci-octeontx2-pem.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/drivers/pci/controller/pci-octeontx2-pem.c b/drivers/pci/controller/pci-octeontx2-pem.c
index 90b5537e8cdb..1e14dc065322 100644
--- a/drivers/pci/controller/pci-octeontx2-pem.c
+++ b/drivers/pci/controller/pci-octeontx2-pem.c
@@ -335,10 +335,10 @@ static void octeontx2_be_workaround_init(struct pci_bus *bus)
 static void octeontx2_be_workaround(struct pci_bus *bus, int where,
 				    int size, u32 val)
 {
-	struct pci_dev *rc;
+	struct pci_host_bridge *rc;
 	u32 reg, be = 0;
 
-	rc = pci_get_domain_bus_and_slot(pci_domain_nr(bus), 0, 0);
+	rc = pci_find_host_bridge(bus);
 
 	/* Setup RAS to inject one error */
 	octeontx2_be_workaround_init(rc->bus);
-- 
2.31.1

