From d78e48c26d08c890ded856f0a09d9f00dd6b7536 Mon Sep 17 00:00:00 2001
From: Linu Cherian <lcherian@marvell.com>
Date: Fri, 31 Jul 2020 14:16:55 +0530
Subject: [PATCH 0681/1921] irqchip/gic-v3: Add workaround for interrupt loss
 on IPI

RCU stalls has been observed during stress-ng tests on
OcteonTx2 silicon and the reason being an interrupt loss on an IPI.

As a workaround, added provision to ensure that every IPI has been
received on the destination core and if an IPI interrupt loss is
encountered, do resend the IPI.

Identifying a lost interrupt:
Once an interrupt is raised on an IPI line, it would be either in
one of the below states.
   A. pending
   B. active
   C. deactivated

Pending/active states can be verified from the corresponding redist
registers. An interrupt would be in deactivated state either because its
already processed or its been lost. So to identify the reason for case C,
per core tx and rx counters has been introduced for each IPI line.

Change-Id: I28710b1c18ad50dbe68244591644fc3b4c609e14
Signed-off-by: Linu Cherian <lcherian@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/33182
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 drivers/irqchip/Makefile                 |   2 +-
 drivers/irqchip/irq-gic-v3-fixes.c       | 159 +++++++++++++++++++++++
 drivers/irqchip/irq-gic-v3.c             |  58 ++++++++-
 include/linux/irqchip/irq-gic-v3-fixes.h |  25 ++++
 4 files changed, 239 insertions(+), 5 deletions(-)
 create mode 100644 drivers/irqchip/irq-gic-v3-fixes.c
 create mode 100644 include/linux/irqchip/irq-gic-v3-fixes.h

diff --git a/drivers/irqchip/Makefile b/drivers/irqchip/Makefile
index 606a003a0000..c028a0d32ed1 100644
--- a/drivers/irqchip/Makefile
+++ b/drivers/irqchip/Makefile
@@ -29,7 +29,7 @@ obj-$(CONFIG_ARM_GIC)			+= irq-gic.o irq-gic-common.o
 obj-$(CONFIG_ARM_GIC_PM)		+= irq-gic-pm.o
 obj-$(CONFIG_ARCH_REALVIEW)		+= irq-gic-realview.o
 obj-$(CONFIG_ARM_GIC_V2M)		+= irq-gic-v2m.o
-obj-$(CONFIG_ARM_GIC_V3)		+= irq-gic-v3.o irq-gic-v3-mbi.o irq-gic-common.o
+obj-$(CONFIG_ARM_GIC_V3)		+= irq-gic-v3.o irq-gic-v3-mbi.o irq-gic-common.o irq-gic-v3-fixes.o
 obj-$(CONFIG_ARM_GIC_V3_ITS)		+= irq-gic-v3-its.o irq-gic-v3-its-platform-msi.o irq-gic-v4.o
 obj-$(CONFIG_ARM_GIC_V3_ITS_PCI)	+= irq-gic-v3-its-pci-msi.o
 obj-$(CONFIG_ARM_GIC_V3_ITS_FSL_MC)	+= irq-gic-v3-its-fsl-mc-msi.o
diff --git a/drivers/irqchip/irq-gic-v3-fixes.c b/drivers/irqchip/irq-gic-v3-fixes.c
new file mode 100644
index 000000000000..ec7f7cda9b6c
--- /dev/null
+++ b/drivers/irqchip/irq-gic-v3-fixes.c
@@ -0,0 +1,159 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Marvell Silicon GICv3 hardware quirks
+ *
+ * Copyright (C) 2020 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/percpu.h>
+#include <linux/io.h>
+#include <linux/irqchip.h>
+#include <linux/irqchip/arm-gic-v3.h>
+#include <linux/irqchip/arm-gic-common.h>
+#include <linux/irqchip/irq-gic-v3-fixes.h>
+
+#include "irq-gic-common.h"
+
+enum ipi_msg_type {
+	IPI_RESCHEDULE,
+	IPI_CALL_FUNC,
+	IPI_CPU_STOP,
+	IPI_CPU_CRASH_STOP,
+	IPI_TIMER,
+	IPI_IRQ_WORK,
+	IPI_WAKEUP,
+	NR_IPIS
+};
+
+struct gic_ipi_track {
+	atomic_t tx_count;
+	atomic_t rx_count;
+	spinlock_t lock;
+};
+
+static struct gic_ipi_track gic_ipitrack[NR_CPUS][NR_IPIS];
+
+static inline void gic_ipi_txcount_inc(int cpu, int irq)
+{
+	atomic_inc(&gic_ipitrack[cpu][irq].tx_count);
+}
+
+void gic_ipi_rxcount_inc(int cpu, int irq)
+{
+	atomic_inc(&gic_ipitrack[cpu][irq].rx_count);
+}
+
+static inline void gic_ipi_count_reset(int cpu, int irq)
+{
+	atomic_set(&gic_ipitrack[cpu][irq].tx_count, 0x0);
+	atomic_set(&gic_ipitrack[cpu][irq].rx_count, 0x0);
+}
+
+static inline bool is_gic_ipi_received(int dest_cpu, int irq)
+{
+	int retry_count = 0xf;
+
+retry:
+	if (gic_rdist_pend_reg(dest_cpu, 0x0) & (1 << irq))
+		return true;
+
+	if (gic_rdist_active_reg(dest_cpu, 0x0) & (1 << irq))
+		return true;
+	smp_rmb(); /* Ensure pend/active reg read happens first */
+
+	if (atomic_read(&gic_ipitrack[dest_cpu][irq].tx_count) ==
+		atomic_read(&gic_ipitrack[dest_cpu][irq].rx_count))
+		return true;
+
+	if (!retry_count)
+		return false;
+
+	retry_count--;
+	goto retry;
+}
+
+void gic_write_sgi1r_retry(int dest_cpu, int irq, u64 val)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&gic_ipitrack[dest_cpu][irq].lock, flags);
+	wmb(); /* Ensure lock is acquired before we generate an IPI */
+retry:
+	gic_write_sgi1r(val);
+	isb(); /* Ensure sgi write is completed before pending/active read */
+	gic_ipi_txcount_inc(dest_cpu, irq);
+	if (is_gic_ipi_received(dest_cpu, irq))
+		goto out;
+
+	/* Seems we have lost an interrupt
+	 * Reset and start again
+	 */
+	gic_ipi_count_reset(dest_cpu, irq);
+	wmb(); /* Ensure the write is completed before we start again */
+	goto retry;
+out:
+	spin_unlock_irqrestore(&gic_ipitrack[dest_cpu][irq].lock, flags);
+}
+
+static bool __maybe_unused gicv3_enable_quirk_otx2(void *data)
+{
+	int cpu, ipi;
+
+	gic_v3_enable_ipimiss_quirk();
+
+	/* Initialize necessary lock */
+	for_each_possible_cpu(cpu)
+		for (ipi = 0; ipi < NR_IPIS; ipi++)
+			spin_lock_init(&gic_ipitrack[cpu][ipi].lock);
+
+	return true;
+}
+
+static const struct gic_quirk gicv3_quirks[] = {
+	{
+		.desc	= "GIC V3: IPI Miss",
+		.iidr	= 0xb100034c,
+		.mask	= 0xff000fff,
+		.init	= gicv3_enable_quirk_otx2,
+	},
+	{
+		.desc	= "GIC V3: IPI Miss",
+		.iidr	= 0xb200034c,
+		.mask	= 0xff000fff,
+		.init	= gicv3_enable_quirk_otx2,
+	},
+	{
+		.desc	= "GIC V3: IPI Miss",
+		.iidr	= 0xb300034c,
+		.mask	= 0xff000fff,
+		.init	= gicv3_enable_quirk_otx2,
+	},
+	{
+		.desc	= "GIC V3: IPI Miss",
+		.iidr	= 0xb400034c,
+		.mask	= 0xff000fff,
+		.init	= gicv3_enable_quirk_otx2,
+	},
+	{
+		.desc	= "GIC V3: IPI Miss",
+		.iidr	= 0xb500034c,
+		.mask	= 0xff000fff,
+		.init	= gicv3_enable_quirk_otx2,
+	},
+	{ /* NULL entry */
+		0,
+		0,
+		0,
+		0,
+	}
+};
+
+void gic_v3_enable_quirks(void __iomem *base)
+{
+	u32 iidr = readl_relaxed(base + GICD_IIDR);
+
+	gic_enable_quirks(iidr, gicv3_quirks, NULL);
+}
diff --git a/drivers/irqchip/irq-gic-v3.c b/drivers/irqchip/irq-gic-v3.c
index d1afd2d0bfea..6dfe3273ade6 100644
--- a/drivers/irqchip/irq-gic-v3.c
+++ b/drivers/irqchip/irq-gic-v3.c
@@ -23,6 +23,7 @@
 #include <linux/irqchip/arm-gic-common.h>
 #include <linux/irqchip/arm-gic-v3.h>
 #include <linux/irqchip/irq-partition-percpu.h>
+#include <linux/irqchip/irq-gic-v3-fixes.h>
 
 #include <asm/cputype.h>
 #include <asm/exception.h>
@@ -57,6 +58,7 @@ struct gic_chip_data {
 
 static struct gic_chip_data gic_data __read_mostly;
 static DEFINE_STATIC_KEY_TRUE(supports_deactivate_key);
+static DEFINE_STATIC_KEY_FALSE(gic_ipimiss_quirk);
 
 /*
  * The behaviours of RPR and PMR registers differ depending on the value of
@@ -94,9 +96,39 @@ static DEFINE_PER_CPU(bool, has_rss);
 #define gic_data_rdist_rd_base()	(gic_data_rdist()->rd_base)
 #define gic_data_rdist_sgi_base()	(gic_data_rdist_rd_base() + SZ_64K)
 
+#define gic_data_rdist_cpu(cpu)		\
+				(per_cpu_ptr(gic_data.rdists.rdist, cpu))
+#define gic_data_rdist_rd_base_cpu(cpu)	\
+				(gic_data_rdist_cpu(cpu)->rd_base)
+#define gic_data_rdist_sgi_base_cpu(cpu)\
+				(gic_data_rdist_rd_base_cpu(cpu) + SZ_64K)
+
 /* Our default, arbitrary priority value. Linux only uses one anyway. */
 #define DEFAULT_PMR_VALUE	0xf0
 
+void gic_v3_enable_ipimiss_quirk(void)
+{
+	static_branch_enable(&gic_ipimiss_quirk);
+}
+
+u32 gic_rdist_pend_reg(int cpu, int offset)
+{
+	void __iomem *base;
+
+	base = gic_data_rdist_sgi_base_cpu(cpu);
+
+	return readl_relaxed(base + GICR_ISPENDR0 + offset);
+}
+
+u32 gic_rdist_active_reg(int cpu, int offset)
+{
+	void __iomem *base;
+
+	base = gic_data_rdist_sgi_base_cpu(cpu);
+
+	return readl_relaxed(base + GICR_ISACTIVER0 + offset);
+}
+
 static inline unsigned int gic_irq(struct irq_data *d)
 {
 	return d->hwirq;
@@ -529,6 +561,12 @@ static asmlinkage void __exception_irq_entry gic_handle_irq(struct pt_regs *regs
 		return;
 	}
 	if (irqnr < 16) {
+		if (static_branch_likely(&gic_ipimiss_quirk)) {
+			gic_ipi_rxcount_inc(smp_processor_id(), irqnr);
+			/* Force increment is done before deactivate */
+			wmb();
+		}
+
 		gic_write_eoir(irqnr);
 		if (static_branch_likely(&supports_deactivate_key))
 			gic_write_dir(irqnr);
@@ -591,6 +629,8 @@ static void __init gic_dist_init(void)
 	u64 affinity;
 	void __iomem *base = gic_data.dist_base;
 
+	gic_v3_enable_quirks(base);
+
 	/* Disable the distributor */
 	writel_relaxed(0, base + GICD_CTLR);
 	gic_dist_wait_for_rwp();
@@ -897,6 +937,10 @@ static u16 gic_compute_target_list(int *base_cpu, const struct cpumask *mask,
 	while (cpu < nr_cpu_ids) {
 		tlist |= 1 << (mpidr & 0xf);
 
+		if (static_branch_likely(&gic_ipimiss_quirk))
+			/* Force only one target at a time */
+			goto out;
+
 		next_cpu = cpumask_next(cpu, mask);
 		if (next_cpu >= nr_cpu_ids)
 			goto out;
@@ -917,8 +961,8 @@ static u16 gic_compute_target_list(int *base_cpu, const struct cpumask *mask,
 #define MPIDR_TO_SGI_AFFINITY(cluster_id, level) \
 	(MPIDR_AFFINITY_LEVEL(cluster_id, level) \
 		<< ICC_SGI1R_AFFINITY_## level ##_SHIFT)
-
-static void gic_send_sgi(u64 cluster_id, u16 tlist, unsigned int irq)
+static void gic_send_sgi(int dest_cpu, u64 cluster_id, u16 tlist,
+			 unsigned int irq)
 {
 	u64 val;
 
@@ -930,7 +974,10 @@ static void gic_send_sgi(u64 cluster_id, u16 tlist, unsigned int irq)
 	       tlist << ICC_SGI1R_TARGET_LIST_SHIFT);
 
 	pr_devel("CPU%d: ICC_SGI1R_EL1 %llx\n", smp_processor_id(), val);
-	gic_write_sgi1r(val);
+	if (static_branch_likely(&gic_ipimiss_quirk))
+		gic_write_sgi1r_retry(dest_cpu, irq, val);
+	else
+		gic_write_sgi1r(val);
 }
 
 static void gic_raise_softirq(const struct cpumask *mask, unsigned int irq)
@@ -951,9 +998,12 @@ static void gic_raise_softirq(const struct cpumask *mask, unsigned int irq)
 		u16 tlist;
 
 		tlist = gic_compute_target_list(&cpu, mask, cluster_id);
-		gic_send_sgi(cluster_id, tlist, irq);
+		gic_send_sgi(cpu, cluster_id, tlist, irq);
 	}
 
+	if (static_branch_likely(&gic_ipimiss_quirk))
+		return;
+
 	/* Force the above writes to ICC_SGI1R_EL1 to be executed */
 	isb();
 }
diff --git a/include/linux/irqchip/irq-gic-v3-fixes.h b/include/linux/irqchip/irq-gic-v3-fixes.h
new file mode 100644
index 000000000000..1f40ff1fac92
--- /dev/null
+++ b/include/linux/irqchip/irq-gic-v3-fixes.h
@@ -0,0 +1,25 @@
+/* SPDX-License-Identifier: GPL-2.0
+ * Marvell Silicon GICv3 hardware quirks
+ *
+ * Copyright (C) 2020 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __LINUX_IRQCHIP_MARVELL_GIC_V3_H
+#define __LINUX_IRQCHIP_MARVELL_GIC_V3_H
+
+#define GICV3_QUIRK_IPI_MISS	(1 << 0)
+
+u32 gic_rdist_pend_reg(int cpu, int offset);
+u32 gic_rdist_active_reg(int cpu, int offset);
+
+void gic_ipi_rxcount_inc(int cpu, int irq);
+void gic_write_sgi1r_retry(int dest_cpu, int irq, u64 val);
+void gic_v3_enable_quirks(void __iomem *base);
+void gic_v3_enable_ipimiss_quirk(void);
+
+#endif
+
-- 
2.31.1

