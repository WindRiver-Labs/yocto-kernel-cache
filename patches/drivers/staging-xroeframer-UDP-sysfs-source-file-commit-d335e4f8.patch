From cc0657f4b8bf1d766e4cfcbf062c59c0c212b4db Mon Sep 17 00:00:00 2001
From: Vasileios Bimpikas <vasileios.bimpikas@xilinx.com>
Date: Fri, 28 Sep 2018 16:00:21 +0100
Subject: [PATCH 1156/1851] staging: xroeframer: UDP sysfs source file commit

commit 20517e2672f7534ad39a43d8d886bb1ff092b41d from
https://github.com/Xilinx/linux-xlnx.git

Committing sysfs_xroe_framer_udp.c, which creates the "udp" sysfs
directory under "xroe" and contains the UDP related entries for
controlling the framer, such as the source and destination ports.

Signed-off-by: Vasileios Bimpikas <vasileios.bimpikas@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
State: not-upstreamable
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 drivers/staging/xroeframer/Makefile           |   3 +-
 drivers/staging/xroeframer/sysfs_xroe.c       |   4 +
 .../xroeframer/sysfs_xroe_framer_udp.c        | 192 ++++++++++++++++++
 drivers/staging/xroeframer/xroe_framer.h      |   2 +
 4 files changed, 200 insertions(+), 1 deletion(-)
 create mode 100644 drivers/staging/xroeframer/sysfs_xroe_framer_udp.c

diff --git a/drivers/staging/xroeframer/Makefile b/drivers/staging/xroeframer/Makefile
index 6bbd20460eca..ed877c2633f6 100644
--- a/drivers/staging/xroeframer/Makefile
+++ b/drivers/staging/xroeframer/Makefile
@@ -7,4 +7,5 @@ obj-$(CONFIG_XROE_FRAMER)	:= framer.o
 framer-objs := 	xroe_framer.o \
 		sysfs_xroe.o \
 		sysfs_xroe_framer_ipv4.o \
-		sysfs_xroe_framer_ipv6.o
+		sysfs_xroe_framer_ipv6.o \
+		sysfs_xroe_framer_udp.o
diff --git a/drivers/staging/xroeframer/sysfs_xroe.c b/drivers/staging/xroeframer/sysfs_xroe.c
index 0f685e4dc466..d718a803dbcf 100644
--- a/drivers/staging/xroeframer/sysfs_xroe.c
+++ b/drivers/staging/xroeframer/sysfs_xroe.c
@@ -452,6 +452,9 @@ int xroe_sysfs_init(void)
 	if (ret)
 		return ret;
 	ret = xroe_sysfs_ipv6_init();
+	if (ret)
+		return ret;
+	ret = xroe_sysfs_udp_init();
 	return ret;
 }
 
@@ -467,6 +470,7 @@ void xroe_sysfs_exit(void)
 	kobject_put(root_xroe_kobj);
 	xroe_sysfs_ipv4_exit();
 	xroe_sysfs_ipv6_exit();
+	xroe_sysfs_udp_exit();
 }
 
 /**
diff --git a/drivers/staging/xroeframer/sysfs_xroe_framer_udp.c b/drivers/staging/xroeframer/sysfs_xroe_framer_udp.c
new file mode 100644
index 000000000000..7117d89ed53b
--- /dev/null
+++ b/drivers/staging/xroeframer/sysfs_xroe_framer_udp.c
@@ -0,0 +1,192 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2018 Xilinx, Inc.
+ *
+ * Vasileios Bimpikas <vasileios.bimpikas@xilinx.com>
+ */
+
+#include <linux/init.h>
+#include <linux/kobject.h>
+#include <linux/module.h>
+#include <linux/stat.h>
+#include <linux/string.h>
+#include <linux/sysfs.h>
+#include "xroe_framer.h"
+
+enum { XROE_SIZE_MAX = 15 };
+static int xroe_size;
+
+/**
+ * udp_source_port_show - Returns the UDP source port
+ * @kobj:	The kernel object of the entry
+ * @attr:	The attributes of the kernel object
+ * @buff:	The buffer containing the UDP source port
+ *
+ * Returns the UDP source port
+ *
+ * Return: XROE_SIZE_MAX on success
+ */
+static ssize_t udp_source_port_show(struct kobject *kobj,
+				    struct kobj_attribute *attr,
+				    char *buff)
+{
+	u32 offset = ETH_UDP_SOURCE_PORT_OFFSET;
+	u32 mask = ETH_UDP_SOURCE_PORT_MASK;
+	u32 buffer = 0;
+	u32 source_port = 0;
+	void __iomem *working_address = ((u8 *)lp->base_addr +
+	ETH_UDP_SOURCE_PORT_ADDR);
+
+	buffer = ioread32(working_address);
+	source_port = (buffer & mask) >> offset;
+
+	sprintf(buff, "%d\n", source_port);
+
+	return XROE_SIZE_MAX;
+}
+
+/**
+ * udp_source_port_store - Writes to the UDP source port sysfs entry
+ * @kobj:	The kernel object of the entry
+ * @attr:	The attributes of the kernel object
+ * @buff:	The buffer containing the UDP source port
+ * @count:	The number of characters typed by the user
+ *
+ * Writes to the UDP source port sysfs entry
+ *
+ * Return: XROE_SIZE_MAX or the value of "count", if that's lesser, on success
+ */
+static ssize_t udp_source_port_store(struct kobject *kobj,
+				     struct kobj_attribute *attr,
+				     const char *buff, size_t count)
+{
+	int ret;
+	u32 offset = ETH_UDP_SOURCE_PORT_OFFSET;
+	u32 mask = ETH_UDP_SOURCE_PORT_MASK;
+	unsigned int source_port = 0;
+	void __iomem *working_address = ((u8 *)lp->base_addr +
+	ETH_UDP_SOURCE_PORT_ADDR);
+
+	xroe_size = min_t(size_t, count, (size_t)XROE_SIZE_MAX);
+	ret = 0;
+	ret = kstrtouint(buff, 10, &source_port);
+	if (ret)
+		return ret;
+	utils_write32withmask(working_address, (u32)source_port, mask, offset);
+	return xroe_size;
+}
+
+/**
+ * udp_destination_port_show - Returns the UDP destination port
+ * @kobj:	The kernel object of the entry
+ * @attr:	The attributes of the kernel object
+ * @buff:	The buffer containing the UDP destination port
+ *
+ * Returns the UDP destination port
+ *
+ * Return: XROE_SIZE_MAX on success
+ */
+static ssize_t udp_destination_port_show(struct kobject *kobj,
+					 struct kobj_attribute *attr,
+					 char *buff)
+{
+	u32 offset = ETH_UDP_DESTINATION_PORT_OFFSET;
+	unsigned long mask = ETH_UDP_DESTINATION_PORT_MASK;
+	u32 buffer = 0;
+	u32 dest_port = 0;
+	void __iomem *working_address = ((u8 *)lp->base_addr +
+	ETH_UDP_DESTINATION_PORT_ADDR);
+
+	buffer = ioread32(working_address);
+	dest_port = (buffer & mask) >> offset;
+
+	sprintf(buff, "%d\n", dest_port);
+
+	return XROE_SIZE_MAX;
+}
+
+/**
+ * udp_destination_port_store - Writes to the UDP destination port sysfs entry
+ * @kobj:	The kernel object of the entry
+ * @attr:	The attributes of the kernel object
+ * @buff:	The buffer containing the UDP destination port
+ * @count:	The number of characters typed by the user
+ *
+ * Writes to the UDP destination port sysfs entry
+ *
+ * Return: XROE_SIZE_MAX or the value of "count", if that's lesser, on success
+ */
+static ssize_t udp_destination_port_store(struct kobject *kobj,
+					  struct kobj_attribute *attr,
+					  const char *buff, size_t count)
+{
+	int ret;
+	u32 offset = ETH_UDP_DESTINATION_PORT_OFFSET;
+	unsigned long mask = ETH_UDP_DESTINATION_PORT_MASK;
+	unsigned int dest_port = 0;
+	void __iomem *working_address = ((u8 *)lp->base_addr +
+	ETH_UDP_DESTINATION_PORT_ADDR);
+
+	xroe_size = min_t(size_t, count, (size_t)XROE_SIZE_MAX);
+	ret = 0;
+	ret = kstrtouint(buff, 10, &dest_port);
+	if (ret)
+		return ret;
+	utils_write32withmask(working_address, (u32)dest_port,
+			      mask, offset);
+	return xroe_size;
+}
+
+/* TODO Use DEVICE_ATTR/_RW/_RO macros */
+
+static struct kobj_attribute source_port =
+	__ATTR(source_port, 0660, udp_source_port_show,
+	       udp_source_port_store);
+static struct kobj_attribute dest_port =
+	__ATTR(dest_port, 0660, udp_destination_port_show,
+	       udp_destination_port_store);
+
+static struct attribute *attrs[] = {
+	&source_port.attr,
+	&dest_port.attr,
+	NULL,
+};
+
+static struct attribute_group attr_group = {
+	.attrs = attrs,
+};
+
+static struct kobject *kobj_udp;
+
+/**
+ * xroe_sysfs_udp_init - Creates the xroe sysfs "udp" subdirectory and entries
+ *
+ * Return: 0 on success, negative value in case of failure to
+ * create the sysfs group
+ *
+ * Creates the xroe sysfs "udp" subdirectory and entries under "xroe"
+ */
+int xroe_sysfs_udp_init(void)
+{
+	int ret;
+
+	kobj_udp = kobject_create_and_add("udp", kobj_framer);
+	if (!kobj_udp)
+		return -ENOMEM;
+	ret = sysfs_create_group(kobj_udp, &attr_group);
+	if (ret)
+		kobject_put(kobj_udp);
+	return ret;
+}
+
+/**
+ * xroe_sysfs_ipv6_exit - Deletes the xroe sysfs "udp" subdirectory & entries
+ *
+ * Deletes the xroe sysfs "udp" subdirectory and entries,
+ * under the "xroe" entry
+ *
+ */
+void xroe_sysfs_udp_exit(void)
+{
+	kobject_put(kobj_udp);
+}
diff --git a/drivers/staging/xroeframer/xroe_framer.h b/drivers/staging/xroeframer/xroe_framer.h
index 0fd55d604812..45dac0c682ca 100644
--- a/drivers/staging/xroeframer/xroe_framer.h
+++ b/drivers/staging/xroeframer/xroe_framer.h
@@ -54,9 +54,11 @@ struct ioctl_arguments {
 int xroe_sysfs_init(void);
 int xroe_sysfs_ipv4_init(void);
 int xroe_sysfs_ipv6_init(void);
+int xroe_sysfs_udp_init(void);
 void xroe_sysfs_exit(void);
 void xroe_sysfs_ipv4_exit(void);
 void xroe_sysfs_ipv6_exit(void);
+void xroe_sysfs_udp_exit(void);
 int utils_write32withmask(void __iomem *working_address, u32 value,
 			  u32 mask, u32 offset);
 int utils_check_address_offset(u32 offset, size_t device_size);
-- 
2.31.1

