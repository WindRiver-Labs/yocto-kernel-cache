From d1e11e3819916e895065c8443f16e90260dec3da Mon Sep 17 00:00:00 2001
From: Tanmay Jagdale <tanmay@marvell.com>
Date: Thu, 8 Oct 2020 13:55:16 +0530
Subject: [PATCH 1888/1921] perf cs-etm: Determine formatted trace support

Some platforms don't contain a formatter in the sink, especially
in topologies with a per core sink. Hence determine if the sink
contains formatted trace by reading the FFSR register that is
exposed through SysFS interface.

Change-Id: I38f7efea3649611b0ce672ccc9dbcb5fd2bb4157
Signed-off-by: Tanmay Jagdale <tanmay@marvell.com>
[WK: The original patch got from Marvell sdk11.21.09, and
 change struct evlist to struct perf_evlist, struct evsel to
 struct perf_evsel, evsel->core.attr to evsel->attr,
 struct perf_cpu_map to struct cpu_map]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 tools/perf/arch/arm/util/cs-etm.c | 36 +++++++++++++++++++++++++++++++
 tools/perf/util/cs-etm.c          |  9 +++++---
 tools/perf/util/cs-etm.h          |  1 +
 3 files changed, 43 insertions(+), 3 deletions(-)

diff --git a/tools/perf/arch/arm/util/cs-etm.c b/tools/perf/arch/arm/util/cs-etm.c
index 772ece0947fc..cfdb5fbbc23b 100644
--- a/tools/perf/arch/arm/util/cs-etm.c
+++ b/tools/perf/arch/arm/util/cs-etm.c
@@ -679,6 +679,8 @@ static int cs_etm_info_fill(struct auxtrace_record *itr,
 	u64 nr_cpu, type;
 	struct cpu_map *cpu_map;
 	struct cpu_map *event_cpus = session->evlist->cpus;
+	struct perf_evlist *evlist = session->evlist;
+	struct perf_evsel *evsel, *cs_etm_evsel = NULL;
 	struct cpu_map *online_cpus = cpu_map__new(NULL);
 	struct cs_etm_recording *ptr =
 			container_of(itr, struct cs_etm_recording, itr);
@@ -715,6 +717,40 @@ static int cs_etm_info_fill(struct auxtrace_record *itr,
 	info->priv[CS_PMU_TYPE_CPUS] |= nr_cpu;
 	info->priv[CS_ETM_SNAPSHOT] = ptr->snapshot_mode;
 
+	/* Find the etm_pmu event from the event list */
+	evlist__for_each_entry(evlist, evsel) {
+		if (evsel->attr.type == cs_etm_pmu->type) {
+			cs_etm_evsel = evsel;
+			break;
+		}
+	}
+
+	/* From the etm_pmu event determine if the sink supports
+	 * formatted trace by reading the sink's FFSR register
+	 * exposed through SysFS
+	 */
+	if (cs_etm_evsel) {
+		struct perf_evsel_config_term *term;
+		char path[PATH_MAX], *sink;
+		int ret;
+		u32 val;
+
+		list_for_each_entry(term, &cs_etm_evsel->config_terms, list) {
+			if (term->type != PERF_EVSEL__CONFIG_TERM_DRV_CFG)
+				continue;
+
+			sink = term->val.drv_cfg;
+			snprintf(path, PATH_MAX, "sink_%s/mgmt/ffsr", sink);
+			ret = perf_pmu__scan_file(cs_etm_pmu, path, "%x", &val);
+			if (ret != 1) {
+				pr_err("%s: can't read file %s\n",
+				       CORESIGHT_ETM_PMU_NAME, path);
+				break;
+			}
+			info->priv[CS_SINK_FORMATTED] = val & (1 << 4) ? 0 : 1;
+		}
+	}
+
 	offset = CS_ETM_SNAPSHOT + 1;
 
 	for (i = 0; i < cpu__max_cpu() && offset < priv_size; i++)
diff --git a/tools/perf/util/cs-etm.c b/tools/perf/util/cs-etm.c
index 4f9b89675ff2..846c184271bf 100644
--- a/tools/perf/util/cs-etm.c
+++ b/tools/perf/util/cs-etm.c
@@ -60,6 +60,7 @@ struct cs_etm_auxtrace {
 	u64 **metadata;
 	u64 kernel_start;
 	unsigned int pmu_type;
+	unsigned int sink_formatted;
 };
 
 struct cs_etm_traceid_queue {
@@ -483,6 +484,7 @@ static int cs_etm__init_trace_params(struct cs_etm_trace_params *t_params,
 
 static int cs_etm__init_decoder_params(struct cs_etm_decoder_params *d_params,
 				       struct cs_etm_queue *etmq,
+				       struct cs_etm_auxtrace *etm,
 				       enum cs_etm_decoder_operation mode)
 {
 	int ret = -EINVAL;
@@ -493,7 +495,7 @@ static int cs_etm__init_decoder_params(struct cs_etm_decoder_params *d_params,
 	d_params->packet_printer = cs_etm__packet_dump;
 	d_params->operation = mode;
 	d_params->data = etmq;
-	d_params->formatted = true;
+	d_params->formatted = etm->sink_formatted;
 	d_params->fsyncs = false;
 	d_params->hsyncs = false;
 	d_params->frame_aligned = true;
@@ -528,7 +530,7 @@ static void cs_etm__dump_event(struct cs_etm_auxtrace *etm,
 		goto out_free;
 
 	/* Set decoder parameters to simply print the trace packets */
-	if (cs_etm__init_decoder_params(&d_params, NULL,
+	if (cs_etm__init_decoder_params(&d_params, NULL, etm,
 					CS_ETM_OPERATION_PRINT))
 		goto out_free;
 
@@ -760,7 +762,7 @@ static struct cs_etm_queue *cs_etm__alloc_queue(struct cs_etm_auxtrace *etm)
 		goto out_free;
 
 	/* Set decoder parameters to decode trace packets */
-	if (cs_etm__init_decoder_params(&d_params, etmq,
+	if (cs_etm__init_decoder_params(&d_params, etmq, etm,
 					CS_ETM_OPERATION_DECODE))
 		goto out_free;
 
@@ -2789,6 +2791,7 @@ int cs_etm__process_auxtrace_info(union perf_event *event,
 
 	etm->num_cpu = num_cpu;
 	etm->pmu_type = pmu_type;
+	etm->sink_formatted = (hdr[CS_SINK_FORMATTED] & 0x1);
 	etm->snapshot_mode = (hdr[CS_ETM_SNAPSHOT] != 0);
 	etm->metadata = metadata;
 	etm->auxtrace_type = auxtrace_info->type;
diff --git a/tools/perf/util/cs-etm.h b/tools/perf/util/cs-etm.h
index ac697ad18c06..fd8855665a93 100644
--- a/tools/perf/util/cs-etm.h
+++ b/tools/perf/util/cs-etm.h
@@ -18,6 +18,7 @@ enum {
 	CS_HEADER_VERSION,
 	/* PMU->type (32 bit), total # of CPUs (32 bit) */
 	CS_PMU_TYPE_CPUS,
+	CS_SINK_FORMATTED,
 	CS_ETM_SNAPSHOT,
 	CS_HEADER_VERSION_MAX,
 };
-- 
2.31.1

