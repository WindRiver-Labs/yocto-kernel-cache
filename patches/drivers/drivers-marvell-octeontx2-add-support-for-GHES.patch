From 9c2df2f1587f1e7f2dedad50865bacd10fa32792 Mon Sep 17 00:00:00 2001
From: Rick Farrington <Ricardo.Farrington@cavium.com>
Date: Sat, 18 Jan 2020 14:36:26 -0500
Subject: [PATCH 452/767] drivers: marvell: octeontx2: add support for GHES

commit 2aa5339be19a3d2906a348e571a62d06805360b0 from
git@git.assembla.com:cavium/WindRiver.linux.git

Enable the firmware (ATF) to report RAS errors
from the LMC, MCC or MDC.

The Generic Hardware Error Source (GHES) allows for
non-standard errors to be reported to the system
(please refer to the ACPI specification).

The standard GHES driver requires the presence of
ACPI tables, and accompanying kernel ACPI support.
However, OcteonTX2 is commonly used in embedded
context with Device Tree, which disables ACPI
in the kernel.  Therefore, the standard GHES
driver does not load or function.

Add support for GHES through a platform driver,
using data from the Device Tree to construct the
required ACPI table (Hardware Error Source Table,
or HEST) and inform the kernel thereof.
Additionally, create GHES devices for the LMC,
MCC & MDC OcteonTX2 devices, allowing the firmware
to propagate detected RAS errors to the kernel.

Change-Id: If39a5334131313d4d9063f119a5694423d865f60
Signed-off-by: Rick Farrington <Ricardo.Farrington@cavium.com>
Reviewed-on: https://sj1git1.cavium.com/21847
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Tested-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[Kevin: Just some minor context mods in order to port to linux-yocto]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../bindings/edac/marvell-sdei-ghes.txt       |  69 ++
 drivers/acpi/apei/ghes.c                      |  64 +-
 drivers/acpi/apei/hest.c                      |  25 +-
 drivers/soc/marvell/Kconfig                   |  21 +
 drivers/soc/marvell/Makefile                  |   1 +
 drivers/soc/marvell/octeontx2-ghes/Makefile   |   8 +
 .../marvell/octeontx2-ghes/otx2-sdei-ghes.c   | 604 ++++++++++++++++++
 .../marvell/octeontx2-ghes/otx2-sdei-ghes.h   |  70 ++
 include/acpi/apei.h                           |   2 +
 9 files changed, 850 insertions(+), 14 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/edac/marvell-sdei-ghes.txt
 create mode 100644 drivers/soc/marvell/octeontx2-ghes/Makefile
 create mode 100644 drivers/soc/marvell/octeontx2-ghes/otx2-sdei-ghes.c
 create mode 100644 drivers/soc/marvell/octeontx2-ghes/otx2-sdei-ghes.h

diff --git a/Documentation/devicetree/bindings/edac/marvell-sdei-ghes.txt b/Documentation/devicetree/bindings/edac/marvell-sdei-ghes.txt
new file mode 100644
index 000000000000..97fc8b2a5254
--- /dev/null
+++ b/Documentation/devicetree/bindings/edac/marvell-sdei-ghes.txt
@@ -0,0 +1,69 @@
+* Marvell OcteonTX SOC sdei-ghes node
+
+The sdei-ghes node is defined to describe resources to the sdei-ghes module.
+
+Abstract
+--------
+
+The Generic Hardware Error Source (GHES) allows for non-standard errors to be
+reported to the system (please refer to the ACPI specification).
+
+The standard GHES driver requires the presence of ACPI tables, and accompanying
+kernel ACPI support, which is not available to systems utilizing Device Tree.
+
+The OcteonTX2 sdei-ghes module provides the required Hardware Error Source Table
+(HEST) to the kernel, allowing the GHES driver to load.
+
+Additionally, this module presents GHES devices to the system, which allows
+the firmware (ATF) to report RAS errors.
+
+The following error sources are supported:
+
+  MDC    - OcteonTX Memory Diagnostic Controller
+  MCC    - OcteonTX Memory Common Controller
+  LMC    - OcteonTX Local Memory DDR4 Controller
+
+Device Tree sdei-ghes binding
+-----------------------------
+
+Required properties:
+- compatible	: Shall be "marvell,sdei-ghes".
+
+Required properties for mdc subnode:
+- reg		: Shall contain three entries, one for each of:
+		  - GHES Error Status Address (ACPI 4.0a, sec 17.3.2.6)
+		  - GHES Error Status Block   (ACPI 4.0a, sec 17.3.2.6.1)
+		  - ring buffer for communication with firmware
+
+- event-id	: SDEI event ID for receiving firmware notifications
+
+Example
+-------
+
+	sdei-ghes {
+		compatible = "marvell,sdei-ghes";
+		#address-cells = <2>;
+		#size-cells = <1>;
+		memory-region = <&ghes_hest_reserved>;
+		ranges = <0x0 0x00000000 0x0 0x7f020000 0x00100>,
+			 <0x0 0x00000100 0x0 0x7f020100 0x00700>,
+			 <0x0 0x00000800 0x0 0x7f020800 0x08000>;
+		mdc@0 {
+			reg = <0x0 0x00000000 0x008>,
+			      <0x0 0x00000100 0x100>,
+			      <0x0 0x00000800 0x800>;
+			event-id = <0x40000000>;
+		};
+		mcc@8 {
+			reg = <0x0 0x00000008 0x008>,
+			      <0x0 0x00000200 0x100>,
+			      <0x0 0x00001000 0x800>;
+			event-id = <0x40000001>;
+		};
+		lmc@10 {
+			reg = <0x0 0x00000010 0x008>,
+			      <0x0 0x00000300 0x100>,
+			      <0x0 0x00001800 0x800>;
+			event-id = <0x40000002>;
+		};
+	}
diff --git a/drivers/acpi/apei/ghes.c b/drivers/acpi/apei/ghes.c
index 6875bf629f16..f51c27879009 100644
--- a/drivers/acpi/apei/ghes.c
+++ b/drivers/acpi/apei/ghes.c
@@ -40,6 +40,7 @@
 #include <linux/sched/clock.h>
 #include <linux/uuid.h>
 #include <linux/ras.h>
+#include <linux/of.h>
 
 #include <acpi/actbl1.h>
 #include <acpi/ghes.h>
@@ -213,6 +214,24 @@ static void ghes_ack_error(struct acpi_hest_generic_v2 *gv2)
 	apei_write(val, &gv2->read_ack_register);
 }
 
+/*
+ * Checks device tree for support of sdei-ghes [driver].
+ * This driver supports GHES in the absence of ACPI.
+ * on entry:
+ *     void
+ * returns:
+ *     true if sdei-ghes support found in Device Tree else false
+ */
+static bool sdei_ghes_present_dt(void)
+{
+	struct device_node *np;
+
+	np = of_find_node_by_name(NULL, "sdei-ghes");
+	of_node_put(np);
+
+	return !!np;
+}
+
 static struct ghes *ghes_new(struct acpi_hest_generic *generic)
 {
 	struct ghes *ghes;
@@ -224,6 +243,20 @@ static struct ghes *ghes_new(struct acpi_hest_generic *generic)
 		return ERR_PTR(-ENOMEM);
 
 	ghes->generic = generic;
+
+	/* If sdei-ghes is present (via device tree), ACPI mappings are not
+	 * available and will be relegated to 'early_mem_remap()'. However, any
+	 * such outstanding 'early' mappings will be detected as leaks during
+	 * late kernel initialization - see 'check_early_ioremap_leak()'.
+	 * Since this mapping is a 'sanity check' only (the mapping isn't used),
+	 * skip this step to avoid it being detected as an [errant] leak.
+	 * Notes:
+	 *   * the presence of the Device Tree disables ACPI
+	 *   * the status register is actually mapped at run-time, when accessed
+	 */
+	if (sdei_ghes_present_dt())
+		goto skip_map_status;
+
 	if (is_hest_type_generic_v2(ghes)) {
 		rc = map_gen_v2(ghes);
 		if (rc)
@@ -233,6 +266,8 @@ static struct ghes *ghes_new(struct acpi_hest_generic *generic)
 	rc = apei_map_generic_address(&generic->error_status_address);
 	if (rc)
 		goto err_unmap_read_ack_addr;
+
+skip_map_status:
 	error_block_length = generic->error_block_length;
 	if (error_block_length > GHES_ESTATUS_MAX_SIZE) {
 		pr_warning(FW_WARN GHES_PFX
@@ -250,6 +285,9 @@ static struct ghes *ghes_new(struct acpi_hest_generic *generic)
 	return ghes;
 
 err_unmap_status_addr:
+	/* if sdei-ghes is present, status was not mapped - skip the UNmap */
+	if (sdei_ghes_present_dt())
+		goto err_free;
 	apei_unmap_generic_address(&generic->error_status_address);
 err_unmap_read_ack_addr:
 	if (is_hest_type_generic_v2(ghes))
@@ -262,6 +300,9 @@ static struct ghes *ghes_new(struct acpi_hest_generic *generic)
 static void ghes_fini(struct ghes *ghes)
 {
 	kfree(ghes->estatus);
+	/* if sdei-ghes is present, status was not mapped - skip the UNmap */
+	if (sdei_ghes_present_dt())
+		return;
 	apei_unmap_generic_address(&ghes->generic->error_status_address);
 	if (is_hest_type_generic_v2(ghes))
 		unmap_gen_v2(ghes);
@@ -1313,7 +1354,8 @@ static int __init ghes_init(void)
 {
 	int rc;
 
-	if (acpi_disabled)
+	/* permit GHES initialization if either ACPI or SDEI_GHES is present */
+	if (acpi_disabled && !sdei_ghes_present_dt())
 		return -ENODEV;
 
 	switch (hest_disable) {
@@ -1337,15 +1379,17 @@ static int __init ghes_init(void)
 	if (rc)
 		goto err;
 
-	rc = apei_osc_setup();
-	if (rc == 0 && osc_sb_apei_support_acked)
-		pr_info(GHES_PFX "APEI firmware first mode is enabled by APEI bit and WHEA _OSC.\n");
-	else if (rc == 0 && !osc_sb_apei_support_acked)
-		pr_info(GHES_PFX "APEI firmware first mode is enabled by WHEA _OSC.\n");
-	else if (rc && osc_sb_apei_support_acked)
-		pr_info(GHES_PFX "APEI firmware first mode is enabled by APEI bit.\n");
-	else
-		pr_info(GHES_PFX "Failed to enable APEI firmware first mode.\n");
+	if (!acpi_disabled) {
+		rc = apei_osc_setup();
+		if (rc == 0 && osc_sb_apei_support_acked)
+			pr_info(GHES_PFX "APEI firmware first mode is enabled by APEI bit and WHEA _OSC.\n");
+		else if (rc == 0 && !osc_sb_apei_support_acked)
+			pr_info(GHES_PFX "APEI firmware first mode is enabled by WHEA _OSC.\n");
+		else if (rc && osc_sb_apei_support_acked)
+			pr_info(GHES_PFX "APEI firmware first mode is enabled by APEI bit.\n");
+		else
+			pr_info(GHES_PFX "Failed to enable APEI firmware first mode.\n");
+	}
 
 	return 0;
 err:
diff --git a/drivers/acpi/apei/hest.c b/drivers/acpi/apei/hest.c
index 267bdbf6a7bf..f9d4e6d3bd64 100644
--- a/drivers/acpi/apei/hest.c
+++ b/drivers/acpi/apei/hest.c
@@ -235,8 +235,12 @@ void __init acpi_hest_init(void)
 		return;
 	}
 
-	status = acpi_get_table(ACPI_SIG_HEST, 0,
-				(struct acpi_table_header **)&hest_tab);
+	/* HEST table may have been initialized by hest_table_set() */
+	if (hest_tab)
+		status = AE_OK;
+	else
+		status = acpi_get_table(ACPI_SIG_HEST, 0,
+					(struct acpi_table_header **)&hest_tab);
 	if (status == AE_NOT_FOUND) {
 		hest_disable = HEST_NOT_FOUND;
 		return;
@@ -253,13 +257,17 @@ void __init acpi_hest_init(void)
 
 	if (!ghes_disable) {
 		rc = apei_hest_parse(hest_parse_ghes_count, &ghes_count);
-		if (rc)
+		if (rc) {
+			pr_err(HEST_PFX "Failed to parse GHES entries\n");
 			goto err;
+		}
 
 		if (ghes_count)
 			rc = hest_ghes_dev_register(ghes_count);
-		if (rc)
+		if (rc) {
+			pr_err(HEST_PFX "Failed to register GHES devices\n");
 			goto err;
+		}
 	}
 
 	pr_info(HEST_PFX "Table parsing has been initialized.\n");
@@ -267,3 +275,12 @@ void __init acpi_hest_init(void)
 err:
 	hest_disable = HEST_DISABLED;
 }
+
+/*
+ * This allows the HEST to be initialized externally, in the absence of ACPI.
+ */
+void __init hest_table_set(struct acpi_table_hest *table)
+{
+	hest_tab = table;
+}
+
diff --git a/drivers/soc/marvell/Kconfig b/drivers/soc/marvell/Kconfig
index 67bd5ca92b18..334c0e2137b0 100644
--- a/drivers/soc/marvell/Kconfig
+++ b/drivers/soc/marvell/Kconfig
@@ -82,4 +82,25 @@ config MDIO_DEBUGFS
 	help
 	provides debugfs support to initiate mdio commands via smc call
 	to the atf.
+
+config OCTEONTX2_SDEI_GHES
+	bool "OcteonTX2 Generic Hardware Error Source (GHES) support"
+	depends on ARM_SDE_INTERFACE
+	help
+	  Select this option to enable support for RAS Generic Hardware Error
+	  Source (GHES) reporting.
+	  This will allow RAS errors that are detected by the OcteonTX2 to
+	  be reported using kernel logging.
+
+config OCTEONTX2_SDEI_GHES_DEBUG
+	bool "OcteonTX2 Generic Hardware Error Source (GHES) verbose debug msgs"
+	depends on OCTEONTX2_SDEI_GHES
+	help
+	  Say Y here if you want the OcteonTX2 GHES support to
+	  write verbose debug messages to the system log.  Select this
+	  if you are having a problem with the OcteonTX2 GHES support
+	  and want to see more details.
+
+	  If you are unsure about this, say N here.
+
 endmenu
diff --git a/drivers/soc/marvell/Makefile b/drivers/soc/marvell/Makefile
index cdc062497815..e8e1b5b63488 100644
--- a/drivers/soc/marvell/Makefile
+++ b/drivers/soc/marvell/Makefile
@@ -2,3 +2,4 @@
 obj-y		+= octeontx2-rm/
 obj-y		+= octeontx2-dpi/
 obj-$(CONFIG_MDIO_DEBUGFS) += mdio_debugfs.o
+obj-y		+= octeontx2-ghes/
diff --git a/drivers/soc/marvell/octeontx2-ghes/Makefile b/drivers/soc/marvell/octeontx2-ghes/Makefile
new file mode 100644
index 000000000000..29878ca771c0
--- /dev/null
+++ b/drivers/soc/marvell/octeontx2-ghes/Makefile
@@ -0,0 +1,8 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for Marvell's OcteonTX2 SDEI/GHES device driver
+#
+
+obj-$(CONFIG_OCTEONTX2_SDEI_GHES) += octeontx2_sdei_ghes.o
+
+octeontx2_sdei_ghes-y := otx2-sdei-ghes.o
diff --git a/drivers/soc/marvell/octeontx2-ghes/otx2-sdei-ghes.c b/drivers/soc/marvell/octeontx2-ghes/otx2-sdei-ghes.c
new file mode 100644
index 000000000000..1cc7213c3d06
--- /dev/null
+++ b/drivers/soc/marvell/octeontx2-ghes/otx2-sdei-ghes.c
@@ -0,0 +1,604 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Supports OcteonTX2 Generic Hardware Error Source[s] (GHES).
+ *
+ */
+
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/of_address.h>
+#include <linux/arm_sdei.h>
+#include <linux/uuid.h>
+#include <linux/acpi.h>
+#include <acpi/apei.h>
+#include <linux/pci.h>
+#include "otx2-sdei-ghes.h"
+
+#define DRV_NAME       "sdei-ghes"
+
+/* The initialization function does not have a device ptr; use 'pr_xxx' */
+#define initerrmsg(fmt, ...) pr_err(DRV_NAME ":" fmt, __VA_ARGS__)
+
+#ifdef CONFIG_OCTEONTX2_SDEI_GHES_DEBUG
+#  define initdbgmsg(fmt, ...) pr_info(DRV_NAME ":" fmt, __VA_ARGS__)
+#  define dbgmsg(dev, ...) dev_info((dev), __VA_ARGS__)
+#else
+#  define initdbgmsg(fmt, ...) (void)(fmt)
+#  define dbgmsg(dev, ...) (void)(dev)
+#endif // CONFIG_OCTEONTX2_SDEI_GHES_DEBUG
+
+static struct acpi_table_hest *hest;
+static struct otx2_ghes_event *event_list;
+
+#define PCI_VENDOR_ID_CAVIUM            0x177d
+#define PCI_DEVICE_ID_OCTEONTX2_MCC     0xa070
+#define PCI_DEVICE_ID_OCTEONTX2_MDC     0xa073
+static const struct pci_device_id sdei_ghes_otx2_pci_tbl[] = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, PCI_DEVICE_ID_OCTEONTX2_MCC) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, PCI_DEVICE_ID_OCTEONTX2_MDC) },
+	{ 0, },
+};
+
+/* SDEI event notification callback. */
+static int sdei_ghes_callback(u32 event_id, struct pt_regs *regs, void *arg)
+{
+	struct acpi_hest_generic_data *hest_gen_data;
+	struct acpi_hest_generic_status *estatus;
+	struct otx2_ghes_err_record *err_rec;
+	struct cper_sec_mem_err_old *mem_err;
+	struct otx2_sdei_ghes_drv *ghes_drv;
+	struct otx2_ghes_event *event;
+	u32 head, tail;
+	size_t idx;
+
+	ghes_drv = arg;
+
+
+	for (idx = 0; idx < ghes_drv->event_count; idx++) {
+		event = &ghes_drv->event_list[idx];
+		if (event->id != event_id)
+			continue;
+
+		head = event->ring->head;
+		tail = event->ring->tail;
+
+		if (head == tail) {
+			initerrmsg("event 0x%x err_rec ring is empty!\n",
+				   event_id);
+			break;
+		}
+
+		err_rec = &event->ring->records[tail];
+
+		estatus = event->estatus;
+
+		estatus->raw_data_length = 0;
+		/* Implementation note: 'data_length' must equal
+		 * 'hest_gen_entry->error_block_length' MINUS
+		 * sizeof(struct acpi_hest_generic_status).
+		 * See 'sdei_ghes_init()'.
+		 */
+
+		/* Initialize 'data_length'; also see modifications below. */
+		estatus->data_length = sizeof(*hest_gen_data);
+		estatus->error_severity = err_rec->severity;
+
+		/* generic data follows header */
+		hest_gen_data = (struct acpi_hest_generic_data *)(estatus + 1);
+		memset(hest_gen_data, 0, sizeof(*hest_gen_data));
+
+		hest_gen_data->revision = 0x201; /* ACPI 4.x */
+		if (err_rec->fru_text[0]) {
+			hest_gen_data->validation_bits =
+				ACPI_HEST_GEN_VALID_FRU_STRING;
+			strncpy(hest_gen_data->fru_text, err_rec->fru_text,
+				sizeof(hest_gen_data->fru_text));
+		}
+		/* copy severity from generic status */
+		hest_gen_data->error_severity = estatus->error_severity;
+		guid_copy((guid_t *)hest_gen_data->section_type,
+			  &CPER_SEC_PLATFORM_MEM);
+
+		hest_gen_data->error_data_length =
+			sizeof(struct cper_sec_mem_err_old);
+		estatus->data_length += sizeof(struct cper_sec_mem_err_old);
+		/* memory error follows generic data */
+		mem_err = (struct cper_sec_mem_err_old *)(hest_gen_data + 1);
+		/* copy error record from ring */
+		memcpy(mem_err, &err_rec->u.mcc, sizeof(*mem_err));
+
+		/* Ensure that estatus is committed to memory prior to
+		 * setting block_status.
+		 */
+		wmb();
+
+		estatus->block_status = ACPI_HEST_CORRECTABLE |
+					(1 << 4); /* i.e. one entry */
+
+		if (++tail >= event->ring->size)
+			tail = 0;
+		event->ring->tail = tail;
+		break;
+	}
+
+	return 0;
+}
+
+/*
+ * Main initialization function for ghes_drv device instance.
+ *
+ * returns:
+ *   0 if no error
+ *   -ENODEV if error occurred initializing device
+ *   ENODEV if device should not be used (not an error per se)
+ */
+static int sdei_ghes_init(struct platform_device *pdev)
+{
+	struct otx2_sdei_ghes_drv *ghes_drv;
+	struct device *dev = &pdev->dev;
+	struct otx2_ghes_event *event;
+	size_t idx;
+	int ret;
+
+	dbgmsg(dev, "%s: entry\n", __func__);
+
+	ghes_drv = platform_get_drvdata(pdev);
+	ret = -ENODEV;
+
+	/* Allocated during initialization (see sdei_ghes_driver_init) */
+	ghes_drv->event_list = event_list;
+	ghes_drv->event_count = hest->error_source_count;
+
+	/* Register & enable each SDEI event */
+	for (idx = 0; idx < ghes_drv->event_count; idx++) {
+		event = &ghes_drv->event_list[idx];
+
+		/* register the event */
+		ret = sdei_event_register(event->id, sdei_ghes_callback,
+					  ghes_drv);
+		if (ret < 0) {
+			dev_err(dev, "Error %d registering event 0x%x (%s)\n",
+				ret, event->id, event->name);
+			break;
+		}
+
+		/* enable the event */
+		ret = sdei_event_enable(event->id);
+		if (ret < 0) {
+			dev_err(dev, "Error %d enabling event 0x%x (%s)\n",
+				ret, event->id, event->name);
+			break;
+		}
+	}
+
+	if (idx != ghes_drv->event_count) {
+		ret = -ENODEV;
+		goto exit;
+	}
+
+	dbgmsg(dev, "Registered & enabled %ld events\n", ghes_drv->event_count);
+
+	ret = 0;
+
+exit:
+	return ret;
+}
+
+/* Main de-initialization function for ghes_drv device instance. */
+static int sdei_ghes_de_init(struct platform_device *pdev)
+{
+	struct otx2_sdei_ghes_drv *ghes_drv;
+	struct device *dev = &pdev->dev;
+	struct otx2_ghes_event *event;
+	int ret, idx;
+
+	dbgmsg(dev, "%s: entry\n", __func__);
+
+	ghes_drv = platform_get_drvdata(pdev);
+
+	for (idx = 0; idx < ghes_drv->event_count; idx++) {
+		event = &ghes_drv->event_list[idx];
+
+		ret = sdei_event_disable(event->id);
+		if (ret < 0)
+			dev_err(dev,
+				"Error %d disabling SDEI event 0x%x (%s)\n",
+				ret, event->id, event->name);
+
+		ret = sdei_event_unregister(event->id);
+		if (ret < 0)
+			dev_err(dev,
+				"Error %d unregistering SDEI event 0x%x (%s)\n",
+				ret, event->id, event->name);
+	}
+
+	return 0;
+}
+
+/* Linux driver framework probe function. */
+static int sdei_ghes_probe(struct platform_device *pdev)
+{
+	struct otx2_sdei_ghes_drv *ghes_drv;
+	struct device *dev = &pdev->dev;
+	int ret;
+
+	dbgmsg(dev, "%s: entry\n", __func__);
+
+	ghes_drv = NULL;
+
+	ret = -ENODEV;
+
+	/* allocate device structure */
+	ghes_drv = devm_kzalloc(dev, sizeof(*ghes_drv), GFP_KERNEL);
+
+	if (ghes_drv == NULL) {
+		ret = -ENOMEM;
+		dev_err(dev, "Unable to allocate drv context.\n");
+		goto exit;
+	}
+
+	platform_set_drvdata(pdev, ghes_drv);
+
+	ret = sdei_ghes_init(pdev);
+
+	/* a negative value indicates an error */
+	if (ret < 0)
+		dev_err(dev, "Error initializing SDEI GHES support.\n");
+
+exit:
+	if (ret) {
+		sdei_ghes_de_init(pdev);
+
+		if (ghes_drv != NULL)
+			devm_kfree(dev, ghes_drv);
+	}
+
+	return ret ? -ENODEV : 0;
+}
+
+static void sdei_ghes_shutdown(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+
+	dbgmsg(dev, "%s: entry\n", __func__);
+}
+
+static int sdei_ghes_remove(struct platform_device *pdev)
+{
+	struct otx2_sdei_ghes_drv *ghes_drv;
+	struct device *dev = &pdev->dev;
+
+	ghes_drv = platform_get_drvdata(pdev);
+
+	dbgmsg(dev, "%s: entry\n", __func__);
+
+	sdei_ghes_de_init(pdev);
+
+	devm_kfree(dev, ghes_drv);
+
+	return 0;
+}
+
+static const struct of_device_id sdei_ghes_of_match[] = {
+	{ .compatible = "marvell,sdei-ghes", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, sdei_ghes_of_match);
+
+static const struct platform_device_id sdei_ghes_pdev_match[] = {
+	{ .name = DRV_NAME, },
+	{},
+};
+MODULE_DEVICE_TABLE(platform, sdei_ghes_pdev_match);
+
+static struct platform_driver sdei_ghes_drv = {
+	.driver = {
+		.name = DRV_NAME,
+		.of_match_table = sdei_ghes_of_match,
+	},
+	.probe = sdei_ghes_probe,
+	.remove = sdei_ghes_remove,
+	.shutdown = sdei_ghes_shutdown,
+	.id_table = sdei_ghes_pdev_match,
+};
+
+/*
+ * Allocates and initializes Hardware Error Source Table (HEST), then
+ * registers it with kernel.
+ */
+static int __init sdei_ghes_hest_init(struct device_node *of_node)
+{
+	const __be32 *of_base0, *of_base1, *of_base2;
+	struct acpi_hest_generic *hest_gen_entry;
+	struct device_node *child_node;
+	struct otx2_ghes_event *event;
+	size_t event_cnt, size, idx;
+	const u32 *evt_id_prop;
+	int ret, prop_sz;
+	void *memblock;
+
+	initdbgmsg("%s: entry\n", __func__);
+
+	ret = -ENODEV;
+
+	/* enumerate events available for subscription */
+	event_cnt = 0;
+	for_each_available_child_of_node(of_node, child_node) {
+		of_base0 = of_get_address(child_node, 0, NULL, NULL);
+		if ((of_base0 == NULL) ||
+		    (of_translate_address(child_node, of_base0) == OF_BAD_ADDR))
+			continue;
+		of_base1 = of_get_address(child_node, 1, NULL, NULL);
+		if ((of_base1 == NULL) ||
+		    (of_translate_address(child_node, of_base1) == OF_BAD_ADDR))
+			continue;
+		of_base2 = of_get_address(child_node, 2, NULL, NULL);
+		if ((of_base2 == NULL) ||
+		    (of_translate_address(child_node, of_base2) == OF_BAD_ADDR))
+			continue;
+		evt_id_prop = of_get_property(child_node, "event-id", &prop_sz);
+		if (!evt_id_prop && (prop_sz != sizeof(*evt_id_prop)))
+			continue;
+
+		event_cnt++;
+		initdbgmsg("Found child %s/%s 0x%llx/0x%llx/0x%llx, ID:0x%x)\n",
+		       child_node->name, child_node->full_name,
+		       (long long)of_translate_address(child_node, of_base0),
+		       (long long)of_translate_address(child_node, of_base1),
+		       (long long)of_translate_address(child_node, of_base2),
+		       be32_to_cpu(*evt_id_prop));
+	}
+
+	/* allocate room for HEST */
+	size = sizeof(struct acpi_table_hest);
+	/* each error source is of type ACPI_HEST_TYPE_GENERIC_ERROR */
+	size += event_cnt * sizeof(struct acpi_hest_generic);
+	/* align event list on 8-byte boundary */
+	size = roundup(size, 8);
+
+	/* allocate room for list of available events */
+	size += event_cnt * sizeof(struct otx2_ghes_event);
+
+	/* allocate everything in one block, ordered as:
+	 *   HEST table
+	 *   event list
+	 */
+	memblock = kzalloc(size, GFP_KERNEL);
+	if (memblock == NULL) {
+		initerrmsg("Unable to allocate HEST & event memory (0x%lx B)\n",
+			   size);
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	/* HEST is at start of allocated block */
+	hest = memblock;
+
+	/* event table is after HEST */
+	size = sizeof(struct acpi_table_hest);
+	size += event_cnt * sizeof(struct acpi_hest_generic);
+	/* align event list on 8-byte boundary (see allocation above) */
+	size = roundup(size, 8);
+	event_list = memblock + size;
+
+	/* populate HEST header */
+	strncpy(hest->header.signature, ACPI_SIG_HEST,
+		sizeof(hest->header.signature));
+	hest->header.length =
+		sizeof(struct acpi_table_hest) +
+		       (event_cnt * sizeof(struct acpi_hest_generic));
+	hest->header.revision = 1;
+#define OTX2_HEST_OEM_ID "MRVL  "
+	strncpy(hest->header.oem_id, OTX2_HEST_OEM_ID,
+		sizeof(hest->header.oem_id));
+	strncpy(hest->header.oem_table_id, "OTX2    ",
+		sizeof(hest->header.oem_table_id));
+	hest->header.oem_revision = 1;
+	strncpy(hest->header.asl_compiler_id, OTX2_HEST_OEM_ID,
+		sizeof(hest->header.asl_compiler_id));
+	hest->header.asl_compiler_revision = 1;
+#pragma message "HEST checksum should be calculated"
+	hest->header.checksum = 0;
+
+	hest->error_source_count = event_cnt;
+
+	/* retrieve/init event IDs from DeviceTree & populate HEST entries */
+	idx = 0;
+	hest_gen_entry = (struct acpi_hest_generic *)(hest + 1);
+	for_each_available_child_of_node(of_node, child_node) {
+		of_base0 = of_get_address(child_node, 0, NULL, NULL);
+		if ((of_base0 == NULL) ||
+		    (of_translate_address(child_node, of_base0) == OF_BAD_ADDR))
+			continue;
+		of_base1 = of_get_address(child_node, 1, NULL, NULL);
+		if ((of_base1 == NULL) ||
+		    (of_translate_address(child_node, of_base1) == OF_BAD_ADDR))
+			continue;
+		of_base2 = of_get_address(child_node, 2, NULL, NULL);
+		if ((of_base2 == NULL) ||
+		    (of_translate_address(child_node, of_base2) == OF_BAD_ADDR))
+			continue;
+		evt_id_prop = of_get_property(child_node, "event-id", &prop_sz);
+		if (!evt_id_prop && (prop_sz != sizeof(*evt_id_prop)))
+			continue;
+
+		event = &event_list[idx];
+
+		/* name is already terminated by 'kzalloc' */
+		strncpy(event->name, child_node->name,
+			sizeof(event->name) - 1);
+		event->id = be32_to_cpu(*evt_id_prop);
+
+		hest_gen_entry->header.type = ACPI_HEST_TYPE_GENERIC_ERROR;
+		hest_gen_entry->header.source_id = idx;
+		hest_gen_entry->related_source_id =
+			hest_gen_entry->header.source_id;
+		hest_gen_entry->reserved = 0;
+		hest_gen_entry->enabled = 1;
+		hest_gen_entry->records_to_preallocate = 1;
+		hest_gen_entry->max_sections_per_record = 1;
+		hest_gen_entry->max_raw_data_length = 0;
+
+		hest_gen_entry->error_status_address.space_id =
+			ACPI_ADR_SPACE_SYSTEM_MEMORY;
+		hest_gen_entry->error_status_address.bit_width = 64;
+		hest_gen_entry->error_status_address.bit_offset = 0;
+		hest_gen_entry->error_status_address.access_width = 4;
+		hest_gen_entry->error_status_address.address =
+			of_translate_address(child_node, of_base0);
+
+		hest_gen_entry->notify.type = ACPI_HEST_NOTIFY_POLLED;
+		hest_gen_entry->notify.length = sizeof(hest_gen_entry->notify);
+		hest_gen_entry->notify.config_write_enable = 0;
+		hest_gen_entry->notify.poll_interval = 1000; /* i.e. 1 sec */
+		hest_gen_entry->notify.vector = event->id;
+		hest_gen_entry->notify.error_threshold_value = 1;
+		hest_gen_entry->notify.error_threshold_window = 1;
+
+		hest_gen_entry->error_block_length =
+			sizeof(struct acpi_hest_generic_status) +
+			sizeof(struct acpi_hest_generic_data) +
+			sizeof(struct cper_sec_mem_err_old);
+
+		event->estatus_address = phys_to_virt(
+				hest_gen_entry->error_status_address.address);
+		if (event->estatus_address == NULL) {
+			initerrmsg("Unable to access estatus_address 0x%llx\n",
+				   hest_gen_entry->error_status_address.address)
+				   ;
+			goto exit;
+		}
+
+		event->estatus_pa = of_translate_address(child_node, of_base1);
+		event->estatus = phys_to_virt(event->estatus_pa);
+		if (event->estatus == NULL) {
+			initerrmsg("Unable to access estatus block 0x%llx\n",
+				   of_translate_address(child_node, of_base1));
+			goto exit;
+		}
+
+		/* Event ring buffer in memory */
+		event->ring = phys_to_virt(of_translate_address(child_node,
+								of_base2));
+		if (event->ring == NULL) {
+			initerrmsg("Unable to access event 0x%x ring buffer\n",
+				   event->id);
+			goto exit;
+		}
+
+		/* clear status */
+		event->estatus->block_status = 0;
+
+		/* set event status address */
+		*event->estatus_address = event->estatus_pa;
+
+		idx++;
+		hest_gen_entry++;
+	}
+
+	if (idx != event_cnt) {
+		ret = -ENODEV;
+		goto exit;
+	}
+
+	initdbgmsg("%s: registering HEST\n", __func__);
+	hest_table_set(hest);
+	acpi_hest_init();
+
+	ret = 0;
+
+exit:
+	return ret;
+}
+
+/*
+ * Enable MSIX at the device level (MSIX_CAPABILITIES Header).
+ *
+ * NOTE: We SHOULD be able to use PCCPV_XXX_VSEC_SCTL[MSIX_SEC_EN]
+ * to enable our SECURE IRQs, but for errata PCC-34263...
+ */
+static void dev_enable_msix(struct pci_dev *pdev)
+{
+	u16 ctrl;
+
+	if ((pdev->msi_enabled) || (pdev->msix_enabled)) {
+		initerrmsg("MSI(%d) or MSIX(%d) already enabled\n",
+			    pdev->msi_enabled, pdev->msix_enabled);
+		return;
+	}
+
+	/* enable MSIX delivery for this device; we handle [secure] MSIX ints */
+	pdev->msix_cap = pci_find_capability(pdev, PCI_CAP_ID_MSIX);
+	if (pdev->msix_cap) {
+		pci_read_config_word(pdev, pdev->msix_cap + PCI_MSIX_FLAGS,
+				     &ctrl);
+		ctrl |= PCI_MSIX_FLAGS_ENABLE;
+		pci_write_config_word(pdev, pdev->msix_cap + PCI_MSIX_FLAGS,
+				      ctrl);
+		initdbgmsg("Set MSI-X Enable for PCI dev %04d:%02d.%d\n",
+			   pdev->bus->number, PCI_SLOT(pdev->devfn),
+			   PCI_FUNC(pdev->devfn));
+	} else {
+		initerrmsg("PCI dev %04d:%02d.%d missing MSIX capabilities\n",
+			   pdev->bus->number, PCI_SLOT(pdev->devfn),
+			   PCI_FUNC(pdev->devfn));
+	}
+}
+
+/* Driver entry point */
+static int __init sdei_ghes_driver_init(void)
+{
+	const struct pci_device_id *pdevid;
+	struct device_node *of_node;
+	struct pci_dev *pdev;
+	int i, rc;
+
+	initdbgmsg("%s: entry\n", __func__);
+
+	rc = -ENODEV;
+
+	of_node = of_find_matching_node_and_match(NULL, sdei_ghes_of_match,
+						  NULL);
+	if (!of_node)
+		return rc;
+
+	/* Initialize Hardware Error Source Table (HEST) */
+	rc = sdei_ghes_hest_init(of_node);
+	if (rc) {
+		initerrmsg("HEST initialization error %d\n", rc);
+		return rc;
+	}
+
+	platform_driver_register(&sdei_ghes_drv);
+	/* Enable MSIX for devices whose [secure] IRQ's we control.
+	 * These IRQs have been initialized by ATF.
+	 * This is required due to an errata against
+	 * PCCPV_XXX_VSEC_SCTL[MSIX_SEC_EN].
+	 */
+	for (i = 0; i < ARRAY_SIZE(sdei_ghes_otx2_pci_tbl); i++) {
+		pdevid = &sdei_ghes_otx2_pci_tbl[i];
+		pdev = NULL;
+		while ((pdev = pci_get_device(pdevid->vendor, pdevid->device,
+			pdev))) {
+			dev_enable_msix(pdev);
+		}
+	}
+
+	return rc;
+}
+
+device_initcall(sdei_ghes_driver_init);
+
+MODULE_DESCRIPTION("OcteonTX2 SDEI GHES Driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DRV_NAME);
+
diff --git a/drivers/soc/marvell/octeontx2-ghes/otx2-sdei-ghes.h b/drivers/soc/marvell/octeontx2-ghes/otx2-sdei-ghes.h
new file mode 100644
index 000000000000..f2f12f042722
--- /dev/null
+++ b/drivers/soc/marvell/octeontx2-ghes/otx2-sdei-ghes.h
@@ -0,0 +1,70 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Supports OcteonTX2 Generic Hardware Error Source[s] (GHES).
+ *
+ */
+
+#ifndef __OTX2_SDEI_GHES_H__
+#define __OTX2_SDEI_GHES_H__
+
+#define SDEI_GHES_EVENT_NAME_MAX_CHARS 16
+/*
+ * @estatus_pa:         physical address of error status information block
+ * @estatus_address:    mapped pointer to error_status_address
+ * @estatus:            mapped pointer to error status block
+ */
+struct otx2_ghes_event {
+	char                            name[SDEI_GHES_EVENT_NAME_MAX_CHARS];
+	u32                             id;
+	phys_addr_t                     estatus_pa;
+	phys_addr_t                     *estatus_address;
+	struct acpi_hest_generic_status *estatus;
+	struct otx2_ghes_err_ring       *ring;
+};
+
+/**
+ * struct otx2_sdei_ghes_drv: driver state
+ *
+ * @of_node:                  associated device tree node
+ * @event_list:               list of [SDEI] events
+ * @event_count:              count of [SDEI] events (size of @event_list)
+ */
+struct otx2_sdei_ghes_drv {
+	struct device_node                   *of_node;
+	struct otx2_ghes_event               *event_list;
+	size_t                               event_count;
+};
+
+#define OTX2_GHES_ERR_REC_FRU_TEXT_LEN 32
+/* This is shared with ATF */
+struct otx2_ghes_err_record {
+	union {
+		struct cper_sec_mem_err_old  mcc;
+		struct cper_sec_mem_err_old  mdc;
+		struct cper_sec_mem_err_old  lmc;
+		struct cper_arm_err_info     ap; /* application processor */
+	} u;
+	uint32_t                             severity; /* CPER_SEV_xxx */
+	char fru_text[OTX2_GHES_ERR_REC_FRU_TEXT_LEN];
+};
+
+/* This is shared with ATF */
+struct otx2_ghes_err_ring {
+	/* The head resides in DRAM & can be updated by ATF (i.e. firmware).
+	 * See Documentation/process/volatile-considered-harmful.rst, line 92.
+	 */
+	uint32_t volatile head;
+	uint32_t          tail;
+	uint32_t          size;       /* ring size */
+	/* ring of records */
+	struct otx2_ghes_err_record records[1] __aligned(8);
+};
+
+#endif // __OTX2_SDEI_GHES_H__
+
diff --git a/include/acpi/apei.h b/include/acpi/apei.h
index 680f80960c3d..5b821a003d7c 100644
--- a/include/acpi/apei.h
+++ b/include/acpi/apei.h
@@ -33,8 +33,10 @@ extern bool ghes_disable;
 
 #ifdef CONFIG_ACPI_APEI
 void __init acpi_hest_init(void);
+void __init hest_table_set(struct acpi_table_hest *table);
 #else
 static inline void acpi_hest_init(void) { return; }
+static inline void hest_table_set(struct acpi_table_hest *table) { return; }
 #endif
 
 typedef int (*apei_hest_func_t)(struct acpi_hest_header *hest_hdr, void *data);
-- 
2.31.1

