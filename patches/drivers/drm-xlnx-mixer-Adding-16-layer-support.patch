From 3379409960edf01e586bab6fa262bb491b7cbc95 Mon Sep 17 00:00:00 2001
From: Venkateshwar Rao Gannavarapu <venkateshwar.rao.gannavarapu@xilinx.com>
Date: Tue, 16 Apr 2019 13:40:18 -0700
Subject: [PATCH 0627/1852] drm: xlnx: mixer: Adding 16 layer support

commit 888547e957d18ebd3cffe6df9220d68746ca600b from
https://github.com/Xilinx/linux-xlnx.git

This patch adds 16 layer support with backward compatibility.

Signed-off-by: Venkateshwar Rao Gannavarapu <venkateshwar.rao.gannavarapu@xilinx.com>
Signed-off-by: Saurabh Sengar <saurabh.singh@xilinx.com>
Reviewed-by: Hyun Kwon <hyun.kwon@xilinx.com>
State: pending
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 drivers/gpu/drm/xlnx/xlnx_mixer.c | 223 ++++++++++++++++++------------
 1 file changed, 134 insertions(+), 89 deletions(-)

diff --git a/drivers/gpu/drm/xlnx/xlnx_mixer.c b/drivers/gpu/drm/xlnx/xlnx_mixer.c
index aaf62f6b074c..2daa4fda078f 100644
--- a/drivers/gpu/drm/xlnx/xlnx_mixer.c
+++ b/drivers/gpu/drm/xlnx/xlnx_mixer.c
@@ -74,15 +74,14 @@
 #define XVMIX_LOGOA_V_HIGH		0x40fff
 
 /************************** Constant Definitions *****************************/
-#define XVMIX_LOGO_EN			BIT(15)
-#define XVMIX_MASK_ENABLE_ALL_LAYERS	(GENMASK(8, 0) | XVMIX_LOGO_EN)
+#define XVMIX_LOGO_OFFSET		0x1000
 #define XVMIX_MASK_DISABLE_ALL_LAYERS   0x0
 #define XVMIX_REG_OFFSET                0x100
 #define XVMIX_MASTER_LAYER_IDX		0x0
 #define XVMIX_LOGO_LAYER_IDX		0x1
 #define XVMIX_DISP_MAX_WIDTH		4096
 #define XVMIX_DISP_MAX_HEIGHT		2160
-#define XVMIX_MAX_LAYERS		10
+#define XVMIX_MAX_OVERLAY_LAYERS	16
 #define XVMIX_MAX_BPC			16
 #define XVMIX_ALPHA_MIN			0
 #define XVMIX_ALPHA_MAX			256
@@ -144,8 +143,14 @@ static const u32 color_table[] = {
  * @XVMIX_LAYER_6: Layer 6
  * @XVMIX_LAYER_7: Layer 7
  * @XVMIX_LAYER_8: Layer 8
- * @XVMIX_LAYER_LOGO: Logo Layer
- * @XVMIX_LAYER_ALL: Layer count
+ * @XVMIX_LAYER_9: Layer 9
+ * @XVMIX_LAYER_10: Layer 10
+ * @XVMIX_LAYER_11: Layer 11
+ * @XVMIX_LAYER_12: Layer 12
+ * @XVMIX_LAYER_13: Layer 13
+ * @XVMIX_LAYER_14: Layer 14
+ * @XVMIX_LAYER_15: Layer 15
+ * @XVMIX_LAYER_16: Layer 16
  */
 enum xlnx_mix_layer_id {
 	XVMIX_LAYER_MASTER = 0,
@@ -157,8 +162,14 @@ enum xlnx_mix_layer_id {
 	XVMIX_LAYER_6,
 	XVMIX_LAYER_7,
 	XVMIX_LAYER_8,
-	XVMIX_LAYER_LOGO,
-	XVMIX_LAYER_ALL
+	XVMIX_LAYER_9,
+	XVMIX_LAYER_10,
+	XVMIX_LAYER_11,
+	XVMIX_LAYER_12,
+	XVMIX_LAYER_13,
+	XVMIX_LAYER_14,
+	XVMIX_LAYER_15,
+	XVMIX_LAYER_16
 };
 
 /**
@@ -186,7 +197,7 @@ enum xlnx_mix_layer_id {
  *  enable layer will be ignored.
  * @scale_fact: Current scaling factor applied to layer
  * @id: The logical layer id identifies which layer this struct describes
- *  (e.g. 0 = master, 1-7 = overlay).
+ *  (e.g. 0 = master, 1-15 = overlay).
  *
  * All mixer layers are reprsented by an instance of this struct:
  * output streaming, overlay, logo.
@@ -236,7 +247,7 @@ struct xlnx_mix_layer_data {
  * @max_layer_height: Max possible height for any layer on this Mixer
  * @max_logo_layer_width: Min possible width for any layer on this Mixer
  * @max_logo_layer_height: Min possible height for any layer on this Mixer
- * @max_layers: Max number of layers (excl: logo)
+ * @num_layers: Max number of layers (excl: logo)
  * @bg_layer_bpc: Bits per component for the background streaming layer
  * @dma_addr_size: dma address size in bits
  * @ppc: Pixels per component
@@ -244,6 +255,10 @@ struct xlnx_mix_layer_data {
  * @bg_color: Current RGB color value for internal background color generator
  * @layer_data: Array of layer data
  * @layer_cnt: Layer data array count
+ * @max_layers: Maximum number of layers supported by hardware
+ * @logo_layer_id: Index of logo layer
+ * @logo_en_mask: Mask used to enable logo layer
+ * @enable_all_mask: Mask used to enable all layers
  * @reset_gpio: GPIO line used to reset IP between modesetting operations
  * @intrpt_handler_fn: Interrupt handler function called when frame is completed
  * @intrpt_data: Data pointer passed to interrupt handler
@@ -262,7 +277,7 @@ struct xlnx_mix_hw {
 	u32                 max_layer_height;
 	u32                 max_logo_layer_width;
 	u32                 max_logo_layer_height;
-	u32                 max_layers;
+	u32                 num_layers;
 	u32                 bg_layer_bpc;
 	u32		    dma_addr_size;
 	u32                 ppc;
@@ -270,6 +285,10 @@ struct xlnx_mix_hw {
 	u64		    bg_color;
 	struct xlnx_mix_layer_data *layer_data;
 	u32 layer_cnt;
+	u32 max_layers;
+	u32 logo_layer_id;
+	u32 logo_en_mask;
+	u32 enable_all_mask;
 	struct gpio_desc *reset_gpio;
 	void (*intrpt_handler_fn)(void *);
 	void *intrpt_data;
@@ -542,12 +561,12 @@ static bool is_window_valid(struct xlnx_mix_hw *mixer, u32 x_pos, u32 y_pos,
 /**
  *  xlnx_mix_layer_enable - Enables the requested layers
  * @mixer: Mixer instance in which to enable a video layer
- * @id: Logical id (e.g. 8 = logo layer) to enable
+ * @id: Logical id (e.g. 16 = logo layer) to enable
  *
  * Enables (permit video output) for layers in mixer
  * Enables the layer denoted by id in the IP core.
  * Layer 0 will indicate the background layer and layer 8 the logo
- * layer. Passing in the enum value XVMIX_LAYER_ALL will enable all
+ * layer. Passing max layers value will enable all
  */
 static void xlnx_mix_layer_enable(struct xlnx_mix_hw *mixer,
 				  enum xlnx_mix_layer_id id)
@@ -569,15 +588,15 @@ static void xlnx_mix_layer_enable(struct xlnx_mix_hw *mixer,
 		return; /* for inactive layers silently return */
 
 	/* Check if request is to enable all layers or single layer */
-	if (id == XVMIX_LAYER_ALL) {
+	if (id == mixer->max_layers) {
 		reg_writel(mixer->base, XVMIX_LAYERENABLE_DATA,
-			   XVMIX_MASK_ENABLE_ALL_LAYERS);
+			   mixer->enable_all_mask);
 
-	} else if ((id < mixer->layer_cnt) ||
-		   ((id == XVMIX_LAYER_LOGO) && mixer->logo_layer_en)) {
+	} else if ((id < mixer->layer_cnt) || ((id == mixer->logo_layer_id) &&
+		   mixer->logo_layer_en)) {
 		curr_state = reg_readl(mixer->base, XVMIX_LAYERENABLE_DATA);
-		if (id == XVMIX_LAYER_LOGO)
-			curr_state |= XVMIX_LOGO_EN;
+		if (id == mixer->logo_layer_id)
+			curr_state |= mixer->logo_en_mask;
 		else
 			curr_state |= BIT(id);
 		reg_writel(mixer->base, XVMIX_LAYERENABLE_DATA, curr_state);
@@ -603,7 +622,7 @@ static void xlnx_mix_disp_layer_enable(struct xlnx_mix_plane *plane)
 	mixer_hw = to_mixer_hw(plane);
 	l_data = plane->mixer_layer;
 	id = l_data->id;
-	if (id < XVMIX_LAYER_MASTER  || id > XVMIX_LAYER_LOGO) {
+	if (id < XVMIX_LAYER_MASTER  || id > mixer_hw->logo_layer_id) {
 		DRM_DEBUG_KMS("Attempt to activate invalid layer: %d\n", id);
 		return;
 	}
@@ -616,11 +635,11 @@ static void xlnx_mix_disp_layer_enable(struct xlnx_mix_plane *plane)
 /**
  * xlnx_mix_layer_disable - Disables the requested layer
  * @mixer:  Mixer for which the layer will be disabled
- * @id: Logical id of the layer to be disabled (0-8)
+ * @id: Logical id of the layer to be disabled (0-16)
  *
  * Disables the layer denoted by layer_id in the IP core.
- * Layer 0 will indicate the background layer and layer 8 the logo
- * layer. Passing in the enum value XVMIX_LAYER_ALL will disable all
+ * Layer 0 will indicate the background layer and layer 16 the logo
+ * layer. Passing the value of max layers will disable all
  * layers.
  */
 static void xlnx_mix_layer_disable(struct xlnx_mix_hw *mixer,
@@ -630,14 +649,14 @@ static void xlnx_mix_layer_disable(struct xlnx_mix_hw *mixer,
 
 	num_layers = mixer->layer_cnt;
 
-	if (id == XVMIX_LAYER_ALL) {
+	if (id == mixer->max_layers) {
 		reg_writel(mixer->base, XVMIX_LAYERENABLE_DATA,
 			   XVMIX_MASK_DISABLE_ALL_LAYERS);
 	} else if ((id < num_layers) ||
-		   ((id == XVMIX_LAYER_LOGO) && (mixer->logo_layer_en))) {
+		   ((id == mixer->logo_layer_id) && (mixer->logo_layer_en))) {
 		curr_state = reg_readl(mixer->base, XVMIX_LAYERENABLE_DATA);
-		if (id == XVMIX_LAYER_LOGO)
-			curr_state &= ~XVMIX_LOGO_EN;
+		if (id == mixer->logo_layer_id)
+			curr_state &= ~(mixer->logo_en_mask);
 		else
 			curr_state &= ~(BIT(id));
 		reg_writel(mixer->base, XVMIX_LAYERENABLE_DATA, curr_state);
@@ -662,7 +681,8 @@ static void xlnx_mix_disp_layer_disable(struct xlnx_mix_plane *plane)
 	else
 		return;
 	layer_id = plane->mixer_layer->id;
-	if (layer_id < XVMIX_LAYER_MASTER  || layer_id > XVMIX_LAYER_LOGO)
+	if (layer_id < XVMIX_LAYER_MASTER  ||
+	    layer_id > mixer_hw->logo_layer_id)
 		return;
 
 	xlnx_mix_layer_disable(mixer_hw, layer_id);
@@ -847,22 +867,23 @@ static int xlnx_mix_get_layer_scaling(struct xlnx_mix_hw *mixer,
 	u32 reg;
 	struct xlnx_mix_layer_data *l_data = xlnx_mix_get_layer_data(mixer, id);
 
-	switch (id) {
-	case XVMIX_LAYER_LOGO:
+	if (id == mixer->logo_layer_id) {
 		if (mixer->logo_layer_en) {
-			reg = XVMIX_LOGOSCALEFACTOR_DATA;
+			if (mixer->max_layers > XVMIX_MAX_OVERLAY_LAYERS)
+				reg = XVMIX_LOGOSCALEFACTOR_DATA +
+					XVMIX_LOGO_OFFSET;
+			else
+				reg = XVMIX_LOGOSCALEFACTOR_DATA;
 			scale_factor = reg_readl(mixer->base, reg);
 			l_data->layer_regs.scale_fact = scale_factor;
 		}
-		break;
-
-	default: /*Layer0-Layer7*/
-		if (id < XVMIX_LAYER_LOGO && l_data->hw_config.can_scale) {
+	} else {
+		/*Layer0-Layer15*/
+		if (id < mixer->logo_layer_id && l_data->hw_config.can_scale) {
 			reg = XVMIX_LAYERSCALE_0_DATA + (id * XVMIX_REG_OFFSET);
 			scale_factor = reg_readl(mixer->base, reg);
 			l_data->layer_regs.scale_fact = scale_factor;
 		}
-		break;
 	}
 	return scale_factor;
 }
@@ -870,7 +891,7 @@ static int xlnx_mix_get_layer_scaling(struct xlnx_mix_hw *mixer,
 /**
  * xlnx_mix_set_layer_window - Sets the position of an overlay layer
  * @mixer: Specific mixer object instance controlling the video
- * @id: Logical layer id (1-7) to be positioned
+ * @id: Logical layer id (1-15) to be positioned
  * @x_pos: new: Column to start display of overlay layer
  * @y_pos: new: Row to start display of overlay layer
  * @width: Number of active columns to dislay for overlay layer
@@ -878,7 +899,7 @@ static int xlnx_mix_get_layer_scaling(struct xlnx_mix_hw *mixer,
  * @stride: Width in bytes of overaly memory buffer (memory layer only)
  *
  * Sets the position of an overlay layer over the background layer (layer 0)
- * Applicable only for layers 1-7 or the logo layer
+ * Applicable only for layers 1-15 or the logo layer
  *
  * Return:
  * Zero on success, -EINVAL if position is invalid or -ENODEV if layer
@@ -902,8 +923,7 @@ static int xlnx_mix_set_layer_window(struct xlnx_mix_hw *mixer,
 	if (!is_window_valid(mixer, x_pos, y_pos, width, height, scale))
 		return status;
 
-	switch (id) {
-	case XVMIX_LAYER_LOGO:
+	if (id == mixer->logo_layer_id) {
 		if (!(mixer->logo_layer_en &&
 		      width <= l_data->hw_config.max_width &&
 		      height <= l_data->hw_config.max_height &&
@@ -911,10 +931,17 @@ static int xlnx_mix_set_layer_window(struct xlnx_mix_hw *mixer,
 		      width >= l_data->hw_config.min_width))
 			return status;
 
-		x_reg = XVMIX_LOGOSTARTX_DATA;
-		y_reg = XVMIX_LOGOSTARTY_DATA;
-		w_reg = XVMIX_LOGOWIDTH_DATA;
-		h_reg = XVMIX_LOGOHEIGHT_DATA;
+		if (mixer->max_layers > XVMIX_MAX_OVERLAY_LAYERS) {
+			x_reg = XVMIX_LOGOSTARTX_DATA + XVMIX_LOGO_OFFSET;
+			y_reg = XVMIX_LOGOSTARTY_DATA + XVMIX_LOGO_OFFSET;
+			w_reg = XVMIX_LOGOWIDTH_DATA + XVMIX_LOGO_OFFSET;
+			h_reg = XVMIX_LOGOHEIGHT_DATA + XVMIX_LOGO_OFFSET;
+		} else {
+			x_reg = XVMIX_LOGOSTARTX_DATA;
+			y_reg = XVMIX_LOGOSTARTY_DATA;
+			w_reg = XVMIX_LOGOWIDTH_DATA;
+			h_reg = XVMIX_LOGOHEIGHT_DATA;
+		}
 		reg_writel(mixer->base, x_reg, x_pos);
 		reg_writel(mixer->base, y_reg, y_pos);
 		reg_writel(mixer->base, w_reg, width);
@@ -924,9 +951,8 @@ static int xlnx_mix_set_layer_window(struct xlnx_mix_hw *mixer,
 		l_data->layer_regs.width = width;
 		l_data->layer_regs.height = height;
 		status = 0;
-		break;
-
-	default: /*Layer1-Layer7*/
+	} else {
+		 /*Layer1-Layer15*/
 
 		if (!(id < mixer->layer_cnt &&
 		      width <= l_data->hw_config.max_width &&
@@ -951,7 +977,6 @@ static int xlnx_mix_set_layer_window(struct xlnx_mix_hw *mixer,
 		if (!l_data->hw_config.is_streaming)
 			reg_writel(mixer->base, (s_reg + off), stride);
 		status = 0;
-		break;
 	}
 	return status;
 }
@@ -1000,7 +1025,7 @@ static int xlnx_mix_set_layer_dimensions(struct xlnx_mix_plane *plane,
 			return ret;
 		xlnx_mix_layer_enable(mixer_hw, XVMIX_LAYER_MASTER);
 	}
-	if (layer_id != XVMIX_LAYER_MASTER && layer_id < XVMIX_LAYER_ALL) {
+	if (layer_id != XVMIX_LAYER_MASTER && layer_id < mixer_hw->max_layers) {
 		ret = xlnx_mix_set_layer_window(mixer_hw, layer_id, crtc_x,
 						crtc_y, width, height, stride);
 		if (ret)
@@ -1041,16 +1066,19 @@ static int xlnx_mix_set_layer_scaling(struct xlnx_mix_hw *mixer,
 	if (!is_window_valid(mixer, x_pos, y_pos, width, height, scale))
 		return -EINVAL;
 
-	switch (id) {
-	case XVMIX_LAYER_LOGO:
+	if (id == mixer->logo_layer_id) {
 		if (mixer->logo_layer_en) {
-			reg_writel(reg, XVMIX_LOGOSCALEFACTOR_DATA, scale);
+			if (mixer->max_layers > XVMIX_MAX_OVERLAY_LAYERS)
+				reg_writel(reg, XVMIX_LOGOSCALEFACTOR_DATA +
+					   XVMIX_LOGO_OFFSET, scale);
+			else
+				reg_writel(reg, XVMIX_LOGOSCALEFACTOR_DATA,
+					   scale);
 			l_data->layer_regs.scale_fact = scale;
 			status = 0;
 		}
-		break;
-
-	default: /* Layer0-Layer7 */
+	} else {
+		 /* Layer0-Layer15 */
 		if (id < mixer->layer_cnt && l_data->hw_config.can_scale) {
 			offset = id * XVMIX_REG_OFFSET;
 
@@ -1059,7 +1087,6 @@ static int xlnx_mix_set_layer_scaling(struct xlnx_mix_hw *mixer,
 			l_data->layer_regs.scale_fact = scale;
 			status = 0;
 		}
-		break;
 	}
 	return status;
 }
@@ -1119,17 +1146,19 @@ static int xlnx_mix_set_layer_alpha(struct xlnx_mix_hw *mixer,
 	int status = -EINVAL;
 
 	layer_data = xlnx_mix_get_layer_data(mixer, layer_id);
-	switch (layer_id) {
-	case XVMIX_LAYER_LOGO:
+
+	if (layer_id == mixer->logo_layer_id) {
 		if (mixer->logo_layer_en) {
-			reg = XVMIX_LOGOALPHA_DATA;
+			if (mixer->max_layers > XVMIX_MAX_OVERLAY_LAYERS)
+				reg = XVMIX_LOGOALPHA_DATA + XVMIX_LOGO_OFFSET;
+			else
+				reg = XVMIX_LOGOALPHA_DATA;
 			reg_writel(mixer->base, reg, alpha);
 			layer_data->layer_regs.alpha = alpha;
 			status = 0;
 		}
-		break;
-
-	default: /*Layer1-Layer7*/
+	} else {
+		 /*Layer1-Layer15*/
 		if (layer_id < mixer->layer_cnt &&
 		    layer_data->hw_config.can_alpha) {
 			u32 offset =  layer_id * XVMIX_REG_OFFSET;
@@ -1139,7 +1168,6 @@ static int xlnx_mix_set_layer_alpha(struct xlnx_mix_hw *mixer,
 			layer_data->layer_regs.alpha = alpha;
 			status = 0;
 		}
-		break;
 	}
 	return status;
 }
@@ -1432,7 +1460,7 @@ static int xlnx_mix_logo_load(struct xlnx_mix_hw *mixer, u32 logo_w, u32 logo_h,
 	u32 width, height, curr_x_pos, curr_y_pos;
 	u32 rbase_addr, gbase_addr, bbase_addr, abase_addr;
 
-	layer_data = xlnx_mix_get_layer_data(mixer, XVMIX_LAYER_LOGO);
+	layer_data = xlnx_mix_get_layer_data(mixer, mixer->logo_layer_id);
 	rword = 0;
 	gword = 0;
 	bword = 0;
@@ -1476,8 +1504,9 @@ static int xlnx_mix_logo_load(struct xlnx_mix_hw *mixer, u32 logo_w, u32 logo_h,
 
 	curr_x_pos = layer_data->layer_regs.x_pos;
 	curr_y_pos = layer_data->layer_regs.y_pos;
-	return xlnx_mix_set_layer_window(mixer, XVMIX_LAYER_LOGO, curr_x_pos,
-					 curr_y_pos, logo_w, logo_h, 0);
+	return xlnx_mix_set_layer_window(mixer, mixer->logo_layer_id,
+					 curr_x_pos, curr_y_pos,
+					 logo_w, logo_h, 0);
 }
 
 static int xlnx_mix_update_logo_img(struct xlnx_mix_plane *plane,
@@ -1485,6 +1514,7 @@ static int xlnx_mix_update_logo_img(struct xlnx_mix_plane *plane,
 				     u32 src_w, u32 src_h)
 {
 	struct xlnx_mix_layer_data *logo_layer = plane->mixer_layer;
+	struct xlnx_mix_hw *mixer = to_mixer_hw(plane);
 	size_t pixel_cnt = src_h * src_w;
 	/* color comp defaults to offset in RG24 buffer */
 	u32 pix_cmp_cnt;
@@ -1503,7 +1533,7 @@ static int xlnx_mix_update_logo_img(struct xlnx_mix_plane *plane,
 	int ret, i, j;
 
 	/* ensure valid conditions for update */
-	if (logo_layer->id != XVMIX_LAYER_LOGO)
+	if (logo_layer->id != mixer->logo_layer_id)
 		return 0;
 
 	if (src_h > max_height || src_w > max_width ||
@@ -1628,16 +1658,6 @@ static int xlnx_mix_set_plane(struct xlnx_mix_plane *plane,
 		return ret;
 
 	switch (layer_id) {
-	case XVMIX_LAYER_LOGO:
-		ret = xlnx_mix_update_logo_img(plane, luma_buffer,
-					       src_w, src_h);
-		if (ret)
-			break;
-
-		ret = xlnx_mix_set_layer_dimensions(plane, crtc_x, crtc_y,
-						    src_w, src_h, luma_stride);
-		break;
-
 	case XVMIX_LAYER_MASTER:
 		if (!plane->mixer_layer->hw_config.is_streaming)
 			xlnx_mix_mark_layer_inactive(plane);
@@ -1660,12 +1680,15 @@ static int xlnx_mix_set_plane(struct xlnx_mix_plane *plane,
 						    src_w, src_h, luma_stride);
 		if (ret)
 			break;
-
-		if (!plane->mixer_layer->hw_config.is_streaming)
-			ret = xlnx_mix_set_layer_buff_addr
-						(mixer_hw,
-						 plane->mixer_layer->id,
-						 luma_addr, chroma_addr);
+		if (layer_id == mixer_hw->logo_layer_id) {
+			ret = xlnx_mix_update_logo_img(plane, luma_buffer,
+						       src_w, src_h);
+		} else {
+			if (!plane->mixer_layer->hw_config.is_streaming)
+				ret = xlnx_mix_set_layer_buff_addr
+					(mixer_hw, plane->mixer_layer->id,
+					 luma_addr, chroma_addr);
+		}
 	}
 	return ret;
 }
@@ -1972,7 +1995,7 @@ static int xlnx_mix_parse_dt_logo_data(struct device_node *node,
 	layer_data->hw_config.can_scale = true;
 	layer_data->layer_regs.buff_addr1 = 0;
 	layer_data->layer_regs.buff_addr2 = 0;
-	layer_data->id = XVMIX_LAYER_LOGO;
+	layer_data->id = mixer_hw->logo_layer_id;
 
 	if (of_property_read_u32(logo_node, "xlnx,logo-width", &max_width)) {
 		DRM_ERROR("Failed to get logo width prop\n");
@@ -2041,13 +2064,26 @@ static int xlnx_mix_dt_parse(struct device *dev, struct xlnx_mix *mixer)
 		dev_err(dev, "Failed to map io mem space for mixer\n");
 		return PTR_ERR(mixer_hw->base);
 	}
+	if (of_device_is_compatible(dev->of_node, "xlnx,mixer-4.0")) {
+		mixer_hw->max_layers = 18;
+		mixer_hw->logo_en_mask = BIT(23);
+		mixer_hw->enable_all_mask = (GENMASK(16, 0) |
+						mixer_hw->logo_en_mask);
+	} else {
+		mixer_hw->max_layers = 10;
+		mixer_hw->logo_en_mask = BIT(15);
+		mixer_hw->enable_all_mask = (GENMASK(8, 0) |
+						mixer_hw->logo_en_mask);
+	}
+
 	ret = of_property_read_u32(node, "xlnx,num-layers",
-				   &mixer_hw->max_layers);
+				   &mixer_hw->num_layers);
 	if (ret) {
 		dev_err(dev, "No xlnx,num-layers dts prop for mixer node\n");
 		return ret;
 	}
-	if (mixer_hw->max_layers > XVMIX_MAX_LAYERS) {
+	mixer_hw->logo_layer_id = mixer_hw->max_layers - 1;
+	if (mixer_hw->num_layers > mixer_hw->max_layers) {
 		dev_err(dev, "Num layer nodes in device tree > mixer max\n");
 		return -EINVAL;
 	}
@@ -2076,7 +2112,7 @@ static int xlnx_mix_dt_parse(struct device *dev, struct xlnx_mix *mixer)
 
 	mixer_hw->logo_layer_en = of_property_read_bool(node,
 							"xlnx,logo-layer");
-	l_cnt = mixer_hw->max_layers + (mixer_hw->logo_layer_en ? 1 : 0);
+	l_cnt = mixer_hw->num_layers + (mixer_hw->logo_layer_en ? 1 : 0);
 	mixer_hw->layer_cnt = l_cnt;
 
 	l_data = devm_kzalloc(dev, sizeof(*l_data) * l_cnt, GFP_KERNEL);
@@ -2132,7 +2168,7 @@ static int xlnx_mix_of_init_layer(struct device *dev, struct device_node *node,
 		dev_err(dev, "xlnx,layer-id property not found\n");
 		return ret;
 	}
-	if (layer->id < 1 || layer->id >= XVMIX_MAX_LAYERS) {
+	if (layer->id < 1 || layer->id >= mixer->mixer_hw.max_layers) {
 		dev_err(dev, "Mixer layer id %u in dts is out of legal range\n",
 			layer->id);
 		return -EINVAL;
@@ -2235,7 +2271,7 @@ static int xlnx_mix_plane_create(struct device *dev, struct xlnx_mix *mixer)
 			return ret;
 	}
 	layer_idx = mixer_hw->logo_layer_en ? 2 : 1;
-	for (i = 1; i < mixer_hw->max_layers; i++, layer_idx++) {
+	for (i = 1; i < mixer_hw->num_layers; i++, layer_idx++) {
 		snprintf(name, sizeof(name), "layer_%d", i);
 		ret = xlnx_mix_of_init_layer(dev, node, name,
 					     &mixer_hw->layer_data[layer_idx],
@@ -2650,7 +2686,7 @@ static void xlnx_mix_init(struct xlnx_mix_hw *mixer)
 	struct xlnx_mix_layer_data *layer_data;
 
 	layer_data = xlnx_mix_get_layer_data(mixer, XVMIX_LAYER_MASTER);
-	xlnx_mix_layer_disable(mixer, XVMIX_LAYER_ALL);
+	xlnx_mix_layer_disable(mixer, mixer->max_layers);
 	xlnx_mix_set_active_area(mixer, layer_data->hw_config.max_width,
 				 layer_data->hw_config.max_height);
 	/* default to blue */
@@ -2754,8 +2790,17 @@ static int xlnx_mix_remove(struct platform_device *pdev)
 	return 0;
 }
 
+/*
+ * TODO:
+ * In Mixer IP core version 4.0, layer enable bits and logo layer offsets
+ * have been changed. To provide backward compatibility number of max layers
+ * field has been taken to differentiate IP versions.
+ * This logic will have to be changed properly using the IP core version.
+ */
+
 static const struct of_device_id xlnx_mix_of_match[] = {
 	{ .compatible = "xlnx,mixer-3.0", },
+	{ .compatible = "xlnx,mixer-4.0", },
 	{ /* end of table */ },
 };
 MODULE_DEVICE_TABLE(of, xlnx_mix_of_match);
-- 
2.31.1

