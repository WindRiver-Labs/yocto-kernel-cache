From ce7b2e316c22224b1133fd0c1b4d9e05beed5964 Mon Sep 17 00:00:00 2001
From: Rohit Athavale <rathaval@xilinx.com>
Date: Fri, 23 Feb 2018 11:15:09 -0800
Subject: [PATCH 0308/1852] v4l: xilinx-vpss-csc: Support for any-to-any color
 space converison

commit c8ddc22ac6315db8805b361f0905bae65007ea4d from
https://github.com/Xilinx/linux-xlnx.git

With this commit the driver supports RGB, YUV 444, YUV 422 and
YUV 420 media bus formats. This commit also updates the VPSS CSC
color controls for any-to-any conversion. VPSS CSC requires
coefficients to be brought into an RGB style of coefficients
before color controls can be applied and thus shadow coefficients
are used to track the color controls.

This commit extracts the color depth information from the
DT and uses it configuring the clip max and contrast. This
commit also allows the user to specify 8-bit or 10-bit color
depth via the DT.

Signed-off-by: Rohit Athavale <rathaval@xilinx.com>
Reviewed-by: Hyun Kwon <hyun.kwon@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
State: pending
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 .../media/platform/xilinx/xilinx-vpss-csc.c   | 553 ++++++++++++------
 1 file changed, 390 insertions(+), 163 deletions(-)

diff --git a/drivers/media/platform/xilinx/xilinx-vpss-csc.c b/drivers/media/platform/xilinx/xilinx-vpss-csc.c
index b9689c24ee7c..b8a18f429f19 100644
--- a/drivers/media/platform/xilinx/xilinx-vpss-csc.c
+++ b/drivers/media/platform/xilinx/xilinx-vpss-csc.c
@@ -44,7 +44,6 @@
 #define XV_CSC_FRACTIONAL_BITS	(12)
 #define XV_CSC_SCALE_FACTOR	(4096)
 /* This a VPSS CSC specific macro used to calculate Contrast */
-#define XV_CSC_RGB_OFFSET_WR(x)	(((x) >> 12) & 0x3FF)
 #define XV_CSC_DIVISOR		(10000)
 #define XV_CSC_DEFAULT_HEIGHT	(720)
 #define XV_CSC_DEFAULT_WIDTH	(1280)
@@ -58,6 +57,9 @@
 #define XCSC_AP_START		BIT(0)
 #define XCSC_AP_AUTO_RESTART	BIT(7)
 #define XCSC_STREAM_ON	(XCSC_AP_START | XCSC_AP_AUTO_RESTART)
+/* Color Control Macros */
+#define XCSC_COLOR_CTRL_COUNT		(5)
+#define XCSC_COLOR_CTRL_DEFAULT		(50)
 
 enum xcsc_color_fmt {
 	XVIDC_CSF_RGB = 0,
@@ -73,9 +75,89 @@ enum xcsc_output_range {
 };
 
 enum xcsc_color_depth {
-	XVIDC_BPC_8 = 8
+	XVIDC_BPC_8 = 8,
+	XVIDC_BPC_10 = 10,
 };
 
+static const s32
+rgb_unity_matrix[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1] = {
+	{XV_CSC_SCALE_FACTOR, 0, 0, 0},
+	{0, XV_CSC_SCALE_FACTOR, 0, 0},
+	{0, 0, XV_CSC_SCALE_FACTOR, 0},
+};
+
+static const s32
+ycrcb_to_rgb_unity[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1] = {
+	{
+	 11644 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR,
+	 0,
+	 17927 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR,
+	 0
+	},
+	{
+	 11644 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR,
+	 -2132 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR,
+	 -5329 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR,
+	 0
+	},
+	{
+	 11644 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR,
+	 21124 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR,
+	 0,
+	 0
+	},
+};
+
+static const s32
+rgb_to_ycrcb_unity[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1] = {
+	{
+	 1826 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR,
+	 6142 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR,
+	 620 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR,
+	 0
+	},
+	{
+	 -1006 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR,
+	 -3386 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR,
+	 4392 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR,
+	 0
+	},
+	{
+	 4392 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR,
+	 -3989 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR,
+	 -403 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR,
+	 0,
+	},
+};
+
+/**
+ * struct xcsc_dev - xilinx vpss csc device structure
+ * @xvip: Xilinx Video IP core struct
+ * @pads: Media bus pads for VPSS CSC
+ * @formats: Current media bus formats
+ * @default_formats: Default media bus formats for VPSS CSC
+ * @vip_formats: Pointer to DT specified media bus code info
+ * @ctrl_handler: V4L2 Control Handler struct
+ * @custom_ctrls: Array of pointers to various custom controls
+ * @cft_in: IP or Hardware specific input video format
+ * @cft_out: IP or Hardware specific output video format
+ * @output_range: Color range for Outgoing video
+ * @color_depth: Data width used to represent color
+ * @brightness: Expected brightness value
+ * @contrast: Expected contrast value
+ * @red_gain: Expected red gain
+ * @green_gain: Expect green gain
+ * @blue_gain: Expected blue gain
+ * @brightness_active: Current brightness value
+ * @contrast_active: Current contrast value
+ * @red_gain_active: Current red gain
+ * @green_gain_active: Current green gain
+ * @blue_gain_active: Current blue gain
+ * @k_hw : Coefficients to be written to IP/Hardware
+ * @shadow_coeff: Coefficients to track RGB equivalents for color controls
+ * @clip_max: Maximum value to clip output color range
+ * @rst_gpio: Handle to PS GPIO specifier to assert/de-assert the reset line
+ */
 struct xcsc_dev {
 	struct xvip_device xvip;
 	struct media_pad pads[2];
@@ -83,6 +165,7 @@ struct xcsc_dev {
 	struct v4l2_mbus_framefmt default_formats[2];
 	const struct xvip_video_format *vip_formats[2];
 	struct v4l2_ctrl_handler ctrl_handler;
+	struct v4l2_ctrl *custom_ctrls[XCSC_COLOR_CTRL_COUNT];
 
 	enum xcsc_color_fmt cft_in;
 	enum xcsc_color_fmt cft_out;
@@ -98,7 +181,8 @@ struct xcsc_dev {
 	s32 red_gain_active;
 	s32 green_gain_active;
 	s32 blue_gain_active;
-	s32 k_hw[3][4];
+	s32 k_hw[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1];
+	s32 shadow_coeff[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1];
 	s32 clip_max;
 	struct gpio_desc *rst_gpio;
 };
@@ -109,8 +193,6 @@ static u32 xcsc_read(struct xcsc_dev *xcsc, u32 reg)
 	u32 data;
 
 	data = xvip_read(&xcsc->xvip, reg);
-	dev_dbg(xcsc->xvip.dev,
-		"Reading 0x%x from register offset 0x%x", data, reg);
 	return data;
 }
 
@@ -158,41 +240,37 @@ static void xcsc_print_coeff(struct xcsc_dev *xcsc)
 		 "-------------CSC Coeff Dump Stop-------\n");
 }
 
+static void
+xcsc_log_coeff(struct device *dev,
+	       s32 coeff[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1])
+{
+	if (!dev)
+		return;
+	dev_dbg(dev, "--- %s : Start Coeff Log ---", __func__);
+	dev_dbg(dev, "R row : %5d  %5d  %5d\n",
+		coeff[0][0], coeff[0][1], coeff[0][2]);
+	dev_dbg(dev, "G row : %5d  %5d  %5d\n",
+		coeff[1][0], coeff[1][1], coeff[1][2]);
+	dev_dbg(dev, "B row : %5d  %5d  %5d\n",
+		coeff[2][0], coeff[2][1], coeff[2][2]);
+	dev_dbg(dev, "Offset: %5d  %5d  %5d\n",
+		coeff[0][3], coeff[1][3], coeff[2][3]);
+	dev_dbg(dev, "---  %s : Stop Coeff Log ---", __func__);
+}
+
 static void xcsc_print_k_hw(struct xcsc_dev *xcsc)
 {
-	dev_info(xcsc->xvip.dev, "-------------CSC Driver k_hw[][] Dump------------\n");
-	dev_info(xcsc->xvip.dev, "k_hw[0][x] R row : %5d  %5d  %5d\n",
-		 xcsc->k_hw[0][0],  xcsc->k_hw[0][1],  xcsc->k_hw[0][2]);
-	dev_info(xcsc->xvip.dev, "k_hw[1][x] G row : %5d  %5d  %5d\n",
-		 xcsc->k_hw[1][0],  xcsc->k_hw[1][1],  xcsc->k_hw[1][2]);
-	dev_info(xcsc->xvip.dev, "k_hw[2][x] B row : %5d  %5d  %5d\n",
-		 xcsc->k_hw[2][0],  xcsc->k_hw[2][1],  xcsc->k_hw[2][2]);
-	dev_info(xcsc->xvip.dev, "k_hw[x][3] Offset : %5d  %5d  %5d\n",
-		 xcsc->k_hw[0][3],  xcsc->k_hw[1][3],  xcsc->k_hw[2][3]);
-	dev_info(xcsc->xvip.dev, "-------------------------------------------------\n");
+	dev_dbg(xcsc->xvip.dev,
+		"-------------CSC Driver k_hw[][] Dump------------\n");
+	xcsc_log_coeff(xcsc->xvip.dev, xcsc->k_hw);
+	dev_dbg(xcsc->xvip.dev,
+		"-------------------------------------------------\n");
 }
 #endif /* DEBUG */
 
 static void xcsc_write(struct xcsc_dev *xcsc, u32 reg, u32 data)
 {
-	dev_dbg(xcsc->xvip.dev,
-		"Writing 0x%x to register offset 0x%x", data, reg);
 	xvip_write(&xcsc->xvip, reg, data);
-#ifdef DEBUG
-	/*
-	 * The IP registers are only 16 bit in width.
-	 * Reg[16:31] are reserved.
-	 * This comes in handy, when matrix mulitplications with
-	 * signed coefficients need debugging
-	 */
-	if (xcsc_read(xcsc, reg) != data) {
-		dev_info(xcsc->xvip.dev,
-			 "Wrote 0x%x does not match read back reg 0x%x",
-			 data, reg);
-		xcsc_print_k_hw(xcsc);
-		xcsc_print_coeff(xcsc);
-	}
-#endif
 }
 
 static void xcsc_write_rgb_3x3(struct xcsc_dev *xcsc)
@@ -223,9 +301,69 @@ static void xcsc_write_coeff(struct xcsc_dev *xcsc)
 	xcsc_write_rgb_offset(xcsc);
 }
 
-static void xcsc_ycrcb_to_rgb(struct xcsc_dev *xcsc, s32 *clip_max)
+static void xcsc_set_v4l2_ctrl_defaults(struct xcsc_dev *xcsc)
+{
+	unsigned int i;
+
+	mutex_lock(xcsc->ctrl_handler.lock);
+	for (i = 0; i < XCSC_COLOR_CTRL_COUNT; i++)
+		xcsc->custom_ctrls[i]->cur.val = XCSC_COLOR_CTRL_DEFAULT;
+	mutex_unlock(xcsc->ctrl_handler.lock);
+}
+
+static void xcsc_set_control_defaults(struct xcsc_dev *xcsc)
+{
+	/* These are VPSS CSC IP specific defaults */
+	xcsc->brightness = 120;
+	xcsc->contrast = 0;
+	xcsc->red_gain = 120;
+	xcsc->blue_gain = 120;
+	xcsc->green_gain = 120;
+	xcsc->brightness_active	= 120;
+	xcsc->contrast_active = 0;
+	xcsc->red_gain_active = 120;
+	xcsc->blue_gain_active = 120;
+	xcsc->green_gain_active = 120;
+}
+
+static void xcsc_copy_coeff(
+	s32 dest[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1],
+	s32 const src[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1])
 {
-	u16 bpc_scale = (1 << (xcsc->color_depth - 8));
+	unsigned int i, j;
+
+	for (i = 0; i < XV_CSC_K_MAX_ROWS; i++)
+		for (j = 0; j < XV_CSC_K_MAX_COLUMNS + 1; j++)
+			memcpy(&dest[i][j], &src[i][j], sizeof(dest[0][0]));
+}
+
+static void xcsc_set_unity_matrix(struct xcsc_dev *xcsc)
+{
+	xcsc_copy_coeff(xcsc->k_hw, rgb_unity_matrix);
+	xcsc_copy_coeff(xcsc->shadow_coeff, rgb_unity_matrix);
+}
+
+static void xcsc_set_default_state(struct xcsc_dev *xcsc)
+{
+	xcsc->cft_in = XVIDC_CSF_RGB;
+	xcsc->cft_out = XVIDC_CSF_RGB;
+	xcsc->output_range = XVIDC_CR_0_255;
+	/* Needed to add 10, 12 and 16 bit color depth support */
+	xcsc->clip_max = BIT(xcsc->color_depth) - 1;
+	xcsc_set_control_defaults(xcsc);
+	xcsc_set_unity_matrix(xcsc);
+	xcsc_write(xcsc, XV_CSC_INVIDEOFORMAT, xcsc->cft_in);
+	xcsc_write(xcsc, XV_CSC_OUTVIDEOFORMAT, xcsc->cft_out);
+	xcsc_write_coeff(xcsc);
+	xcsc_write(xcsc, XV_CSC_CLIPMAX, xcsc->clip_max);
+	xcsc_write(xcsc, XV_CSC_CLAMPMIN, XCSC_CLAMP_MIN_ZERO);
+}
+
+static void
+xcsc_ycrcb_to_rgb(struct xcsc_dev *xcsc, s32 *clip_max,
+		  s32 temp[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1])
+{
+	u16 bpc_scale = BIT(xcsc->color_depth - 8);
 
 	/*
 	 * See http://graficaobscura.com/matrix/index.html for
@@ -238,24 +376,49 @@ static void xcsc_ycrcb_to_rgb(struct xcsc_dev *xcsc, s32 *clip_max)
 	 *
 	 * Coefficients valid only for BT 709
 	 */
-	xcsc->k_hw[0][0] = 11644 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR;
-	xcsc->k_hw[0][1] = 0;
-	xcsc->k_hw[0][2] = 17927 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR;
-	xcsc->k_hw[1][0] = 11644 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR;
-	xcsc->k_hw[1][1] = -2132 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR;
-	xcsc->k_hw[1][2] = -5329 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR;
-	xcsc->k_hw[2][0] = 11644 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR;
-	xcsc->k_hw[2][1] = 21124 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR;
-	xcsc->k_hw[2][2] = 0;
-	xcsc->k_hw[0][3] = -248 * bpc_scale;
-	xcsc->k_hw[1][3] = 77 * bpc_scale;
-	xcsc->k_hw[2][3] = -289 * bpc_scale;
-	*clip_max = ((1 <<  xcsc->color_depth) - 1);
+	dev_dbg(xcsc->xvip.dev, "Performing YCrCb to RGB BT 709");
+	xcsc_copy_coeff(temp, ycrcb_to_rgb_unity);
+	temp[0][3] = -248 * bpc_scale;
+	temp[1][3] = 77 * bpc_scale;
+	temp[2][3] = -289 * bpc_scale;
+	*clip_max = BIT(xcsc->color_depth) - 1;
 }
 
-static void xcsc_rgb_to_ycrcb(struct xcsc_dev *xcsc, s32 *clip_max)
+static void
+xcsc_matrix_multiply(s32 K1[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1],
+		     s32 K2[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1],
+		     s32 kout[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1])
 {
-	u16 bpc_scale = (1 << (xcsc->color_depth - 8));
+	s32 A, B, C, D, E, F, G, H, I, J, K, L, M, N;
+	s32 O, P, Q, R, S, T, U, V, W, X;
+
+	A = K1[0][0]; B = K1[0][1]; C = K1[0][2]; J = K1[0][3];
+	D = K1[1][0]; E = K1[1][1]; F = K1[1][2]; K = K1[1][3];
+	G = K1[2][0]; H = K1[2][1]; I = K1[2][2]; L = K1[2][3];
+
+	M = K2[0][0]; N = K2[0][1]; O = K2[0][2]; V = K2[0][3];
+	P = K2[1][0]; Q = K2[1][1]; R = K2[1][2]; W = K2[1][3];
+	S = K2[2][0]; T = K2[2][1]; U = K2[2][2]; X = K2[2][3];
+
+	kout[0][0] = (M * A + N * D + O * G) / XV_CSC_SCALE_FACTOR;
+	kout[0][1] = (M * B + N * E + O * H) / XV_CSC_SCALE_FACTOR;
+	kout[0][2] = (M * C + N * F + O * I) / XV_CSC_SCALE_FACTOR;
+	kout[1][0] = (P * A + Q * D + R * G) / XV_CSC_SCALE_FACTOR;
+	kout[1][1] = (P * B + Q * E + R * H) / XV_CSC_SCALE_FACTOR;
+	kout[1][2] = (P * C + Q * F + R * I) / XV_CSC_SCALE_FACTOR;
+	kout[2][0] = (S * A + T * D + U * G) / XV_CSC_SCALE_FACTOR;
+	kout[2][1] = (S * B + T * E + U * H) / XV_CSC_SCALE_FACTOR;
+	kout[2][2] = (S * C + T * F + U * I) / XV_CSC_SCALE_FACTOR;
+	kout[0][3] = ((M * J + N * K + O * L) / XV_CSC_SCALE_FACTOR) + V;
+	kout[1][3] = ((P * J + Q * K + R * L) / XV_CSC_SCALE_FACTOR) + W;
+	kout[2][3] = ((S * J + T * K + U * L) / XV_CSC_SCALE_FACTOR) + X;
+}
+
+static void
+xcsc_rgb_to_ycrcb(struct xcsc_dev *xcsc, s32 *clip_max,
+		  s32 temp[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1])
+{
+	u16 bpc_scale = BIT(xcsc->color_depth - 8);
 
 	/*
 	 * See http://graficaobscura.com/matrix/index.html for
@@ -269,22 +432,14 @@ static void xcsc_rgb_to_ycrcb(struct xcsc_dev *xcsc, s32 *clip_max)
 	 * Coefficients valid only for BT 709
 	 */
 	dev_dbg(xcsc->xvip.dev, "Performing RGB to YCrCb BT 709");
-	xcsc->k_hw[0][0] = 1826 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR;
-	xcsc->k_hw[0][1] = 6142 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR;
-	xcsc->k_hw[0][2] = 620 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR;
-	xcsc->k_hw[1][0] = -1006 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR;
-	xcsc->k_hw[1][1] = -3386 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR;
-	xcsc->k_hw[1][2] = 4392 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR;
-	xcsc->k_hw[2][0] = 4392 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR;
-	xcsc->k_hw[2][1] = -3989 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR;
-	xcsc->k_hw[2][2] = -403 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR;
-	xcsc->k_hw[0][3] = 16 * bpc_scale;
-	xcsc->k_hw[1][3] = 128 * bpc_scale;
-	xcsc->k_hw[2][3] = 128 * bpc_scale;
-	*clip_max = ((1 <<  xcsc->color_depth) - 1);
-}
-
-static int xcsc_set_coeff(struct xcsc_dev *xcsc)
+	xcsc_copy_coeff(temp, rgb_to_ycrcb_unity);
+	temp[0][3] = 16 * bpc_scale;
+	temp[1][3] = 128 * bpc_scale;
+	temp[2][3] = 128 * bpc_scale;
+	*clip_max = BIT(xcsc->color_depth) - 1;
+}
+
+static int xcsc_update_formats(struct xcsc_dev *xcsc)
 {
 	u32 color_in, color_out;
 
@@ -305,6 +460,10 @@ static int xcsc_set_coeff(struct xcsc_dev *xcsc)
 		dev_dbg(xcsc->xvip.dev, "Media Format In : YUV 422");
 		xcsc->cft_in = XVIDC_CSF_YCRCB_422;
 		break;
+	case MEDIA_BUS_FMT_VYYUYY8_1X24:
+		dev_dbg(xcsc->xvip.dev, "Media Format In : YUV 420");
+		xcsc->cft_in = XVIDC_CSF_YCRCB_420;
+		break;
 	}
 
 	switch (color_out) {
@@ -312,19 +471,33 @@ static int xcsc_set_coeff(struct xcsc_dev *xcsc)
 		xcsc->cft_out = XVIDC_CSF_RGB;
 		dev_dbg(xcsc->xvip.dev, "Media Format Out : RGB");
 		if (color_in != MEDIA_BUS_FMT_RBG888_1X24)
-			xcsc_ycrcb_to_rgb(xcsc, &xcsc->clip_max);
+			xcsc_ycrcb_to_rgb(xcsc, &xcsc->clip_max, xcsc->k_hw);
+		else
+			xcsc_set_unity_matrix(xcsc);
 		break;
 	case MEDIA_BUS_FMT_VUY8_1X24:
 		xcsc->cft_out = XVIDC_CSF_YCRCB_444;
 		dev_dbg(xcsc->xvip.dev, "Media Format Out : YUV 444");
 		if (color_in == MEDIA_BUS_FMT_RBG888_1X24)
-			xcsc_rgb_to_ycrcb(xcsc, &xcsc->clip_max);
+			xcsc_rgb_to_ycrcb(xcsc, &xcsc->clip_max, xcsc->k_hw);
+		else
+			xcsc_set_unity_matrix(xcsc);
 		break;
 	case MEDIA_BUS_FMT_UYVY8_1X16:
 		xcsc->cft_out = XVIDC_CSF_YCRCB_422;
 		dev_dbg(xcsc->xvip.dev, "Media Format Out : YUV 422");
 		if (color_in == MEDIA_BUS_FMT_RBG888_1X24)
-			xcsc_rgb_to_ycrcb(xcsc, &xcsc->clip_max);
+			xcsc_rgb_to_ycrcb(xcsc, &xcsc->clip_max, xcsc->k_hw);
+		else
+			xcsc_set_unity_matrix(xcsc);
+		break;
+	case MEDIA_BUS_FMT_VYYUYY8_1X24:
+		xcsc->cft_out = XVIDC_CSF_YCRCB_420;
+		dev_dbg(xcsc->xvip.dev, "Media Format Out : YUV 420");
+		if (color_in ==  MEDIA_BUS_FMT_RBG888_1X24)
+			xcsc_rgb_to_ycrcb(xcsc, &xcsc->clip_max, xcsc->k_hw);
+		else
+			xcsc_set_unity_matrix(xcsc);
 		break;
 	}
 
@@ -336,6 +509,7 @@ static int xcsc_set_coeff(struct xcsc_dev *xcsc)
 	xcsc_write(xcsc, XV_CSC_CLIPMAX, xcsc->clip_max);
 	xcsc_write(xcsc, XV_CSC_CLAMPMIN, XCSC_CLAMP_MIN_ZERO);
 #ifdef DEBUG
+	xcsc_print_k_hw(xcsc);
 	xcsc_print_coeff(xcsc);
 #endif
 	return 0;
@@ -361,51 +535,48 @@ __xcsc_get_pad_format(struct xcsc_dev *xcsc,
 	}
 }
 
-static void xcsc_set_default_state(struct xcsc_dev *xcsc)
+static void
+xcsc_correct_coeff(struct xcsc_dev *xcsc,
+		   s32 temp[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1])
 {
-	xcsc->cft_in = XVIDC_CSF_RGB;
-	xcsc->cft_out = XVIDC_CSF_RGB;
-	xcsc->output_range = XVIDC_CR_0_255;
-	/* Needed to add 10,12 and 16 bit color depth support */
-	xcsc->color_depth = XVIDC_BPC_8;
-	/* These are VPSS CSC IP specific defaults */
-	xcsc->brightness = 120;
-	xcsc->contrast = 0;
-	xcsc->red_gain = 120;
-	xcsc->blue_gain = 120;
-	xcsc->green_gain = 120;
-	xcsc->brightness_active	= 120;
-	xcsc->contrast_active = 0;
-	xcsc->red_gain_active = 120;
-	xcsc->blue_gain_active = 120;
-	xcsc->green_gain_active = 120;
-	/* This represents an identity matrix mutliped by 2^12 */
-	xcsc->k_hw[0][0] = XV_CSC_SCALE_FACTOR;
-	xcsc->k_hw[0][1] = 0;
-	xcsc->k_hw[0][2] = 0;
-	xcsc->k_hw[1][0] = 0;
-	xcsc->k_hw[1][1] = XV_CSC_SCALE_FACTOR;
-	xcsc->k_hw[1][2] = 0;
-	xcsc->k_hw[2][0] = 0;
-	xcsc->k_hw[2][1] = 0;
-	xcsc->k_hw[2][2] = XV_CSC_SCALE_FACTOR;
-	xcsc->k_hw[0][3] = 0;
-	xcsc->k_hw[1][3] = 0;
-	xcsc->k_hw[2][3] = 0;
-	xcsc->clip_max = ((1 << xcsc->color_depth) - 1);
+	s32 csc_change[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1] = { {0} };
+	s32 csc_extra[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1] = { {0} };
+	u32 mbus_in = xcsc->formats[XVIP_PAD_SINK].code;
+	u32 mbus_out = xcsc->formats[XVIP_PAD_SOURCE].code;
 
-	xcsc_write(xcsc, XV_CSC_INVIDEOFORMAT, xcsc->cft_in);
-	xcsc_write(xcsc, XV_CSC_OUTVIDEOFORMAT, xcsc->cft_out);
-
-	xcsc_write_coeff(xcsc);
-
-	xcsc_write(xcsc, XV_CSC_CLIPMAX, xcsc->clip_max);
-	xcsc_write(xcsc, XV_CSC_CLAMPMIN, XCSC_CLAMP_MIN_ZERO);
+#ifdef DEBUG
+	xcsc_log_coeff(xcsc->xvip.dev, temp);
+#endif
+	if (mbus_in == MEDIA_BUS_FMT_RBG888_1X24 && mbus_out == mbus_in) {
+		dev_dbg(xcsc->xvip.dev, "%s : RGB to RGB", __func__);
+		xcsc_copy_coeff(xcsc->k_hw,
+				(const s32 (*)[XV_CSC_K_MAX_COLUMNS + 1])temp);
+	} else if (mbus_in == MEDIA_BUS_FMT_RBG888_1X24 &&
+		   mbus_out != MEDIA_BUS_FMT_RBG888_1X24) {
+		dev_dbg(xcsc->xvip.dev, "%s : RGB to YUV", __func__);
+		xcsc_rgb_to_ycrcb(xcsc, &xcsc->clip_max, csc_change);
+		xcsc_matrix_multiply(temp, csc_change, xcsc->k_hw);
+	} else if (mbus_in != MEDIA_BUS_FMT_RBG888_1X24 &&
+		   mbus_out == MEDIA_BUS_FMT_RBG888_1X24) {
+		dev_dbg(xcsc->xvip.dev, "%s : YUV to RGB", __func__);
+		xcsc_ycrcb_to_rgb(xcsc, &xcsc->clip_max, csc_change);
+		xcsc_matrix_multiply(csc_change, temp, xcsc->k_hw);
+	} else if (mbus_in != MEDIA_BUS_FMT_RBG888_1X24 &&
+		   mbus_out != MEDIA_BUS_FMT_RBG888_1X24) {
+		dev_dbg(xcsc->xvip.dev, "%s : YUV to YUV", __func__);
+		xcsc_ycrcb_to_rgb(xcsc, &xcsc->clip_max, csc_change);
+		xcsc_matrix_multiply(csc_change, temp, csc_extra);
+		xcsc_rgb_to_ycrcb(xcsc, &xcsc->clip_max, csc_change);
+		xcsc_matrix_multiply(csc_extra, csc_change, xcsc->k_hw);
+	} else {
+		/* Should never get here */
+		WARN_ON(1);
+	}
 }
 
 static void xcsc_set_brightness(struct xcsc_dev *xcsc)
 {
-	int i, j;
+	unsigned int i, j;
 
 	dev_dbg(xcsc->xvip.dev,
 		"%s : Brightness %d Brightness Active %d",
@@ -416,32 +587,35 @@ static void xcsc_set_brightness(struct xcsc_dev *xcsc)
 		return;
 	for (i = 0; i < XV_CSC_K_MAX_ROWS; i++) {
 		for (j = 0; j < XV_CSC_K_MAX_COLUMNS; j++) {
-			xcsc->k_hw[i][j] =
-			((xcsc->k_hw[i][j] * xcsc->brightness) /
-					xcsc->brightness_active);
+			xcsc->shadow_coeff[i][j] = (xcsc->shadow_coeff[i][j] *
+						    xcsc->brightness) /
+						    xcsc->brightness_active;
 		}
 	}
 	xcsc->brightness_active = xcsc->brightness;
-	xcsc_write_rgb_3x3(xcsc);
+	xcsc_correct_coeff(xcsc, xcsc->shadow_coeff);
+	xcsc_write_coeff(xcsc);
 }
 
 static void xcsc_set_contrast(struct xcsc_dev *xcsc)
 {
 	s32 contrast;
+	u8 scale = BIT(xcsc->color_depth - 8);
 
 	contrast = xcsc->contrast - xcsc->contrast_active;
 	dev_dbg(xcsc->xvip.dev,
-		"%s : Contrast Difference %d", __func__, contrast);
-
+		"%s : Contrast Difference %d scale = %d",
+		__func__, contrast, scale);
+	/* Avoid updates if same */
+	if (!contrast)
+		return;
 	/* Update RGB Offsets */
-	xcsc->k_hw[0][3] +=
-		XV_CSC_RGB_OFFSET_WR(contrast * XV_CSC_SCALE_FACTOR);
-	xcsc->k_hw[1][3] +=
-		XV_CSC_RGB_OFFSET_WR(contrast * XV_CSC_SCALE_FACTOR);
-	xcsc->k_hw[2][3] +=
-		XV_CSC_RGB_OFFSET_WR(contrast * XV_CSC_SCALE_FACTOR);
+	xcsc->shadow_coeff[0][3] += contrast * scale;
+	xcsc->shadow_coeff[1][3] += contrast * scale;
+	xcsc->shadow_coeff[2][3] += contrast * scale;
 	xcsc->contrast_active = xcsc->contrast;
-	xcsc_write_rgb_offset(xcsc);
+	xcsc_correct_coeff(xcsc, xcsc->shadow_coeff);
+	xcsc_write_coeff(xcsc);
 }
 
 static void xcsc_set_red_gain(struct xcsc_dev *xcsc)
@@ -452,18 +626,19 @@ static void xcsc_set_red_gain(struct xcsc_dev *xcsc)
 		(xcsc->red_gain_active - 20) / 2);
 
 	if (xcsc->red_gain != xcsc->red_gain_active) {
-		xcsc->k_hw[0][0] = ((xcsc->k_hw[0][0] *
-			xcsc->red_gain) / xcsc->red_gain_active);
-		xcsc->k_hw[0][1] = ((xcsc->k_hw[0][1] *
-			xcsc->red_gain) / xcsc->red_gain_active);
-		xcsc->k_hw[0][2] = ((xcsc->k_hw[0][2] *
-			xcsc->red_gain) / xcsc->red_gain_active);
+		xcsc->shadow_coeff[0][0] = (xcsc->shadow_coeff[0][0] *
+					    xcsc->red_gain) /
+					    xcsc->red_gain_active;
+		xcsc->shadow_coeff[0][1] = (xcsc->shadow_coeff[0][1] *
+					    xcsc->red_gain) /
+					    xcsc->red_gain_active;
+		xcsc->shadow_coeff[0][2] = (xcsc->shadow_coeff[0][2] *
+					    xcsc->red_gain) /
+					    xcsc->red_gain_active;
 		xcsc->red_gain_active = xcsc->red_gain;
+		xcsc_correct_coeff(xcsc, xcsc->shadow_coeff);
+		xcsc_write_coeff(xcsc);
 	}
-
-	xcsc_write(xcsc, XV_CSC_K11, xcsc->k_hw[0][0]);
-	xcsc_write(xcsc, XV_CSC_K12, xcsc->k_hw[0][1]);
-	xcsc_write(xcsc, XV_CSC_K13, xcsc->k_hw[0][2]);
 }
 
 static void xcsc_set_green_gain(struct xcsc_dev *xcsc)
@@ -474,17 +649,19 @@ static void xcsc_set_green_gain(struct xcsc_dev *xcsc)
 		 (xcsc->green_gain_active - 20) / 2);
 
 	if (xcsc->green_gain != xcsc->green_gain_active) {
-		xcsc->k_hw[1][0] = ((xcsc->k_hw[1][0] *
-			xcsc->green_gain) / xcsc->green_gain_active);
-		xcsc->k_hw[1][1] = ((xcsc->k_hw[1][1] *
-			xcsc->green_gain) / xcsc->green_gain_active);
-		xcsc->k_hw[1][2] = ((xcsc->k_hw[1][2] *
-			xcsc->green_gain) / xcsc->green_gain_active);
+		xcsc->shadow_coeff[1][0] = (xcsc->shadow_coeff[1][0] *
+					    xcsc->green_gain) /
+					    xcsc->green_gain_active;
+		xcsc->shadow_coeff[1][1] = (xcsc->shadow_coeff[1][1] *
+					    xcsc->green_gain) /
+					    xcsc->green_gain_active;
+		xcsc->shadow_coeff[1][2] = (xcsc->shadow_coeff[1][2] *
+					    xcsc->green_gain) /
+					    xcsc->green_gain_active;
 		xcsc->green_gain_active = xcsc->green_gain;
+		xcsc_correct_coeff(xcsc, xcsc->shadow_coeff);
+		xcsc_write_coeff(xcsc);
 	}
-	xcsc_write(xcsc, XV_CSC_K21, xcsc->k_hw[1][0]);
-	xcsc_write(xcsc, XV_CSC_K22, xcsc->k_hw[1][1]);
-	xcsc_write(xcsc, XV_CSC_K23, xcsc->k_hw[1][2]);
 }
 
 static void xcsc_set_blue_gain(struct xcsc_dev *xcsc)
@@ -495,18 +672,19 @@ static void xcsc_set_blue_gain(struct xcsc_dev *xcsc)
 		 (xcsc->blue_gain_active - 20) / 2);
 
 	if (xcsc->blue_gain != xcsc->blue_gain_active) {
-		xcsc->k_hw[2][0] = ((xcsc->k_hw[2][0] *
-			xcsc->blue_gain) / xcsc->blue_gain_active);
-		xcsc->k_hw[2][1] = ((xcsc->k_hw[2][1] *
-			xcsc->blue_gain) / xcsc->blue_gain_active);
-		xcsc->k_hw[2][2] = ((xcsc->k_hw[2][2] *
-			xcsc->blue_gain) / xcsc->blue_gain_active);
+		xcsc->shadow_coeff[2][0] = (xcsc->shadow_coeff[2][0] *
+					    xcsc->blue_gain) /
+					     xcsc->blue_gain_active;
+		xcsc->shadow_coeff[2][1] = (xcsc->shadow_coeff[2][1] *
+					    xcsc->blue_gain) /
+					     xcsc->blue_gain_active;
+		xcsc->shadow_coeff[2][2] = (xcsc->shadow_coeff[2][2] *
+					    xcsc->blue_gain) /
+					     xcsc->blue_gain_active;
 		xcsc->blue_gain_active = xcsc->blue_gain;
+		xcsc_correct_coeff(xcsc, xcsc->shadow_coeff);
+		xcsc_write_coeff(xcsc);
 	}
-
-	xcsc_write(xcsc, XV_CSC_K31, xcsc->k_hw[2][0]);
-	xcsc_write(xcsc, XV_CSC_K32, xcsc->k_hw[2][1]);
-	xcsc_write(xcsc, XV_CSC_K33, xcsc->k_hw[2][2]);
 }
 
 static void xcsc_set_size(struct xcsc_dev *xcsc)
@@ -525,15 +703,32 @@ static int xcsc_s_stream(struct v4l2_subdev *subdev, int enable)
 {
 	struct xcsc_dev *xcsc = to_csc(subdev);
 
+	dev_dbg(xcsc->xvip.dev, "%s : Stream %s", __func__,
+		enable ? "On" : "Off");
 	if (!enable) {
 		/* Reset the Global IP Reset through PS GPIO */
 		gpiod_set_value_cansleep(xcsc->rst_gpio, XCSC_RESET_ASSERT);
 		gpiod_set_value_cansleep(xcsc->rst_gpio, XCSC_RESET_DEASSERT);
 		return 0;
 	}
+	xcsc_write(xcsc, XV_CSC_INVIDEOFORMAT, xcsc->cft_in);
+	xcsc_write(xcsc, XV_CSC_OUTVIDEOFORMAT, xcsc->cft_out);
+	xcsc_write(xcsc, XV_CSC_CLIPMAX, xcsc->clip_max);
+	xcsc_write(xcsc, XV_CSC_CLAMPMIN, XCSC_CLAMP_MIN_ZERO);
 	xcsc_set_size(xcsc);
-	xcsc_set_coeff(xcsc);
-
+	xcsc_write_coeff(xcsc);
+#ifdef DEBUG
+	xcsc_print_coeff(xcsc);
+	dev_dbg(xcsc->xvip.dev, "cft_in = %d cft_out = %d",
+		xcsc_read(xcsc, XV_CSC_INVIDEOFORMAT),
+		xcsc_read(xcsc, XV_CSC_OUTVIDEOFORMAT));
+	dev_dbg(xcsc->xvip.dev, "clipmax = %d clampmin = %d",
+		xcsc_read(xcsc, XV_CSC_CLIPMAX),
+		xcsc_read(xcsc, XV_CSC_CLAMPMIN));
+	dev_dbg(xcsc->xvip.dev, "height = %d width = %d",
+		xcsc_read(xcsc, XV_CSC_HEIGHT),
+		xcsc_read(xcsc, XV_CSC_WIDTH));
+#endif
 	/* Start VPSS CSC IP */
 	xcsc_write(xcsc, XV_CSC_AP_CTRL, XCSC_STREAM_ON);
 	return 0;
@@ -571,6 +766,7 @@ static int xcsc_set_format(struct v4l2_subdev *subdev,
 	case MEDIA_BUS_FMT_VUY8_1X24:
 	case MEDIA_BUS_FMT_RBG888_1X24:
 	case MEDIA_BUS_FMT_UYVY8_1X16:
+	case MEDIA_BUS_FMT_VYYUYY8_1X24:
 		break;
 	default:
 		/* Unsupported Format. Default to RGB */
@@ -583,6 +779,10 @@ static int xcsc_set_format(struct v4l2_subdev *subdev,
 	__propagate->height = __format->height;
 
 	fmt->format = *__format;
+	xcsc_update_formats(xcsc);
+	xcsc_set_control_defaults(xcsc);
+	xcsc_set_v4l2_ctrl_defaults(xcsc);
+	dev_info(xcsc->xvip.dev, "VPSS CSC color controls reset to defaults");
 	return 0;
 }
 
@@ -627,6 +827,7 @@ static int xcsc_s_ctrl(struct v4l2_ctrl *ctrl)
 		break;
 	}
 #ifdef DEBUG
+	xcsc_print_k_hw(xcsc);
 	xcsc_print_coeff(xcsc);
 #endif
 	return 0;
@@ -636,7 +837,7 @@ static const struct v4l2_ctrl_ops xcsc_ctrl_ops = {
 	.s_ctrl = xcsc_s_ctrl,
 };
 
-static struct v4l2_ctrl_config xcsc_ctrls[] = {
+static struct v4l2_ctrl_config xcsc_color_ctrls[XCSC_COLOR_CTRL_COUNT] = {
 	/* Brightness */
 	{
 		.ops = &xcsc_ctrl_ops,
@@ -646,7 +847,7 @@ static struct v4l2_ctrl_config xcsc_ctrls[] = {
 		.min = 0,
 		.max = 100,
 		.step = 1,
-		.def = 50,
+		.def = XCSC_COLOR_CTRL_DEFAULT,
 		.flags = V4L2_CTRL_FLAG_SLIDER,
 	},
 	/* Contrast */
@@ -658,7 +859,7 @@ static struct v4l2_ctrl_config xcsc_ctrls[] = {
 		.min = 0,
 		.max = 100,
 		.step = 1,
-		.def = 50,
+		.def = XCSC_COLOR_CTRL_DEFAULT,
 		.flags = V4L2_CTRL_FLAG_SLIDER,
 	},
 	/* Red Gain */
@@ -670,7 +871,7 @@ static struct v4l2_ctrl_config xcsc_ctrls[] = {
 		.min = 0,
 		.max = 100,
 		.step = 1,
-		.def = 50,
+		.def = XCSC_COLOR_CTRL_DEFAULT,
 		.flags = V4L2_CTRL_FLAG_SLIDER,
 	},
 	/* Blue Gain */
@@ -682,7 +883,7 @@ static struct v4l2_ctrl_config xcsc_ctrls[] = {
 		.min = 0,
 		.max = 100,
 		.step = 1,
-		.def = 50,
+		.def = XCSC_COLOR_CTRL_DEFAULT,
 		.flags = V4L2_CTRL_FLAG_SLIDER,
 	},
 	/* Green Gain */
@@ -694,7 +895,7 @@ static struct v4l2_ctrl_config xcsc_ctrls[] = {
 		.min = 0,
 		.max = 100,
 		.step = 1,
-		.def = 50,
+		.def = XCSC_COLOR_CTRL_DEFAULT,
 		.flags = V4L2_CTRL_FLAG_SLIDER,
 	},
 };
@@ -738,6 +939,7 @@ static int xcsc_parse_of(struct xcsc_dev *xcsc)
 	struct device_node *ports, *port;
 	int rval;
 	u32 port_id = 0;
+	u32 video_width[2];
 
 	ports = of_get_child_by_name(node, "ports");
 	if (!ports)
@@ -763,8 +965,30 @@ static int xcsc_parse_of(struct xcsc_dev *xcsc)
 				return -EINVAL;
 			}
 			xcsc->vip_formats[port_id] = vip_format;
+
+			rval = of_property_read_u32(port, "xlnx,video-width",
+						    &video_width[port_id]);
+			if (rval < 0) {
+				dev_err(dev,
+					"DT Port%d xlnx,video-width not found",
+					port_id);
+				return rval;
+			}
 		}
 	}
+	if (video_width[0] != video_width[1]) {
+		dev_err(dev, "Changing video width in DT not supported");
+		return -EINVAL;
+	}
+	switch (video_width[0]) {
+	case XVIDC_BPC_8:
+	case XVIDC_BPC_10:
+		xcsc->color_depth = video_width[0];
+		break;
+	default:
+		dev_err(dev, "Unsupported color depth %d", video_width[0]);
+		return -EINVAL;
+	}
 	/* Reset GPIO */
 	xcsc->rst_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
 	if (IS_ERR(xcsc->rst_gpio)) {
@@ -808,6 +1032,7 @@ static int xcsc_probe(struct platform_device *pdev)
 	subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
 
 	/* Default Formats Initialization */
+	xcsc_set_default_state(xcsc);
 	def_fmt = &xcsc->default_formats[XVIP_PAD_SINK];
 	def_fmt->code = xcsc->vip_formats[XVIP_PAD_SINK]->code;
 	def_fmt->field = V4L2_FIELD_NONE;
@@ -824,7 +1049,6 @@ static int xcsc_probe(struct platform_device *pdev)
 	xcsc->formats[XVIP_PAD_SOURCE] = *def_fmt;
 	xcsc->pads[XVIP_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
 	xcsc->pads[XVIP_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
-	xcsc_set_default_state(xcsc);
 
 	/* Init Media Entity */
 	subdev->entity.ops = &xcsc_media_ops;
@@ -832,10 +1056,12 @@ static int xcsc_probe(struct platform_device *pdev)
 	if (rval < 0)
 		goto media_error;
 	/* V4L2 Control Setup */
-	v4l2_ctrl_handler_init(&xcsc->ctrl_handler, ARRAY_SIZE(xcsc_ctrls));
-	for (itr = 0; itr < ARRAY_SIZE(xcsc_ctrls); itr++) {
-		v4l2_ctrl_new_custom(&xcsc->ctrl_handler,
-				     &xcsc_ctrls[itr], NULL);
+	v4l2_ctrl_handler_init(&xcsc->ctrl_handler,
+			       ARRAY_SIZE(xcsc_color_ctrls));
+	for (itr = 0; itr < ARRAY_SIZE(xcsc_color_ctrls); itr++) {
+		xcsc->custom_ctrls[itr] =
+			v4l2_ctrl_new_custom(&xcsc->ctrl_handler,
+					     &xcsc_color_ctrls[itr], NULL);
 	}
 	if (xcsc->ctrl_handler.error) {
 		dev_err(&pdev->dev, "Failed to add  v4l2 controls");
@@ -854,7 +1080,8 @@ static int xcsc_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev, "failed to register subdev\n");
 		goto ctrl_error;
 	}
-	dev_info(&pdev->dev, "VPSS CSC Probe Successful");
+	dev_info(&pdev->dev, "VPSS CSC %d-bit Color Depth Probe Successful",
+		 xcsc->color_depth);
 	return 0;
 ctrl_error:
 	v4l2_ctrl_handler_free(&xcsc->ctrl_handler);
-- 
2.31.1

