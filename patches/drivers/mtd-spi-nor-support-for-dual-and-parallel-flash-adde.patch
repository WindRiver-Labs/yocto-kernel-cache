From 9a82bac07dc0e8c3974718057f05684dc4b15972 Mon Sep 17 00:00:00 2001
From: Tejas Prajapati Rameshchandra <tejaspra@xilinx.com>
Date: Tue, 19 Sep 2017 11:33:41 +0530
Subject: [PATCH] mtd: spi-nor: support for dual and parallel flash added.

Quad mode support along with block protection on dual stacked and parallel NOR flash added.
support for reading and writing status register added with extended address
register read write to access more than 16MB with 3 byte addressing.

Signed-off-by: Tejas Prajapati Rameshchandra <tejaspra@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
[Quanyang: original patch taken from
https://github.com/Xilinx/linux-xlnx.git xlnx_rebase_v4.19]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Jiping Ma <jiping.ma2@windriver.com>
---
 drivers/mtd/devices/m25p80.c  |   1 +
 drivers/mtd/spi-nor/spi-nor.c | 488 ++++++++++++++++++++++++++++++----
 drivers/spi/spi.c             |   8 +
 include/linux/mtd/spi-nor.h   |  29 ++
 include/linux/spi/spi.h       |  13 +
 5 files changed, 486 insertions(+), 53 deletions(-)

diff --git a/drivers/mtd/devices/m25p80.c b/drivers/mtd/devices/m25p80.c
index c50888670250..dceeec32a4ca 100644
--- a/drivers/mtd/devices/m25p80.c
+++ b/drivers/mtd/devices/m25p80.c
@@ -190,6 +190,7 @@ static int m25p_probe(struct spi_mem *spimem)
 
 	spi_mem_set_drvdata(spimem, flash);
 	flash->spimem = spimem;
+	nor->spi = spi;
 
 	if (spi->mode & SPI_RX_OCTAL) {
 		hwcaps.mask |= SNOR_HWCAPS_READ_1_1_8;
diff --git a/drivers/mtd/spi-nor/spi-nor.c b/drivers/mtd/spi-nor/spi-nor.c
index 77b8e36e9fa8..aa8cd89ebe53 100644
--- a/drivers/mtd/spi-nor/spi-nor.c
+++ b/drivers/mtd/spi-nor/spi-nor.c
@@ -21,6 +21,7 @@
 #include <linux/of_platform.h>
 #include <linux/spi/flash.h>
 #include <linux/mtd/spi-nor.h>
+#include <linux/spi/spi.h>
 
 /* Define max times to check status register before we give up. */
 
@@ -296,15 +297,25 @@ struct flash_info {
 static int read_sr(struct spi_nor *nor)
 {
 	int ret;
-	u8 val;
+	u8 val[2];
+
+        if (nor->isparallel) {
+                ret = nor->read_reg(nor, SPINOR_OP_RDSR, &val[0], 2);
+                if (ret < 0) {
+                        pr_err("error %d reading SR\n", (int) ret);
+                        return ret;
+                }
+                val[0] |= val[1];
+        } else {
+                ret = nor->read_reg(nor, SPINOR_OP_RDSR, &val[0], 1);
+                if (ret < 0) {
+                        pr_err("error %d reading SR\n", (int) ret);
+                        return ret;
+                }
 
-	ret = nor->read_reg(nor, SPINOR_OP_RDSR, &val, 1);
-	if (ret < 0) {
-		pr_err("error %d reading SR\n", (int) ret);
-		return ret;
 	}
 
-	return val;
+	return val[0];
 }
 
 /*
@@ -315,17 +326,57 @@ static int read_sr(struct spi_nor *nor)
 static int read_fsr(struct spi_nor *nor)
 {
 	int ret;
-	u8 val;
-
-	ret = nor->read_reg(nor, SPINOR_OP_RDFSR, &val, 1);
-	if (ret < 0) {
-		pr_err("error %d reading FSR\n", ret);
-		return ret;
+	u8 val[2];
+
+        if (nor->isparallel) {
+                ret = nor->read_reg(nor, SPINOR_OP_RDFSR, &val[0], 2);
+                if (ret < 0) {
+                        pr_err("error %d reading FSR\n", ret);
+                        return ret;
+                }
+                val[0] &= val[1];
+        } else {
+                ret = nor->read_reg(nor, SPINOR_OP_RDFSR, &val[0], 1);
+                if (ret < 0) {
+                        pr_err("error %d reading FSR\n", ret);
+                        return ret;
+                }
 	}
 
-	return val;
+	return val[0];
+}
+
+/**
+ * read_ear - Get the extended/bank address register value
+ * @nor:       Pointer to the flash control structure
+ *
+ * This routine reads the Extended/bank address register value
+ *
+ * Return:     Negative if error occured.
+ */
+static int read_ear(struct spi_nor *nor, struct flash_info *info)
+{
+       int ret;
+       u8 val;
+       u8 code;
+
+       /* This is actually Spansion */
+       if (JEDEC_MFR(info) == CFI_MFR_AMD)
+               code = SPINOR_OP_BRRD;
+       /* This is actually Micron */
+       else if (JEDEC_MFR(info) == CFI_MFR_ST)
+               code = SPINOR_OP_RDEAR;
+       else
+               return -EINVAL;
+
+       ret = nor->read_reg(nor, code, &val, 1);
+       if (ret < 0)
+               return ret;
+
+       return val;
 }
 
+
 /*
  * Read configuration register, returning its value in the
  * location. Return the configuration register value.
@@ -621,6 +672,50 @@ static int spi_nor_wait_till_ready(struct spi_nor *nor)
 						    DEFAULT_READY_WAIT_JIFFIES);
 }
 
+/*
+ * Update Extended Address/bank selection Register.
+ * Call with flash->lock locked.
+ */
+static int write_ear(struct spi_nor *nor, u32 addr)
+{
+       u8 code;
+       u8 ear;
+       int ret;
+       struct mtd_info *mtd = &nor->mtd;
+
+       /* Wait until finished previous write command. */
+       if (spi_nor_wait_till_ready(nor))
+               return 1;
+
+       if (mtd->size <= (0x1000000) << nor->shift)
+               return 0;
+
+       addr = addr % (u32) mtd->size;
+       ear = addr >> 24;
+
+       if ((!nor->isstacked) && (ear == nor->curbank))
+               return 0;
+
+       if (nor->isstacked && (mtd->size <= 0x2000000))
+               return 0;
+
+       if (nor->jedec_id == CFI_MFR_AMD)
+               code = SPINOR_OP_BRWR;
+       if (nor->jedec_id == CFI_MFR_ST) {
+               write_enable(nor);
+               code = SPINOR_OP_WREAR;
+       }
+       nor->cmd_buf[0] = ear;
+
+       ret = nor->write_reg(nor, code, nor->cmd_buf, 1);
+       if (ret < 0)
+               return ret;
+
+       nor->curbank = ear;
+
+       return 0;
+}
+
 /*
  * Erase the whole flash memory
  *
@@ -628,9 +723,28 @@ static int spi_nor_wait_till_ready(struct spi_nor *nor)
  */
 static int erase_chip(struct spi_nor *nor)
 {
+	u32 ret;
+
 	dev_dbg(nor->dev, " %lldKiB\n", (long long)(nor->mtd.size >> 10));
+        if (nor->isstacked)
+                nor->spi->master->flags &= ~SPI_MASTER_U_PAGE;
+ 
+        ret = nor->write_reg(nor, SPINOR_OP_CHIP_ERASE, NULL, 0);
+        if (ret)
+                return ret;
+ 
+        if (nor->isstacked) {
+                /* Wait until previous write command finished */
+                ret = spi_nor_wait_till_ready(nor);
+                if (ret)
+                        return ret;
+ 
+                nor->spi->master->flags |= SPI_MASTER_U_PAGE;
+ 
+                ret = nor->write_reg(nor, SPINOR_OP_CHIP_ERASE, NULL, 0);
+        }
+        return ret;
 
-	return nor->write_reg(nor, SPINOR_OP_CHIP_ERASE, NULL, 0);
 }
 
 static int spi_nor_lock_and_prep(struct spi_nor *nor, enum spi_nor_ops ops)
@@ -982,7 +1096,7 @@ static int spi_nor_erase_multi_sectors(struct spi_nor *nor, u64 addr, u32 len)
 static int spi_nor_erase(struct mtd_info *mtd, struct erase_info *instr)
 {
 	struct spi_nor *nor = mtd_to_spi_nor(mtd);
-	u32 addr, len;
+	u32 addr, len, offset;
 	uint32_t rem;
 	int ret;
 
@@ -1034,9 +1148,31 @@ static int spi_nor_erase(struct mtd_info *mtd, struct erase_info *instr)
 	/* "sector"-at-a-time erase */
 	} else if (spi_nor_has_uniform_erase(nor)) {
 		while (len) {
-			write_enable(nor);
-
-			ret = spi_nor_erase_sector(nor, addr);
+                        write_enable(nor);
+                        offset = addr;
+                        if (nor->isparallel == 1)
+                                offset /= 2;
+ 
+                        if (nor->isstacked == 1) {
+                                if (offset >= (mtd->size / 2)) {
+                                        offset = offset - (mtd->size / 2);
+                                        nor->spi->master->flags |=
+                                                SPI_MASTER_U_PAGE;
+                                } else {
+                                        nor->spi->master->flags &=
+                                                ~SPI_MASTER_U_PAGE;
+                                }
+                        }
+                        if (nor->addr_width == 3) {
+                                /* Update Extended Address Register */
+                                ret = write_ear(nor, offset);
+                                if (ret)
+                                        goto erase_err;
+                        }
+                        ret = spi_nor_wait_till_ready(nor);
+                        if (ret)
+                                goto erase_err;
+                        ret = spi_nor_erase_sector(nor, offset);
 			if (ret)
 				goto erase_err;
 
@@ -1353,11 +1489,24 @@ static int spi_nor_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
 {
 	struct spi_nor *nor = mtd_to_spi_nor(mtd);
 	int ret;
+        uint8_t status;
+        uint8_t lock_bits;
 
 	ret = spi_nor_lock_and_prep(nor, SPI_NOR_OPS_LOCK);
 	if (ret)
 		return ret;
 
+        if (nor->isparallel == 1)
+                ofs = ofs >> nor->shift;
+ 
+        if (nor->isstacked == 1) {
+                if (ofs >= (mtd->size / 2)) {
+                        ofs = ofs - (mtd->size / 2);
+                        nor->spi->master->flags |= SPI_MASTER_U_PAGE;
+                } else
+                        nor->spi->master->flags &= ~SPI_MASTER_U_PAGE;
+        }
+
 	ret = nor->flash_lock(nor, ofs, len);
 
 	spi_nor_unlock_and_unprep(nor, SPI_NOR_OPS_UNLOCK);
@@ -1368,11 +1517,24 @@ static int spi_nor_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
 {
 	struct spi_nor *nor = mtd_to_spi_nor(mtd);
 	int ret;
+        uint8_t status;
+        uint8_t lock_bits;
 
 	ret = spi_nor_lock_and_prep(nor, SPI_NOR_OPS_UNLOCK);
 	if (ret)
 		return ret;
 
+        if (nor->isparallel == 1)
+                ofs = ofs >> nor->shift;
+  
+        if (nor->isstacked == 1) {
+                if (ofs >= (mtd->size / 2)) {
+                        ofs = ofs - (mtd->size / 2);
+                        nor->spi->master->flags |= SPI_MASTER_U_PAGE;
+                } else
+                        nor->spi->master->flags &= ~SPI_MASTER_U_PAGE;
+        }
+
 	ret = nor->flash_unlock(nor, ofs, len);
 
 	spi_nor_unlock_and_unprep(nor, SPI_NOR_OPS_LOCK);
@@ -2172,20 +2334,73 @@ static int spi_nor_read(struct mtd_info *mtd, loff_t from, size_t len,
 {
 	struct spi_nor *nor = mtd_to_spi_nor(mtd);
 	ssize_t ret;
+        u32 offset = from;
+        u32 stack_shift = 0;
+        u32 read_len = 0;
+        u32 rem_bank_len = 0;
+        u8 bank;
+        u8 is_ofst_odd = 0;
+        loff_t addr = 0;
+ 
+ #define OFFSET_16_MB 0x1000000
+
 
 	dev_dbg(nor->dev, "from 0x%08x, len %zd\n", (u32)from, len);
 
+        if ((nor->isparallel) && (offset & 1)) {
+                /* We can hit this case when we use file system like ubifs */
+                from = (loff_t)(from - 1);
+                len = (size_t)(len + 1);
+                is_ofst_odd = 1;
+        }
+ 
 	ret = spi_nor_lock_and_prep(nor, SPI_NOR_OPS_READ);
 	if (ret)
 		return ret;
 
 	while (len) {
-		loff_t addr = from;
+               if (nor->addr_width == 3) {
+                       bank = (u32)from / (OFFSET_16_MB << nor->shift);
+                       rem_bank_len = ((OFFSET_16_MB << nor->shift) *
+                                                       (bank + 1)) - from;
+               }
+               offset = from;
+
+               if (nor->isparallel == 1)
+                       offset /= 2;
+
+               if (nor->isstacked == 1) {
+                       stack_shift = 1;
+                       if (offset >= (mtd->size / 2)) {
+                               offset = offset - (mtd->size / 2);
+                               nor->spi->master->flags |= SPI_MASTER_U_PAGE;
+                       } else {
+                               nor->spi->master->flags &= ~SPI_MASTER_U_PAGE;
+                       }
+               }
+
+               /* Die cross over issue is not handled */
+               if (nor->addr_width == 4) {
+                       rem_bank_len = (mtd->size >> stack_shift) -
+                                       (offset << nor->shift);
+               }
+               if (nor->addr_width == 3)
+                       write_ear(nor, offset);
+               if (len < rem_bank_len)
+                       read_len = len;
+               else
+                       read_len = rem_bank_len;
+
+               /* Wait till previous write/erase is done. */
+               ret = spi_nor_wait_till_ready(nor);
+               if (ret)
+                       goto read_err;
+
 
 		if (nor->flags & SNOR_F_S3AN_ADDR_DEFAULT)
-			addr = spi_nor_s3an_addr_convert(nor, addr);
+			addr = spi_nor_s3an_addr_convert(nor, offset);
 
-		ret = nor->read(nor, addr, len, buf);
+		ret = nor->read(nor, offset, read_len, buf);
 		if (ret == 0) {
 			/* We shouldn't see 0-length reads */
 			ret = -EIO;
@@ -2195,8 +2410,13 @@ static int spi_nor_read(struct mtd_info *mtd, loff_t from, size_t len,
 			goto read_err;
 
 		WARN_ON(ret > len);
-		*retlen += ret;
-		buf += ret;
+                if (is_ofst_odd == 1) {
+                        memcpy(buf, (buf + 1), (len - 1));
+                        *retlen += (ret - 1);
+                } else {
+                        *retlen += ret;
+                }
+ 		buf += ret;
 		from += ret;
 		len -= ret;
 	}
@@ -2297,9 +2517,34 @@ static int spi_nor_write(struct mtd_info *mtd, loff_t to, size_t len,
 	struct spi_nor *nor = mtd_to_spi_nor(mtd);
 	size_t page_offset, page_remain, i;
 	ssize_t ret;
+        u32 offset, stack_shift=0;
+        u8 bank = 0;
+        u32 rem_bank_len = 0;
+ 
+#define OFFSET_16_MB 0x1000000
+
 
 	dev_dbg(nor->dev, "to 0x%08x, len %zd\n", (u32)to, len);
 
+        /*
+         * Cannot write to odd offset in parallel mode,
+         * so write 2 bytes first
+         */
+        if ((nor->isparallel) && (to & 1)) {
+ 
+                u8 two[2] = {0xff, buf[0]};
+                size_t local_retlen;
+ 
+                ret = spi_nor_write(mtd, to & ~1, 2, &local_retlen, two);
+                if (ret < 0)
+                        return ret;
+ 
+                *retlen += 1; /* We've written only one actual byte */
+                ++buf;
+                --len;
+                ++to;
+        }
+
 	ret = spi_nor_lock_and_prep(nor, SPI_NOR_OPS_WRITE);
 	if (ret)
 		return ret;
@@ -2308,30 +2553,55 @@ static int spi_nor_write(struct mtd_info *mtd, loff_t to, size_t len,
 		ssize_t written;
 		loff_t addr = to + i;
 
-		/*
-		 * If page_size is a power of two, the offset can be quickly
-		 * calculated with an AND operation. On the other cases we
-		 * need to do a modulus operation (more expensive).
-		 * Power of two numbers have only one bit set and we can use
-		 * the instruction hweight32 to detect if we need to do a
-		 * modulus (do_div()) or not.
-		 */
-		if (hweight32(nor->page_size) == 1) {
-			page_offset = addr & (nor->page_size - 1);
-		} else {
-			uint64_t aux = addr;
+                if (nor->addr_width == 3) {
+                        bank = (u32)to / (OFFSET_16_MB << nor->shift);
+                        rem_bank_len = ((OFFSET_16_MB << nor->shift) *
+                                                        (bank + 1)) - to;
+                }
+                page_offset = ((to + i)) & (nor->page_size - 1);
+                WARN_ONCE(page_offset,
+                          "Writing at offset %zu into a NOR page. Writing partial pages may decrease reliability and increase wear of NOR flash.",
+                          page_offset);
+ 
+                offset = (to + i);
+ 
+                if (nor->isparallel == 1)
+                        offset /= 2;
+ 
+                if (nor->isstacked == 1) {
+                        stack_shift = 1;
+                        if (offset >= (mtd->size / 2)) {
+                                offset = offset - (mtd->size / 2);
+                                nor->spi->master->flags |= SPI_MASTER_U_PAGE;
+                        } else {
+                                nor->spi->master->flags &= ~SPI_MASTER_U_PAGE;
+                        }
 
-			page_offset = do_div(aux, nor->page_size);
 		}
-		/* the size of data remaining on the first page */
-		page_remain = min_t(size_t,
-				    nor->page_size - page_offset, len - i);
+ 
+                /* Die cross over issue is not handled */
+                if (nor->addr_width == 4)
+                        rem_bank_len = (mtd->size >> stack_shift) - offset;
+                if (nor->addr_width == 3)
+                        write_ear(nor, (offset >> nor->shift));
+                if (len < rem_bank_len) {
+                        page_remain = min_t(size_t,
+ 				    nor->page_size - page_offset, len - i);
+                }
+                else {
+                /* the size of data remaining on the first page */
+                        page_remain = rem_bank_len;
+                }
+                ret = spi_nor_wait_till_ready(nor);
+                if (ret)
+                        goto write_err;
 
 		if (nor->flags & SNOR_F_S3AN_ADDR_DEFAULT)
 			addr = spi_nor_s3an_addr_convert(nor, addr);
 
 		write_enable(nor);
-		ret = nor->write(nor, addr, page_remain, buf + i);
+
+		ret = nor->write(nor, (offset), page_remain, buf + i);
 		if (ret < 0)
 			goto write_err;
 		written = ret;
@@ -4075,12 +4345,14 @@ int spi_nor_scan(struct spi_nor *nor, const char *name,
 		 const struct spi_nor_hwcaps *hwcaps)
 {
 	struct spi_nor_flash_parameter params;
-	const struct flash_info *info = NULL;
+	struct flash_info *info = NULL;
 	struct device *dev = nor->dev;
 	struct mtd_info *mtd = &nor->mtd;
 	struct device_node *np = spi_nor_get_flash_node(nor);
+	struct device_node *np_spi;
 	int ret;
 	int i;
+	u32 is_dual;
 
 	ret = spi_nor_check(nor);
 	if (ret)
@@ -4092,10 +4364,10 @@ int spi_nor_scan(struct spi_nor *nor, const char *name,
 	nor->write_proto = SNOR_PROTO_1_1_1;
 
 	if (name)
-		info = spi_nor_match_id(name);
+		info = (struct flash_info *)spi_nor_match_id(name);
 	/* Try to auto-detect if chip name wasn't specified or not found */
 	if (!info)
-		info = spi_nor_read_id(nor);
+		info = (struct flash_info *)spi_nor_read_id(nor);
 	if (IS_ERR_OR_NULL(info))
 		return -ENOENT;
 
@@ -4119,7 +4391,7 @@ int spi_nor_scan(struct spi_nor *nor, const char *name,
 			 */
 			dev_warn(dev, "found %s, expected %s\n",
 				 jinfo->name, info->name);
-			info = jinfo;
+			info = (struct flash_info *)jinfo;
 		}
 	}
 
@@ -4159,6 +4431,73 @@ int spi_nor_scan(struct spi_nor *nor, const char *name,
 	mtd->size = params.size;
 	mtd->_erase = spi_nor_erase;
 	mtd->_read = spi_nor_read;
+#ifdef CONFIG_OF
+        np_spi = of_get_next_parent(np);
+        if ((of_property_match_string(np_spi, "compatible",
+                    "xlnx,zynq-qspi-1.0") >= 0) ||
+                        (of_property_match_string(np_spi, "compatible",
+                                        "xlnx,zynqmp-qspi-1.0") >= 0)) {
+                        if (of_property_read_u32(np_spi, "is-dual",
+                                                 &is_dual) < 0) {
+                                /* Default to single if prop not defined */
+                                nor->shift = 0;
+                                nor->isstacked = 0;
+                                nor->isparallel = 0;
+                        } else {
+                                if (is_dual == 1) {
+                                        /* dual parallel */
+                                        nor->shift = 1;
+                                        info->sector_size <<= nor->shift;
+                                        info->page_size <<= nor->shift;
+                                        mtd->size <<= nor->shift;
+                                        nor->isparallel = 1;
+                                        nor->isstacked = 0;
+                                        nor->spi->master->flags |=
+                                                        (SPI_MASTER_DATA_STRIPE
+                                                        | SPI_MASTER_BOTH_CS);
+                                } else {
+#ifdef CONFIG_SPI_ZYNQ_QSPI_DUAL_STACKED
+                                        /* dual stacked */
+                                        nor->shift = 0;
+                                        mtd->size <<= 1;
+                                        info->n_sectors <<= 1;
+                                        nor->isstacked = 1;
+                                        nor->isparallel = 0;
+#else
+                                        u32 is_stacked;
+                                        if (of_property_read_u32(np_spi,
+                                                        "is-stacked",
+                                                        &is_stacked) < 0) {
+                                                is_stacked = 0;
+                                        }
+                                        if (is_stacked) {
+                                                /* dual stacked */
+                                                nor->shift = 0;
+                                                mtd->size <<= 1;
+                                                info->n_sectors <<= 1;
+                                                nor->isstacked = 1;
+                                                nor->isparallel = 0;
+                                        } else {
+                                                /* single */
+                                                nor->shift = 0;
+                                                nor->isstacked = 0;
+                                                nor->isparallel = 0;
+                                        }
+#endif
+                               }
+                       }
+       }
+#if 0
+       pr_info("parallel %d stacked %d shift %d mtsize %d\n",
+               nor->isparallel, nor->isstacked, nor->shift, mtd->size);
+#endif
+#else
+        /* Default to single */
+        nor->shift = 0;
+        nor->isstacked = 0;
+        nor->isparallel = 0;
+#endif
+
 	mtd->_resume = spi_nor_resume;
 
 	/* NOR protection support for STmicro/Micron chips and similar */
@@ -4191,9 +4530,19 @@ int spi_nor_scan(struct spi_nor *nor, const char *name,
 	if (info->flags & USE_CLSR)
 		nor->flags |= SNOR_F_USE_CLSR;
 
+#ifdef CONFIG_MTD_SPI_NOR_USE_4K_SECTORS
+        /* prefer "small sector" erase if possible */
+        if (nor->shift &&
+                        (info->flags & SECT_4K ||
+                        info->flags & SECT_4K_PMC)) {
+                mtd->erasesize = 4096 << nor->shift;
+        }
+#endif
+
 	if (info->flags & SPI_NOR_NO_ERASE)
 		mtd->flags |= MTD_NO_ERASE;
 
+	nor->jedec_id = info->id[0];
 	mtd->dev.parent = dev;
 	nor->page_size = params.page_size;
 	mtd->writebufsize = nor->page_size;
@@ -4232,19 +4581,52 @@ int spi_nor_scan(struct spi_nor *nor, const char *name,
 	} else if (info->addr_width) {
 		nor->addr_width = info->addr_width;
 	} else if (mtd->size > 0x1000000) {
-		/* enable 4-byte addressing if the device exceeds 16MiB */
-		nor->addr_width = 4;
+#ifdef CONFIG_OF
+                np_spi = of_get_next_parent(np);
+                if (of_property_match_string(np_spi, "compatible",
+                                             "xlnx,zynq-qspi-1.0") >= 0) {
+                        int status;
+ 
+                        nor->addr_width = 3;
+                        set_4byte(nor, false);
+                        status = read_ear(nor, info);
+                        if (status < 0)
+                                dev_warn(dev, "failed to read ear reg\n");
+                        else
+                                nor->curbank = status & EAR_SEGMENT_MASK;
+                } else {
+#endif
+                        /*
+                         * enable 4-byte addressing
+                         * if the device exceeds 16MiB
+                         */
+                        nor->addr_width = 4;
+                        if (JEDEC_MFR(info) == SNOR_MFR_SPANSION ||
+                            info->flags & SPI_NOR_4B_OPCODES)
+                                spi_nor_set_4byte_opcodes(nor);
+                        else
+                                if (nor->isstacked) {
+                                        nor->spi->master->flags |= SPI_MASTER_U_PAGE;
+                                        set_4byte(nor, true);
+                                        nor->spi->master->flags &= ~SPI_MASTER_U_PAGE;
+                                }
+#ifdef CONFIG_OF
+                }
+#endif
 	} else {
 		nor->addr_width = 3;
 	}
 
-	if (info->flags & SPI_NOR_4B_OPCODES ||
-	    (JEDEC_MFR(info) == SNOR_MFR_SPANSION && mtd->size > SZ_16M))
-		nor->flags |= SNOR_F_4B_OPCODES;
-
-	if (nor->addr_width == 4 && nor->flags & SNOR_F_4B_OPCODES &&
-	    !(nor->flags & SNOR_F_HAS_4BAIT))
-		spi_nor_set_4byte_opcodes(nor);
+        if (of_property_match_string(np_spi, "compatible",
+                                             "xlnx,zynq-qspi-1.0") < 0) {
+                if (info->flags & SPI_NOR_4B_OPCODES ||
+                        (JEDEC_MFR(info) == SNOR_MFR_SPANSION && mtd->size > SZ_16M))
+                        nor->flags |= SNOR_F_4B_OPCODES;
+ 
+                if (nor->addr_width == 4 && nor->flags & SNOR_F_4B_OPCODES &&
+                        !(nor->flags & SNOR_F_HAS_4BAIT))
+                        spi_nor_set_4byte_opcodes(nor);
+        }
 
 	if (nor->addr_width > SPI_NOR_MAX_ADDR_WIDTH) {
 		dev_err(dev, "address width is too large: %u\n",
diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index be5b4b65c016..586a0c0b62cf 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -3056,6 +3056,14 @@ static int __spi_validate(struct spi_device *spi, struct spi_message *message)
 		}
 	}
 
+        /*
+         *  Data stripe option is selected if and only if when
+         *  two chips are enabled
+         */
+        if ((ctlr->flags & SPI_MASTER_DATA_STRIPE)
+                        && !(ctlr->flags & SPI_MASTER_BOTH_CS))
+                        return -EINVAL;
+
 	/* Half-duplex links include original MicroWire, and ones with
 	 * only one data pin like SPI_3WIRE (switches direction) or where
 	 * either MOSI or MISO is missing.  They can also be caused by
diff --git a/include/linux/mtd/spi-nor.h b/include/linux/mtd/spi-nor.h
index 9f57cdfcc93d..e1e8fbb26d32 100644
--- a/include/linux/mtd/spi-nor.h
+++ b/include/linux/mtd/spi-nor.h
@@ -98,6 +98,8 @@
 #define SPINOR_OP_WRDI		0x04	/* Write disable */
 #define SPINOR_OP_AAI_WP	0xad	/* Auto address increment word program */
 
+#define GLOBAL_BLKPROT_UNLK    0x98    /* Clear global write protection bits */
+
 /* Used for S3AN flashes only */
 #define SPINOR_OP_XSE		0x50	/* Sector erase */
 #define SPINOR_OP_XPP		0x82	/* Page program */
@@ -113,6 +115,7 @@
 
 /* Used for Spansion flashes only. */
 #define SPINOR_OP_BRWR		0x17	/* Bank register write */
+#define SPINOR_OP_BRRD          0x16    /* Bank register read */
 #define SPINOR_OP_CLSR		0x30	/* Clear status register 1 */
 
 /* Used for Micron flashes only. */
@@ -126,8 +129,16 @@
 #define SR_BP0			BIT(2)	/* Block protect 0 */
 #define SR_BP1			BIT(3)	/* Block protect 1 */
 #define SR_BP2			BIT(4)	/* Block protect 2 */
+#define SR_BP_BIT_OFFSET        2       /* Offset to Block protect 0 */
+#define SR_BP_BIT_MASK          (SR_BP2 | SR_BP1 | SR_BP0)
 #define SR_TB			BIT(5)	/* Top/Bottom protect */
 #define SR_SRWD			BIT(7)	/* SR write protect */
+#define SR_BP3                 0x40
+/* Bit to determine whether protection starts from top or bottom */
+#define SR_BP_TB               0x20
+#define BP_BITS_FROM_SR(sr)    (((sr) & SR_BP_BIT_MASK) >> SR_BP_BIT_OFFSET)
+#define M25P_MAX_LOCKABLE_SECTORS      64
+
 /* Spansion/Cypress specific status bits */
 #define SR_E_ERR		BIT(5)
 #define SR_P_ERR		BIT(6)
@@ -145,6 +156,15 @@
 
 /* Configuration Register bits. */
 #define CR_QUAD_EN_SPAN		BIT(1)	/* Spansion Quad I/O */
+/* Extended/Bank Address Register bits */
+#define EAR_SEGMENT_MASK       0x7 /* 128 Mb segment mask */
+
+enum read_mode {
+       SPI_NOR_NORMAL = 0,
+       SPI_NOR_FAST,
+       SPI_NOR_DUAL,
+       SPI_NOR_QUAD,
+};
 
 /* Status Register 2 bits. */
 #define SR2_QUAD_EN_BIT7	BIT(7)
@@ -382,6 +402,7 @@ struct spi_nor {
 	struct mtd_info		mtd;
 	struct mutex		lock;
 	struct device		*dev;
+	struct spi_device       *spi;
 	const struct flash_info	*info;
 	u32			page_size;
 	u8			addr_width;
@@ -389,10 +410,18 @@ struct spi_nor {
 	u8			read_opcode;
 	u8			read_dummy;
 	u8			program_opcode;
+        enum read_mode          flash_read;
+        u32                     jedec_id;
+        u16                     curbank;
+        u16                     n_sectors;
+        u32                     sector_size;
 	enum spi_nor_protocol	read_proto;
 	enum spi_nor_protocol	write_proto;
 	enum spi_nor_protocol	reg_proto;
 	bool			sst_write_second;
+        bool                    shift;
+        bool                    isparallel;
+        bool                    isstacked;
 	u32			flags;
 	u8			cmd_buf[SPI_NOR_MAX_CMD_SIZE];
 	struct spi_nor_erase_map	erase_map;
diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 053abd22ad31..a518d6c61276 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -463,6 +463,19 @@ struct spi_controller {
 #define SPI_CONTROLLER_MUST_TX		BIT(4)	/* requires tx */
 
 #define SPI_MASTER_GPIO_SS		BIT(5)	/* GPIO CS must select slave */
+       /* Controller may support data stripe feature when more than one
+        * chips are present.
+        * Setting data stripe will send data in following manner:
+        * -> even bytes i.e. 0, 2, 4,... are transmitted on lower data bus
+        * -> odd bytes i.e. 1, 3, 5,.. are transmitted on upper data bus
+        */
+#define SPI_MASTER_QUAD_MODE   BIT(6) /* support quad mode */
+#define SPI_MASTER_DATA_STRIPE BIT(7)          /* support data stripe */
+       /* Controller may support asserting more than one chip select at once.
+        * This flag will enable that feature.
+        */
+#define SPI_MASTER_BOTH_CS     BIT(8)          /* assert both chip selects */
+#define SPI_MASTER_U_PAGE       BIT(9)          /* select upper flash */
 
 	/* flag indicating this is an SPI slave controller */
 	bool			slave;
-- 
2.17.1

