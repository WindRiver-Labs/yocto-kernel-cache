From 167f83020eab82ec654fa8ea66e832c0fa0e3da0 Mon Sep 17 00:00:00 2001
From: Smadar Fuks <smadarf@marvell.com>
Date: Mon, 24 Aug 2020 18:34:11 -0400
Subject: [PATCH 0757/1921] octeontx2-af: Free RVU REE irq properly

Fix REE crash at free_irq in rvu_ree_unregister_interrupts_block
during rmmod of AF driver.
In order to support 2 REEs in the same interrupt handler function,
request_irq is called with struct rvu_block as a cookie, instead
of struct rvu. following that, free_irq should also be called with
the same cookie which is struct rvu_block.
In addition REE0 and REE1 have different irq names.

Change-Id: I6a49d38deec74a866a045d4df3d355425546d2d9
Signed-off-by: Smadar Fuks <smadarf@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/35229
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 .../ethernet/marvell/octeontx2/af/rvu_ree.c   | 25 +++++++++++++------
 1 file changed, 17 insertions(+), 8 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_ree.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_ree.c
index 6eb80ffd4c12..b572d0f3b911 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_ree.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_ree.c
@@ -34,6 +34,11 @@
 /* Administrative instruction queue size */
 #define REE_AQ_SIZE		128
 
+static const char *ree_irq_name[MAX_REE_BLKS][REE_AF_INT_VEC_CNT] = {
+		{ "REE0_AF_RAS", "REE0_AF_RVU", "REE0_AF_DONE", "REE0_AF_AQ" },
+		{ "REE1_AF_RAS", "REE1_AF_RVU", "REE1_AF_DONE", "REE1_AF_AQ" },
+};
+
 enum ree_cmp_ops {
 	REE_CMP_EQ,	/* Equal to data*/
 	REE_CMP_GEQ,	/* Equal or greater than data */
@@ -988,9 +993,12 @@ static irqreturn_t rvu_ree_af_aq_intr_handler(int irq, void *ptr)
 static void rvu_ree_unregister_interrupts_block(struct rvu *rvu, int blkaddr)
 {
 	int i, offs;
+	struct rvu_block *block;
+	struct rvu_hwinfo *hw = rvu->hw;
 
-	if (!is_block_implemented(rvu->hw, blkaddr))
+	if (!is_block_implemented(hw, blkaddr))
 		return;
+	block = &hw->block[blkaddr];
 
 	offs = rvu_read64(rvu, blkaddr, REE_PRIV_AF_INT_CFG) & 0x7FF;
 	if (!offs) {
@@ -1007,7 +1015,7 @@ static void rvu_ree_unregister_interrupts_block(struct rvu *rvu, int blkaddr)
 
 	for (i = 0; i < REE_AF_INT_VEC_CNT; i++)
 		if (rvu->irq_allocated[offs + i]) {
-			free_irq(pci_irq_vector(rvu->pdev, offs + i), rvu);
+			free_irq(pci_irq_vector(rvu->pdev, offs + i), block);
 			rvu->irq_allocated[offs + i] = false;
 		}
 }
@@ -1038,7 +1046,8 @@ static int rvu_ree_af_request_irq(struct rvu_block *block,
 	return rvu->irq_allocated[offset];
 }
 
-static int rvu_ree_register_interrupts_block(struct rvu *rvu, int blkaddr)
+static int rvu_ree_register_interrupts_block(struct rvu *rvu, int blkaddr,
+					     int blkid)
 {
 	struct rvu_hwinfo *hw = rvu->hw;
 	struct rvu_block *block;
@@ -1060,7 +1069,7 @@ static int rvu_ree_register_interrupts_block(struct rvu *rvu, int blkaddr)
 	/* Register and enable RAS interrupt */
 	ret = rvu_ree_af_request_irq(block, offs + REE_AF_INT_VEC_RAS,
 				     rvu_ree_af_ras_intr_handler,
-				     "REEAF RAS");
+				     ree_irq_name[blkid][REE_AF_INT_VEC_RAS]);
 	if (!ret)
 		goto err;
 	rvu_write64(rvu, blkaddr, REE_AF_RAS_ENA_W1S, ~0ULL);
@@ -1068,7 +1077,7 @@ static int rvu_ree_register_interrupts_block(struct rvu *rvu, int blkaddr)
 	/* Register and enable RVU interrupt */
 	ret = rvu_ree_af_request_irq(block, offs + REE_AF_INT_VEC_RVU,
 				     rvu_ree_af_rvu_intr_handler,
-				     "REEAF RVU");
+				     ree_irq_name[blkid][REE_AF_INT_VEC_RVU]);
 	if (!ret)
 		goto err;
 	rvu_write64(rvu, blkaddr, REE_AF_RVU_INT_ENA_W1S, ~0ULL);
@@ -1081,7 +1090,7 @@ static int rvu_ree_register_interrupts_block(struct rvu *rvu, int blkaddr)
 	/* Register and enable AQ interrupt */
 	ret = rvu_ree_af_request_irq(block, offs + REE_AF_INT_VEC_AQ,
 				     rvu_ree_af_aq_intr_handler,
-				     "REEAF RVU");
+				     ree_irq_name[blkid][REE_AF_INT_VEC_AQ]);
 	if (!ret)
 		goto err;
 	rvu_write64(rvu, blkaddr, REE_AF_AQ_INT_ENA_W1S, ~0ULL);
@@ -1096,11 +1105,11 @@ int rvu_ree_register_interrupts(struct rvu *rvu)
 {
 	int ret;
 
-	ret = rvu_ree_register_interrupts_block(rvu, BLKADDR_REE0);
+	ret = rvu_ree_register_interrupts_block(rvu, BLKADDR_REE0, 0);
 	if (ret)
 		return ret;
 
-	return rvu_ree_register_interrupts_block(rvu, BLKADDR_REE1);
+	return rvu_ree_register_interrupts_block(rvu, BLKADDR_REE1, 1);
 }
 
 static int rvu_ree_init_block(struct rvu *rvu, int blkaddr)
-- 
2.31.1

