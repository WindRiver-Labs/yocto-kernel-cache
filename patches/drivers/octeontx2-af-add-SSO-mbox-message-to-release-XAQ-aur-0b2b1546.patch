From 5ac7595dbc5ae287a8a0b962d265fe71348cf45f Mon Sep 17 00:00:00 2001
From: Shijith Thotton <sthotton@marvell.com>
Date: Thu, 17 Sep 2020 16:11:15 +0000
Subject: [PATCH 0770/1921] octeontx2-af: add SSO mbox message to release XAQ
 aura

XAQ aura should be released from an SSO LF before disabling it.
Otherwise NPA error interrupt (NPA_LF_ERR_INT[AURA_DIS]) will be
generated for future aura related operations by SSO.

New mbox message can be used to release an aura from an SSO LF before
disabling it.

Change-Id: Id12943cc4ee74c7b3e0598ed46e95fe35827be13
Signed-off-by: Shijith Thotton <sthotton@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/36514
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 .../net/ethernet/marvell/octeontx2/af/mbox.h  |  7 ++
 .../ethernet/marvell/octeontx2/af/rvu_sso.c   | 87 +++++++++++++------
 2 files changed, 66 insertions(+), 28 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/af/mbox.h b/drivers/net/ethernet/marvell/octeontx2/af/mbox.h
index 7e91fddae271..108568b33b29 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/mbox.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/mbox.h
@@ -195,6 +195,8 @@ M(SSO_WS_CACHE_INV,	0x607, sso_ws_cache_inv, msg_req, msg_rsp)	\
 M(SSO_GRP_QOS_CONFIG,	0x608, sso_grp_qos_config, sso_grp_qos_cfg, msg_rsp)\
 M(SSO_GRP_GET_STATS,	0x609, sso_grp_get_stats, sso_info_req, sso_grp_stats)\
 M(SSO_HWS_GET_STATS,	0x610, sso_hws_get_stats, sso_info_req, sso_hws_stats)\
+M(SSO_HW_RELEASE_XAQ,	0x611, sso_hw_release_xaq_aura,			\
+				sso_release_xaq, msg_rsp)	\
 /* TIM mbox IDs (range 0x800 - 0x9FF) */				\
 M(TIM_LF_ALLOC,		0x800, tim_lf_alloc,				\
 				tim_lf_alloc_req, tim_lf_alloc_rsp)	\
@@ -1127,6 +1129,11 @@ struct sso_hw_setconfig {
 	u16	hwgrps;
 };
 
+struct sso_release_xaq {
+	struct mbox_msghdr hdr;
+	u16	hwgrps;
+};
+
 struct sso_info_req {
 	struct mbox_msghdr hdr;
 	union {
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_sso.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_sso.c
index 29da67daf276..6380c4f0e381 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_sso.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_sso.c
@@ -585,6 +585,64 @@ int rvu_ssow_lf_teardown(struct rvu *rvu, u16 pcifunc, int lf, int slot)
 	return 0;
 }
 
+static void rvu_sso_deinit_xaq_aura(struct rvu *rvu, int blkaddr, int lf,
+				    int hwgrp)
+{
+	u64 reg;
+
+	reg = rvu_read64(rvu, blkaddr, SSO_AF_HWGRPX_AW_STATUS(lf));
+	if (reg & SSO_HWGRP_AW_STS_XAQ_BUFSC_MASK || reg & BIT_ULL(3)) {
+		reg = rvu_read64(rvu, blkaddr, SSO_AF_HWGRPX_AW_CFG(lf));
+		reg = (reg & ~SSO_HWGRP_AW_CFG_RWEN) |
+			SSO_HWGRP_AW_CFG_XAQ_BYP_DIS;
+		rvu_write64(rvu, blkaddr, SSO_AF_HWGRPX_AW_CFG(lf), reg);
+
+		reg = rvu_read64(rvu, blkaddr, SSO_AF_HWGRPX_AW_STATUS(lf));
+		if (reg & SSO_HWGRP_AW_STS_TPTR_VLD) {
+			rvu_poll_reg(rvu, blkaddr, SSO_AF_HWGRPX_AW_STATUS(lf),
+				     SSO_HWGRP_AW_STS_NPA_FETCH, true);
+
+			rvu_write64(rvu, blkaddr, SSO_AF_HWGRPX_AW_STATUS(lf),
+				    SSO_HWGRP_AW_STS_TPTR_VLD);
+		}
+
+		if (rvu_poll_reg(rvu, blkaddr, SSO_AF_HWGRPX_AW_STATUS(lf),
+				 SSO_HWGRP_AW_STS_XAQ_BUFSC_MASK, true))
+			dev_warn(rvu->dev,
+				 "SSO_HWGRP(%d)_AW_STATUS[XAQ_BUF_CACHED] not cleared",
+				 lf);
+	}
+}
+
+int rvu_mbox_handler_sso_hw_release_xaq_aura(struct rvu *rvu,
+					     struct sso_release_xaq *req,
+					     struct msg_rsp *rsp)
+{
+	struct rvu_hwinfo *hw = rvu->hw;
+	u16 pcifunc = req->hdr.pcifunc;
+	int hwgrp, lf, blkaddr;
+
+	blkaddr = rvu_get_blkaddr(rvu, BLKTYPE_SSO, pcifunc);
+	if (blkaddr < 0)
+		return SSO_AF_ERR_LF_INVALID;
+
+	for (hwgrp = 0; hwgrp < req->hwgrps; hwgrp++) {
+		lf = rvu_get_lf(rvu, &hw->block[blkaddr], pcifunc, hwgrp);
+		if (lf < 0)
+			return SSO_AF_ERR_LF_INVALID;
+
+		rvu_sso_deinit_xaq_aura(rvu, blkaddr, lf, hwgrp);
+		/* disable XAQ */
+		rvu_write64(rvu, blkaddr, SSO_AF_HWGRPX_AW_CFG(lf),
+			    SSO_HWGRP_AW_CFG_LDWB | SSO_HWGRP_AW_CFG_LDT |
+			    SSO_HWGRP_AW_CFG_STT);
+		rvu_write64(rvu, blkaddr, SSO_AF_HWGRPX_XAQ_AURA(lf), 0);
+		rvu_write64(rvu, blkaddr, SSO_AF_XAQX_GMCTL(lf), 0);
+	}
+
+	return 0;
+}
+
 int rvu_mbox_handler_sso_hw_setconfig(struct rvu *rvu,
 				      struct sso_hw_setconfig *req,
 				      struct msg_rsp *rsp)
@@ -616,34 +674,7 @@ int rvu_mbox_handler_sso_hw_setconfig(struct rvu *rvu,
 		if (lf < 0)
 			return SSO_AF_ERR_LF_INVALID;
 
-		reg = rvu_read64(rvu, blkaddr, SSO_AF_HWGRPX_AW_STATUS(lf));
-		if (reg & SSO_HWGRP_AW_STS_XAQ_BUFSC_MASK || reg & BIT_ULL(3)) {
-			reg = rvu_read64(rvu, blkaddr,
-					 SSO_AF_HWGRPX_AW_CFG(lf));
-			reg = (reg & ~SSO_HWGRP_AW_CFG_RWEN) |
-			       SSO_HWGRP_AW_CFG_XAQ_BYP_DIS;
-			rvu_write64(rvu, blkaddr, SSO_AF_HWGRPX_AW_CFG(lf),
-				    reg);
-
-			reg = rvu_read64(rvu, blkaddr,
-					 SSO_AF_HWGRPX_AW_STATUS(lf));
-			if (reg & SSO_HWGRP_AW_STS_TPTR_VLD) {
-				rvu_poll_reg(rvu, blkaddr,
-					     SSO_AF_HWGRPX_AW_STATUS(lf),
-					     SSO_HWGRP_AW_STS_NPA_FETCH, true);
-
-				rvu_write64(rvu, blkaddr,
-					    SSO_AF_HWGRPX_AW_STATUS(lf),
-					    SSO_HWGRP_AW_STS_TPTR_VLD);
-			}
-
-			if (rvu_poll_reg(rvu, blkaddr,
-					 SSO_AF_HWGRPX_AW_STATUS(lf),
-					 SSO_HWGRP_AW_STS_XAQ_BUFSC_MASK, true))
-				dev_warn(rvu->dev,
-					 "SSO_HWGRP(%d)_AW_STATUS[XAQ_BUF_CACHED] not cleared",
-					 lf);
-		}
+		rvu_sso_deinit_xaq_aura(rvu, blkaddr, lf, hwgrp);
 
 		rvu_write64(rvu, blkaddr, SSO_AF_HWGRPX_XAQ_AURA(lf),
 			    npa_aura_id);
-- 
2.31.1

