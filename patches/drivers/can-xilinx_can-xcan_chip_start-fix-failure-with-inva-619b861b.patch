From e79903dd85fc2681b8faaed4e123c2a7864058ef Mon Sep 17 00:00:00 2001
From: Anssi Hannula <anssi.hannula@bitwise.fi>
Date: Wed, 3 Apr 2019 15:18:53 +0300
Subject: [PATCH 1487/1851] can: xilinx_can: xcan_chip_start(): fix failure
 with invalid bus

commit 3486cc40ccbfe4cbf55feecce88a792e3043c178 upstream

Currently the xilinx_can xcan_chip_start() function, called from
.ndo_open() and via CAN_MODE_START (bus-off restart), waits for the SR
register to show the wanted operating state, with a 1 sec timeout.

However, that register bit will only be set once the HW has observed 11
consecutive recessive bits (BusIdle) on the bus.

If the bus will not see the 11 bits (e.g. it is stuck dominant), the
function will timeout and return an error. If this was done as part of a
scheduled restart from bus-off, the interface will stay in bus-off state
forever even if the bus recovers later.

According to M_CAN and FLEXCAN documentation they also wait for 11
consecutive recessive bits, but their drivers do not seem to wait for
that.

To make the behavior consistent, modify xilinx_can to also not wait for
the synchronization to complete.

The only way for users to know for sure that the bus has been joined
successfully is to see successfully received or transmitted frames. That
does not seem optimal, but it is consistent with other drivers and we
should have a properly working restart-ms with xilinx_can.

Tested on ZynqMP with Xilinx CAN-FD 1.0.

Fixes: b1201e44f50b ("can: xilinx CAN controller support")
Signed-off-by: Anssi Hannula <anssi.hannula@bitwise.fi>
Tested-by: Appana Durga Kedareswara Rao <appana.durga.rao@xilinx.com>
Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 drivers/net/can/xilinx_can.c | 13 +------------
 1 file changed, 1 insertion(+), 12 deletions(-)

diff --git a/drivers/net/can/xilinx_can.c b/drivers/net/can/xilinx_can.c
index b2d326fae96d..b2b8f61f387f 100644
--- a/drivers/net/can/xilinx_can.c
+++ b/drivers/net/can/xilinx_can.c
@@ -458,9 +458,8 @@ static int xcan_set_bittiming(struct net_device *ndev)
 static int xcan_chip_start(struct net_device *ndev)
 {
 	struct xcan_priv *priv = netdev_priv(ndev);
-	u32 reg_msr, reg_sr_mask;
+	u32 reg_msr;
 	int err;
-	unsigned long timeout;
 	u32 ier;
 
 	/* Check if it is in reset mode */
@@ -486,10 +485,8 @@ static int xcan_chip_start(struct net_device *ndev)
 	/* Check whether it is loopback mode or normal mode  */
 	if (priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK) {
 		reg_msr = XCAN_MSR_LBACK_MASK;
-		reg_sr_mask = XCAN_SR_LBACK_MASK;
 	} else {
 		reg_msr = 0x0;
-		reg_sr_mask = XCAN_SR_NORMAL_MASK;
 	}
 
 	/* enable the first extended filter, if any, as cores with extended
@@ -501,14 +498,6 @@ static int xcan_chip_start(struct net_device *ndev)
 	priv->write_reg(priv, XCAN_MSR_OFFSET, reg_msr);
 	priv->write_reg(priv, XCAN_SRR_OFFSET, XCAN_SRR_CEN_MASK);
 
-	timeout = jiffies + XCAN_TIMEOUT;
-	while (!(priv->read_reg(priv, XCAN_SR_OFFSET) & reg_sr_mask)) {
-		if (time_after(jiffies, timeout)) {
-			netdev_warn(ndev,
-				    "timed out for correct mode\n");
-			return -ETIMEDOUT;
-		}
-	}
 	netdev_dbg(ndev, "status:#x%08x\n",
 		   priv->read_reg(priv, XCAN_SR_OFFSET));
 
-- 
2.31.1

