From 0b3a2d2fdabb88c8c33a661b9dc4289f9697b526 Mon Sep 17 00:00:00 2001
From: Sunil Goutham <sgoutham@marvell.com>
Date: Tue, 30 Jul 2019 18:29:27 +0530
Subject: [PATCH 291/767] octeontx2-pf: Support for HW TSO offload

commit 5bf8158bf4ee78d8c2a377f39aeb509bb348decb from
git@git.assembla.com:cavium/WindRiver.linux.git

On latest silicon 96xx B0 HW issues wrt TSO
offload have been fixed. This patch enables
using HW TSO offload on this silicon.

Change-Id: Idf1b022566ca7bb1046d0d600b4336ea36d727d9
Signed-off-by: Sunil Goutham <sgoutham@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/13436
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Reviewed-on: https://sj1git1.cavium.com/13445
Tested-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../marvell/octeontx2/nic/otx2_common.c       | 10 ++---
 .../marvell/octeontx2/nic/otx2_common.h       | 13 ++++++
 .../ethernet/marvell/octeontx2/nic/otx2_pf.c  |  9 +---
 .../marvell/octeontx2/nic/otx2_txrx.c         | 44 ++++++++++++++++---
 .../ethernet/marvell/octeontx2/nic/otx2_vf.c  |  3 +-
 5 files changed, 57 insertions(+), 22 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.c
index b3b526ff632e..754e3e9c95c7 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.c
@@ -620,12 +620,10 @@ static int otx2_sq_init(struct otx2_nic *pfvf, u16 qidx, u16 sqb_aura)
 	if (err)
 		return err;
 
-	if (!pfvf->hw.hw_tso) {
-		err = qmem_alloc(pfvf->dev, &sq->tso_hdrs, qset->sqe_cnt,
-				 TSO_HEADER_SIZE);
-		if (err)
-			return err;
-	}
+	err = qmem_alloc(pfvf->dev, &sq->tso_hdrs, qset->sqe_cnt,
+			 TSO_HEADER_SIZE);
+	if (err)
+		return err;
 
 	sq->sqe_base = sq->sqe->base;
 	sq->sg = kcalloc(qset->sqe_cnt, sizeof(struct sg_list), GFP_KERNEL);
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h
index 314bdea831de..9e3442dbc6b7 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h
@@ -272,6 +272,19 @@ static inline bool is_95xx_A0(struct pci_dev *pdev)
 		(pdev->subsystem_device == PCI_SUBSYS_DEVID_95XX_RVU_PFVF);
 }
 
+static inline void otx2_setup_dev_hw_settings(struct otx2_nic *pfvf)
+{
+	struct otx2_hw *hw = &pfvf->hw;
+
+	pfvf->cq_time_wait = CQ_TIMER_THRESH_DEFAULT;
+	pfvf->cq_ecount_wait = CQ_CQE_THRESH_DEFAULT;
+
+	hw->hw_tso = true;
+
+	if (is_96xx_A0(pfvf->pdev) || is_95xx_A0(pfvf->pdev))
+		hw->hw_tso = false;
+}
+
 /* Register read/write APIs */
 static inline void otx2_write64(struct otx2_nic *nic, u64 offset, u64 val)
 {
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c
index a9045398b3e4..d736f15c14a8 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c
@@ -1252,8 +1252,7 @@ static void otx2_free_sq_res(struct otx2_nic *pf)
 	for (qidx = 0; qidx < pf->hw.tx_queues; qidx++) {
 		sq = &qset->sq[qidx];
 		qmem_free(pf->dev, sq->sqe);
-		if (!pf->hw.hw_tso)
-			qmem_free(pf->dev, sq->tso_hdrs);
+		qmem_free(pf->dev, sq->tso_hdrs);
 		kfree(sq->sg);
 		qmem_free(pf->dev, sq->timestamps);
 	}
@@ -2138,11 +2137,7 @@ static int otx2_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	if (err)
 		goto err_detach_rsrc;
 
-	if (!is_96xx_A0(pf->pdev) && !is_95xx_A0(pf->pdev))
-		hw->hw_tso = true;
-
-	pf->cq_time_wait = CQ_TIMER_THRESH_DEFAULT;
-	pf->cq_ecount_wait = CQ_CQE_THRESH_DEFAULT;
+	otx2_setup_dev_hw_settings(pf);
 
 	/* Don't check for error.  Proceed without ptp */
 	otx2_ptp_init(pf);
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_txrx.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_txrx.c
index 923ac46457b4..893d3d1d00b0 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_txrx.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_txrx.c
@@ -614,13 +614,24 @@ static void otx2_sqe_add_ext(struct otx2_nic *pfvf, struct otx2_snd_queue *sq,
 	ext->subdc = NIX_SUBDC_EXT;
 	if (skb_shinfo(skb)->gso_size) {
 		ext->lso = 1;
-		/* Is this TSOv4 or TSOv6, other GSO offloads not supported */
-		if (skb_shinfo(skb)->gso_type & SKB_GSO_TCPV4)
-			ext->lso_format = pfvf->hw.lso_tsov4_idx;
-		else
-			ext->lso_format = pfvf->hw.lso_tsov6_idx;
 		ext->lso_sb = skb_transport_offset(skb) + tcp_hdrlen(skb);
 		ext->lso_mps = skb_shinfo(skb)->gso_size;
+
+		/* Only TSOv4 and TSOv6 GSO offloads are supported */
+		if (skb_shinfo(skb)->gso_type & SKB_GSO_TCPV4) {
+			ext->lso_format = pfvf->hw.lso_tsov4_idx;
+
+			/* HW adds payload size to 'ip_hdr->tot_len' while
+			 * sending TSO segment, hence set payload length
+			 * in IP header of the packet to just header length.
+			 */
+			ip_hdr(skb)->tot_len =
+				htons(ext->lso_sb - skb_network_offset(skb));
+		} else {
+			ext->lso_format = pfvf->hw.lso_tsov6_idx;
+			ipv6_hdr(skb)->payload_len =
+				htons(ext->lso_sb - skb_network_offset(skb));
+		}
 	} else if (skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) {
 		ext->tstmp = 1;
 	}
@@ -849,13 +860,32 @@ static void otx2_sq_append_tso(struct otx2_nic *pfvf, struct otx2_snd_queue *sq,
 	}
 }
 
+static inline bool is_hw_tso_supported(struct otx2_nic *pfvf,
+				       struct sk_buff *skb)
+{
+	int payload_len, last_seg_size;
+
+	if (!pfvf->hw.hw_tso)
+		return false;
+
+	/* HW has an issue due to which when the payload of the last LSO
+	 * segment is shorter than 16 bytes, some header fields may not
+	 * be correctly modified, hence don't offload such TSO segments.
+	 */
+	payload_len = skb->len - (skb_transport_offset(skb) + tcp_hdrlen(skb));
+	last_seg_size = payload_len % skb_shinfo(skb)->gso_size;
+	if (last_seg_size && last_seg_size < 16)
+		return false;
+	return true;
+}
+
 static int otx2_get_sqe_count(struct otx2_nic *pfvf, struct sk_buff *skb)
 {
 	if (!skb_shinfo(skb)->gso_size)
 		return 1;
 
 	/* HW TSO */
-	if (skb_shinfo(skb)->gso_size && pfvf->hw.hw_tso)
+	if (is_hw_tso_supported(pfvf, skb))
 		return 1;
 
 	/* SW TSO */
@@ -908,7 +938,7 @@ bool otx2_sq_append_skb(struct net_device *netdev, struct otx2_snd_queue *sq,
 		num_segs = skb_shinfo(skb)->nr_frags + 1;
 	}
 
-	if (skb_shinfo(skb)->gso_size && !pfvf->hw.hw_tso) {
+	if (skb_shinfo(skb)->gso_size && !is_hw_tso_supported(pfvf, skb)) {
 		otx2_sq_append_tso(pfvf, sq, skb, qidx);
 		return true;
 	}
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_vf.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_vf.c
index 4321d90db9ec..f20f65569792 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_vf.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_vf.c
@@ -537,8 +537,7 @@ static int otx2vf_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	if (err)
 		goto err_detach_rsrc;
 
-	if (!is_96xx_A0(vf->pdev) && !is_95xx_A0(vf->pdev))
-		hw->hw_tso = true;
+	otx2_setup_dev_hw_settings(vf);
 
 	/* Assign default mac address */
 	otx2_get_mac_from_af(netdev);
-- 
2.31.1

