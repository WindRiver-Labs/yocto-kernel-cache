From cefeae7aaa6a16eea5c7efe2926deae0370dc6ff Mon Sep 17 00:00:00 2001
From: Bhaskara Budiredla <bbudiredla@marvell.com>
Date: Fri, 10 Jul 2020 18:21:10 +0530
Subject: [PATCH 599/767] drivers: gicv3: fetches atf mem region for LPI prop
 and pend tables

commit c3c89efef10ad9f9347bef6ffa1de2daccb7ac63 from
git@git.assembla.com:cavium/WindRiver.linux.git

This patch fetches Non-secure memory reserved through ATF
for redistributors LPI property and pending tables. This
is done to allow the secondary kernel to track the primary
kernel allocations as LPI config cannot be reprogrammed to
use different tables.

As per GICv3 architecture, once LPI tables are assigned to
redistributors and LPI delivery is enabled, there is no
guarantee that LPIs can be turned off as most implementations
do not allow it, nor it can be reprogrammed with other tables.

Change-Id: I8d8eb7d2c21ec52f8cf326233b9d604acf11c38f
Signed-off-by: Bhaskara Budiredla <bbudiredla@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/31752
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Tested-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[Kevin: Adjust the patch due to the change in e1a2e2010ba9]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/irqchip/Makefile                 |  2 +-
 drivers/irqchip/irq-gic-v3-fixes.c       | 92 ++++++++++++++++++++++++
 drivers/irqchip/irq-gic-v3-its.c         | 32 ++++++---
 include/linux/irqchip/arm-gic-v3.h       |  3 +
 include/linux/irqchip/irq-gic-v3-fixes.h | 21 ++++++
 5 files changed, 138 insertions(+), 12 deletions(-)
 create mode 100644 drivers/irqchip/irq-gic-v3-fixes.c
 create mode 100644 include/linux/irqchip/irq-gic-v3-fixes.h

diff --git a/drivers/irqchip/Makefile b/drivers/irqchip/Makefile
index 606a003a0000..c028a0d32ed1 100644
--- a/drivers/irqchip/Makefile
+++ b/drivers/irqchip/Makefile
@@ -29,7 +29,7 @@ obj-$(CONFIG_ARM_GIC)			+= irq-gic.o irq-gic-common.o
 obj-$(CONFIG_ARM_GIC_PM)		+= irq-gic-pm.o
 obj-$(CONFIG_ARCH_REALVIEW)		+= irq-gic-realview.o
 obj-$(CONFIG_ARM_GIC_V2M)		+= irq-gic-v2m.o
-obj-$(CONFIG_ARM_GIC_V3)		+= irq-gic-v3.o irq-gic-v3-mbi.o irq-gic-common.o
+obj-$(CONFIG_ARM_GIC_V3)		+= irq-gic-v3.o irq-gic-v3-mbi.o irq-gic-common.o irq-gic-v3-fixes.o
 obj-$(CONFIG_ARM_GIC_V3_ITS)		+= irq-gic-v3-its.o irq-gic-v3-its-platform-msi.o irq-gic-v4.o
 obj-$(CONFIG_ARM_GIC_V3_ITS_PCI)	+= irq-gic-v3-its-pci-msi.o
 obj-$(CONFIG_ARM_GIC_V3_ITS_FSL_MC)	+= irq-gic-v3-its-fsl-mc-msi.o
diff --git a/drivers/irqchip/irq-gic-v3-fixes.c b/drivers/irqchip/irq-gic-v3-fixes.c
new file mode 100644
index 000000000000..a3fee8e48ba8
--- /dev/null
+++ b/drivers/irqchip/irq-gic-v3-fixes.c
@@ -0,0 +1,92 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Marvell Silicon gicv3 definitions
+ *
+ * Copyright (C) 2020 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/percpu.h>
+#include <linux/arm-smccc.h>
+#include <linux/irqchip.h>
+#include <linux/irqchip/arm-gic-v3.h>
+#include <linux/irqchip/irq-gic-v3-fixes.h>
+
+#define OCTEONTX_LPI_PROP_TBL_BASE      0xc2000c0c
+#define gic_data_rdist()		(raw_cpu_ptr(gic_rdists->rdist))
+
+struct page *its_prop_alloc_pages(struct rdists *gic_rdists,
+				size_t prop_tbl_sz,  gfp_t gfp_flags)
+{
+	struct page *prop_page;
+	struct arm_smccc_res res;
+	void *vaddr;
+
+	gic_rdists->prop_table_pa = 0;
+	gic_rdists->prop_table_va = NULL;
+	arm_smccc_smc(OCTEONTX_LPI_PROP_TBL_BASE, 0, 0, 0, 0, 0, 0, 0, &res);
+	if (res.a0 == SMCCC_RET_SUCCESS) {
+		vaddr = memremap(res.a1, prop_tbl_sz, MEMREMAP_WB);
+		if (!vaddr)
+			return NULL;
+
+		gic_rdists->prop_table_pa = res.a1;
+		gic_rdists->prop_table_va = vaddr;
+		prop_page = NULL;
+	} else {
+		pr_warn("Failed to allocate LPI tables in atf\n");
+		prop_page = alloc_pages(gfp_flags, get_order(prop_tbl_sz));
+		if (!prop_page)
+			return NULL;
+
+		gic_rdists->prop_table_pa = page_to_phys(prop_page);
+		gic_rdists->prop_table_va = page_address(prop_page);
+	}
+
+	return prop_page;
+}
+
+struct page *its_pend_alloc_pages(struct rdists *gic_rdists,
+		size_t prop_tbl_sz, size_t pend_tbl_sz, gfp_t gfp_flags)
+{
+	struct page *pend_page;
+	void *vaddr;
+
+	gic_data_rdist()->pend_paddr = 0;
+	gic_data_rdist()->pend_vaddr = NULL;
+
+	if (!gic_rdists->prop_page) {
+		phys_addr_t paddr;
+
+		paddr = gic_rdists->prop_table_pa +
+			prop_tbl_sz +
+			pend_tbl_sz * smp_processor_id();
+		vaddr = memremap(paddr, pend_tbl_sz, MEMREMAP_WB);
+		if (!vaddr)
+			return NULL;
+
+		memset(vaddr, 0, pend_tbl_sz);
+		gic_data_rdist()->pend_paddr = paddr;
+		gic_data_rdist()->pend_vaddr = vaddr;
+		pend_page = NULL;
+	} else {
+		pend_page = alloc_pages(gfp_flags | __GFP_ZERO,
+			      get_order(max_t(u32, pend_tbl_sz, SZ_64K)));
+		if (!pend_page)
+			return NULL;
+
+		gic_data_rdist()->pend_paddr = page_to_phys(pend_page);
+		gic_data_rdist()->pend_vaddr = page_address(pend_page);
+	}
+
+	return pend_page;
+}
+
+int redist_lpis_enabled(struct rdists *gic_rdists)
+{
+	void __iomem *rbase = gic_data_rdist()->rd_base;
+
+	return (readl_relaxed(rbase + GICR_CTLR) & GICR_CTLR_ENABLE_LPIS);
+}
diff --git a/drivers/irqchip/irq-gic-v3-its.c b/drivers/irqchip/irq-gic-v3-its.c
index eeea66daa389..4d5e0e8e42f0 100644
--- a/drivers/irqchip/irq-gic-v3-its.c
+++ b/drivers/irqchip/irq-gic-v3-its.c
@@ -31,6 +31,7 @@
 #include <linux/irqchip.h>
 #include <linux/irqchip/arm-gic-v3.h>
 #include <linux/irqchip/arm-gic-v4.h>
+#include <linux/irqchip/irq-gic-v3-fixes.h>
 
 #include <asm/cputype.h>
 #include <asm/exception.h>
@@ -1638,11 +1639,12 @@ static struct page *its_allocate_prop_table(gfp_t gfp_flags)
 {
 	struct page *prop_page;
 
-	prop_page = alloc_pages(gfp_flags, get_order(LPI_PROPBASE_SZ));
-	if (!prop_page)
+	prop_page = its_prop_alloc_pages(gic_rdists,
+					LPI_PROPBASE_SZ, gfp_flags);
+	if (!prop_page && !gic_rdists->prop_table_va)
 		return NULL;
 
-	gic_reset_prop_table(page_address(prop_page));
+	gic_reset_prop_table(gic_rdists->prop_table_va);
 
 	return prop_page;
 }
@@ -2014,13 +2016,13 @@ static struct page *its_allocate_pending_table(gfp_t gfp_flags)
 {
 	struct page *pend_page;
 
-	pend_page = alloc_pages(gfp_flags | __GFP_ZERO,
-				get_order(LPI_PENDBASE_SZ));
-	if (!pend_page)
+	pend_page = its_pend_alloc_pages(gic_rdists, LPI_PROPBASE_SZ,
+				LPI_PENDBASE_SZ, gfp_flags | __GFP_ZERO);
+	if (!pend_page && !gic_data_rdist()->pend_vaddr)
 		return NULL;
 
 	/* Make sure the GIC will observe the zero-ed page */
-	gic_flush_dcache_to_poc(page_address(pend_page), LPI_PENDBASE_SZ);
+	gic_flush_dcache_to_poc(gic_data_rdist()->pend_vaddr, LPI_PENDBASE_SZ);
 
 	return pend_page;
 }
@@ -2164,6 +2166,7 @@ static void its_cpu_init_lpis(void)
 			val &= ~(GICR_PROPBASER_SHAREABILITY_MASK |
 				 GICR_PROPBASER_CACHEABILITY_MASK);
 			val |= GICR_PROPBASER_nC;
+
 			gicr_write_propbaser(val, rbase + GICR_PROPBASER);
 		}
 		pr_info_once("GIC: using cache flushing for LPI property table\n");
@@ -2171,7 +2174,7 @@ static void its_cpu_init_lpis(void)
 	}
 
 	/* set PENDBASE */
-	val = (page_to_phys(pend_page) |
+	val = (gic_data_rdist()->pend_paddr |
 	       GICR_PENDBASER_InnerShareable |
 	       GICR_PENDBASER_RaWaWb);
 
@@ -3787,9 +3790,16 @@ int its_cpu_init(void)
 	if (!list_empty(&its_nodes)) {
 		int ret;
 
-		ret = redist_disable_lpis();
-		if (ret)
-			return ret;
+		/*
+		 * This field resets to 0 after power up and is
+		 * set to 1 during Primary Kernel booting and is
+		 * RES1 for Secondary Kerenl booting.
+		 */
+		if (!redist_lpis_enabled(gic_rdists)) {
+			ret = redist_disable_lpis();
+			if (ret)
+				return ret;
+		}
 
 		its_cpu_init_lpis();
 		its_cpu_init_collections();
diff --git a/include/linux/irqchip/arm-gic-v3.h b/include/linux/irqchip/arm-gic-v3.h
index 67c4b9806d43..f439e3e85a86 100644
--- a/include/linux/irqchip/arm-gic-v3.h
+++ b/include/linux/irqchip/arm-gic-v3.h
@@ -577,9 +577,12 @@ struct rdists {
 	struct {
 		void __iomem	*rd_base;
 		struct page	*pend_page;
+		phys_addr_t	pend_paddr;
+		void		*pend_vaddr;
 		phys_addr_t	phys_base;
 		bool		lpi_enabled;
 	} __percpu		*rdist;
+	struct page		*prop_page;
 	phys_addr_t		prop_table_pa;
 	void			*prop_table_va;
 	u64			flags;
diff --git a/include/linux/irqchip/irq-gic-v3-fixes.h b/include/linux/irqchip/irq-gic-v3-fixes.h
new file mode 100644
index 000000000000..3b03be60650c
--- /dev/null
+++ b/include/linux/irqchip/irq-gic-v3-fixes.h
@@ -0,0 +1,21 @@
+/* SPDX-License-Identifier: GPL-2.0
+ * Marvell Silicon gicv3 definitions
+ *
+ * Copyright (C) 2020 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __LINUX_IRQCHIP_MARVELL_GIC_V3_H
+#define __LINUX_IRQCHIP_MARVELL_GIC_V3_H
+
+struct page *its_prop_alloc_pages(struct rdists *gic_rdists,
+				size_t prop_tbl_sz,  gfp_t gfp_flags);
+struct page *its_pend_alloc_pages(struct rdists *gic_rdists,
+		size_t prop_tbl_sz, size_t pend_tbl_sz, gfp_t gfp_flags);
+int redist_lpis_enabled(struct rdists *gic_rdists);
+
+#endif
+
-- 
2.31.1

