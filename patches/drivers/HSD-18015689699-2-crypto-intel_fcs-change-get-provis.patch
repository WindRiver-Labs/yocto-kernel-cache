From 4848be1307853c843887d20bdb3bf30125abc217 Mon Sep 17 00:00:00 2001
From: Siew Chin Lim <elly.siew.chin.lim@intel.com>
Date: Mon, 6 Sep 2021 09:57:31 +0800
Subject: [PATCH 05/20] HSD #18015689699-2: crypto: intel_fcs: change get
 provision data to async SMC call

commt 63348ea80ce1bfbebf196bd8d8ed1663615f1917 from
https://github.com/altera-opensource/linux-socfpga/commits/socfpga-5.4.124-lts

Change INTEL_SIP_SMC_FCS_GET_PROVISION_DATA's SMC call to async from sync
to avoid long runtime which may cause the watchdog timeout issue.

Signed-off-by: Richard Gong <richard.gong@intel.com>
Signed-off-by: Siew Chin Lim <elly.siew.chin.lim@intel.com>
Integrated-by: Abhishek Paliwal <paliwal.abhishek@windriver.com>
---
 drivers/crypto/intel_fcs.c | 60 +++++++++++++++++++++++++++-----------
 1 file changed, 43 insertions(+), 17 deletions(-)

diff --git a/drivers/crypto/intel_fcs.c b/drivers/crypto/intel_fcs.c
index 7ea594329fae..d8c55d7c59f5 100644
--- a/drivers/crypto/intel_fcs.c
+++ b/drivers/crypto/intel_fcs.c
@@ -494,33 +494,59 @@ static long fcs_ioctl(struct file *file, unsigned int cmd,
 		}
 
 		msg->command = COMMAND_FCS_GET_PROVISION_DATA;
-		msg->payload = s_buf;
-		msg->payload_length = data->com_paras.gp_data.size;
-		priv->client.receive_cb = fcs_data_callback;
+		msg->payload = NULL;
+		msg->payload_length = 0;
+		priv->client.receive_cb = fcs_vab_callback;
 
 		ret = fcs_request_service(priv, (void *)msg,
 					  FCS_REQUEST_TIMEOUT);
 		if (!ret && !priv->status) {
-			if (!priv->kbuf) {
-				dev_err(dev, "failure on kbuf\n");
-				fcs_close_services(priv, s_buf, NULL);
-				return -EFAULT;
-			}
-			data->com_paras.gp_data.size = priv->size;
-			ret = copy_to_user(data->com_paras.gp_data.addr,
-					   priv->kbuf, priv->size);
-			if (ret) {
-				dev_err(dev, "failure on copy_to_user\n");
-				fcs_close_services(priv, s_buf, NULL);
-				return -EFAULT;
+			/* to query the complete status */
+			msg->arg[0] = ASYNC_POLL_SERVICE;
+			msg->payload = s_buf;
+			msg->payload_length = data->com_paras.gp_data.size;
+			msg->command = COMMAND_POLL_SERVICE_STATUS_ASYNC;
+			priv->client.receive_cb = fcs_data_callback;
+
+			timeout = 100;
+			while (timeout != 0) {
+				ret = fcs_request_service(priv, (void *)msg,
+							  FCS_REQUEST_TIMEOUT);
+				dev_dbg(dev, "request service ret=%d\n", ret);
+
+				if (!ret && !priv->status) {
+					if (priv->size) {
+						if (!priv->kbuf) {
+							dev_err(dev, "failure on kbuf\n");
+							fcs_close_services(priv, s_buf, NULL);
+							return -EFAULT;
+						}
+
+						data->com_paras.gp_data.size = priv->size;
+						ret = copy_to_user(data->com_paras.gp_data.addr,
+								   priv->kbuf, priv->size);
+						if (ret) {
+							dev_err(dev, "failure on copy_to_user\n");
+							fcs_close_services(priv, s_buf, NULL);
+							return -EFAULT;
+						}
+						break;
+					}
+				} else {
+					data->com_paras.gp_data.addr = NULL;
+					data->com_paras.gp_data.size = 0;
+					break;
+				}
+				timeout--;
+				mdelay(500);
 			}
-			data->status = 0;
 		} else {
 			data->com_paras.gp_data.addr = NULL;
 			data->com_paras.gp_data.size = 0;
-			data->status = priv->status;
 		}
 
+		data->status = priv->status;
+
 		if (copy_to_user((void __user *)arg, data, sizeof(*data))) {
 			dev_err(dev, "failure on copy_to_user\n");
 			fcs_close_services(priv, s_buf, NULL);
-- 
2.31.1

