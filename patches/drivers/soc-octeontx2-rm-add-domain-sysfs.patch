From 1a1759140d159c5bfa10b806c0056dbc20e02eb4 Mon Sep 17 00:00:00 2001
From: Stanislaw Kardach <skardach@marvell.com>
Date: Thu, 20 Dec 2018 15:52:18 +0300
Subject: [PATCH 153/767] soc: octeontx2-rm: add domain sysfs

commit 9b54c6583059413399b87d5ab9ba43589c7b5ae3 from
git@git.assembla.com:cavium/WindRiver.linux.git

This commit provides convenience sysfs interfaces for partitioning
non-NIC resources and OcteonTX2 RVU based NIC devices between users in
form of application domains.

Change-Id: I54048ec9bfb8319bff0b23e61d390ca208d6f52d
Signed-off-by: Stanislaw Kardach <skardach@marvell.com>
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/soc/marvell/Kconfig                   |  55 ++
 drivers/soc/marvell/octeontx2-rm/Makefile     |   1 +
 .../soc/marvell/octeontx2-rm/domain_sysfs.c   | 583 ++++++++++++++++++
 .../soc/marvell/octeontx2-rm/domain_sysfs.h   |  18 +
 drivers/soc/marvell/octeontx2-rm/otx2_rm.c    |  19 +
 5 files changed, 676 insertions(+)
 create mode 100644 drivers/soc/marvell/octeontx2-rm/domain_sysfs.c
 create mode 100644 drivers/soc/marvell/octeontx2-rm/domain_sysfs.h

diff --git a/drivers/soc/marvell/Kconfig b/drivers/soc/marvell/Kconfig
index cdd35d459b5e..25952bcee90f 100644
--- a/drivers/soc/marvell/Kconfig
+++ b/drivers/soc/marvell/Kconfig
@@ -12,4 +12,59 @@ config OCTEONTX2_RM
 	  OcteonTX2 Resource Virtualization Unit SSO/TIM PFs which are used
 	  for interfacing with non-NIC hardware offload units.
 
+config OCTEONTX2_RM_DOM_SYSFS
+	bool "OcteonTX2 RVU Resource Manager domain sysfs"
+	depends on OCTEONTX2_RM
+	---help---
+	  Enable Application Domain sysfs which simplifies management of
+	  SSO/TIM VFs and OcteonTX2 RVU based NIC devices by the system
+	  administrator. This interface consists of the following files:
+
+	  I. /sys/bus/pci/drivers/octeontx2-rm/0*/create_domain
+
+	  Writing to this file will:
+	  1. Create a domain directory in /sys/bus/pci/drivers/octeontx2-rm/0*
+	     with the domain name
+	  2. Reserve one of SSO/TIM VFs for this domain and set its limits
+	     according to the specification passed in write string
+	  3. Create symlinks to all devices that will be part of the domain
+	     in the directory created in point 1
+	  4. Create domain_id file returning the ID assigned to this domain
+	     (effectively the domain name)
+	  5. Create domain_in_use file which reports state of domain's
+	     SSO/TIM device's in_use file to indicate when domain is used
+	     by an application.
+
+	  The syntax for writing into this file is:
+
+	      name;param:val(;param:val)*
+
+	  * name - domain name
+	  * param - parameter name, based on the parameter, its value 'val'
+	    has to have a different format:
+	    * sso, ssow, npa, tim, cpt - 'val' is an integer value of the
+	      number of LFs to assign to the domain
+	    * port - 'val' is in 'DDDD:BB:DD.F' format and specifies device
+	      representing a port.
+
+	  There are the following rules when creating a domain:
+
+	  1. Domain names must be unique
+	  2. Each domain must have at least 1 NPA and 1 SSOW LF
+	  3. One port may be only assigned to a single domain
+
+	  II. /sys/bus/pci/drivers/octeontx2-rm/0*/destroy_domain
+
+	  Writing domain name to this file will cause given domain to be
+	  removed from the sysfs. This includes:
+	  1. Setting all limits of domain's SSO/TIM device to 0
+	  2. Removing all sysfs structures for this domain
+	  3. Removing all ports in this application domain from the list of
+	     ports in use.
+
+	  Removal of the domain is disabled while domain is in use, that
+	  is while the 'in_use' flag of the domain's SSO/TIM device is set.
+	  User/admin may query the status of this flag using the
+	  'domain_in_use'  file in the domain's sysfs directory.
+
 endmenu
diff --git a/drivers/soc/marvell/octeontx2-rm/Makefile b/drivers/soc/marvell/octeontx2-rm/Makefile
index 6257b6aea4b5..2dc61fd4a8c8 100644
--- a/drivers/soc/marvell/octeontx2-rm/Makefile
+++ b/drivers/soc/marvell/octeontx2-rm/Makefile
@@ -6,4 +6,5 @@
 obj-$(CONFIG_OCTEONTX2_RM) += octeontx2_rm.o
 
 octeontx2_rm-y := otx2_rm.o quota.o
+octeontx2_rm-$(CONFIG_OCTEONTX2_RM_DOM_SYSFS) += domain_sysfs.o
 ccflags-y += -I$(srctree)/drivers/net/ethernet/marvell/octeontx2/af
diff --git a/drivers/soc/marvell/octeontx2-rm/domain_sysfs.c b/drivers/soc/marvell/octeontx2-rm/domain_sysfs.c
new file mode 100644
index 000000000000..355e667b889d
--- /dev/null
+++ b/drivers/soc/marvell/octeontx2-rm/domain_sysfs.c
@@ -0,0 +1,583 @@
+// SPDX-License-Identifier: GPL-2.0
+/* OcteonTX2 RVU Resource Manager driver
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/sysfs.h>
+#include "domain_sysfs.h"
+#include "otx2_rm.h"
+
+#define DOMAIN_NAME_LEN	32
+#define PCI_SCAN_FMT	"%04x:%02x:%02x.%02x"
+
+/* The format of DP is: DP(_name, _param_type, _scanf_fmt) */
+#define DOM_PARAM_SPEC	\
+DP(ssow, int, "%d")	\
+DP(sso, int, "%d")	\
+DP(npa, int, "%d")	\
+DP(cpt, int, "%d")	\
+DP(tim, int, "%d")
+
+struct domain_params {
+	const char *name;
+#define DP(_name, _type, _1) \
+	_type _name;
+DOM_PARAM_SPEC
+#undef DP
+	const char *ports[RM_MAX_PORTS];
+	u16 port_cnt;
+};
+
+struct domain {
+	char			name[DOMAIN_NAME_LEN];
+	struct kobj_attribute	domain_id;
+	struct kobj_attribute	domain_in_use;
+	/* List of all ports attached to the domain */
+	struct rvu_port		*ports;
+	struct kobject		*kobj;
+	struct rvu_vf		*rvf;
+	int			port_count;
+	bool			in_use;
+};
+
+struct rvu_port {
+	/* handle in global list of ports associated to all domains */
+	struct list_head	list;
+	struct pci_dev		*pdev;
+	struct domain		*domain;
+};
+
+struct domain_sysfs {
+	struct list_head	list;
+	struct kobj_attribute	create_domain;
+	struct kobj_attribute	destroy_domain;
+	/* List of all ports added to all domains. Used for validating if new
+	 * domain creation doesn't want to take an already taken port.
+	 */
+	struct list_head	ports;
+	struct rm_dev		*rdev;
+	struct kobject		*parent;
+	struct domain		*domains;
+	size_t			domains_len;
+};
+
+static DEFINE_MUTEX(domain_sysfs_lock);
+static LIST_HEAD(domain_sysfs_list);
+
+static ssize_t
+domain_id_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)
+{
+	struct domain *dom = container_of(attr, struct domain, domain_id);
+
+	return snprintf(buf, PAGE_SIZE, "%s\n", dom->name);
+}
+
+static ssize_t
+domain_in_use_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)
+{
+	struct domain *dom = container_of(attr, struct domain, domain_in_use);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", dom->rvf->in_use);
+}
+
+static int do_destroy_domain(struct domain_sysfs *lsfs, struct domain *domain)
+{
+	struct device *dev = &lsfs->rdev->pdev->dev;
+	int i;
+
+	if (domain->rvf->in_use) {
+		dev_err(dev, "Domain %s is in use.\n", domain->name);
+		return -EBUSY;
+	}
+
+	sysfs_remove_file(domain->kobj, &domain->domain_id.attr);
+	domain->domain_id.attr.mode = 0;
+	sysfs_remove_file(domain->kobj, &domain->domain_in_use.attr);
+	domain->domain_in_use.attr.mode = 0;
+	for (i = 0; i < domain->port_count; i++) {
+		sysfs_remove_link(domain->kobj,
+				  pci_name(domain->ports[i].pdev));
+	}
+	sysfs_remove_link(domain->kobj, pci_name(domain->rvf->pdev));
+	kobject_del(domain->kobj);
+	mutex_lock(&lsfs->rdev->lock);
+	// restore limits
+	lsfs->rdev->vf_limits.sso->a[domain->rvf->vf_id].val = 0;
+	lsfs->rdev->vf_limits.ssow->a[domain->rvf->vf_id].val = 0;
+	lsfs->rdev->vf_limits.npa->a[domain->rvf->vf_id].val = 0;
+	lsfs->rdev->vf_limits.cpt->a[domain->rvf->vf_id].val = 0;
+	lsfs->rdev->vf_limits.tim->a[domain->rvf->vf_id].val = 0;
+	mutex_unlock(&lsfs->rdev->lock);
+
+	mutex_lock(&domain_sysfs_lock);
+	// FREE ALL allocated ports
+	for (i = 0; i < domain->port_count; i++) {
+		list_del(&domain->ports[i].list);
+		pci_dev_put(domain->ports[i].pdev);
+	}
+	kfree(domain->ports);
+	domain->ports = NULL;
+	domain->port_count = 0;
+	domain->in_use = false;
+	domain->name[0] = '\0';
+	mutex_unlock(&domain_sysfs_lock);
+
+	return 0;
+}
+
+static int
+do_create_domain(struct domain_sysfs *lsfs, struct domain_params *dparams)
+{
+	struct device *dev = &lsfs->rdev->pdev->dev;
+	struct domain *domain = NULL;
+	struct rvu_port *ports = NULL, *cur;
+	u32 dom, bus, slot, fn;
+	int old_sso, old_ssow, old_npa, old_cpt, old_tim, device;
+	int res = 0, i;
+
+	/* Validate parameters */
+	if (dparams == NULL)
+		return -EINVAL;
+	if (strnlen(dparams->name, DOMAIN_NAME_LEN) >= DOMAIN_NAME_LEN) {
+		dev_err(dev, "Domain name too long, max %d characters.\n",
+			DOMAIN_NAME_LEN);
+		return -EINVAL;
+	}
+	if (dparams->npa != 1) {
+		dev_err(dev, "Exactly 1 NPA resource required.\n");
+		return -EINVAL;
+	}
+	if (dparams->ssow < 1) {
+		dev_err(dev, "At least 1 SSOW resource required.\n");
+		return -EINVAL;
+	}
+	mutex_lock(&domain_sysfs_lock);
+	/* Find a free domain device */
+	for (i = 0; i < lsfs->domains_len; i++) {
+		if (!strncmp(lsfs->domains[i].name, dparams->name,
+			     DOMAIN_NAME_LEN)) {
+			dev_err(dev, "Domain %s exists already.\n",
+				dparams->name);
+			res = -EINVAL;
+			goto err_dom;
+		}
+		if (lsfs->domains[i].in_use == false &&
+		    lsfs->domains[i].rvf->in_use == false) {
+			if (domain == NULL)
+				domain = &lsfs->domains[i];
+		}
+	}
+	if (domain == NULL) {
+		dev_err(dev, "No free device to create new domain.\n");
+		res = -ENODEV;
+		goto err_dom;
+	}
+	strncpy(domain->name, dparams->name, DOMAIN_NAME_LEN);
+	domain->in_use = true;
+	/* Verify ports are valid and supported. */
+	if (dparams->port_cnt == 0)
+		goto skip_ports;
+	ports = kcalloc(dparams->port_cnt, sizeof(struct rvu_port), GFP_KERNEL);
+	if (ports == NULL) {
+		dev_err(dev, "Not enough memory.\n");
+		res = -ENOMEM;
+		goto err_ports;
+	}
+	for (i = 0; i < dparams->port_cnt; i++) {
+		if (sscanf(dparams->ports[i], PCI_SCAN_FMT, &dom, &bus, &slot,
+		    &fn) != 4) {
+			dev_err(dev, "Invalid port: %s.\n", dparams->ports[i]);
+			res = -EINVAL;
+			goto err_ports;
+		}
+		ports[i].pdev =
+			pci_get_domain_bus_and_slot(dom, bus,
+						    PCI_DEVFN(slot, fn));
+		if (ports[i].pdev == NULL) {
+			dev_err(dev, "Unknown port: %s.\n", dparams->ports[i]);
+			res = -ENODEV;
+			goto err_ports;
+		}
+		device = ports[i].pdev->device;
+		if (ports[i].pdev->vendor != PCI_VENDOR_ID_CAVIUM ||
+		    (device != PCI_DEVID_OCTEONTX2_RVU_PF &&
+		     device != PCI_DEVID_OCTEONTX2_PASS1_RVU_PF &&
+		     device != PCI_DEVID_OCTEONTX2_RVU_AFVF &&
+		     device != PCI_DEVID_OCTEONTX2_PASS1_RVU_AFVF &&
+		     device != PCI_DEVID_OCTEONTX2_RVU_VF &&
+		     device != PCI_DEVID_OCTEONTX2_PASS1_RVU_VF)) {
+			dev_err(dev, "Unsupported port: %s.\n",
+				dparams->ports[i]);
+			res = -EINVAL;
+			goto err_ports;
+		}
+		list_for_each_entry(cur, &lsfs->ports, list) {
+			if (cur->pdev != ports[i].pdev)
+				continue;
+			dev_err(dev,
+				"Port %s already assigned to domain %s.\n",
+				dparams->ports[i], cur->domain->name);
+			res = -EBUSY;
+			goto err_ports;
+		}
+	}
+	for (i = 0; i < dparams->port_cnt; i++) {
+		ports[i].domain = domain;
+		list_add(&ports[i].list, &lsfs->ports);
+	}
+	domain->ports = ports;
+	domain->port_count = dparams->port_cnt;
+skip_ports:
+	mutex_unlock(&domain_sysfs_lock);
+	/* Check domain spec against limits for the parent RVU. */
+	mutex_lock(&lsfs->rdev->lock);
+	old_sso = lsfs->rdev->vf_limits.sso->a[domain->rvf->vf_id].val;
+	old_ssow = lsfs->rdev->vf_limits.ssow->a[domain->rvf->vf_id].val;
+	old_npa = lsfs->rdev->vf_limits.npa->a[domain->rvf->vf_id].val;
+	old_cpt = lsfs->rdev->vf_limits.cpt->a[domain->rvf->vf_id].val;
+	old_tim = lsfs->rdev->vf_limits.tim->a[domain->rvf->vf_id].val;
+#define CHECK_LIMITS(_ls, _val, _n, _idx) do {				    \
+	if (quotas_get_sum(_ls) + _val - _ls->a[_idx].val > _ls->max_sum) { \
+		dev_err(dev,						    \
+			"Not enough "_n" LFs, currently used: %lld/%lld\n", \
+			quotas_get_sum(_ls), _ls->max_sum);		    \
+		res = -ENODEV;						    \
+		goto err_limits;					    \
+	}								    \
+} while (0)
+	CHECK_LIMITS(lsfs->rdev->vf_limits.sso, dparams->sso, "SSO",
+		     domain->rvf->vf_id);
+	CHECK_LIMITS(lsfs->rdev->vf_limits.ssow, dparams->ssow, "SSOW",
+		     domain->rvf->vf_id);
+	CHECK_LIMITS(lsfs->rdev->vf_limits.npa, dparams->npa, "NPA",
+		     domain->rvf->vf_id);
+	CHECK_LIMITS(lsfs->rdev->vf_limits.cpt, dparams->cpt, "CPT",
+		     domain->rvf->vf_id);
+	CHECK_LIMITS(lsfs->rdev->vf_limits.tim, dparams->tim, "TIM",
+		     domain->rvf->vf_id);
+	/* Now that checks are done, update the limits */
+	lsfs->rdev->vf_limits.sso->a[domain->rvf->vf_id].val = dparams->sso;
+	lsfs->rdev->vf_limits.ssow->a[domain->rvf->vf_id].val = dparams->ssow;
+	lsfs->rdev->vf_limits.npa->a[domain->rvf->vf_id].val = dparams->npa;
+	lsfs->rdev->vf_limits.cpt->a[domain->rvf->vf_id].val = dparams->cpt;
+	lsfs->rdev->vf_limits.tim->a[domain->rvf->vf_id].val = dparams->tim;
+	mutex_unlock(&lsfs->rdev->lock);
+
+	/* Set it up according to user spec */
+	domain->kobj = kobject_create_and_add(dparams->name, lsfs->parent);
+	if (domain->kobj == NULL) {
+		dev_err(dev, "Failed to create domain directory.\n");
+		res = -ENOMEM;
+		goto err_kobject_create;
+	}
+	res = sysfs_create_link(domain->kobj, &domain->rvf->pdev->dev.kobj,
+				pci_name(domain->rvf->pdev));
+	if (res < 0) {
+		dev_err(dev, "Failed to create dev links for domain %s.\n",
+			domain->name);
+		res = -ENOMEM;
+		goto err_dom_dev_symlink;
+	}
+	for (i = 0; i < dparams->port_cnt; i++) {
+		res = sysfs_create_link(domain->kobj, &ports[i].pdev->dev.kobj,
+					pci_name(ports[i].pdev));
+		if (res < 0) {
+			dev_err(dev,
+				"Failed to create dev links for domain %s.\n",
+				domain->name);
+			res = -ENOMEM;
+			goto err_dom_port_symlink;
+		}
+	}
+	domain->domain_in_use.attr.mode = 0444;
+	domain->domain_in_use.attr.name = "domain_in_use";
+	domain->domain_in_use.show = domain_in_use_show;
+	res = sysfs_create_file(domain->kobj, &domain->domain_in_use.attr);
+	if (res < 0) {
+		dev_err(dev,
+			"Failed to create domain_in_use file for domain %s.\n",
+			domain->name);
+		res = -ENOMEM;
+		goto err_dom_in_use;
+	}
+
+	domain->domain_id.attr.mode = 0444;
+	domain->domain_id.attr.name = "domain_id";
+	domain->domain_id.show = domain_id_show;
+	res = sysfs_create_file(domain->kobj, &domain->domain_id.attr);
+	if (res < 0) {
+		dev_err(dev, "Failed to create domain_id file for domain %s.\n",
+			domain->name);
+		res = -ENOMEM;
+		goto err_dom_id;
+	}
+
+	return res;
+
+err_dom_id:
+	domain->domain_id.attr.mode = 0;
+	sysfs_remove_file(domain->kobj, &domain->domain_in_use.attr);
+err_dom_in_use:
+	domain->domain_in_use.attr.mode = 0;
+err_dom_port_symlink:
+	for (i = 0; i < dparams->port_cnt; i++)
+		sysfs_remove_link(domain->kobj, pci_name(ports[i].pdev));
+	sysfs_remove_link(domain->kobj, pci_name(domain->rvf->pdev));
+err_dom_dev_symlink:
+	kobject_del(domain->kobj);
+err_kobject_create:
+	mutex_lock(&lsfs->rdev->lock);
+err_limits:
+	// restore limits
+	lsfs->rdev->vf_limits.sso->a[domain->rvf->vf_id].val = old_sso;
+	lsfs->rdev->vf_limits.ssow->a[domain->rvf->vf_id].val = old_ssow;
+	lsfs->rdev->vf_limits.npa->a[domain->rvf->vf_id].val = old_npa;
+	lsfs->rdev->vf_limits.cpt->a[domain->rvf->vf_id].val = old_cpt;
+	lsfs->rdev->vf_limits.tim->a[domain->rvf->vf_id].val = old_tim;
+	mutex_unlock(&lsfs->rdev->lock);
+	mutex_lock(&domain_sysfs_lock);
+err_ports:
+	// FREE ALL allocated ports
+	for (i = 0; i < dparams->port_cnt; i++) {
+		if (ports[i].pdev == NULL)
+			break;
+		if (ports[i].domain != NULL)
+			list_del(&ports[i].list);
+		pci_dev_put(ports[i].pdev);
+	}
+	kfree(ports);
+	domain->ports = NULL;
+	domain->port_count = 0;
+	domain->in_use = false;
+	domain->name[0] = '\0';
+err_dom:
+	mutex_unlock(&domain_sysfs_lock);
+	return res;
+}
+
+static ssize_t
+destroy_domain_store(struct kobject *kobj, struct kobj_attribute *attr,
+		    const char *buf, size_t count)
+{
+	struct domain_sysfs *lsfs =
+		container_of(attr, struct domain_sysfs, destroy_domain);
+	struct device *dev = &lsfs->rdev->pdev->dev;
+	struct domain *domain = NULL;
+	char name[DOMAIN_NAME_LEN], *name_ptr;
+	int i, res;
+
+	strncpy(name, buf, DOMAIN_NAME_LEN);
+	name_ptr = strim(name);
+	if (strlen(name_ptr) == 0) {
+		dev_err(dev, "Empty domain name.\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&domain_sysfs_lock);
+	/* Find a free domain device */
+	for (i = 0; i < lsfs->domains_len; i++) {
+		if (!strncmp(lsfs->domains[i].name, name_ptr,
+		    DOMAIN_NAME_LEN)) {
+			domain = &lsfs->domains[i];
+			break;
+		}
+	}
+	if (domain == NULL) {
+		dev_err(dev, "Domain '%s' doesn't exist.\n", name);
+		res = -EINVAL;
+		goto err_dom;
+	}
+	mutex_unlock(&domain_sysfs_lock);
+
+	res = do_destroy_domain(lsfs, domain);
+	if (res == 0)
+		res = count;
+err_dom:
+	mutex_unlock(&domain_sysfs_lock);
+	return res;
+}
+
+static ssize_t
+create_domain_store(struct kobject *kobj, struct kobj_attribute *attr,
+		    const char *buf, size_t count)
+{
+	struct domain_params *dparams = NULL;
+	struct domain_sysfs *lsfs =
+		container_of(attr, struct domain_sysfs, create_domain);
+	struct device *dev = &lsfs->rdev->pdev->dev;
+	int res = 0;
+	char *start;
+	char *end;
+	char *ptr = NULL;
+	const char *name;
+	char *temp;
+	char *errmsg = "Invalid domain specification format.";
+
+	if (strlen(buf) == 0) {
+		dev_err(dev, "Empty domain spec.\n");
+		return -EINVAL;
+	}
+
+	dparams = kzalloc(sizeof(*dparams), GFP_KERNEL);
+	if (dparams == NULL) {
+		errmsg = "Not enough memory";
+		res = -ENOMEM;
+		goto error;
+	}
+
+	end = kzalloc(PAGE_SIZE, GFP_KERNEL);
+	if (end == NULL) {
+		errmsg = "Not enough memory";
+		res = -ENOMEM;
+		goto error;
+	}
+
+	ptr = end;
+	memcpy(end, buf, count);
+
+	name = strsep(&end, ";");
+	if (end == NULL) {
+		res = -EINVAL;
+		goto error;
+	}
+
+	dparams->name = name;
+
+	for (;;) {
+		start = strsep(&end, ";");
+		if (start == NULL)
+			break;
+		start = strim(start);
+		if (!*start)
+			continue;
+
+		if (!strncmp(strim(start), "port", sizeof("port") - 1)) {
+			temp = strsep(&start, ":");
+			if (dparams->port_cnt >= RM_MAX_PORTS)
+				goto error;
+			dparams->ports[dparams->port_cnt++] = strim(start);
+		}
+		#define DP(_name, _1, _fmt)				\
+		else if (!strncmp(strim(start), #_name,			\
+				  sizeof(#_name) - 1)) {		\
+			temp = strsep(&start, ":");			\
+			start = strim(start);				\
+			res = sscanf(start, _fmt, &dparams->_name);	\
+			if (res != 1)					\
+				goto error;				\
+			continue;					\
+		}
+		DOM_PARAM_SPEC
+		#undef DP
+		else {
+			res = -EINVAL;
+			goto error;
+		}
+	}
+	res = do_create_domain(lsfs, dparams);
+	if (res < 0) {
+		errmsg = "Failed to create application domain.";
+		goto error;
+	} else
+		res = count;
+error:
+	if (res < 0)
+		dev_err(dev, "%s\n", errmsg);
+	kfree(ptr);
+	kfree(dparams);
+	return res;
+}
+
+int domain_sysfs_create(struct rm_dev *rm)
+{
+	struct domain_sysfs *lsfs;
+	int res = 0, i;
+
+	if (rm == NULL || rm->num_vfs == 0)
+		return -EINVAL;
+
+	lsfs = kzalloc(sizeof(*lsfs), GFP_KERNEL);
+	if (lsfs == NULL) {
+		res = -ENOMEM;
+		goto err_lsfs_alloc;
+	}
+
+	INIT_LIST_HEAD(&lsfs->ports);
+	lsfs->rdev = rm;
+	lsfs->domains_len = rm->num_vfs;
+	lsfs->domains =
+		kcalloc(lsfs->domains_len, sizeof(struct domain), GFP_KERNEL);
+	if (lsfs->domains == NULL)
+		goto err_domains_alloc;
+	for (i = 0; i < lsfs->domains_len; i++)
+		lsfs->domains[i].rvf = &rm->vf_info[i];
+
+	lsfs->create_domain.attr.name = "create_domain";
+	lsfs->create_domain.attr.mode = 0200;
+	lsfs->create_domain.store = create_domain_store;
+	res = sysfs_create_file(&rm->pdev->dev.kobj, &lsfs->create_domain.attr);
+	if (res)
+		goto err_create_domain;
+
+	lsfs->destroy_domain.attr.name = "destroy_domain";
+	lsfs->destroy_domain.attr.mode = 0200;
+	lsfs->destroy_domain.store = destroy_domain_store;
+	res = sysfs_create_file(&rm->pdev->dev.kobj,
+				&lsfs->destroy_domain.attr);
+	if (res)
+		goto err_destroy_domain;
+
+	lsfs->parent = &rm->pdev->dev.kobj;
+
+	mutex_lock(&domain_sysfs_lock);
+	list_add_tail(&lsfs->list, &domain_sysfs_list);
+	mutex_unlock(&domain_sysfs_lock);
+
+	return 0;
+
+err_destroy_domain:
+	sysfs_remove_file(&rm->pdev->dev.kobj, &lsfs->create_domain.attr);
+err_create_domain:
+	kfree(lsfs->domains);
+err_domains_alloc:
+	kfree(lsfs);
+err_lsfs_alloc:
+	return res;
+}
+
+void domain_sysfs_destroy(struct rm_dev *rm)
+{
+	struct list_head *pos, *n;
+	struct domain_sysfs *lsfs;
+
+	if (rm == NULL)
+		return;
+
+	mutex_lock(&domain_sysfs_lock);
+	list_for_each_safe(pos, n, &domain_sysfs_list) {
+		lsfs = container_of(pos, struct domain_sysfs, list);
+		if (lsfs->rdev == rm) {
+			list_del(pos);
+			break;
+		}
+		lsfs = NULL;
+	}
+	mutex_unlock(&domain_sysfs_lock);
+
+	if (lsfs == NULL)
+		return;
+
+
+
+	if (lsfs->destroy_domain.attr.mode != 0)
+		sysfs_remove_file(lsfs->parent, &lsfs->destroy_domain.attr);
+	if (lsfs->create_domain.attr.mode != 0)
+		sysfs_remove_file(lsfs->parent, &lsfs->create_domain.attr);
+
+	kfree(lsfs->domains);
+	kfree(lsfs);
+}
diff --git a/drivers/soc/marvell/octeontx2-rm/domain_sysfs.h b/drivers/soc/marvell/octeontx2-rm/domain_sysfs.h
new file mode 100644
index 000000000000..d28d5b8e8f38
--- /dev/null
+++ b/drivers/soc/marvell/octeontx2-rm/domain_sysfs.h
@@ -0,0 +1,18 @@
+// SPDX-License-Identifier: GPL-2.0
+/* OcteonTX2 RVU Resource Manager driver
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef DOMAIN_SYSFS_H_
+#define DOMAIN_SYSFS_H_
+
+#include "otx2_rm.h"
+
+int domain_sysfs_create(struct rm_dev *rm);
+void domain_sysfs_destroy(struct rm_dev *rm);
+
+#endif /* DOMAIN_SYSFS_H_ */
diff --git a/drivers/soc/marvell/octeontx2-rm/otx2_rm.c b/drivers/soc/marvell/octeontx2-rm/otx2_rm.c
index 447964672855..a398603a4319 100644
--- a/drivers/soc/marvell/octeontx2-rm/otx2_rm.c
+++ b/drivers/soc/marvell/octeontx2-rm/otx2_rm.c
@@ -19,6 +19,9 @@
 #include "rvu_struct.h"
 #include "otx2_rm.h"
 
+#ifdef CONFIG_OCTEONTX2_RM_DOM_SYSFS
+#include "domain_sysfs.h"
+#endif
 
 #define DRV_NAME	"octeontx2-rm"
 #define DRV_VERSION	"1.0"
@@ -1341,6 +1344,9 @@ int __sriov_disable(struct pci_dev *pdev)
 	disable_vf_flr_int(pdev);
 	disable_vf_mbox_int(pdev);
 
+#ifdef CONFIG_OCTEONTX2_RM_DOM_SYSFS
+	domain_sysfs_destroy(rm);
+#endif
 	vf_sysfs_destroy(pdev);
 
 	if (rm->pfvf_mbox_wq) {
@@ -1469,10 +1475,23 @@ int __sriov_enable(struct pci_dev *pdev, int num_vfs)
 		goto err_vf_sysfs_create;
 	}
 
+#ifdef CONFIG_OCTEONTX2_RM_DOM_SYSFS
+	err = domain_sysfs_create(rm);
+	if (err) {
+		dev_err(&pdev->dev, "Failed to create RM domain sysfs\n");
+		err = -EFAULT;
+		goto err_domain_sysfs_create;
+	}
+#endif
+
 	enable_vf_mbox_int(pdev);
 	enable_vf_flr_int(pdev);
 	return num_vfs;
 
+#ifdef CONFIG_OCTEONTX2_RM_DOM_SYSFS
+err_domain_sysfs_create:
+	vf_sysfs_destroy(pdev);
+#endif
 err_vf_sysfs_create:
 err_workqueue_alloc:
 	destroy_workqueue(rm->pfvf_mbox_wq);
-- 
2.31.1

