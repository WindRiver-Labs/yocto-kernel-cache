From d9c1121e790032e35744073e3c1ff7486c8e9d77 Mon Sep 17 00:00:00 2001
From: Bhaskara Budiredla <bbudiredla@marvell.com>
Date: Tue, 18 May 2021 09:42:27 +0530
Subject: [PATCH 1572/1921] drivers: mmc: cleanup mmc_oops driver

This removes mmc_oops driver to replace it with mmc_pstore driver

Change-Id: If7e3ec5c9d6b86af8c1064cd499fb3ce2b58949e
Signed-off-by: Bhaskara Budiredla <bbudiredla@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/52781
Reviewed-by: Sunil Kovvuri Goutham <sgoutham@marvell.com>
Tested-by: Sunil Kovvuri Goutham <sgoutham@marvell.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 drivers/mmc/core/Kconfig           |   8 -
 drivers/mmc/core/Makefile          |   1 -
 drivers/mmc/core/block.c           |  18 --
 drivers/mmc/core/block.h           |   3 -
 drivers/mmc/core/core.c            |  23 --
 drivers/mmc/core/mmc_oops.c        | 398 -----------------------------
 drivers/mmc/host/cavium-thunderx.c |  14 +-
 drivers/mmc/host/cavium.c          |  75 ------
 drivers/mmc/host/cavium.h          |   3 -
 include/linux/mmc/card.h           |   4 -
 include/linux/mmc/core.h           |   4 -
 include/linux/mmc/host.h           |   5 -
 12 files changed, 2 insertions(+), 554 deletions(-)
 delete mode 100644 drivers/mmc/core/mmc_oops.c

diff --git a/drivers/mmc/core/Kconfig b/drivers/mmc/core/Kconfig
index eb85a209e566..c12fe13e4b14 100644
--- a/drivers/mmc/core/Kconfig
+++ b/drivers/mmc/core/Kconfig
@@ -81,11 +81,3 @@ config MMC_TEST
 	  This driver is only of interest to those developing or
 	  testing a host driver. Most people should say N here.
 
-config MMC_OOPS
-	bool "Log panic/oops to a MMC buffer"
-	depends on PSTORE
-	default n
-	help
-	  Oops driver to store the crash dumps to MMC device at a specified
-	  user partition number. The driver is based on pstore frontend
-	  filesystem to access the backend persistent MMC storage device.
diff --git a/drivers/mmc/core/Makefile b/drivers/mmc/core/Makefile
index f2db2f526871..95ffe008ebdf 100644
--- a/drivers/mmc/core/Makefile
+++ b/drivers/mmc/core/Makefile
@@ -17,5 +17,4 @@ mmc_core-$(CONFIG_DEBUG_FS)	+= debugfs.o
 obj-$(CONFIG_MMC_BLOCK)		+= mmc_block.o
 mmc_block-objs			:= block.o queue.o
 obj-$(CONFIG_MMC_TEST)		+= mmc_test.o
-obj-$(CONFIG_MMC_OOPS)          += mmc_oops.o
 obj-$(CONFIG_SDIO_UART)		+= sdio_uart.o
diff --git a/drivers/mmc/core/block.c b/drivers/mmc/core/block.c
index ebdef17b6313..7f480c6b1981 100644
--- a/drivers/mmc/core/block.c
+++ b/drivers/mmc/core/block.c
@@ -2864,20 +2864,6 @@ static void mmc_blk_remove_debugfs(struct mmc_card *card,
 
 #endif /* CONFIG_DEBUG_FS */
 
-#ifdef CONFIG_MMC_OOPS
-sector_t mmc_blk_get_start(struct mmc_card *card, int part_num)
-{
-	struct mmc_blk_data *md = dev_get_drvdata(&card->dev);
-	struct gendisk *disk = md->disk;
-	struct disk_part_tbl *part_tbl = disk->part_tbl;
-
-	if (part_num < 0 || part_num >= part_tbl->len)
-		return 0;
-
-	return part_tbl->part[part_num]->start_sect;
-}
-#endif
-
 static int mmc_blk_probe(struct mmc_card *card)
 {
 	struct mmc_blk_data *md, *part_md;
@@ -2921,10 +2907,6 @@ static int mmc_blk_probe(struct mmc_card *card)
 			goto out;
 	}
 
-#ifdef CONFIG_MMC_OOPS
-	if (mmc_card_mmc(card) || mmc_card_sd(card))
-		mmc_oops_card_set(card);
-#endif
 	/* Add two debugfs entries */
 	mmc_blk_add_debugfs(card, md);
 
diff --git a/drivers/mmc/core/block.h b/drivers/mmc/core/block.h
index 91d5c5a3b82c..31153f656f41 100644
--- a/drivers/mmc/core/block.h
+++ b/drivers/mmc/core/block.h
@@ -16,8 +16,5 @@ void mmc_blk_mq_recovery(struct mmc_queue *mq);
 struct work_struct;
 
 void mmc_blk_mq_complete_work(struct work_struct *work);
-#ifdef CONFIG_MMC_OOPS
-sector_t mmc_blk_get_start(struct mmc_card *card, int part_num);
-#endif
 
 #endif
diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index ca9bdbbb30f9..6db0efde7429 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -586,29 +586,6 @@ int mmc_cqe_recovery(struct mmc_host *host)
 }
 EXPORT_SYMBOL(mmc_cqe_recovery);
 
-#ifdef CONFIG_MMC_OOPS
-/**
- *      mmc_wait_for_oops_req - initiate a blocking mmc request
- *      @host: MMC host to start command
- *      @mrq: MMC request to start
- *
- *      Start a new MMC custom command request for a host, and
- *      wait for the command to complete based on request data timeout.
- */
-void mmc_wait_for_oops_req(struct mmc_host *host, struct mmc_request *mrq)
-{
-	unsigned int timeout;
-
-	host->ops->req_cleanup_pending(host);
-	mmc_start_request(host, mrq);
-
-	if (mrq->data) {
-		timeout = mrq->data->timeout_ns / NSEC_PER_MSEC;
-		host->ops->req_completion_poll(host, timeout);
-	}
-}
-#endif
-
 /**
  *	mmc_is_req_done - Determine if a 'cap_cmd_during_tfr' request is done
  *	@host: MMC host
diff --git a/drivers/mmc/core/mmc_oops.c b/drivers/mmc/core/mmc_oops.c
deleted file mode 100644
index 4531a2adf4fa..000000000000
--- a/drivers/mmc/core/mmc_oops.c
+++ /dev/null
@@ -1,398 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/* Marvell MMC oops pstore backend driver
- *
- * Copyright (C) 2020 Marvell International Ltd.
- *  Portions of this driver are based on the patch
- *  https://patchwork.kernel.org/patch/5897821/
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/pstore.h>
-#include <linux/slab.h>
-#include <linux/mmc/mmc.h>
-#include <linux/mmc/host.h>
-#include <linux/mmc/card.h>
-#include <linux/scatterlist.h>
-#include "block.h"
-#include "bus.h"
-#include "card.h"
-#include "core.h"
-
-#define PART_TYPE		0
-#define DEFAULT_RECORD_SIZE	10240
-
-static ulong mem_size = DEFAULT_RECORD_SIZE;
-module_param_named(pstore_size, mem_size, ulong, 0400);
-MODULE_PARM_DESC(mem_size, "Amount of reserved memory in mmc");
-
-static ulong rcrd_size = DEFAULT_RECORD_SIZE;
-module_param_named(pstore_rcrdsize, rcrd_size, ulong, 0400);
-MODULE_PARM_DESC(rcrd_size, "Size of one dump(default: DEFAULT_RECORD_SIZE");
-
-static char mmcdev[80];
-module_param_string(mmcdev, mmcdev, 80, 0400);
-MODULE_PARM_DESC(mmcdev, "MMC device to host crash dumps");
-
-static int mmc_partnum = -1;
-module_param_named(mmcdev_partnum, mmc_partnum, int, 0400);
-MODULE_PARM_DESC(mmc_partnum, "Partition number of mmcdev");
-
-struct mmc_oops_context {
-	struct mmc_card	*card;
-	struct mmc_request *mrq;
-	unsigned long blk_offset;
-	unsigned int mem_size;
-	size_t record_size;
-	u32 flags;
-	unsigned int dump_read_cnt;
-	unsigned int dump_write_cnt;
-	struct pstore_info pstore;
-};
-
-static int mmc_oops_pstore_open(struct pstore_info *psi)
-{
-	struct mmc_oops_context *cxt = psi->data;
-
-	cxt->dump_read_cnt = 0;
-	return 0;
-}
-
-static void mmc_part_switch(struct mmc_oops_context *cxt)
-{
-	unsigned int timeout_ms = cxt->card->ext_csd.part_time;
-	struct mmc_card *card = cxt->card;
-	struct mmc_host *host = card->host;
-	struct mmc_command cmd = {};
-	struct mmc_request mrq = {};
-	bool use_r1b_resp = true;
-
-	if (timeout_ms && host->max_busy_timeout &&
-		(timeout_ms > host->max_busy_timeout))
-		use_r1b_resp = false;
-
-	cmd.opcode = MMC_SWITCH;
-	cmd.arg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
-			(EXT_CSD_PART_CONFIG << 16) |
-			(PART_TYPE << 8) |
-			EXT_CSD_CMD_SET_NORMAL;
-	cmd.flags = MMC_CMD_AC;
-	if (use_r1b_resp) {
-		cmd.flags |= MMC_RSP_SPI_R1B | MMC_RSP_R1B;
-		cmd.busy_timeout = timeout_ms;
-	} else {
-		cmd.flags |= MMC_RSP_SPI_R1 | MMC_RSP_R1;
-	}
-
-	memset(cmd.resp, 0, sizeof(cmd.resp));
-	cmd.retries = MMC_CMD_RETRIES;
-	cmd.data = NULL;
-
-	mrq.cmd = &cmd;
-	mmc_wait_for_oops_req(host, &mrq);
-	mdelay(card->ext_csd.part_time);
-}
-
-static void mmc_prep_rq(struct mmc_request *mrq, char *buf,
-	       unsigned long blk_offset, unsigned int nblks,
-	       struct scatterlist *sg, u32 opcode, unsigned int flags)
-{
-	mrq->cmd->opcode = opcode;
-	mrq->cmd->arg = blk_offset;
-	mrq->cmd->flags = MMC_RSP_R1 | MMC_CMD_ADTC;
-
-	if (nblks == 1) {
-		mrq->stop = NULL;
-	} else {
-		mrq->stop->opcode = MMC_STOP_TRANSMISSION;
-		mrq->stop->arg = 0;
-		mrq->stop->flags = MMC_RSP_R1B | MMC_CMD_AC;
-	}
-
-	mrq->data->blksz = 512;
-	mrq->data->blocks = nblks;
-	mrq->data->flags = flags;
-	mrq->data->sg = sg;
-	mrq->data->sg_len = 1;
-}
-
-static void mmc_oops_read(struct mmc_oops_context *cxt,
-	char *buf, unsigned long blk_offset, unsigned int size)
-{
-	struct mmc_request *mrq = cxt->mrq;
-	struct mmc_card *card = cxt->card;
-	struct mmc_host *host = card->host;
-	unsigned int nblks = (size >> 9);
-	struct scatterlist sg;
-	u32 opcode = (nblks > 1) ?
-			MMC_READ_MULTIPLE_BLOCK : MMC_READ_SINGLE_BLOCK;
-
-	mmc_prep_rq(mrq, buf, blk_offset, nblks, &sg, opcode, MMC_DATA_READ);
-	sg_init_one(&sg, buf, size);
-	mmc_set_data_timeout(mrq->data, cxt->card);
-
-	mmc_claim_host(host);
-	mmc_wait_for_req(host, mrq);
-	mdelay(mrq->data->timeout_ns / NSEC_PER_MSEC);
-	mmc_release_host(host);
-
-	if (mrq->cmd->error)
-		pr_err("Failed to post request: %d\n", mrq->cmd->error);
-	if (mrq->data->error)
-		pr_err("Failed to complete write: %d\n", mrq->data->error);
-}
-
-static ssize_t mmc_oops_pstore_read(struct pstore_record *record)
-{
-	struct mmc_oops_context *cxt = record->psi->data;
-	ssize_t size = cxt->record_size;
-
-	if (!cxt->card) {
-		pr_err("Unavailable mmc device chosen for pstore\n");
-		size = -ENOSPC;
-		goto out;
-	}
-
-	if (cxt->dump_read_cnt >= 1) {
-		size = 0;
-		goto out;
-	}
-
-	record->buf = kzalloc(size, GFP_KERNEL);
-	if (record->buf == NULL) {
-		size = -ENOMEM;
-		goto out;
-	}
-
-	if (mmc_card_mmc(cxt->card))
-		mmc_part_switch(cxt);
-
-	mmc_oops_read(cxt, record->buf, cxt->blk_offset, cxt->record_size);
-	cxt->dump_read_cnt += 1;
-out:
-	if (size < 0)
-		kfree(record->buf);
-
-	return size;
-}
-
-static void mmc_oops_write(struct mmc_oops_context *cxt,
-	char *buf, unsigned long blk_offset, unsigned int size)
-{
-	struct mmc_request *mrq = cxt->mrq;
-	struct mmc_card *card = cxt->card;
-	struct mmc_host *host = card->host;
-	unsigned int nblks = (size >> 9);
-	struct scatterlist sg;
-	u32 opcode = (nblks > 1) ? MMC_WRITE_MULTIPLE_BLOCK : MMC_WRITE_BLOCK;
-
-	mmc_prep_rq(mrq, buf, blk_offset, nblks, &sg, opcode, MMC_DATA_WRITE);
-	sg_init_one(&sg, buf, size);
-	mmc_set_data_timeout(mrq->data, cxt->card);
-
-	mmc_claim_host(host);
-	mmc_wait_for_oops_req(host, mrq);
-	mmc_release_host(card->host);
-
-}
-
-static int mmc_oops_pstore_write(struct pstore_record *record)
-{
-	struct mmc_oops_context *cxt = record->psi->data;
-
-	if (!cxt->card)
-		return -ENOSPC;
-
-	if (record->type != PSTORE_TYPE_DMESG)
-		return -EINVAL;
-
-	if (record->reason != KMSG_DUMP_OOPS &&
-		record->reason != KMSG_DUMP_PANIC)
-		return -EINVAL;
-
-	if (record->reason == KMSG_DUMP_OOPS)
-		return -EINVAL;
-
-	if (record->part != 1)
-		return -ENOSPC;
-
-	if (mmc_card_mmc(cxt->card))
-		mmc_part_switch(cxt);
-
-	mmc_oops_write(cxt, record->buf, cxt->blk_offset, cxt->record_size);
-	cxt->dump_write_cnt += 1;
-
-	return 0;
-}
-
-static struct mmc_oops_context oops_cxt = {
-	.pstore = {
-		.owner	= THIS_MODULE,
-		.name	= "mmc_oops",
-		.open	= mmc_oops_pstore_open,
-		.read	= mmc_oops_pstore_read,
-		.write	= mmc_oops_pstore_write,
-	},
-};
-
-int mmc_oops_card_set(struct mmc_card *card)
-{
-	struct mmc_oops_context *cxt = &oops_cxt;
-	struct mmc_host *host = card->host;
-
-	if (strcmp(mmc_hostname(card->host), mmcdev) || mmc_partnum == -1)
-		return 0;
-
-	if (!mmc_card_mmc(card) && !mmc_card_sd(card))
-		return -ENODEV;
-
-	if (!host->ops->req_cleanup_pending || !host->ops->req_completion_poll)
-		return -ENODEV;
-
-	cxt->blk_offset = mmc_blk_get_start(card, mmc_partnum);
-	if (!cxt->blk_offset)
-		return -EINVAL;
-
-	cxt->card = card;
-	pr_info("host is %s, partition is p%d\n",
-		mmc_hostname(card->host), mmc_partnum);
-
-	return 0;
-}
-EXPORT_SYMBOL(mmc_oops_card_set);
-
-static int mmc_oops_probe(struct mmc_card *card)
-{
-	int ret = 0;
-
-	ret = mmc_oops_card_set(card);
-	if (ret)
-		return ret;
-
-	mmc_claim_host(card->host);
-
-	return 0;
-}
-
-static void mmc_oops_remove(struct mmc_card *card)
-{
-	mmc_release_host(card->host);
-}
-
-static struct mmc_driver mmc_oops_driver = {
-	.drv		= {
-		.name	= "mmc_oops",
-	},
-	.probe		= mmc_oops_probe,
-	.remove		= mmc_oops_remove,
-};
-
-static int __init mmc_oops_init(void)
-{
-	struct mmc_oops_context *cxt = &oops_cxt;
-	struct mmc_command *cmd, *stop;
-	struct mmc_request *mrq;
-	struct mmc_data *data;
-	int err = -EINVAL;
-
-	/* Exit silently if no device specified */
-	if (strlen(mmcdev) == 0 || mmc_partnum == -1)
-		return -ENODEV;
-
-	if (!mem_size || !rcrd_size)
-		goto out;
-
-	err = mmc_register_driver(&mmc_oops_driver);
-	if (err)
-		goto out;
-
-	cxt->card = NULL;
-
-	cxt->mem_size = mem_size;
-	cxt->record_size = (rcrd_size < DEFAULT_RECORD_SIZE) ?
-				(rcrd_size < 512 ? 512 : rcrd_size) :
-					DEFAULT_RECORD_SIZE;
-
-	mrq = kzalloc(sizeof(struct mmc_request), GFP_KERNEL);
-	if (!mrq)
-		goto remove_driver;
-
-	cmd = kzalloc(sizeof(struct mmc_command), GFP_KERNEL);
-	if (!cmd)
-		goto free_mrq;
-
-	stop = kzalloc(sizeof(struct mmc_command), GFP_KERNEL);
-	if (!stop)
-		goto free_cmd;
-
-	data = kzalloc(sizeof(struct mmc_data), GFP_KERNEL);
-	if (!data)
-		goto free_stop;
-
-	mrq->cmd = cmd;
-	mrq->data = data;
-	mrq->stop = stop;
-	cxt->mrq = mrq;
-
-	cxt->pstore.data = cxt;
-	cxt->pstore.bufsize = cxt->record_size;
-	cxt->pstore.buf = kmalloc(cxt->pstore.bufsize, GFP_KERNEL);
-	if (!cxt->pstore.buf) {
-		err = -ENOMEM;
-		goto free_data;
-	}
-
-	cxt->pstore.flags = PSTORE_FLAGS_DMESG;
-
-	err = pstore_register(&cxt->pstore);
-	if (err) {
-		pr_info("pstore registration failed\n");
-		goto free_pbuf;
-	}
-
-	return err;
-
-free_pbuf:
-	kfree(cxt->pstore.buf);
-free_data:
-	kfree(data);
-free_stop:
-	kfree(stop);
-free_cmd:
-	kfree(cmd);
-free_mrq:
-	kfree(mrq);
-remove_driver:
-	mmc_unregister_driver(&mmc_oops_driver);
-out:
-	pr_info("failed to complete init %d\n", err);
-	return err;
-}
-
-static void __exit mmc_oops_exit(void)
-{
-	struct mmc_oops_context *cxt = &oops_cxt;
-
-	pstore_unregister(&cxt->pstore);
-	kfree(cxt->pstore.buf);
-	cxt->pstore.bufsize = 0;
-
-	kfree(cxt->mrq->data);
-	kfree(cxt->mrq->stop);
-	kfree(cxt->mrq->cmd);
-	kfree(cxt->mrq);
-
-	mmc_unregister_driver(&mmc_oops_driver);
-}
-
-module_init(mmc_oops_init);
-module_exit(mmc_oops_exit);
-
-MODULE_AUTHOR("Bhaskara Budiredla <bbudiredla@marvell.com>");
-MODULE_DESCRIPTION("MMC oops pstore backend driver");
diff --git a/drivers/mmc/host/cavium-thunderx.c b/drivers/mmc/host/cavium-thunderx.c
index caeb161b5ad4..b1923ed2a357 100644
--- a/drivers/mmc/host/cavium-thunderx.c
+++ b/drivers/mmc/host/cavium-thunderx.c
@@ -21,22 +21,12 @@
 
 static void thunder_mmc_acquire_bus(struct cvm_mmc_host *host)
 {
-#ifdef CONFIG_MMC_OOPS
-	if (!host->pstore)
-		down(&host->mmc_serializer);
-#else
-		down(&host->mmc_serializer);
-#endif
+	down(&host->mmc_serializer);
 }
 
 static void thunder_mmc_release_bus(struct cvm_mmc_host *host)
 {
-#ifdef CONFIG_MMC_OOPS
-	if (!host->pstore)
-		up(&host->mmc_serializer);
-#else
-		up(&host->mmc_serializer);
-#endif
+	up(&host->mmc_serializer);
 }
 
 static void thunder_mmc_int_enable(struct cvm_mmc_host *host, u64 val)
diff --git a/drivers/mmc/host/cavium.c b/drivers/mmc/host/cavium.c
index 039dd1174878..9cc166b8ef59 100644
--- a/drivers/mmc/host/cavium.c
+++ b/drivers/mmc/host/cavium.c
@@ -874,74 +874,6 @@ irqreturn_t cvm_mmc_interrupt(int irq, void *dev_id)
 	return IRQ_RETVAL(emm_int != 0);
 }
 
-#ifdef CONFIG_MMC_OOPS
-static int cvm_req_completion_poll(struct mmc_host *host, unsigned long msecs)
-{
-	struct cvm_mmc_slot *slot = mmc_priv(host);
-	struct cvm_mmc_host *cvm_host = slot->host;
-	u64 emm_int;
-
-	while (msecs) {
-		emm_int = readq(cvm_host->base + MIO_EMM_INT(cvm_host));
-
-		if (emm_int & MIO_EMM_INT_DMA_DONE)
-			return 0;
-		else if (emm_int & MIO_EMM_INT_DMA_ERR)
-			return -EIO;
-		mdelay(1);
-		msecs--;
-	}
-
-	return -ETIMEDOUT;
-}
-
-static void cvm_req_cleanup_pending(struct mmc_host *host)
-{
-	struct cvm_mmc_slot *slot = mmc_priv(host);
-	struct cvm_mmc_host *cvm_host = slot->host;
-	u64 fifo_cfg;
-	u64 dma_cfg;
-	u64 emm_int;
-	int cnt;
-
-	cvm_host->pstore = 1;
-
-	/* Clear pending DMA FIFO queue */
-	fifo_cfg = readq(cvm_host->dma_base + MIO_EMM_DMA_FIFO_CFG(cvm_host));
-	if (FIELD_GET(MIO_EMM_DMA_FIFO_CFG_COUNT, fifo_cfg))
-		writeq(MIO_EMM_DMA_FIFO_CFG_CLR,
-			cvm_host->dma_base + MIO_EMM_DMA_FIFO_CFG(cvm_host));
-
-	/* Clear ongoing DMA, if there is any */
-	dma_cfg = readq(cvm_host->dma_base + MIO_EMM_DMA_CFG(cvm_host));
-	if (dma_cfg & MIO_EMM_DMA_CFG_EN) {
-		dma_cfg |= MIO_EMM_DMA_CFG_CLR;
-		writeq(dma_cfg, cvm_host->dma_base +
-				MIO_EMM_DMA_CFG(cvm_host));
-		do {
-			dma_cfg = readq(cvm_host->dma_base +
-					MIO_EMM_DMA_CFG(cvm_host));
-		} while (dma_cfg & MIO_EMM_DMA_CFG_EN);
-	}
-
-	/* Clear pending DMA interrupts */
-	emm_int = readq(cvm_host->base + MIO_EMM_INT(cvm_host));
-	if (emm_int)
-		writeq(emm_int, cvm_host->base + MIO_EMM_INT(cvm_host));
-
-	/* Clear prepared and yet to be fired DMA requests */
-	for (cnt = 0; cnt < CAVIUM_MAX_MMC; cnt++) {
-		if (cvm_host->slot[cnt]) {
-			if (cvm_host->slot[cnt]->current_req) {
-				cvm_host->slot[cnt]->current_req = NULL;
-				cvm_host->slot[cnt]->dma_active = false;
-				break;
-			}
-		}
-	}
-}
-#endif
-
 /*
  * Program DMA_CFG and if needed DMA_ADR.
  * Returns 0 on error, DMA address otherwise.
@@ -2078,10 +2010,6 @@ static const struct mmc_host_ops cvm_mmc_ops = {
 	.hw_reset	= cvm_mmc_reset,
 	.execute_tuning = cvm_prepare_tuning,
 	.prepare_hs400_tuning = cvm_prepare_hs400_tuning,
-#ifdef CONFIG_MMC_OOPS
-	.req_cleanup_pending = cvm_req_cleanup_pending,
-	.req_completion_poll = cvm_req_completion_poll,
-#endif
 };
 
 static void cvm_mmc_set_clock(struct cvm_mmc_slot *slot, unsigned int clock)
@@ -2380,9 +2308,6 @@ int cvm_mmc_of_slot_probe(struct device *dev, struct cvm_mmc_host *host)
 	slot->bus_id = id;
 	slot->cached_rca = 1;
 
-#ifdef CONFIG_MMC_OOPS
-	host->pstore = 0;
-#endif
 	host->acquire_bus(host);
 	host->slot[id] = slot;
 	host->use_vqmmc |= !IS_ERR_OR_NULL(slot->mmc->supply.vqmmc);
diff --git a/drivers/mmc/host/cavium.h b/drivers/mmc/host/cavium.h
index beb7edd7b454..9ffd4ec5fa56 100644
--- a/drivers/mmc/host/cavium.h
+++ b/drivers/mmc/host/cavium.h
@@ -134,9 +134,6 @@ struct cvm_mmc_host {
 	bool tap_requires_noclk;
 	bool calibrate_glitch;
 	bool cond_clock_glitch;
-#ifdef CONFIG_MMC_OOPS
-	bool pstore;
-#endif
 	spinlock_t irq_handler_lock;
 	struct semaphore mmc_serializer;
 
diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 0cc00fdd3509..9b6336ad3266 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -318,10 +318,6 @@ static inline bool mmc_large_sector(struct mmc_card *card)
 
 bool mmc_card_is_blockaddr(struct mmc_card *card);
 
-#ifdef CONFIG_MMC_OOPS
-int mmc_oops_card_set(struct mmc_card *card);
-#endif /* CONFIG_MMC_OOPS */
-
 #define mmc_card_mmc(c)		((c)->type == MMC_TYPE_MMC)
 #define mmc_card_sd(c)		((c)->type == MMC_TYPE_SD)
 #define mmc_card_sdio(c)	((c)->type == MMC_TYPE_SDIO)
diff --git a/include/linux/mmc/core.h b/include/linux/mmc/core.h
index d4baab4a7c7e..b7ba8810a3b5 100644
--- a/include/linux/mmc/core.h
+++ b/include/linux/mmc/core.h
@@ -169,10 +169,6 @@ struct mmc_request {
 
 struct mmc_card;
 
-#ifdef CONFIG_MMC_OOPS
-extern void mmc_wait_for_oops_req(struct mmc_host *, struct mmc_request *);
-#endif /* CONFIG_MMC_OOPS */
-
 void mmc_wait_for_req(struct mmc_host *host, struct mmc_request *mrq);
 int mmc_wait_for_cmd(struct mmc_host *host, struct mmc_command *cmd,
 		int retries);
diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 82faea0d1acc..4a4a64834d8e 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -168,11 +168,6 @@ struct mmc_host_ops {
 	 */
 	int	(*multi_io_quirk)(struct mmc_card *card,
 				  unsigned int direction, int blk_size);
-#ifdef CONFIG_MMC_OOPS
-	void	(*req_cleanup_pending)(struct mmc_host *host);
-	int	(*req_completion_poll)(struct mmc_host *host,
-					unsigned long timeout);
-#endif
 };
 
 struct mmc_cqe_ops {
-- 
2.31.1

