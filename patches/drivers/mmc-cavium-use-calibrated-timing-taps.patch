From 50a22aff0ed6c00fcc956965c7262fd163ba597b Mon Sep 17 00:00:00 2001
From: Peter Swain <pswain@cavium.com>
Date: Mon, 26 Aug 2019 13:07:51 -0700
Subject: [PATCH 332/767] mmc: cavium: use calibrated timing taps

commit 74b3b6eb39f111c52e0a464ec1ee4974eb85ac7b from
git@git.assembla.com:cavium/WindRiver.linux.git

Uses the calibrated tap-delay reading to determine data_out
& cmd_out parameters. To do the calibration, certain HW sequence
has been employed for the reliable operation of calibration.

A scale factor is added to simplify testing, starts at 100%
and can be tweaked via modparam. A switch is added to force
the constant timing params, for comparison with old code.

Forced clock is used for cnf95. Also a redundant read has
been removed.

Change-Id: I38b488afadee8f66f3cdde824464b24badaf8234
Signed-off-by: Peter Swain <pswain@marvell.com>
Signed-off-by: Sujeet Baranwal <sbaranwal@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/14926
Reviewed-by: Peter Swain <pswain@cavium.com>
Reviewed-by: Sujeet Kumar Baranwal <Sujeet.Baranwal@cavium.com>
Tested-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/mmc/host/cavium-thunderx.c | 97 ++++++++++++++++++++++++------
 drivers/mmc/host/cavium.c          | 93 ++++++++++++++++++++--------
 drivers/mmc/host/cavium.h          |  3 +-
 3 files changed, 147 insertions(+), 46 deletions(-)

diff --git a/drivers/mmc/host/cavium-thunderx.c b/drivers/mmc/host/cavium-thunderx.c
index 81602975629f..7fbf33e34217 100644
--- a/drivers/mmc/host/cavium-thunderx.c
+++ b/drivers/mmc/host/cavium-thunderx.c
@@ -16,6 +16,7 @@
 #include <linux/of_platform.h>
 #include <linux/pci.h>
 #include <linux/delay.h>
+#include <linux/bitfield.h>
 #include "cavium.h"
 
 static void thunder_mmc_acquire_bus(struct cvm_mmc_host *host)
@@ -59,32 +60,65 @@ static int thunder_mmc_register_interrupts(struct cvm_mmc_host *host,
 /* calibration evaluates the per tap delay */
 static void thunder_calibrate_mmc(struct cvm_mmc_host *host)
 {
-	u64 emm_cfg, tap;
-	u32 retries = 10, tap_delay;
+	u32 retries = 10;
+	u32 delay = 4;
+	unsigned int ps;
+	const char *how = "default";
 
-	if (!is_mmc_otx2(host))
+	if (is_mmc_8xxx(host))
 		return;
 
-	if (is_mmc_otx2(host)) {
-		/* set _DEBUG[CLK_ON]=1 as workaround for clock issue */
+	/* set _DEBUG[CLK_ON]=1 as workaround for clock issue */
+	if (is_mmc_otx2_A0(host) || is_mmc_95xx(host))
 		writeq(1, host->base + MIO_EMM_DEBUG(host));
 
+	if (is_mmc_otx2_A0(host)) {
 		/*
 		 * Operation of up to 100 MHz may be achieved by skipping the
 		 * steps that establish the tap delays and instead assuming
 		 * that MIO_EMM_TAP[DELAY] returns 0x4 indicating 78 pS/tap.
 		 */
-		tap_delay = 4;
 	} else {
-		/* MIO_EMM_CFG[BUS_ENA] must be zero for calibration */
-		emm_cfg = readq(host->base + MIO_EMM_CFG(host));
-		if (emm_cfg & MIO_EMM_CFG_BUS_ENA) {
-			pr_err("failure: bus is not disabled\n");
-			return;
-		}
+		u64 tap;
+		u64 emm_cfg = readq(host->base + MIO_EMM_CFG(host));
+		u64 tcfg;
+		u64 emm_io_ctl;
+		u64 emm_switch;
+		u64 emm_wdog;
+		u64 emm_sts_mask;
+		u64 emm_debug;
+		u64 emm_timing;
+		u64 emm_rca;
+
+		/*
+		 * MIO_EMM_CFG[BUS_ENA] must be zero for calibration,
+		 * but that resets whole host, so save state.
+		 */
+		emm_io_ctl = readq(host->base + MIO_EMM_IO_CTL(host));
+		emm_switch = readq(host->base + MIO_EMM_SWITCH(host));
+		emm_wdog = readq(host->base + MIO_EMM_WDOG(host));
+		emm_sts_mask =
+			readq(host->base + MIO_EMM_STS_MASK(host));
+		emm_debug = readq(host->base + MIO_EMM_DEBUG(host));
+		emm_timing = readq(host->base + MIO_EMM_TIMING(host));
+		emm_rca = readq(host->base + MIO_EMM_RCA(host));
+
+		/* reset controller */
+		tcfg = emm_cfg;
+		tcfg &= ~MIO_EMM_CFG_BUS_ENA;
+		writeq(tcfg, host->base + MIO_EMM_CFG(host));
+		udelay(1);
+
+		/* restart with phantom slot 3 */
+		tcfg |= FIELD_PREP(MIO_EMM_CFG_BUS_ENA, 1ull << 3);
+		writeq(tcfg, host->base + MIO_EMM_CFG(host));
+		mdelay(1);
 
 		/* Start calibration */
+		writeq(0, host->base + MIO_EMM_CALB(host));
+		udelay(5);
 		writeq(START_CALIBRATION, host->base + MIO_EMM_CALB(host));
+		udelay(5);
 
 		do {
 			/* wait for approximately 300 coprocessor clock */
@@ -92,21 +126,46 @@ static void thunder_calibrate_mmc(struct cvm_mmc_host *host)
 			tap = readq(host->base + MIO_EMM_TAP(host));
 		} while (!tap && retries--);
 
-		if (!retries)
-			pr_debug("retries exhausted, calibration failed\n");
+		/* leave calibration mode */
+		writeq(0, host->base + MIO_EMM_CALB(host));
+		udelay(5);
+
+		if (retries <= 0 || !tap) {
+			how = "fallback";
+		} else {
+			/* calculate the per-tap delay */
+			delay = tap & MIO_EMM_TAP_DELAY;
+			how = "calibrated";
+		}
+
+		/* restore old state */
+		writeq(emm_cfg, host->base + MIO_EMM_CFG(host));
+		mdelay(1);
+		writeq(emm_rca, host->base + MIO_EMM_RCA(host));
+		writeq(emm_timing, host->base + MIO_EMM_TIMING(host));
+		writeq(emm_debug, host->base + MIO_EMM_DEBUG(host));
+		writeq(emm_sts_mask,
+			host->base + MIO_EMM_STS_MASK(host));
+		writeq(emm_wdog, host->base + MIO_EMM_WDOG(host));
+		writeq(emm_switch, host->base + MIO_EMM_SWITCH(host));
+		writeq(emm_io_ctl, host->base + MIO_EMM_IO_CTL(host));
+		mdelay(1);
 
-		/* calculate the per-tap delay */
-		tap_delay = tap & MIO_EMM_TAP_DELAY;
 	}
 
 	/*
+	 * Scale measured/guessed calibration value to pS:
 	 * The delay value should be multiplied by 10 ns(or 10000 ps)
 	 * and then divided by no of taps to determine the estimated
 	 * delay in pico second. The nominal value is 125 ps per tap.
 	 */
-	host->per_tap_delay =  (tap_delay * PS_10000) / TOTAL_NO_OF_TAPS;
-	pr_debug("tap_delay %d per_tap_delay %d\n",
-		tap_delay, host->per_tap_delay);
+	ps = (delay * PS_10000) / TOTAL_NO_OF_TAPS;
+	if (host->per_tap_delay != ps) {
+		dev_info(host->dev, "%s delay:%d per_tap_delay:%dpS\n",
+			how, delay, ps);
+		host->per_tap_delay = ps;
+		host->delay_logged = 0;
+	}
 }
 
 static int thunder_mmc_probe(struct pci_dev *pdev,
diff --git a/drivers/mmc/host/cavium.c b/drivers/mmc/host/cavium.c
index d8c9a09ebcc4..5005efd113ee 100644
--- a/drivers/mmc/host/cavium.c
+++ b/drivers/mmc/host/cavium.c
@@ -122,10 +122,18 @@ static struct cvm_mmc_cr_type cvm_mmc_cr_types[] = {
 	{0, 0}		/* CMD63 */
 };
 
-static int tapdance = 2;
+static int tapdance;
 module_param(tapdance, int, 0644);
 MODULE_PARM_DESC(tapdance, "adjust bus-timing: (0=mid-eye, positive=Nth_fastest_tap)");
 
+static int clk_scale = 100;
+module_param(clk_scale, int, 0644);
+MODULE_PARM_DESC(clk_scale, "percent scale data_/cmd_out taps (default 100)");
+
+static bool fixed_timing;
+module_param(fixed_timing, bool, 0444);
+MODULE_PARM_DESC(fixed_timing, "use fixed data_/cmd_out taps");
+
 static bool ddr_cmd_taps;
 module_param(ddr_cmd_taps, bool, 0644);
 MODULE_PARM_DESC(ddr_cmd_taps, "reduce cmd_out_taps in DDR modes, as before");
@@ -148,12 +156,54 @@ static void cvm_mmc_set_timing(struct cvm_mmc_slot *slot)
 	writeq(slot->taps, slot->host->base + MIO_EMM_TIMING(slot->host));
 }
 
+static int tout(struct cvm_mmc_slot *slot, int ps, int hint)
+{
+	struct cvm_mmc_host *host = slot->host;
+	struct mmc_host *mmc = slot->mmc;
+	int tap_ps = host->per_tap_delay;
+	int timing = mmc->ios.timing;
+	static int old_scale;
+	int taps;
+
+	if (fixed_timing)
+		return hint;
+
+	if (!hint)
+		hint = 63;
+
+	if (!tap_ps)
+		return hint;
+
+	taps = min((int)(ps * clk_scale) / (tap_ps * 100), 63);
+
+	/* when modparam is adjusted, re-announce timing */
+	if (old_scale != clk_scale) {
+		host->delay_logged = 0;
+		old_scale = clk_scale;
+	}
+
+	if (!test_and_set_bit(timing,
+			&host->delay_logged))
+		dev_info(host->dev, "mmc%d.ios_timing:%d %dpS hint:%d taps:%d\n",
+			mmc->index, timing, ps, hint, taps);
+
+	return taps;
+}
+
 static int cvm_mmc_configure_delay(struct cvm_mmc_slot *slot)
 {
 	struct cvm_mmc_host *host = slot->host;
 	struct mmc_host *mmc = slot->mmc;
 
-	if (is_mmc_otx2(host)) {
+	pr_debug("slot%d.configure_delay\n", slot->bus_id);
+
+	if (is_mmc_8xxx(host)) {
+		/* MIO_EMM_SAMPLE is till T83XX */
+		u64 emm_sample =
+			FIELD_PREP(MIO_EMM_SAMPLE_CMD_CNT, slot->cmd_cnt) |
+			FIELD_PREP(MIO_EMM_SAMPLE_DAT_CNT, slot->data_cnt);
+		writeq(emm_sample, host->base + MIO_EMM_SAMPLE(host));
+	} else {
 		int half = MAX_NO_OF_TAPS / 2;
 		int cin = FIELD_GET(MIO_EMM_TIMING_CMD_IN, slot->taps);
 		int din = FIELD_GET(MIO_EMM_TIMING_DATA_IN, slot->taps);
@@ -163,36 +213,39 @@ static int cvm_mmc_configure_delay(struct cvm_mmc_slot *slot)
 			cin = din = half;
 		/*
 		 * EMM_CMD hold time from rising edge of EMMC_CLK.
-		 * Typically 5.0 ns at frequencies < 26 MHz.
-		 * Typically 2.5 ns at frequencies <= 52 MHz.
-		 * Typically 0.4 ns at frequencies > 52 MHz.
+		 * Typically 3.0 ns at frequencies < 26 MHz.
+		 * Typically 3.0 ns at frequencies <= 52 MHz SDR.
+		 * Typically 2.5 ns at frequencies <= 52 MHz DDR.
+		 * Typically 0.8 ns at frequencies > 52 MHz SDR.
+		 * Typically 0.4 ns at frequencies > 52 MHz DDR.
 		 */
 		switch (mmc->ios.timing) {
 		case MMC_TIMING_LEGACY:
 		default:
-			cout = 63;
 			if (mmc->card && mmc_card_mmc(mmc->card))
-				cout = 39;
+				cout = tout(slot, 5000, 39);
+			else
+				cout = tout(slot, 8000, 63);
 			break;
 		case MMC_TIMING_UHS_SDR12:
-			cout = 39;
+			cout = tout(slot, 3000, 39);
 			break;
 		case MMC_TIMING_MMC_HS:
-			cout = 32;
+			cout = tout(slot, 2500, 32);
 			break;
 		case MMC_TIMING_SD_HS:
 		case MMC_TIMING_UHS_SDR25:
 		case MMC_TIMING_UHS_SDR50:
-			cout = 26;
+			cout = tout(slot, 2000, 26);
 			break;
 		case MMC_TIMING_UHS_DDR50:
 		case MMC_TIMING_MMC_DDR52:
-			cout = 20;
+			cout = tout(slot, 1500, 20);
 			break;
 		case MMC_TIMING_UHS_SDR104:
 		case MMC_TIMING_MMC_HS200:
 		case MMC_TIMING_MMC_HS400:
-			cout = 10;
+			cout = tout(slot, 800, 10);
 			break;
 		}
 
@@ -204,7 +257,7 @@ static int cvm_mmc_configure_delay(struct cvm_mmc_slot *slot)
 			else
 				dout = cout / 2;
 		} else
-			dout = 10;
+			dout = tout(slot, 800, 10);
 
 		slot->taps =
 			FIELD_PREP(MIO_EMM_TIMING_CMD_IN, cin) |
@@ -212,14 +265,8 @@ static int cvm_mmc_configure_delay(struct cvm_mmc_slot *slot)
 			FIELD_PREP(MIO_EMM_TIMING_DATA_IN, din) |
 			FIELD_PREP(MIO_EMM_TIMING_DATA_OUT, dout);
 
-		pr_debug("taps %llx\n", slot->taps);
+		pr_debug("slot%d.taps %llx\n", slot->bus_id, slot->taps);
 		cvm_mmc_set_timing(slot);
-	} else {
-		/* MIO_EMM_SAMPLE is till T8XXX */
-		u64 emm_sample =
-			FIELD_PREP(MIO_EMM_SAMPLE_CMD_CNT, slot->cmd_cnt) |
-			FIELD_PREP(MIO_EMM_SAMPLE_DAT_CNT, slot->data_cnt);
-		writeq(emm_sample, host->base + MIO_EMM_SAMPLE(host));
 	}
 
 	return 0;
@@ -655,12 +702,6 @@ irqreturn_t cvm_mmc_interrupt(int irq, void *dev_id)
 	if (slot)
 		req = slot->current_req;
 
-	rsp_sts = readq(host->base + MIO_EMM_RSP_STS(host));
-	bus_id = get_bus_id(rsp_sts);
-	slot = host->slot[bus_id];
-	if (slot)
-		req = slot->current_req;
-
 	/* Clear interrupt bits (write 1 clears ). */
 	emm_int = readq(host->base + MIO_EMM_INT(host));
 	writeq(emm_int, host->base + MIO_EMM_INT(host));
diff --git a/drivers/mmc/host/cavium.h b/drivers/mmc/host/cavium.h
index 9f37b45a62f7..9c9f663cceb5 100644
--- a/drivers/mmc/host/cavium.h
+++ b/drivers/mmc/host/cavium.h
@@ -124,6 +124,7 @@ struct cvm_mmc_host {
 	struct platform_device *slot_pdev[CAVIUM_MAX_MMC];
 	/* octtx2 specific */
 	unsigned int per_tap_delay; /* per tap delay in pico second */
+	unsigned long delay_logged; /* per-ios.timing bitmask */
 
 	void (*set_shared_power)(struct cvm_mmc_host *, int);
 	void (*acquire_bus)(struct cvm_mmc_host *);
@@ -288,7 +289,7 @@ struct cvm_mmc_cr_mods {
 irqreturn_t cvm_mmc_interrupt(int irq, void *dev_id);
 int cvm_mmc_of_slot_probe(struct device *dev, struct cvm_mmc_host *host);
 int cvm_mmc_of_slot_remove(struct cvm_mmc_slot *slot);
-void calibrate_mmc(struct cvm_mmc_host *host);
+
 
 extern const char *cvm_mmc_irq_names[];
 
-- 
2.31.1

