From 1641d8d599b6532f9291c453f657a2323f17000d Mon Sep 17 00:00:00 2001
From: Wendy Liang <wendy.liang@xilinx.com>
Date: Thu, 16 Jan 2020 13:18:37 -0800
Subject: [PATCH 0853/1851] remoteproc: Add support for peek from remote and
 acking kick from remote

commit c7cb205e27c736950adc568503c5a8c7deaae43f from
https://github.com/Xilinx/linux-xlnx.git

Add support for checking if remote has kicked and acking the
remote's kick in include/linux/remoteproc. Update
remoteproc_internal to indicate if the driver allows to kick
remoteproc from sysfs. Add remoteproc_sysfs support for kicking
remote, storing remote kick and checking if remote has kicked.

Signed-off-by: Wendy Liang <wendy.liang@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
State: pending
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 drivers/remoteproc/remoteproc_internal.h |  23 +++++
 drivers/remoteproc/remoteproc_sysfs.c    | 104 +++++++++++++++++++++++
 include/linux/remoteproc.h               |   6 ++
 3 files changed, 133 insertions(+)

diff --git a/drivers/remoteproc/remoteproc_internal.h b/drivers/remoteproc/remoteproc_internal.h
index 493ef9262411..b563ef36d8a9 100644
--- a/drivers/remoteproc/remoteproc_internal.h
+++ b/drivers/remoteproc/remoteproc_internal.h
@@ -119,4 +119,27 @@ struct resource_table *rproc_find_loaded_rsc_table(struct rproc *rproc,
 	return NULL;
 }
 
+static inline
+bool rproc_allow_sysfs_kick(struct rproc *rproc)
+{
+	return (rproc->sysfs_kick) ? true : false;
+}
+
+static inline
+bool rproc_peek_remote_kick(struct rproc *rproc)
+{
+	if (rproc->ops->peek_remote_kick)
+		return rproc->ops->peek_remote_kick(rproc);
+	else
+		return false;
+}
+
+static inline
+void rproc_ack_remote_kick(struct rproc *rproc)
+{
+	if (rproc->ops->ack_remote_kick)
+		rproc->ops->ack_remote_kick(rproc);
+}
+
+int rproc_create_kick_sysfs(struct rproc *rproc);
 #endif /* REMOTEPROC_INTERNAL_H */
diff --git a/drivers/remoteproc/remoteproc_sysfs.c b/drivers/remoteproc/remoteproc_sysfs.c
index 7f8536b73295..ed89bdac1da5 100644
--- a/drivers/remoteproc/remoteproc_sysfs.c
+++ b/drivers/remoteproc/remoteproc_sysfs.c
@@ -113,6 +113,82 @@ static ssize_t state_store(struct device *dev,
 }
 static DEVICE_ATTR_RW(state);
 
+/**
+ * kick_store() - Kick remote from sysfs.
+ * @dev: remoteproc device
+ * @attr: sysfs device attribute
+ * @buf: sysfs buffer
+ * @count: size of the contents in buf
+ *
+ * It will just raise a signal, no content is expected for now.
+ *
+ * Return: the input count if it allows kick from sysfs,
+ * as it is always expected to succeed.
+ */
+static ssize_t kick_store(struct device *dev,
+			  struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct rproc *rproc = to_rproc(dev);
+
+	(void)attr;
+	(void)buf;
+
+	if (rproc->ops->kick)
+		rproc->ops->kick(rproc, 0);
+	else
+		count = -EINVAL;
+	return count;
+}
+static DEVICE_ATTR_WO(kick);
+
+/**
+ * remote_kick_show() - Check if remote has kicked
+ * @dev: remoteproc device
+ * @attr: sysfs device attribute
+ * @buf: sysfs buffer
+ *
+ * It will check if the remote has kicked.
+ *
+ * Return: always 2, and the value in the sysfs buffer
+ * shows if the remote has kicked. '0' - not kicked, '1' - kicked.
+ */
+static ssize_t remote_kick_show(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	struct rproc *rproc = to_rproc(dev);
+
+	buf[0] = '0';
+	buf[1] = '\n';
+	if (rproc_peek_remote_kick(rproc))
+		buf[0] = '1';
+	return 2;
+}
+
+/**
+ * remote_kick_store() - Ack the kick from remote
+ * @dev: remoteproc device
+ * @attr: sysfs device attribute
+ * @buf: sysfs buffer
+ * @count: size of the contents in buf
+ *
+ * It will ack the remote, no response contents is expected.
+ *
+ * Return: the input count if it allows kick from sysfs,
+ * as it is always expected to succeed.
+ */
+static ssize_t remote_kick_store(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t count)
+{
+	struct rproc *rproc = to_rproc(dev);
+
+	rproc_ack_remote_kick(rproc);
+	return count;
+}
+static DEVICE_ATTR_RW(remote_kick);
+
 /* Expose the name of the remote processor via sysfs */
 static ssize_t name_show(struct device *dev, struct device_attribute *attr,
 			 char *buf)
@@ -144,6 +220,34 @@ struct class rproc_class = {
 	.dev_groups	= rproc_devgroups,
 };
 
+/**
+ * rproc_create_kick_sysfs() - create kick remote sysfs entry
+ * @rproc: remoteproc
+ *
+ * It will create kick remote sysfs entry if kick remote
+ * from sysfs is allowed.
+ *
+ * Return: 0 for success, and negative value for failure.
+ */
+int rproc_create_kick_sysfs(struct rproc *rproc)
+{
+	struct device *dev = &rproc->dev;
+	int ret;
+
+	if (!rproc_allow_sysfs_kick(rproc))
+		return -EINVAL;
+	ret = sysfs_create_file(&dev->kobj, &dev_attr_kick.attr);
+	if (ret) {
+		dev_err(dev, "failed to create sysfs for kick.\n");
+		return ret;
+	}
+	ret = sysfs_create_file(&dev->kobj, &dev_attr_remote_kick.attr);
+	if (ret)
+		dev_err(dev, "failed to create sysfs for remote kick.\n");
+	return ret;
+}
+EXPORT_SYMBOL(rproc_create_kick_sysfs);
+
 int __init rproc_init_sysfs(void)
 {
 	/* create remoteproc device class for sysfs */
diff --git a/include/linux/remoteproc.h b/include/linux/remoteproc.h
index 16ad66683ad0..a2758fce3602 100644
--- a/include/linux/remoteproc.h
+++ b/include/linux/remoteproc.h
@@ -358,6 +358,8 @@ enum rsc_handling_status {
  * @start:	power on the device and boot it
  * @stop:	power off the device
  * @kick:	kick a virtqueue (virtqueue id given as a parameter)
+ * @peek_remote_kick: check if remote has kicked
+ * @ack_remote_kick: ack remote kick
  * @da_to_va:	optional platform hook to perform address translations
  * @parse_fw:	parse firmware to extract information (e.g. resource table)
  * @handle_rsc:	optional platform hook to handle vendor resources. Should return
@@ -374,6 +376,8 @@ struct rproc_ops {
 	int (*start)(struct rproc *rproc);
 	int (*stop)(struct rproc *rproc);
 	void (*kick)(struct rproc *rproc, int vqid);
+	bool (*peek_remote_kick)(struct rproc *rproc);
+	void (*ack_remote_kick)(struct rproc *rproc);
 	void * (*da_to_va)(struct rproc *rproc, u64 da, int len);
 	int (*parse_fw)(struct rproc *rproc, const struct firmware *fw);
 	int (*handle_rsc)(struct rproc *rproc, u32 rsc_type, void *rsc,
@@ -481,6 +485,7 @@ struct rproc_dump_segment {
  * @auto_boot: flag to indicate if remote processor should be auto-started
  * @dump_segments: list of segments in the firmware
  * @nb_vdev: number of vdev currently handled by rproc
+ * @sysfs_kick: allow kick remoteproc from sysfs
  */
 struct rproc {
 	struct list_head node;
@@ -514,6 +519,7 @@ struct rproc {
 	bool auto_boot;
 	struct list_head dump_segments;
 	int nb_vdev;
+	int sysfs_kick;
 };
 
 /**
-- 
2.31.1

