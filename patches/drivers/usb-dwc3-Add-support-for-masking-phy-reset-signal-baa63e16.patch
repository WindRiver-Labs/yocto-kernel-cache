From ce28cd4979f9b6244ebf32e6584089b60a8bcbaf Mon Sep 17 00:00:00 2001
From: Piyush Mehta <piyush.mehta@xilinx.com>
Date: Thu, 23 Jan 2020 19:51:17 +0530
Subject: [PATCH 1025/1851] usb: dwc3: Add support for masking phy reset signal

commit 128feece434d1c02d2dfac7e4103b2c73b6afb27 from
https://github.com/Xilinx/linux-xlnx.git

Versal usb controller drives phy reset signal during
Soft Reset or Core Reset to issue reset to the ULPI
phy. The ULPI phy needs to be resetted only at the time
of initialization. This patch updates the code to provide
a function for masking the phy reset signal from reaching
the ULPI phy. This function is called only after the phy
initialization is done.

Signed-off-by: Anurag Kumar Vulisha <anurag.kumar.vulisha@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
Signed-off-by: Piyush Mehta <piyush.mehta@xilinx.com>
State: pending
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 drivers/usb/dwc3/core.c           |  5 ++++
 drivers/usb/dwc3/core.h           |  4 ++++
 drivers/usb/dwc3/dwc3-of-simple.c | 39 +++++++++++++++++++++++++++++++
 3 files changed, 48 insertions(+)

diff --git a/drivers/usb/dwc3/core.c b/drivers/usb/dwc3/core.c
index bcab0cf51344..f108f6cd3192 100644
--- a/drivers/usb/dwc3/core.c
+++ b/drivers/usb/dwc3/core.c
@@ -1004,6 +1004,9 @@ int dwc3_core_init(struct dwc3 *dwc)
 	if (ret)
 		goto err0a;
 
+	if (dwc->mask_phy_rst)
+		dwc3_mask_phy_reset(dwc->dev, TRUE);
+
 	dwc3_core_setup_global_control(dwc);
 	dwc3_core_num_eps(dwc);
 
@@ -1454,6 +1457,8 @@ static void dwc3_get_properties(struct dwc3 *dwc)
 				"snps,enable_guctl1_ipd_quirk");
 	dwc->dis_metastability_quirk = device_property_read_bool(dev,
 				"snps,dis_metastability_quirk");
+	dwc->mask_phy_rst = device_property_read_bool(dev,
+				"snps,mask_phy_reset");
 
 	/* Check if extra quirks to be added */
 	dwc3_simple_check_quirks(dwc);
diff --git a/drivers/usb/dwc3/core.h b/drivers/usb/dwc3/core.h
index e938a37250be..e61448c066d0 100644
--- a/drivers/usb/dwc3/core.h
+++ b/drivers/usb/dwc3/core.h
@@ -1264,6 +1264,7 @@ struct dwc3 {
 	unsigned		is_hibernated:1;
 
 	unsigned		dis_metastability_quirk:1;
+	unsigned		mask_phy_rst:1;
 
 	u16			imod_interval;
 	bool			is_d3;
@@ -1452,6 +1453,7 @@ void dwc3_simple_wakeup_capable(struct device *dev, bool wakeup);
 void dwc3_set_simple_data(struct dwc3 *dwc);
 void dwc3_simple_check_quirks(struct dwc3 *dwc);
 int dwc3_set_usb_core_power(struct dwc3 *dwc, bool on);
+void dwc3_mask_phy_reset(struct device *dev, bool mask);
 #else
 static inline int dwc3_enable_hw_coherency(struct device *dev)
 { return 1; }
@@ -1463,6 +1465,8 @@ void dwc3_simple_check_quirks(struct dwc3 *dwc)
 { ; }
 int dwc3_set_usb_core_power(struct dwc3 *dwc, bool on)
 { ; }
+void dwc3_mask_phy_reset(struct device *dev, bool mask)
+{ ; }
 #endif
 
 bool dwc3_has_imod(struct dwc3 *dwc);
diff --git a/drivers/usb/dwc3/dwc3-of-simple.c b/drivers/usb/dwc3/dwc3-of-simple.c
index 7bb121faea3d..50d7e20a2d39 100644
--- a/drivers/usb/dwc3/dwc3-of-simple.c
+++ b/drivers/usb/dwc3/dwc3-of-simple.c
@@ -31,6 +31,10 @@
 #include "core.h"
 #include "io.h"
 
+/* USB phy reset mask register */
+#define XLNX_USB_PHY_RST		0x001C
+#define XLNX_PHY_RST_MASK		0x1
+
 /* Xilinx USB 3.0 IP Register */
 #define XLNX_USB_COHERENCY		0x005C
 #define XLNX_USB_COHERENCY_ENABLE	0x1
@@ -105,6 +109,41 @@ int dwc3_enable_hw_coherency(struct device *dev)
 }
 EXPORT_SYMBOL(dwc3_enable_hw_coherency);
 
+void dwc3_mask_phy_reset(struct device *dev, bool mask)
+{
+	struct device_node *node = of_get_parent(dev->of_node);
+
+	/* This is only valid for versal platforms */
+	if (of_device_is_compatible(node, "xlnx,versal-dwc3")) {
+		struct platform_device *pdev_parent;
+		struct dwc3_of_simple *simple;
+		u32 reg;
+
+		pdev_parent = of_find_device_by_node(node);
+		simple = platform_get_drvdata(pdev_parent);
+
+		reg = readl(simple->regs + XLNX_USB_PHY_RST);
+
+		if (mask)
+			/*
+			 * Mask the phy reset signal from comtroller
+			 * reaching ULPI phy. This can be done by
+			 * writing 0 into usb2_phy_reset register
+			 */
+			reg &= ~XLNX_PHY_RST_MASK;
+		else
+			/*
+			 * Allow phy reset signal from controller to
+			 * reset ULPI phy. This can be done by writing
+			 * 0x1 into usb2_phy_reset register
+			 */
+			reg |= XLNX_PHY_RST_MASK;
+
+		writel(reg, simple->regs + XLNX_USB_PHY_RST);
+	}
+}
+EXPORT_SYMBOL(dwc3_mask_phy_reset);
+
 void dwc3_set_simple_data(struct dwc3 *dwc)
 {
 	struct device_node *node = of_get_parent(dwc->dev->of_node);
-- 
2.31.1

