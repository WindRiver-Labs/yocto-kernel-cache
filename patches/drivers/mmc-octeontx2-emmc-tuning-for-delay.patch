From 6da40cbd7a8cf7181e0536aaccb6cccd1b9d7cff Mon Sep 17 00:00:00 2001
From: Sujeet Baranwal <sbaranwal@marvell.com>
Date: Fri, 31 May 2019 16:58:46 -0700
Subject: [PATCH 229/767] mmc: octeontx2: emmc tuning for delay

commit a89115b544a0df5146ab3d28495bda974dbec514 from
git@git.assembla.com:cavium/WindRiver.linux.git

The eMMC/SD interface supports a variety of devices with
board configurations and different timing requirements.
The interface supports independent programmable setup/hold
times on outgoing EMMC_CMD and EMMC_DAT signals as well as
separate programmable sample clocks for the inbound EMMC_CMD,
EMMC_DAT,and EMMC_DS signals. Timing is specified via the
MIO_EMM_TIMING register which controls the programmable
delay lines.

Change-Id: I44408cfccb07f28ab1beb8f6bfc97bd90a3ed529
Signed-off-by: Sujeet Baranwal <sujeet.baranwal@cavium.com>
Reviewed-on: https://sj1git1.cavium.com/8537
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Tested-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/mmc/host/cavium.c | 104 ++++++++++++++++++++++++++++++++++++--
 drivers/mmc/host/cavium.h |  19 ++++++-
 2 files changed, 117 insertions(+), 6 deletions(-)

diff --git a/drivers/mmc/host/cavium.c b/drivers/mmc/host/cavium.c
index 847565aceddf..d62d952e51af 100644
--- a/drivers/mmc/host/cavium.c
+++ b/drivers/mmc/host/cavium.c
@@ -118,6 +118,102 @@ static struct cvm_mmc_cr_type cvm_mmc_cr_types[] = {
 	{0, 0}		/* CMD63 */
 };
 
+static bool ddr_cmd_taps;
+module_param(ddr_cmd_taps, bool, 0644);
+MODULE_PARM_DESC(ddr_cmd_taps, "reduce cmd_out_taps in DDR modes, as before");
+
+static bool cvm_is_mmc_timing_ddr(struct cvm_mmc_slot *slot)
+{
+	if ((slot->mmc->ios.timing == MMC_TIMING_UHS_DDR50) ||
+	   (slot->mmc->ios.timing == MMC_TIMING_MMC_DDR52) ||
+	   (slot->mmc->ios.timing == MMC_TIMING_MMC_HS400))
+		return true;
+	else
+		return false;
+}
+
+static void cvm_mmc_set_timing(struct cvm_mmc_slot *slot)
+{
+	if (!is_mmc_otx2(slot->host))
+		return;
+
+	writeq(slot->taps, slot->host->base + MIO_EMM_TIMING(slot->host));
+}
+
+static int cvm_mmc_configure_delay(struct cvm_mmc_slot *slot)
+{
+	struct cvm_mmc_host *host = slot->host;
+	struct mmc_host *mmc = slot->mmc;
+
+	if (is_mmc_otx2(host)) {
+		int half = MAX_NO_OF_TAPS / 2;
+		int cin = FIELD_GET(MIO_EMM_TIMING_CMD_IN, slot->taps);
+		int din = FIELD_GET(MIO_EMM_TIMING_DATA_IN, slot->taps);
+		int cout, dout;
+
+		if (!slot->taps)
+			cin = din = half;
+		/*
+		 * EMM_CMD hold time from rising edge of EMMC_CLK.
+		 * Typically 5.0 ns at frequencies < 26 MHz.
+		 * Typically 2.5 ns at frequencies <= 52 MHz.
+		 * Typically 0.4 ns at frequencies > 52 MHz.
+		 */
+		switch (mmc->ios.timing) {
+		case MMC_TIMING_LEGACY:
+		default:
+			cout = 63;
+			if (mmc->card && mmc_card_mmc(mmc->card))
+				cout = 39;
+			break;
+		case MMC_TIMING_UHS_SDR12:
+			cout = 39;
+			break;
+		case MMC_TIMING_MMC_HS:
+			cout = 32;
+			break;
+		case MMC_TIMING_SD_HS:
+		case MMC_TIMING_UHS_SDR25:
+		case MMC_TIMING_UHS_SDR50:
+			cout = 26;
+			break;
+		case MMC_TIMING_UHS_DDR50:
+		case MMC_TIMING_MMC_DDR52:
+			cout = 20;
+			break;
+		case MMC_TIMING_UHS_SDR104:
+		case MMC_TIMING_MMC_HS200:
+		case MMC_TIMING_MMC_HS400:
+			cout = 10;
+			break;
+		}
+
+		if (!cvm_is_mmc_timing_ddr(slot))
+			dout = cout;
+		else if (ddr_cmd_taps)
+			cout = dout = cout / 2;
+		else
+			dout = cout / 2;
+
+		slot->taps =
+			FIELD_PREP(MIO_EMM_TIMING_CMD_IN, cin) |
+			FIELD_PREP(MIO_EMM_TIMING_CMD_OUT, cout) |
+			FIELD_PREP(MIO_EMM_TIMING_DATA_IN, din) |
+			FIELD_PREP(MIO_EMM_TIMING_DATA_OUT, dout);
+
+		pr_debug("taps %llx\n", slot->taps);
+		cvm_mmc_set_timing(slot);
+	} else {
+		/* MIO_EMM_SAMPLE is till T8XXX */
+		u64 emm_sample =
+			FIELD_PREP(MIO_EMM_SAMPLE_CMD_CNT, slot->cmd_cnt) |
+			FIELD_PREP(MIO_EMM_SAMPLE_DAT_CNT, slot->data_cnt);
+		writeq(emm_sample, host->base + MIO_EMM_SAMPLE(host));
+	}
+
+	return 0;
+}
+
 static struct cvm_mmc_cr_mods cvm_mmc_get_cr_mods(struct mmc_command *cmd)
 {
 	struct cvm_mmc_cr_type *cr;
@@ -312,11 +408,11 @@ static void cvm_mmc_switch_to(struct cvm_mmc_slot *slot)
 	host->powered = true;
 
 	emm_sample = FIELD_PREP(MIO_EMM_SAMPLE_CMD_CNT, slot->cmd_cnt) |
-		     FIELD_PREP(MIO_EMM_SAMPLE_DAT_CNT, slot->dat_cnt);
+		     FIELD_PREP(MIO_EMM_SAMPLE_DAT_CNT, slot->data_cnt);
 	writeq(emm_sample, host->base + MIO_EMM_SAMPLE(host));
 
 	emmc_io_drive_setup(slot);
-
+	cvm_mmc_configure_delay(slot);
 	host->last_slot = slot->bus_id;
 }
 
@@ -1082,12 +1178,12 @@ static int cvm_mmc_of_parse(struct device *dev, struct cvm_mmc_slot *slot)
 	of_property_read_u32(node, "cavium,dat-clk-skew", &dat_skew);
 	if (is_mmc_8xxx(slot->host) || is_mmc_otx2(slot->host)) {
 		slot->cmd_cnt = cmd_skew;
-		slot->dat_cnt = dat_skew;
+		slot->data_cnt = dat_skew;
 	} else {
 		u64 clock_period = 1000000000000ull / slot->host->sys_freq;
 
 		slot->cmd_cnt = (cmd_skew + clock_period / 2) / clock_period;
-		slot->dat_cnt = (dat_skew + clock_period / 2) / clock_period;
+		slot->data_cnt = (dat_skew + clock_period / 2) / clock_period;
 	}
 
 	/* Get current drive and clk skew */
diff --git a/drivers/mmc/host/cavium.h b/drivers/mmc/host/cavium.h
index 564359f8fd8d..1ad1dfdd8f0c 100644
--- a/drivers/mmc/host/cavium.h
+++ b/drivers/mmc/host/cavium.h
@@ -29,6 +29,7 @@
 #define PCI_SUBSYS_DEVID_9XXX	0xB
 
 #define KHZ_400 (400000)
+#define MHZ_26  (26000000)
 #define MHZ_52  (52000000)
 #define MHZ_100 (100000000)
 #define MHZ_200 (200000000)
@@ -47,6 +48,11 @@
 #define START_CALIBRATION	(0x1)
 #define TOTAL_NO_OF_TAPS	(512)
 #define PS_10000		(10 * 1000)
+#define PS_5000			(5000)
+#define PS_2500			(2500)
+#define PS_400			(400)
+#define MAX_NO_OF_TAPS		(63)
+
 
 /* DMA register addresses */
 #define MIO_EMM_DMA_FIFO_CFG(x)	(0x00 + x->reg_off_dma)
@@ -138,8 +144,12 @@ struct cvm_mmc_slot {
 	u64 cached_switch;
 	u64 cached_rca;
 
-	unsigned int cmd_cnt;		/* sample delay */
-	unsigned int dat_cnt;		/* sample delay */
+	u64 taps;			/* otx2: MIO_EMM_TIMING */
+	unsigned int cmd_cnt;		/* sample cmd in delay */
+	unsigned int data_cnt;		/* sample data in delay */
+
+	unsigned int cmd_out_tap;	/* sample cmd out delay */
+	unsigned int data_out_tap;	/* sample data out delay */
 
 	int drive;			/* Current drive */
 	int slew;			/* clock skew */
@@ -210,6 +220,11 @@ struct cvm_mmc_cr_mods {
 #define MIO_EMM_CALB_START		BIT_ULL(0)
 #define MIO_EMM_TAP_DELAY		GENMASK_ULL(7, 0)
 
+#define MIO_EMM_TIMING_CMD_IN		GENMASK_ULL(53, 48)
+#define MIO_EMM_TIMING_CMD_OUT		GENMASK_ULL(37, 32)
+#define MIO_EMM_TIMING_DATA_IN		GENMASK_ULL(21, 16)
+#define MIO_EMM_TIMING_DATA_OUT		GENMASK_ULL(5, 0)
+
 #define MIO_EMM_INT_NCB_FLT		BIT_ULL(7)
 #define MIO_EMM_INT_SWITCH_ERR		BIT_ULL(6)
 #define MIO_EMM_INT_SWITCH_DONE		BIT_ULL(5)
-- 
2.31.1

