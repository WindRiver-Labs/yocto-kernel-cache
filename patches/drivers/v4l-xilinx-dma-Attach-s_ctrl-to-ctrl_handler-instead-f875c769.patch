From 9125eb3507d021e6d2c495114f6b4e5d93e91158 Mon Sep 17 00:00:00 2001
From: Dylan Yip <dylan.yip@xilinx.com>
Date: Fri, 6 Sep 2019 08:57:22 -0700
Subject: [PATCH 0669/1851] v4l: xilinx: dma: Attach s_ctrl to ctrl_handler
 instead of ioctl

commit 3a45ad8c0d5711607ce8573099ec90f46f865c62 from
https://github.com/Xilinx/linux-xlnx.git

Previous s_ctrl implementation was being ignored due to addition of
control handler. This patch fixes that by creating v4l2_ctrl_ops to
attach s_ctrl to control handler.

Signed-off-by: Dylan Yip <dylan.yip@xilinx.com>
Reviewed-by: Hyun Kwon <hyun.kwon@xilinx.com>
State: pending
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 drivers/media/platform/xilinx/xilinx-dma.c | 149 ++++++++++++++-------
 1 file changed, 98 insertions(+), 51 deletions(-)

diff --git a/drivers/media/platform/xilinx/xilinx-dma.c b/drivers/media/platform/xilinx/xilinx-dma.c
index 50a264d1be8c..392ecd4cfc59 100644
--- a/drivers/media/platform/xilinx/xilinx-dma.c
+++ b/drivers/media/platform/xilinx/xilinx-dma.c
@@ -1134,55 +1134,6 @@ xvip_dma_set_format(struct file *file, void *fh, struct v4l2_format *format)
 	return 0;
 }
 
-static int
-xvip_dma_set_ctrl(struct file *file, void *fh, struct v4l2_control *ctl)
-{
-	struct v4l2_fh *vfh = file->private_data;
-	struct xvip_dma *dma = to_xvip_dma(vfh->vdev);
-	int ret = 0;
-
-	switch (ctl->id)  {
-	case V4L2_CID_XILINX_LOW_LATENCY:
-		if (ctl->value == XVIP_LOW_LATENCY_ENABLE) {
-			if (vb2_is_busy(&dma->queue))
-				return -EBUSY;
-
-			dma->low_latency_cap = true;
-			/*
-			 * Don't use auto-restart for low latency
-			 * to avoid extra one frame delay between
-			 * programming and actual writing of data
-			 */
-			xilinx_xdma_set_mode(dma->dma, DEFAULT);
-		} else if (ctl->value == XVIP_LOW_LATENCY_DISABLE) {
-			if (vb2_is_busy(&dma->queue))
-				return -EBUSY;
-
-			dma->low_latency_cap = false;
-			xilinx_xdma_set_mode(dma->dma, AUTO_RESTART);
-		} else if (ctl->value == XVIP_START_DMA) {
-			/*
-			 * In low latency capture, the driver allows application
-			 * to start dma when queue has buffers. That's why we
-			 * don't check for vb2_is_busy().
-			 */
-			if (dma->low_latency_cap &&
-			    vb2_is_streaming(&dma->queue))
-				dma_async_issue_pending(dma->dma);
-			else
-				ret = -EINVAL;
-		} else {
-			ret = -EINVAL;
-		}
-
-		break;
-	default:
-		ret = -EINVAL;
-	}
-
-	return ret;
-}
-
 static int
 xvip_dma_g_selection(struct file *file, void *fh, struct v4l2_selection *sel)
 {
@@ -1295,7 +1246,6 @@ static const struct v4l2_ioctl_ops xvip_dma_ioctl_ops = {
 	.vidioc_s_fmt_vid_cap_mplane	= xvip_dma_set_format,
 	.vidioc_s_fmt_vid_out		= xvip_dma_set_format,
 	.vidioc_s_fmt_vid_out_mplane	= xvip_dma_set_format,
-	.vidioc_s_ctrl			= xvip_dma_set_ctrl,
 	.vidioc_try_fmt_vid_cap		= xvip_dma_try_format,
 	.vidioc_try_fmt_vid_cap_mplane	= xvip_dma_try_format,
 	.vidioc_try_fmt_vid_out		= xvip_dma_try_format,
@@ -1315,6 +1265,75 @@ static const struct v4l2_ioctl_ops xvip_dma_ioctl_ops = {
 	.vidioc_s_input		= &xvip_dma_set_input,
 };
 
+/* -----------------------------------------------------------------------------
+ * V4L2 controls
+ */
+
+static int xvip_dma_s_ctrl(struct v4l2_ctrl *ctl)
+{
+	struct xvip_dma *dma = container_of(ctl->handler, struct xvip_dma,
+					    ctrl_handler);
+	int ret = 0;
+
+	switch (ctl->id)  {
+	case V4L2_CID_XILINX_LOW_LATENCY:
+		if (ctl->val == XVIP_LOW_LATENCY_ENABLE) {
+			if (vb2_is_busy(&dma->queue))
+				return -EBUSY;
+
+			dma->low_latency_cap = true;
+			/*
+			 * Don't use auto-restart for low latency
+			 * to avoid extra one frame delay between
+			 * programming and actual writing of data
+			 */
+			xilinx_xdma_set_mode(dma->dma, DEFAULT);
+		} else if (ctl->val == XVIP_LOW_LATENCY_DISABLE) {
+			if (vb2_is_busy(&dma->queue))
+				return -EBUSY;
+
+			dma->low_latency_cap = false;
+			xilinx_xdma_set_mode(dma->dma, AUTO_RESTART);
+		} else if (ctl->val == XVIP_START_DMA) {
+			/*
+			 * In low latency capture, the driver allows application
+			 * to start dma when queue has buffers. That's why we
+			 * don't check for vb2_is_busy().
+			 */
+			if (dma->low_latency_cap &&
+			    vb2_is_streaming(&dma->queue))
+				dma_async_issue_pending(dma->dma);
+			else
+				ret = -EINVAL;
+		} else {
+			ret = -EINVAL;
+		}
+
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops xvip_dma_ctrl_ops = {
+	.s_ctrl = xvip_dma_s_ctrl,
+};
+
+static const struct v4l2_ctrl_config xvip_dma_ctrls[] = {
+	{
+		.ops = &xvip_dma_ctrl_ops,
+		.id = V4L2_CID_XILINX_LOW_LATENCY,
+		.name = "Low Latency Controls",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = XVIP_LOW_LATENCY_ENABLE,
+		.max = XVIP_START_DMA,
+		.step = 1,
+		.def = XVIP_LOW_LATENCY_DISABLE,
+	}
+};
+
 /* -----------------------------------------------------------------------------
  * V4L2 file operations
  */
@@ -1402,12 +1421,39 @@ int xvip_dma_init(struct xvip_composite_device *xdev, struct xvip_dma *dma,
 	if (ret < 0)
 		goto error;
 
-	ret = v4l2_ctrl_handler_init(&dma->ctrl_handler, 0);
+	ret = v4l2_ctrl_handler_init(&dma->ctrl_handler,
+				     ARRAY_SIZE(xvip_dma_ctrls));
 	if (ret < 0) {
 		dev_err(dma->xdev->dev, "failed to initialize V4L2 ctrl\n");
 		goto error;
 	}
+
+	for (i = 0; i < ARRAY_SIZE(xvip_dma_ctrls); i++) {
+		struct v4l2_ctrl *ctrl;
+
+		dev_dbg(dma->xdev->dev, "%d ctrl = 0x%x\n", i,
+			xvip_dma_ctrls[i].id);
+		ctrl = v4l2_ctrl_new_custom(&dma->ctrl_handler,
+					    &xvip_dma_ctrls[i], NULL);
+		if (!ctrl) {
+			dev_err(dma->xdev->dev, "Failed for %s ctrl\n",
+				xvip_dma_ctrls[i].name);
+			goto error;
+		}
+	}
+
+	if (dma->ctrl_handler.error) {
+		dev_err(dma->xdev->dev, "failed to add controls\n");
+		ret = dma->ctrl_handler.error;
+		goto error;
+	}
+
 	dma->video.ctrl_handler = &dma->ctrl_handler;
+	ret = v4l2_ctrl_handler_setup(&dma->ctrl_handler);
+	if (ret < 0) {
+		dev_err(dma->xdev->dev, "failed to set controls\n");
+		goto error;
+	}
 
 	/* ... and the video node... */
 	dma->video.fops = &xvip_dma_fops;
@@ -1506,6 +1552,7 @@ void xvip_dma_cleanup(struct xvip_dma *dma)
 	if (!IS_ERR(dma->dma))
 		dma_release_channel(dma->dma);
 
+	v4l2_ctrl_handler_free(&dma->ctrl_handler);
 	media_entity_cleanup(&dma->video.entity);
 
 	mutex_destroy(&dma->lock);
-- 
2.31.1

