From ba76ee86e3de920669330ff28cd8ac785c77bbd1 Mon Sep 17 00:00:00 2001
From: Linu Cherian <lcherian@marvell.com>
Date: Fri, 4 Oct 2019 15:51:28 +0530
Subject: [PATCH 0666/1921] coresight: tmc: Fixes for Marvell OcteonTx CN9xxx
 ETR HW issues.

1. For each HW issue, corresponding driver option will be enabled
   as listed below.

- Buffer size multiplier used is 8 byte instead of 4 bytes
  Driver option CORESIGHT_OPTS_BUFFSIZE_8BX handles this.

- Non secure trace buffer not supported
  Driver option CORESIGHT_OPTS_SECURE_BUFF handles this.
  Driver uses SMC calls for managing secure trace buffer.

- Control registers not reset upon cpu reset
  Driver option CORESIGHT_OPTS_RESET_CTL_REG handles this.

2. SMC call for secure buffer allocation do have the option of
   requesting LLC locked buffer. This can be enabled using
   "cache-lock" property in the DTS.

3. We do make an assumption that secure trace buffer is equally partitioned
   among all the cpus. This will keep the buffer allocation simplified
   in secure world. Hence we expect, arm-buffer-size DTS attribute value
   be same for all the ETR nodes.

Change-Id: I4a6acaf0dc38fb48c27204674458e173e25f83c0
Signed-off-by: Linu Cherian <lcherian@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/16636
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/32241
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 .../hwtracing/coresight/coresight-tmc-etr.c   |  85 ++++++++++++--
 drivers/hwtracing/coresight/coresight-tmc.c   |  22 +++-
 drivers/hwtracing/coresight/coresight-tmc.h   | 104 +++++++++++++++++-
 3 files changed, 200 insertions(+), 11 deletions(-)

diff --git a/drivers/hwtracing/coresight/coresight-tmc-etr.c b/drivers/hwtracing/coresight/coresight-tmc-etr.c
index ed77c7f7b344..a1f0d5776ac4 100644
--- a/drivers/hwtracing/coresight/coresight-tmc-etr.c
+++ b/drivers/hwtracing/coresight/coresight-tmc-etr.c
@@ -14,6 +14,7 @@
 #include <linux/slab.h>
 #include <linux/types.h>
 #include <linux/vmalloc.h>
+#include <linux/arm-smccc.h>
 #include "coresight-catu.h"
 #include "coresight-etm-perf.h"
 #include "coresight-priv.h"
@@ -108,6 +109,17 @@ struct etr_sg_table {
 	dma_addr_t		hwaddr;
 };
 
+void *tmc_etr_drvbuf_vaddr(struct tmc_drvdata *drvdata)
+{
+	struct etr_buf *etr_buf;
+	struct etr_flat_buf *flat_buf;
+
+	etr_buf = drvdata->etr_buf;
+	flat_buf = etr_buf->private;
+
+	return flat_buf->vaddr;
+}
+
 /*
  * tmc_etr_sg_table_entries: Total number of table entries required to map
  * @nr_pages system pages.
@@ -595,6 +607,8 @@ static int tmc_etr_alloc_flat_buf(struct tmc_drvdata *drvdata,
 {
 	struct etr_flat_buf *flat_buf;
 	struct device *real_dev = drvdata->csdev->dev.parent;
+	u64 s_hwaddr = 0;
+	int err;
 
 	/* We cannot reuse existing pages for flat buf */
 	if (pages)
@@ -611,12 +625,40 @@ static int tmc_etr_alloc_flat_buf(struct tmc_drvdata *drvdata,
 		return -ENOMEM;
 	}
 
+	if (!(drvdata->etr_options & CORESIGHT_OPTS_SECURE_BUFF))
+		goto skip_secure_buffer;
+
+	/* Register driver allocated dma buffer for necessary
+	 * mapping in the secure world
+	 */
+	if (tmc_register_drvbuf(drvdata, flat_buf->daddr, etr_buf->size)) {
+		err = -ENOMEM;
+		goto reg_err;
+	}
+
+	/* Allocate secure trace buffer */
+	if (tmc_alloc_secbuf(drvdata, etr_buf->size, &s_hwaddr)) {
+		err = -ENOMEM;
+		goto salloc_err;
+	}
+
+skip_secure_buffer:
 	flat_buf->size = etr_buf->size;
 	flat_buf->dev = &drvdata->csdev->dev;
 	etr_buf->hwaddr = flat_buf->daddr;
+	etr_buf->s_hwaddr = s_hwaddr;
 	etr_buf->mode = ETR_MODE_FLAT;
 	etr_buf->private = flat_buf;
 	return 0;
+
+salloc_err:
+	tmc_unregister_drvbuf(drvdata, etr_buf->hwaddr,
+					      etr_buf->size);
+reg_err:
+	dma_free_coherent(real_dev, etr_buf->size, flat_buf->vaddr,
+			  flat_buf->daddr);
+	return err;
+
 }
 
 static void tmc_etr_free_flat_buf(struct etr_buf *etr_buf)
@@ -634,15 +676,24 @@ static void tmc_etr_free_flat_buf(struct etr_buf *etr_buf)
 
 static void tmc_etr_sync_flat_buf(struct etr_buf *etr_buf, u64 rrp, u64 rwp)
 {
+	u64 w_offset;
+
 	/*
 	 * Adjust the buffer to point to the beginning of the trace data
 	 * and update the available trace data.
 	 */
-	etr_buf->offset = rrp - etr_buf->hwaddr;
-	if (etr_buf->full)
+	if (etr_buf->secure)
+		w_offset = rwp - etr_buf->s_hwaddr;
+	else /* TODO: Need to verify if rrp can be replaced as below */
+		w_offset = rwp - etr_buf->hwaddr;
+
+	if (etr_buf->full) {
+		etr_buf->offset = w_offset;
 		etr_buf->len = etr_buf->size;
-	else
-		etr_buf->len = rwp - rrp;
+	} else {
+		etr_buf->offset = 0;
+		etr_buf->len = w_offset;
+	}
 }
 
 static ssize_t tmc_etr_get_data_flat_buf(struct etr_buf *etr_buf,
@@ -845,6 +896,11 @@ static struct etr_buf *tmc_alloc_etr_buf(struct tmc_drvdata *drvdata,
 		return ERR_PTR(-ENOMEM);
 
 	etr_buf->size = size;
+	/* TODO: Consider using etr_buf->secure everywhere instead of
+	 * etr_options for consistency
+	 */
+	if (drvdata->etr_options & CORESIGHT_OPTS_SECURE_BUFF)
+		etr_buf->secure = true;
 
 	/*
 	 * If we have to use an existing list of pages, we cannot reliably
@@ -957,10 +1013,16 @@ static void __tmc_etr_enable_hw(struct tmc_drvdata *drvdata)
 
 	CS_UNLOCK(drvdata->base);
 
+	if (drvdata->etr_options & CORESIGHT_OPTS_RESET_CTL_REG)
+		tmc_disable_hw(drvdata);
+
 	/* Wait for TMCSReady bit to be set */
 	tmc_wait_for_tmcready(drvdata);
 
-	writel_relaxed(etr_buf->size / 4, drvdata->base + TMC_RSZ);
+	if (drvdata && CORESIGHT_OPTS_BUFFSIZE_8BX)
+		writel_relaxed(etr_buf->size / 8, drvdata->base + TMC_RSZ);
+	else
+		writel_relaxed(etr_buf->size / 4, drvdata->base + TMC_RSZ);
 	writel_relaxed(TMC_MODE_CIRCULAR_BUFFER, drvdata->base + TMC_MODE);
 
 	axictl = readl_relaxed(drvdata->base + TMC_AXICTL);
@@ -977,7 +1039,11 @@ static void __tmc_etr_enable_hw(struct tmc_drvdata *drvdata)
 		axictl |= TMC_AXICTL_SCT_GAT_MODE;
 
 	writel_relaxed(axictl, drvdata->base + TMC_AXICTL);
-	tmc_write_dba(drvdata, etr_buf->hwaddr);
+	if (drvdata->etr_options & CORESIGHT_OPTS_SECURE_BUFF)
+		tmc_write_dba(drvdata, etr_buf->s_hwaddr);
+	else
+		tmc_write_dba(drvdata, etr_buf->hwaddr);
+
 	/*
 	 * If the TMC pointers must be programmed before the session,
 	 * we have to set it properly (i.e, RRP/RWP to base address and
@@ -985,7 +1051,10 @@ static void __tmc_etr_enable_hw(struct tmc_drvdata *drvdata)
 	 */
 	if (tmc_etr_has_cap(drvdata, TMC_ETR_SAVE_RESTORE)) {
 		tmc_write_rrp(drvdata, etr_buf->hwaddr);
-		tmc_write_rwp(drvdata, etr_buf->hwaddr);
+		if (drvdata->etr_options & CORESIGHT_OPTS_SECURE_BUFF)
+			tmc_write_rwp(drvdata, etr_buf->s_hwaddr);
+		else
+			tmc_write_rwp(drvdata, etr_buf->hwaddr);
 		sts = readl_relaxed(drvdata->base + TMC_STS) & ~TMC_STS_FULL;
 		writel_relaxed(sts, drvdata->base + TMC_STS);
 	}
@@ -1088,7 +1157,7 @@ static void tmc_etr_sync_sysfs_buf(struct tmc_drvdata *drvdata)
 		 * Insert barrier packets at the beginning, if there was
 		 * an overflow.
 		 */
-		if (etr_buf->full)
+		if (etr_buf->full && !drvdata->formatter_en)
 			tmc_etr_buf_insert_barrier_packet(etr_buf,
 							  etr_buf->offset);
 	}
diff --git a/drivers/hwtracing/coresight/coresight-tmc.c b/drivers/hwtracing/coresight/coresight-tmc.c
index e1fa9e86dd2c..2fdad6ec21eb 100644
--- a/drivers/hwtracing/coresight/coresight-tmc.c
+++ b/drivers/hwtracing/coresight/coresight-tmc.c
@@ -183,6 +183,10 @@ static ssize_t tmc_read(struct file *file, char __user *data, size_t len,
 	if (actual <= 0)
 		return 0;
 
+	if ((drvdata->etr_options & CORESIGHT_OPTS_SECURE_BUFF) &&
+		tmc_copy_secure_buffer(drvdata, bufp, actual))
+		return -EFAULT;
+
 	if (copy_to_user(data, bufp, actual)) {
 		dev_dbg(&drvdata->csdev->dev,
 			"%s: copy_to_user failed\n", __func__);
@@ -461,15 +465,29 @@ static int tmc_probe(struct amba_device *adev, const struct amba_id *id)
 
 	spin_lock_init(&drvdata->spinlock);
 
+	drvdata->cpu = coresight_get_cpu(dev);
+
+	/* Enable options for Silicon issues */
+	if (id->id == OCTEONTX_CN9XXX_ETR)
+		drvdata->etr_options = CORESIGHT_OPTS_BUFFSIZE_8BX |
+					CORESIGHT_OPTS_SECURE_BUFF |
+					CORESIGHT_OPTS_RESET_CTL_REG;
+
 	devid = readl_relaxed(drvdata->base + CORESIGHT_DEVID);
 	drvdata->config_type = BMVAL(devid, 6, 7);
 	drvdata->memwidth = tmc_get_memwidth(devid);
+	drvdata->formatter_en = !(readl_relaxed(drvdata->base + TMC_FFSR) &
+				  TMC_FFSR_FT_NOT_PRESENT);
 	/* This device is not associated with a session */
 	drvdata->pid = -1;
 
-	if (drvdata->config_type == TMC_CONFIG_TYPE_ETR)
+	if (drvdata->config_type == TMC_CONFIG_TYPE_ETR) {
 		drvdata->size = tmc_etr_get_default_buffer_size(dev);
-	else
+		if (dev->fwnode)
+			drvdata->cache_lock_en =
+				fwnode_property_read_bool(dev->fwnode,
+							       "cache-lock");
+	} else
 		drvdata->size = readl_relaxed(drvdata->base + TMC_RSZ) * 4;
 
 	desc.dev = dev;
diff --git a/drivers/hwtracing/coresight/coresight-tmc.h b/drivers/hwtracing/coresight/coresight-tmc.h
index e8d75877147f..a813581116e6 100644
--- a/drivers/hwtracing/coresight/coresight-tmc.h
+++ b/drivers/hwtracing/coresight/coresight-tmc.h
@@ -10,6 +10,7 @@
 #include <linux/dma-mapping.h>
 #include <linux/idr.h>
 #include <linux/miscdevice.h>
+#include <linux/arm-smccc.h>
 #include <linux/mutex.h>
 #include <linux/refcount.h>
 
@@ -75,6 +76,9 @@
 #define TMC_AXICTL_AXCACHE_OS	(0xf << 2)
 #define TMC_AXICTL_ARCACHE_OS	(0xf << 16)
 
+/* TMC_FFSR - 0x300 */
+#define TMC_FFSR_FT_NOT_PRESENT	BIT(4)
+
 /* TMC_FFCR - 0x304 */
 #define TMC_FFCR_FLUSHMAN_BIT	6
 #define TMC_FFCR_EN_FMT		BIT(0)
@@ -137,6 +141,26 @@ enum tmc_mem_intf_width {
 /* Marvell OcteonTx CN9xxx device */
 #define OCTEONTX_CN9XXX_ETR		0x000cc213
 
+/* Marvell OcteonTx CN9xxx HW issues */
+#define CORESIGHT_OPTS_BUFFSIZE_8BX	(0x1U << 0) /* 8 byte size multiplier */
+#define CORESIGHT_OPTS_SECURE_BUFF	(0x1U << 1) /* Trace buffer is Secure */
+#define CORESIGHT_OPTS_RESET_CTL_REG	(0x1U << 2) /* Reset CTL on reset */
+
+/* SMC call ids for managing the secure trace buffer */
+
+/* Args: x1 - size, x2 - cpu, x3 - llc lock flag
+ * Returns: x0 - status, x1 - secure buffer address
+ */
+#define OCTEONTX_TRC_ALLOC_SBUF		0xc2000c05
+/* Args: x1 - non secure buffer address, x2 - size */
+#define OCTEONTX_TRC_REGISTER_DRVBUF	0xc2000c06
+/* Args: x1 - dst(non secure), x2 - src(secure), x3 - size */
+#define OCTEONTX_TRC_COPY_TO_DRVBUF	0xc2000c07
+/* Args: x1 - secure buffer address, x2 - size */
+#define OCTEONTX_TRC_FREE_SBUF		0xc2000c08
+/* Args: x1 - non secure buffer address, x2 - size */
+#define OCTEONTX_TRC_UNREGISTER_DRVBUF	0xc2000c09
+
 enum etr_mode {
 	ETR_MODE_FLAT,		/* Uses contiguous flat buffer */
 	ETR_MODE_ETR_SG,	/* Uses in-built TMC ETR SG mechanism */
@@ -150,8 +174,10 @@ struct etr_buf_operations;
  * refcount	; Number of sources currently using this etr_buf.
  * @mode	: Mode of the ETR buffer, contiguous, Scatter Gather etc.
  * @full	: Trace data overflow
+ * @secure	: Secure status of ETR buffer
  * @size	: Size of the buffer.
  * @hwaddr	: Address to be programmed in the TMC:DBA{LO,HI}
+ * @s_hwaddr:	: Secure trace buffer address
  * @offset	: Offset of the trace data in the buffer for consumption.
  * @len		: Available trace data @buf (may round up to the beginning).
  * @ops		: ETR buffer operations for the mode.
@@ -161,8 +187,10 @@ struct etr_buf {
 	refcount_t			refcount;
 	enum etr_mode			mode;
 	bool				full;
+	bool				secure;
 	ssize_t				size;
 	dma_addr_t			hwaddr;
+	dma_addr_t			s_hwaddr;
 	unsigned long			offset;
 	s64				len;
 	const struct etr_buf_operations	*ops;
@@ -175,6 +203,8 @@ struct etr_buf {
  * @csdev:	component vitals needed by the framework.
  * @miscdev:	specifics to handle "/dev/xyz.tmc" entry.
  * @spinlock:	only one at a time pls.
+ * @formatter_en: Formatter enable/disable status
+ * @cache_lock_en: Cache lock status
  * @pid:	Process ID of the process being monitored by the session
  *		that is using this component.
  * @buf:	Snapshot of the trace data for ETF/ETB.
@@ -186,6 +216,8 @@ struct etr_buf {
  * @memwidth:	width of the memory interface databus, in bytes.
  * @trigger_cntr: amount of words to store after a trigger.
  * @etr_caps:	Bitmask of capabilities of the TMC ETR, inferred from the
+ * @etr_options: Bitmask of options to manage Silicon issues
+ * @cpu:	CPU id this component is associated with
  *		device configuration register (DEVID)
  * @idr:	Holds etr_bufs allocated for this ETR.
  * @idr_mutex:	Access serialisation for idr.
@@ -198,6 +230,8 @@ struct tmc_drvdata {
 	struct miscdevice	miscdev;
 	spinlock_t		spinlock;
 	pid_t			pid;
+	bool			formatter_en;
+	bool			cache_lock_en;
 	bool			reading;
 	union {
 		char		*buf;		/* TMC ETB */
@@ -210,6 +244,8 @@ struct tmc_drvdata {
 	enum tmc_mem_intf_width	memwidth;
 	u32			trigger_cntr;
 	u32			etr_caps;
+	u32			etr_options;
+	int			cpu;
 	struct idr		idr;
 	struct mutex		idr_mutex;
 	struct etr_buf		*sysfs_buf;
@@ -278,7 +314,7 @@ int tmc_read_unprepare_etr(struct tmc_drvdata *drvdata);
 extern const struct coresight_ops tmc_etr_cs_ops;
 ssize_t tmc_etr_get_sysfs_trace(struct tmc_drvdata *drvdata,
 				loff_t pos, size_t len, char **bufpp);
-
+void *tmc_etr_drvbuf_vaddr(struct tmc_drvdata *drvdata);
 
 #define TMC_REG_PAIR(name, lo_off, hi_off)				\
 static inline u64							\
@@ -332,4 +368,70 @@ tmc_sg_table_buf_size(struct tmc_sg_table *sg_table)
 
 struct coresight_device *tmc_etr_get_catu_device(struct tmc_drvdata *drvdata);
 
+static inline int tmc_alloc_secbuf(struct tmc_drvdata *drvdata,
+				   size_t len, dma_addr_t *s_paddr)
+{
+	struct arm_smccc_res res;
+
+	arm_smccc_smc(OCTEONTX_TRC_ALLOC_SBUF, len, drvdata->cpu,
+		      drvdata->cache_lock_en, 0, 0, 0, 0, &res);
+	if (res.a0 != SMCCC_RET_SUCCESS)
+		return -EFAULT;
+
+	*s_paddr = res.a1;
+	return 0;
+}
+
+static inline int tmc_free_secbuf(struct tmc_drvdata *drvdata,
+				  dma_addr_t s_paddr, size_t len)
+{
+	struct arm_smccc_res res;
+
+	arm_smccc_smc(OCTEONTX_TRC_FREE_SBUF, s_paddr, len,
+		      0, 0, 0, 0, 0, &res);
+	return 0;
+}
+
+static inline int tmc_register_drvbuf(struct tmc_drvdata *drvdata,
+				      dma_addr_t paddr, size_t len)
+{
+	struct arm_smccc_res res;
+
+	arm_smccc_smc(OCTEONTX_TRC_REGISTER_DRVBUF, paddr, len,
+		      0, 0, 0, 0, 0, &res);
+	if (res.a0 != SMCCC_RET_SUCCESS)
+		return -EFAULT;
+
+	return 0;
+}
+
+static inline int tmc_unregister_drvbuf(struct tmc_drvdata *drvdata,
+					dma_addr_t paddr, size_t len)
+{
+	struct arm_smccc_res res;
+
+	arm_smccc_smc(OCTEONTX_TRC_UNREGISTER_DRVBUF, paddr, len,
+		      0, 0, 0, 0, 0, &res);
+	return 0;
+
+}
+
+static inline int tmc_copy_secure_buffer(struct tmc_drvdata *drvdata,
+					 char *bufp, size_t len)
+{
+	struct arm_smccc_res res;
+	struct etr_buf *etr_buf;
+	uint64_t offset;
+
+	etr_buf = drvdata->etr_buf;
+	offset = bufp - (char *)tmc_etr_drvbuf_vaddr(drvdata);
+
+	arm_smccc_smc(OCTEONTX_TRC_COPY_TO_DRVBUF, etr_buf->hwaddr + offset,
+		      etr_buf->s_hwaddr + offset, len, 0, 0, 0, 0, &res);
+	if (res.a0 != SMCCC_RET_SUCCESS)
+		return -EFAULT;
+
+	return 0;
+}
+
 #endif
-- 
2.31.1

