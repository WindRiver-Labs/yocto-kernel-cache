From dc54120f6ef46bcff9bca631e38ea2ed87d1ffe3 Mon Sep 17 00:00:00 2001
From: Bharat Bhushan <bbhushan2@marvell.com>
Date: Thu, 4 Feb 2021 20:26:56 -0800
Subject: [PATCH 1241/1921] Revert "vfio-pci: protect remap_pfn_range() from
 simultaneous calls"

This reverts commit 61de584ea1ff1956bed9f091bf6580684e3aee34.

Reason for revert: This patch does not fix the issue completely.
So revert this till we get proper fix

Change-Id: I792d0d1b9eb0b760bb15fb661cadc6cc246a5035
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/45376
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Tested-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 drivers/vfio/pci/vfio_pci.c         | 48 ++---------------------------
 drivers/vfio/pci/vfio_pci_private.h |  2 --
 2 files changed, 3 insertions(+), 47 deletions(-)

diff --git a/drivers/vfio/pci/vfio_pci.c b/drivers/vfio/pci/vfio_pci.c
index 61e765ae5deb..766af2e4f584 100644
--- a/drivers/vfio/pci/vfio_pci.c
+++ b/drivers/vfio/pci/vfio_pci.c
@@ -1372,11 +1372,6 @@ static ssize_t vfio_pci_write(void *device_data, const char __user *buf,
 	return vfio_pci_rw(device_data, (char __user *)buf, count, ppos, true);
 }
 
-struct vdev_vma_priv {
-	struct vfio_pci_device *vdev;
-	bool vma_mapped;
-};
-
 /* Return 1 on zap and vma_lock acquired, 0 on contention (only with @try) */
 static int vfio_pci_zap_and_vma_lock(struct vfio_pci_device *vdev, bool try)
 {
@@ -1451,20 +1446,15 @@ static int vfio_pci_zap_and_vma_lock(struct vfio_pci_device *vdev, bool try)
 			list_for_each_entry_safe(mmap_vma, tmp,
 						 &vdev->vma_list, vma_next) {
 				struct vm_area_struct *vma = mmap_vma->vma;
-				struct vdev_vma_priv *p;
 
 				if (vma->vm_mm != mm)
 					continue;
 
 				list_del(&mmap_vma->vma_next);
 				kfree(mmap_vma);
-				p = vma->vm_private_data;
 
-				mutex_lock(&vdev->map_lock);
 				zap_vma_ptes(vma, vma->vm_start,
 					     vma->vm_end - vma->vm_start);
-				p->vma_mapped = false;
-				mutex_unlock(&vdev->map_lock);
 			}
 			mutex_unlock(&vdev->vma_lock);
 		}
@@ -1521,19 +1511,12 @@ static int __vfio_pci_add_vma(struct vfio_pci_device *vdev,
  */
 static void vfio_pci_mmap_open(struct vm_area_struct *vma)
 {
-	struct vdev_vma_priv *p = vma->vm_private_data;
-	struct vfio_pci_device *vdev = p->vdev;
-
-	mutex_lock(&vdev->map_lock);
-	p->vma_mapped = false;
 	zap_vma_ptes(vma, vma->vm_start, vma->vm_end - vma->vm_start);
-	mutex_unlock(&vdev->map_lock);
 }
 
 static void vfio_pci_mmap_close(struct vm_area_struct *vma)
 {
-	struct vdev_vma_priv *p = vma->vm_private_data;
-	struct vfio_pci_device *vdev = p->vdev;
+	struct vfio_pci_device *vdev = vma->vm_private_data;
 	struct vfio_pci_mmap_vma *mmap_vma;
 
 	mutex_lock(&vdev->vma_lock);
@@ -1541,7 +1524,6 @@ static void vfio_pci_mmap_close(struct vm_area_struct *vma)
 		if (mmap_vma->vma == vma) {
 			list_del(&mmap_vma->vma_next);
 			kfree(mmap_vma);
-			kfree(p);
 			break;
 		}
 	}
@@ -1551,8 +1533,7 @@ static void vfio_pci_mmap_close(struct vm_area_struct *vma)
 static vm_fault_t vfio_pci_mmap_fault(struct vm_fault *vmf)
 {
 	struct vm_area_struct *vma = vmf->vma;
-	struct vdev_vma_priv *p = vma->vm_private_data;
-	struct vfio_pci_device *vdev = p->vdev;
+	struct vfio_pci_device *vdev = vma->vm_private_data;
 	vm_fault_t ret = VM_FAULT_NOPAGE;
 
 	mutex_lock(&vdev->vma_lock);
@@ -1572,24 +1553,10 @@ static vm_fault_t vfio_pci_mmap_fault(struct vm_fault *vmf)
 
 	mutex_unlock(&vdev->vma_lock);
 
-	/*
-	 * The vdev->map_lock in vfio_pci_zap_and_vma_lock() nests
-	 * inside the vdev->vma_lock but doesn't depend on that for
-	 * protection of the VMA.
-	 * So take vdev->map_lock after releasing vdev->vma_lock.
-	 */
-	mutex_lock(&vdev->map_lock);
-	if (p->vma_mapped)
-		goto unlock_out;
-
 	if (remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
 			    vma->vm_end - vma->vm_start, vma->vm_page_prot))
 		ret = VM_FAULT_SIGBUS;
-	else
-		p->vma_mapped = true;
 
-unlock_out:
-	mutex_unlock(&vdev->map_lock);
 up_out:
 	up_read(&vdev->memory_lock);
 	return ret;
@@ -1607,7 +1574,6 @@ static int vfio_pci_mmap(void *device_data, struct vm_area_struct *vma)
 	struct pci_dev *pdev = vdev->pdev;
 	unsigned int index;
 	u64 phys_len, req_len, pgoff, req_start;
-	struct vdev_vma_priv *priv;
 	int ret;
 
 	index = vma->vm_pgoff >> (VFIO_PCI_OFFSET_SHIFT - PAGE_SHIFT);
@@ -1656,14 +1622,7 @@ static int vfio_pci_mmap(void *device_data, struct vm_area_struct *vma)
 		}
 	}
 
-	priv = kzalloc(sizeof(struct vdev_vma_priv), GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
-
-	priv->vdev = vdev;
-	priv->vma_mapped = false;
-
-	vma->vm_private_data = priv;
+	vma->vm_private_data = vdev;
 	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
 	vma->vm_pgoff = (pci_resource_start(pdev, index) >> PAGE_SHIFT) + pgoff;
 
@@ -1926,7 +1885,6 @@ static int vfio_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	INIT_LIST_HEAD(&vdev->dummy_resources_list);
 	INIT_LIST_HEAD(&vdev->ioeventfds_list);
 	mutex_init(&vdev->vma_lock);
-	mutex_init(&vdev->map_lock);
 	INIT_LIST_HEAD(&vdev->vma_list);
 	init_rwsem(&vdev->memory_lock);
 
diff --git a/drivers/vfio/pci/vfio_pci_private.h b/drivers/vfio/pci/vfio_pci_private.h
index a69ed9ab7120..cfbcd92f2fd7 100644
--- a/drivers/vfio/pci/vfio_pci_private.h
+++ b/drivers/vfio/pci/vfio_pci_private.h
@@ -142,8 +142,6 @@ struct vfio_pci_device {
 	struct mutex		vma_lock;
 	struct list_head	vma_list;
 	struct rw_semaphore	memory_lock;
-	/* Protects VMA against simultaneous remaps. */
-	struct mutex		map_lock;
 };
 
 #define is_intx(vdev) (vdev->irq_type == VFIO_PCI_INTX_IRQ_INDEX)
-- 
2.31.1

