From bf85d6d8b84b2d9cf4db4f44dc0b9756c267662d Mon Sep 17 00:00:00 2001
From: Wojciech Bartczak <wbartczak@marvell.com>
Date: Fri, 19 Mar 2021 10:14:07 -0700
Subject: [PATCH 1376/1921] clk: control device frequency using sysfs

Scmi provides means in its clock protocol to get or set
device clocks controlled by SCP. sysfs nodes are exposed
for user to make amends to desired frequencies.

Caution is that these commands shall be executed by root
process only else poses security hazards as changing clock
frequencies are not recommended in user space.

Reviewed-on: https://sj1git1.cavium.com/16004

Signed-off-by: Wojciech Bartczak <wbartczak@marvell.com>
Change-Id: I64ca7ab9f2abf598eaf6d212216c4f71571cee42
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/48456
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Chandrakala Chavva <cchavva@marvell.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 drivers/clk/clk-scmi.c            | 11 ++++
 drivers/clk/clk.c                 | 96 ++++++++++++++++++++++++++++++-
 drivers/firmware/arm_scmi/clock.c | 19 ++++++
 include/linux/clk-provider.h      |  1 +
 include/linux/scmi_protocol.h     |  2 +
 5 files changed, 128 insertions(+), 1 deletion(-)

diff --git a/drivers/clk/clk-scmi.c b/drivers/clk/clk-scmi.c
index e3cdb4a282fe..671db3f08770 100644
--- a/drivers/clk/clk-scmi.c
+++ b/drivers/clk/clk-scmi.c
@@ -86,6 +86,16 @@ static void scmi_clk_disable(struct clk_hw *hw)
 	clk->handle->clk_ops->disable(clk->handle, clk->id);
 }
 
+static int scmi_clk_get_available_rates(struct clk_hw *hw, u64 *rate)
+{
+	struct scmi_clk *clk = to_scmi_clk(hw);
+
+	return clk->handle->clk_ops->available_rates(clk->handle,
+						     clk->id,
+						     rate);
+}
+
+
 static const struct clk_ops scmi_clk_ops = {
 	.recalc_rate = scmi_clk_recalc_rate,
 	.round_rate = scmi_clk_round_rate,
@@ -98,6 +108,7 @@ static const struct clk_ops scmi_clk_ops = {
 	 */
 	.prepare = scmi_clk_enable,
 	.unprepare = scmi_clk_disable,
+	.get_available_rates = scmi_clk_get_available_rates,
 };
 
 static int scmi_clk_ops_init(struct device *dev, struct scmi_clk *sclk)
diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 36e9f38a3882..3fa60eaa16b7 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -21,6 +21,7 @@
 #include <linux/pm_runtime.h>
 #include <linux/sched.h>
 #include <linux/clkdev.h>
+#include <linux/uaccess.h>
 
 #include "clk.h"
 
@@ -3140,6 +3141,97 @@ static int clk_max_rate_show(struct seq_file *s, void *data)
 }
 DEFINE_SHOW_ATTRIBUTE(clk_max_rate);
 
+static ssize_t clk_clock_freq_get(struct file *file, char __user *user_buf,
+				  size_t count, loff_t *ppos)
+{
+	char buf[32];
+	int len;
+	struct clk_core *core = file->f_inode->i_private;
+	u32 clk_cur_freq = clk_core_get_rate(core);
+
+	len = snprintf(buf, sizeof(buf), "%u\n", clk_cur_freq);
+	return simple_read_from_buffer(user_buf, count, ppos, buf, (size_t)len);
+}
+
+static ssize_t clk_clock_freq_set(struct file *file,
+				  const char __user *user_buf,
+				  size_t count, loff_t *ppos)
+{
+	struct clk_core *core = file->f_inode->i_private;
+	char buf[32];
+	size_t len;
+	u32 new_clk_freq;
+
+	len = min(count, sizeof(buf) - 1);
+	if (copy_from_user(buf, user_buf, len))
+		return -EFAULT;
+
+	/* Make the buffer a valid string that we can not overrun */
+	buf[len] = '\0';
+	if (kstrtouint(buf, 0, &new_clk_freq))
+		return -EINVAL;
+	/* Set for clock without parent */
+	if (core->ops->set_rate) {
+		core->ops->set_rate(core->hw, new_clk_freq, 0);
+		return len;
+	}
+
+	return -EPERM;
+}
+
+static int clk_clock_freq_dummy(struct seq_file *s, void *unused)
+{
+	return 0;
+}
+
+static int clk_clock_freq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, clk_clock_freq_dummy, inode->i_private);
+}
+
+/* File operations for reading or setting vaious device clock fequencies */
+static const struct file_operations clk_clock_freq_fops = {
+	.open  = clk_clock_freq_open,
+	.read  = clk_clock_freq_get,
+	.write = clk_clock_freq_set,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+static int clk_core_get_available_rate(struct clk_core *core, u64 *rates)
+{
+	if (core->ops->get_available_rates)
+		return core->ops->get_available_rates(core->hw, rates);
+
+	return -EPERM;
+}
+
+static int clk_available_clock_freq_show(struct seq_file *s, void *data)
+{
+#define MAX_NO_OF_RATES 16
+	u64 rates_buf[MAX_NO_OF_RATES];
+	int no_of_freqs, i;
+	struct clk_core *core = s->private;
+
+	no_of_freqs = clk_core_get_available_rate(core, rates_buf);
+	if (no_of_freqs < 0)
+		return no_of_freqs;
+
+	/* no freq found */
+	if (no_of_freqs <= 0 || no_of_freqs > MAX_NO_OF_RATES) {
+		pr_err("Fail to get available fequencies (%d)\n", no_of_freqs);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < no_of_freqs; i++)
+		seq_printf(s, "%llu ", rates_buf[i]);
+	seq_puts(s, "\n");
+
+	return 0;
+}
+
+DEFINE_SHOW_ATTRIBUTE(clk_available_clock_freq);
+
 static void clk_debug_create_one(struct clk_core *core, struct dentry *pdentry)
 {
 	struct dentry *root;
@@ -3150,7 +3242,9 @@ static void clk_debug_create_one(struct clk_core *core, struct dentry *pdentry)
 	root = debugfs_create_dir(core->name, pdentry);
 	core->dentry = root;
 
-	debugfs_create_ulong("clk_rate", 0444, root, &core->rate);
+	debugfs_create_file("clk_rate", 0644, root, core, &clk_clock_freq_fops);
+	debugfs_create_file("clk_available_freq", 0444, root, core,
+			    &clk_available_clock_freq_fops);
 	debugfs_create_file("clk_min_rate", 0444, root, core, &clk_min_rate_fops);
 	debugfs_create_file("clk_max_rate", 0444, root, core, &clk_max_rate_fops);
 	debugfs_create_ulong("clk_accuracy", 0444, root, &core->accuracy);
diff --git a/drivers/firmware/arm_scmi/clock.c b/drivers/firmware/arm_scmi/clock.c
index 2b9121f0336d..6224317d8a14 100644
--- a/drivers/firmware/arm_scmi/clock.c
+++ b/drivers/firmware/arm_scmi/clock.c
@@ -190,6 +190,24 @@ scmi_clock_describe_rates_get(const struct scmi_handle *handle, u32 clk_id,
 	return ret;
 }
 
+static int
+scmi_clock_available_rates(const struct scmi_handle *handle, u32 clk_id,
+			   u64 *rates)
+{
+	struct clock_info *cinfo = handle->clk_priv;
+	struct scmi_clock_info *clk = cinfo->clk + clk_id;
+
+	if (!rates)
+		return -EINVAL;
+
+	/* Copy all the rates into user specified buffer */
+	memcpy(rates, &clk->list.rates[0],
+	       clk->list.num_rates * sizeof(*rates));
+
+	return clk->list.num_rates;
+}
+
+
 static int
 scmi_clock_rate_get(const struct scmi_handle *handle, u32 clk_id, u64 *value)
 {
@@ -297,6 +315,7 @@ static struct scmi_clk_ops clk_ops = {
 	.rate_set = scmi_clock_rate_set,
 	.enable = scmi_clock_enable,
 	.disable = scmi_clock_disable,
+	.available_rates = scmi_clock_available_rates,
 };
 
 static int scmi_clock_protocol_init(struct scmi_handle *handle)
diff --git a/include/linux/clk-provider.h b/include/linux/clk-provider.h
index aa6978e8297e..f00a15ffe867 100644
--- a/include/linux/clk-provider.h
+++ b/include/linux/clk-provider.h
@@ -247,6 +247,7 @@ struct clk_ops {
 					  struct clk_duty *duty);
 	void		(*init)(struct clk_hw *hw);
 	void		(*debug_init)(struct clk_hw *hw, struct dentry *dentry);
+	int		(*get_available_rates)(struct clk_hw *hw, u64 *rates);
 };
 
 /**
diff --git a/include/linux/scmi_protocol.h b/include/linux/scmi_protocol.h
index b6c1cdfa2d57..e96755d2fb5a 100644
--- a/include/linux/scmi_protocol.h
+++ b/include/linux/scmi_protocol.h
@@ -74,6 +74,8 @@ struct scmi_clk_ops {
 			u64 rate);
 	int (*enable)(const struct scmi_handle *handle, u32 clk_id);
 	int (*disable)(const struct scmi_handle *handle, u32 clk_id);
+	int (*available_rates)(const struct scmi_handle *handle, u32 clk_id,
+			       u64 *rates);
 };
 
 /**
-- 
2.31.1

