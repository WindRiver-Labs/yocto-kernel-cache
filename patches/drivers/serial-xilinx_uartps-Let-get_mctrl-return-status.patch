From 6297b8f258f0f62c8be4a87bfca94f353bffe752 Mon Sep 17 00:00:00 2001
From: Maarten Brock <m.brock@vanmierlo.com>
Date: Wed, 4 Dec 2019 09:58:53 +0530
Subject: [PATCH 0026/1852] serial: xilinx_uartps: Let get_mctrl return status

commit 67422fb7d50babca6d213fa4fb377134e71b0bf2 from
https://github.com/Xilinx/linux-xlnx.git

Some of the applications like microcom do not work if
modem is disabled. To fix them we always return
TIOCM_CTS | TIOCM_DSR | TIOCM_CAR instead of 0 when
using cts_override. Make get_mctrl return actual status
when not using cts_override.

Signed-off-by: Maarten Brock <m.brock@vanmierlo.com>
Signed-off-by: Shubhrajyoti Datta <shubhrajyoti.datta@xilinx.com>
Link: https://lkml.org/lkml/2019/11/25/316
State: upstream (422c6d3b09afb187b5aeedc3a99d759703023be0)
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 drivers/tty/serial/xilinx_uartps.c | 28 +++++++++++++++++++++++++---
 1 file changed, 25 insertions(+), 3 deletions(-)

diff --git a/drivers/tty/serial/xilinx_uartps.c b/drivers/tty/serial/xilinx_uartps.c
index 4265f7a696be..d6441ddc5936 100644
--- a/drivers/tty/serial/xilinx_uartps.c
+++ b/drivers/tty/serial/xilinx_uartps.c
@@ -157,6 +157,16 @@ MODULE_PARM_DESC(rx_timeout, "Rx timeout, 1-255");
 #define CDNS_UART_MODEMCR_RTS	0x00000002 /* Request to send output control */
 #define CDNS_UART_MODEMCR_DTR	0x00000001 /* Data Terminal Ready */
 
+/*
+ * Modem Status register:
+ * The read/write Modem Status register reports the interface with the modem
+ * or data set, or a peripheral device emulating a modem.
+ */
+#define CDNS_UART_MODEMSR_DCD	BIT(7) /* Data Carrier Detect */
+#define CDNS_UART_MODEMSR_RI	BIT(6) /* Ting Indicator */
+#define CDNS_UART_MODEMSR_DSR	BIT(5) /* Data Set Ready */
+#define CDNS_UART_MODEMSR_CTS	BIT(4) /* Clear To Send */
+
 /*
  * Channel Status Register:
  * The channel status register (CSR) is provided to enable the control logic
@@ -1001,12 +1011,24 @@ static void cdns_uart_config_port(struct uart_port *port, int flags)
  */
 static unsigned int cdns_uart_get_mctrl(struct uart_port *port)
 {
+	u32 val;
+	unsigned int mctrl = 0;
 	struct cdns_uart *cdns_uart_data = port->private_data;
 
 	if (cdns_uart_data->cts_override)
-		return 0;
-
-	return TIOCM_CTS | TIOCM_DSR | TIOCM_CAR;
+		return TIOCM_CTS | TIOCM_DSR | TIOCM_CAR;
+
+	val = readl(port->membase + CDNS_UART_MODEMSR);
+	if (val & CDNS_UART_MODEMSR_CTS)
+		mctrl |= TIOCM_CTS;
+	if (val & CDNS_UART_MODEMSR_DSR)
+		mctrl |= TIOCM_DSR;
+	if (val & CDNS_UART_MODEMSR_RI)
+		mctrl |= TIOCM_RNG;
+	if (val & CDNS_UART_MODEMSR_DCD)
+		mctrl |= TIOCM_CAR;
+
+	return mctrl;
 }
 
 static void cdns_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)
-- 
2.31.1

