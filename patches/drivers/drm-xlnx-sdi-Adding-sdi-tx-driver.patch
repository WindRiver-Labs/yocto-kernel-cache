From 2b92574b3f77a204649c161f97f915a27cc139ac Mon Sep 17 00:00:00 2001
From: Saurabh Sengar <saurabh.singh@xilinx.com>
Date: Fri, 2 Feb 2018 13:50:31 +0530
Subject: [PATCH 0255/1852] drm: xlnx: sdi: Adding sdi-tx driver

commit f02a531dd69dce767ab676bdfb2b17176c3a754f from
https://github.com/Xilinx/linux-xlnx.git

Adding sdi transmitter subsystem driver
SDI transmitter subsystem implements a SDI transmit interface in
accordance to the serial digital interface (SDI) family of standards.
The subsystem accepts video from AXI-4 Stream Video interface and outputs
Native Video stream, and allows for fast selection of the top-level
parameters and automates most of the lower level parameterization. The
AXI4-Stream video interface allows a seamless interface to other
AXI4-Stream-based subsystems.

Signed-off-by: Saurabh Sengar <saurabh.singh@xilinx.com>
Reviewed-by: Hyun Kwon <hyun.kwon@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
State: pending
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 drivers/gpu/drm/xlnx/Kconfig           |   6 +
 drivers/gpu/drm/xlnx/Makefile          |   3 +
 drivers/gpu/drm/xlnx/xlnx_sdi.c        | 882 +++++++++++++++++++++++++
 drivers/gpu/drm/xlnx/xlnx_sdi_modes.h  | 356 ++++++++++
 drivers/gpu/drm/xlnx/xlnx_sdi_timing.c | 370 +++++++++++
 drivers/gpu/drm/xlnx/xlnx_sdi_timing.h |  20 +
 6 files changed, 1637 insertions(+)
 create mode 100644 drivers/gpu/drm/xlnx/xlnx_sdi.c
 create mode 100644 drivers/gpu/drm/xlnx/xlnx_sdi_modes.h
 create mode 100644 drivers/gpu/drm/xlnx/xlnx_sdi_timing.c
 create mode 100644 drivers/gpu/drm/xlnx/xlnx_sdi_timing.h

diff --git a/drivers/gpu/drm/xlnx/Kconfig b/drivers/gpu/drm/xlnx/Kconfig
index e3f40d1301fa..27dbb9ee58b0 100644
--- a/drivers/gpu/drm/xlnx/Kconfig
+++ b/drivers/gpu/drm/xlnx/Kconfig
@@ -59,3 +59,9 @@ config DRM_XLNX_MIXER
 	depends on DRM_XLNX
 	help
 	  DRM driver for Xilinx Mixer driver
+
+config DRM_XLNX_SDI
+	tristate "Xilinx DRM SDI Subsystem Driver"
+	depends on DRM_XLNX
+	help
+	  DRM driver for Xilinx SDI Tx Subsystem.
diff --git a/drivers/gpu/drm/xlnx/Makefile b/drivers/gpu/drm/xlnx/Makefile
index 5c89ad2efec8..0d33d5f7d43c 100644
--- a/drivers/gpu/drm/xlnx/Makefile
+++ b/drivers/gpu/drm/xlnx/Makefile
@@ -6,5 +6,8 @@ obj-$(CONFIG_DRM_XLNX_DSI) += xlnx_dsi.o
 
 obj-$(CONFIG_DRM_XLNX_MIXER) += xlnx_mixer.o
 
+xlnx-sdi-objs += xlnx_sdi.o xlnx_sdi_timing.o
+obj-$(CONFIG_DRM_XLNX_SDI) += xlnx-sdi.o
+
 zynqmp-dpsub-objs += zynqmp_disp.o zynqmp_dpsub.o zynqmp_dp.o
 obj-$(CONFIG_DRM_ZYNQMP_DPSUB) += zynqmp-dpsub.o
diff --git a/drivers/gpu/drm/xlnx/xlnx_sdi.c b/drivers/gpu/drm/xlnx/xlnx_sdi.c
new file mode 100644
index 000000000000..5ba9d4805733
--- /dev/null
+++ b/drivers/gpu/drm/xlnx/xlnx_sdi.c
@@ -0,0 +1,882 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Xilinx FPGA SDI Tx Subsystem driver.
+ *
+ * Copyright (c) 2017 Xilinx Pvt., Ltd
+ *
+ * Contacts: Saurabh Sengar <saurabhs@xilinx.com>
+ */
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drmP.h>
+#include <drm/drm_probe_helper.h>
+#include <linux/component.h>
+#include <linux/device.h>
+#include <linux/of_device.h>
+#include <linux/of_graph.h>
+#include <linux/phy/phy.h>
+#include <video/videomode.h>
+#include "xlnx_sdi_modes.h"
+#include "xlnx_sdi_timing.h"
+
+/* SDI register offsets */
+#define XSDI_TX_RST_CTRL		0x00
+#define XSDI_TX_MDL_CTRL		0x04
+#define XSDI_TX_GLBL_IER		0x0C
+#define XSDI_TX_ISR_STAT		0x10
+#define XSDI_TX_IER_STAT		0x14
+#define XSDI_TX_ST352_LINE		0x18
+#define XSDI_TX_ST352_DATA_CH0		0x1C
+#define XSDI_TX_VER			0x3C
+#define XSDI_TX_SYS_CFG			0x40
+#define XSDI_TX_STS_SB_TDATA		0x60
+#define XSDI_TX_AXI4S_STS1		0x68
+#define XSDI_TX_AXI4S_STS2		0x6C
+
+/* MODULE_CTRL register masks */
+#define XSDI_TX_CTRL_M			BIT(7)
+#define XSDI_TX_CTRL_INS_CRC		BIT(12)
+#define XSDI_TX_CTRL_INS_ST352		BIT(13)
+#define XSDI_TX_CTRL_OVR_ST352		BIT(14)
+#define XSDI_TX_CTRL_INS_SYNC_BIT	BIT(16)
+#define XSDI_TX_CTRL_INS_LN		BIT(19)
+#define XSDI_TX_CTRL_INS_EDH		BIT(20)
+#define XSDI_TX_CTRL_MODE		0x7
+#define XSDI_TX_CTRL_MUX		0x7
+#define XSDI_TX_CTRL_MODE_SHIFT		4
+#define XSDI_TX_CTRL_M_SHIFT		7
+#define XSDI_TX_CTRL_MUX_SHIFT		8
+#define XSDI_TX_CTRL_ST352_F2_EN_SHIFT	15
+
+/* TX_ST352_LINE register masks */
+#define XSDI_TX_ST352_LINE_MASK		GENMASK(10, 0)
+#define XSDI_TX_ST352_LINE_F2_SHIFT	16
+
+/* ISR STAT register masks */
+#define XSDI_GTTX_RSTDONE_INTR		BIT(0)
+#define XSDI_TX_CE_ALIGN_ERR_INTR	BIT(1)
+#define XSDI_AXI4S_VID_LOCK_INTR	BIT(8)
+#define XSDI_OVERFLOW_INTR		BIT(9)
+#define XSDI_UNDERFLOW_INTR		BIT(10)
+#define XSDI_IER_EN_MASK		(XSDI_GTTX_RSTDONE_INTR | \
+					XSDI_TX_CE_ALIGN_ERR_INTR | \
+					XSDI_OVERFLOW_INTR | \
+					XSDI_UNDERFLOW_INTR)
+
+/* RST_CTRL_OFFSET masks */
+#define XSDI_TX_CTRL_EN			BIT(0)
+#define XSDI_TX_BRIDGE_CTRL_EN		BIT(8)
+#define XSDI_TX_AXI4S_CTRL_EN		BIT(9)
+/* STS_SB_TX_TDATA masks */
+#define XSDI_TX_TDATA_GT_RESETDONE	BIT(2)
+
+#define XSDI_TX_MUX_SD_HD_3GA		0
+#define	XSDI_TX_MUX_3GB			1
+#define	XSDI_TX_MUX_8STREAM_6G_12G	2
+#define	XSDI_TX_MUX_4STREAM_6G		3
+#define	XSDI_TX_MUX_16STREAM_12G	4
+
+#define SDI_MAX_DATASTREAM		8
+#define PIXELS_PER_CLK			2
+#define XSDI_CH_SHIFT			29
+#define XST352_PROG_PIC			BIT(6)
+#define XST352_PROG_TRANS		BIT(7)
+#define XST352_2048_SHIFT		BIT(6)
+#define ST352_BYTE3			0x00
+#define ST352_BYTE4			0x01
+#define GT_TIMEOUT			50
+/* SDI modes */
+#define XSDI_MODE_HD			0
+#define	XSDI_MODE_SD			1
+#define	XSDI_MODE_3GA			2
+#define	XSDI_MODE_3GB			3
+#define	XSDI_MODE_6G			4
+#define	XSDI_MODE_12G			5
+
+/**
+ * enum payload_line_1 - Payload Ids Line 1 number
+ * @PAYLD_LN1_HD_3_6_12G:	line 1 HD,3G,6G or 12G mode value
+ * @PAYLD_LN1_SDPAL:		line 1 SD PAL mode value
+ * @PAYLD_LN1_SDNTSC:		line 1 SD NTSC mode value
+ */
+enum payload_line_1 {
+	PAYLD_LN1_HD_3_6_12G = 10,
+	PAYLD_LN1_SDPAL = 9,
+	PAYLD_LN1_SDNTSC = 13
+};
+
+/**
+ * enum payload_line_2 - Payload Ids Line 2 number
+ * @PAYLD_LN2_HD_3_6_12G:	line 2 HD,3G,6G or 12G mode value
+ * @PAYLD_LN2_SDPAL:		line 2 SD PAL mode value
+ * @PAYLD_LN2_SDNTSC:		line 2 SD NTSC mode value
+ */
+enum payload_line_2 {
+	PAYLD_LN2_HD_3_6_12G = 572,
+	PAYLD_LN2_SDPAL = 322,
+	PAYLD_LN2_SDNTSC = 276
+};
+
+/**
+ * struct xlnx_sdi - Core configuration SDI Tx subsystem device structure
+ * @encoder: DRM encoder structure
+ * @connector: DRM connector structure
+ * @dev: device structure
+ * @base: Base address of SDI subsystem
+ * @mode_flags: SDI operation mode related flags
+ * @wait_event: wait event
+ * @event_received: wait event status
+ * @sdi_mode: configurable SDI mode parameter, supported values are:
+ *		0 - HD
+ *		1 - SD
+ *		2 - 3GA
+ *		3 - 3GB
+ *		4 - 6G
+ *		5 - 12G
+ * @sdi_mod_prop_val: configurable SDI mode parameter value
+ * @sdi_data_strm: configurable SDI data stream parameter
+ * @sdi_data_strm_prop_val: configurable number of SDI data streams
+ *			    value currently supported are 2, 4 and 8
+ * @is_frac_prop: configurable SDI fractional fps parameter
+ * @is_frac_prop_val: configurable SDI fractional fps parameter value
+ */
+struct xlnx_sdi {
+	struct drm_encoder encoder;
+	struct drm_connector connector;
+	struct device *dev;
+	void __iomem *base;
+	u32 mode_flags;
+	wait_queue_head_t wait_event;
+	bool event_received;
+	struct drm_property *sdi_mode;
+	u32 sdi_mod_prop_val;
+	struct drm_property *sdi_data_strm;
+	u32 sdi_data_strm_prop_val;
+	struct drm_property *is_frac_prop;
+	bool is_frac_prop_val;
+};
+
+#define connector_to_sdi(c) container_of(c, struct xlnx_sdi, connector)
+#define encoder_to_sdi(e) container_of(e, struct xlnx_sdi, encoder)
+
+static inline void xlnx_sdi_writel(void __iomem *base, int offset, u32 val)
+{
+	writel(val, base + offset);
+}
+
+static inline u32 xlnx_sdi_readl(void __iomem *base, int offset)
+{
+	return readl(base + offset);
+}
+
+/**
+ * xlnx_sdi_en_axi4s - Enable SDI Tx AXI4S-to-Video core
+ * @sdi:	Pointer to SDI Tx structure
+ *
+ * This function enables the SDI Tx AXI4S-to-Video core.
+ */
+static void xlnx_sdi_en_axi4s(struct xlnx_sdi *sdi)
+{
+	u32 data;
+
+	data = xlnx_sdi_readl(sdi->base, XSDI_TX_RST_CTRL);
+	data |= XSDI_TX_AXI4S_CTRL_EN;
+	xlnx_sdi_writel(sdi->base, XSDI_TX_RST_CTRL, data);
+}
+
+/**
+ * xlnx_sdi_en_bridge - Enable SDI Tx bridge
+ * @sdi:	Pointer to SDI Tx structure
+ *
+ * This function enables the SDI Tx bridge.
+ */
+static void xlnx_sdi_en_bridge(struct xlnx_sdi *sdi)
+{
+	u32 data;
+
+	data = xlnx_sdi_readl(sdi->base, XSDI_TX_RST_CTRL);
+	data |= XSDI_TX_BRIDGE_CTRL_EN;
+	xlnx_sdi_writel(sdi->base, XSDI_TX_RST_CTRL, data);
+}
+
+/**
+ * xlnx_sdi_irq_handler - SDI Tx interrupt
+ * @irq:	irq number
+ * @data:	irq data
+ *
+ * Return: IRQ_HANDLED for all cases.
+ *
+ * This is the compact GT ready interrupt.
+ */
+static irqreturn_t xlnx_sdi_irq_handler(int irq, void *data)
+{
+	struct xlnx_sdi *sdi = (struct xlnx_sdi *)data;
+	u32 reg;
+
+	reg = xlnx_sdi_readl(sdi->base, XSDI_TX_ISR_STAT);
+
+	if (reg & XSDI_GTTX_RSTDONE_INTR)
+		dev_dbg(sdi->dev, "GT reset interrupt received\n");
+	if (reg & XSDI_TX_CE_ALIGN_ERR_INTR)
+		dev_err_ratelimited(sdi->dev, "SDI SD CE align error\n");
+	if (reg & XSDI_OVERFLOW_INTR)
+		dev_err_ratelimited(sdi->dev, "AXI-4 Stream Overflow error\n");
+	if (reg & XSDI_UNDERFLOW_INTR)
+		dev_err_ratelimited(sdi->dev, "AXI-4 Stream Underflow error\n");
+	xlnx_sdi_writel(sdi->base, XSDI_TX_ISR_STAT,
+			reg & ~(XSDI_AXI4S_VID_LOCK_INTR));
+
+	reg = xlnx_sdi_readl(sdi->base, XSDI_TX_STS_SB_TDATA);
+	if (reg & XSDI_TX_TDATA_GT_RESETDONE) {
+		sdi->event_received = true;
+		wake_up_interruptible(&sdi->wait_event);
+	}
+	return IRQ_HANDLED;
+}
+
+/**
+ * xlnx_sdi_set_payload_line - set ST352 packet line number
+ * @sdi:	Pointer to SDI Tx structure
+ * @line_1:	line number used to insert st352 packet for field 1.
+ * @line_2:	line number used to insert st352 packet for field 2.
+ *
+ * This function set 352 packet line number.
+ */
+static void xlnx_sdi_set_payload_line(struct xlnx_sdi *sdi,
+				      u32 line_1, u32 line_2)
+{
+	u32 data;
+
+	data = ((line_1 & XSDI_TX_ST352_LINE_MASK) |
+		((line_2 & XSDI_TX_ST352_LINE_MASK) <<
+		XSDI_TX_ST352_LINE_F2_SHIFT));
+
+	xlnx_sdi_writel(sdi->base, XSDI_TX_ST352_LINE, data);
+
+	data = xlnx_sdi_readl(sdi->base, XSDI_TX_MDL_CTRL);
+	data |= (1 << XSDI_TX_CTRL_ST352_F2_EN_SHIFT);
+
+	xlnx_sdi_writel(sdi->base, XSDI_TX_MDL_CTRL, data);
+}
+
+/**
+ * xlnx_sdi_set_payload_data - set ST352 packet payload
+ * @sdi:		Pointer to SDI Tx structure
+ * @data_strm:		data stream number
+ * @payload:		st352 packet payload
+ *
+ * This function set ST352 payload data to corresponding stream.
+ */
+static void xlnx_sdi_set_payload_data(struct xlnx_sdi *sdi,
+				      u32 data_strm, u32 payload)
+{
+	xlnx_sdi_writel(sdi->base,
+			(XSDI_TX_ST352_DATA_CH0 + (data_strm * 4)), payload);
+}
+
+/**
+ * xlnx_sdi_set_display_disable - Disable the SDI Tx IP core enable
+ * register bit
+ * @sdi: SDI structure having the updated user parameters
+ *
+ * This function takes the SDI strucure and disables the core enable bit
+ * of core configuration register.
+ */
+static void xlnx_sdi_set_display_disable(struct xlnx_sdi *sdi)
+{
+	u32 i;
+
+	for (i = 0; i < SDI_MAX_DATASTREAM; i++)
+		xlnx_sdi_set_payload_data(sdi, i, 0);
+
+	xlnx_sdi_writel(sdi->base, XSDI_TX_GLBL_IER, 0);
+	xlnx_sdi_writel(sdi->base, XSDI_TX_RST_CTRL, 0);
+}
+
+/**
+ * xlnx_sdi_payload_config -  config the SDI payload parameters
+ * @sdi:	pointer Xilinx SDI Tx structure
+ * @mode:	display mode
+ *
+ * This function config the SDI st352 payload parameter.
+ */
+static void xlnx_sdi_payload_config(struct xlnx_sdi *sdi, u32 mode)
+{
+	u32 payload_1, payload_2;
+
+	switch (mode) {
+	case XSDI_MODE_SD:
+		payload_1 = PAYLD_LN1_SDPAL;
+		payload_2 = PAYLD_LN2_SDPAL;
+		break;
+	case XSDI_MODE_HD:
+	case XSDI_MODE_3GA:
+	case XSDI_MODE_3GB:
+	case XSDI_MODE_6G:
+	case XSDI_MODE_12G:
+		payload_1 = PAYLD_LN1_HD_3_6_12G;
+		payload_2 = PAYLD_LN2_HD_3_6_12G;
+		break;
+	default:
+		payload_1 = 0;
+		payload_2 = 0;
+		break;
+	}
+
+	xlnx_sdi_set_payload_line(sdi, payload_1, payload_2);
+}
+
+/**
+ * xlnx_sdi_set_mode -  Set mode parameters in SDI Tx
+ * @sdi:	pointer Xilinx SDI Tx structure
+ * @mode:	SDI Tx display mode
+ * @is_frac:	0 - integer 1 - fractional
+ * @mux_ptrn:	specifiy the data stream interleaving pattern to be used
+ * This function config the SDI st352 payload parameter.
+ */
+static void xlnx_sdi_set_mode(struct xlnx_sdi *sdi, u32 mode,
+			      bool is_frac, u32 mux_ptrn)
+{
+	u32 data;
+
+	xlnx_sdi_payload_config(sdi, mode);
+
+	data = xlnx_sdi_readl(sdi->base, XSDI_TX_MDL_CTRL);
+	data &= ~(XSDI_TX_CTRL_MODE << XSDI_TX_CTRL_MODE_SHIFT);
+	data &= ~(XSDI_TX_CTRL_M);
+	data &= ~(XSDI_TX_CTRL_MUX << XSDI_TX_CTRL_MUX_SHIFT);
+
+	data |= (((mode & XSDI_TX_CTRL_MODE) << XSDI_TX_CTRL_MODE_SHIFT) |
+		(is_frac  << XSDI_TX_CTRL_M_SHIFT) |
+		((mux_ptrn & XSDI_TX_CTRL_MUX) << XSDI_TX_CTRL_MUX_SHIFT));
+
+	xlnx_sdi_writel(sdi->base, XSDI_TX_MDL_CTRL, data);
+}
+
+/**
+ * xlnx_sdi_set_config_parameters - Configure SDI Tx registers with parameters
+ * given from user application.
+ * @sdi: SDI structure having the updated user parameters
+ *
+ * This function takes the SDI structure having drm_property parameters
+ * configured from  user application and writes them into SDI IP registers.
+ */
+static void xlnx_sdi_set_config_parameters(struct xlnx_sdi *sdi)
+{
+	int mux_ptrn = -EINVAL;
+
+	switch (sdi->sdi_mod_prop_val) {
+	case XSDI_MODE_3GA:
+		mux_ptrn = XSDI_TX_MUX_SD_HD_3GA;
+		break;
+	case XSDI_MODE_3GB:
+		mux_ptrn = XSDI_TX_MUX_3GB;
+		break;
+	case XSDI_MODE_6G:
+		if (sdi->sdi_data_strm_prop_val == 4)
+			mux_ptrn = XSDI_TX_MUX_4STREAM_6G;
+		else if (sdi->sdi_data_strm_prop_val == 8)
+			mux_ptrn = XSDI_TX_MUX_8STREAM_6G_12G;
+		break;
+	case XSDI_MODE_12G:
+		if (sdi->sdi_data_strm_prop_val == 8)
+			mux_ptrn = XSDI_TX_MUX_8STREAM_6G_12G;
+		break;
+	default:
+		mux_ptrn = 0;
+		break;
+	}
+	if (mux_ptrn == -EINVAL) {
+		dev_err(sdi->dev, "%d data stream not supported for %d mode",
+			sdi->sdi_data_strm_prop_val, sdi->sdi_mod_prop_val);
+		return;
+	}
+	xlnx_sdi_set_mode(sdi, sdi->sdi_mod_prop_val, sdi->is_frac_prop_val,
+			  mux_ptrn);
+}
+
+/**
+ * xlnx_sdi_atomic_set_property - implementation of drm_connector_funcs
+ * set_property invoked by IOCTL call to DRM_IOCTL_MODE_OBJ_SETPROPERTY
+ *
+ * @connector: pointer Xilinx SDI connector
+ * @state: DRM connector state
+ * @property: pointer to the drm_property structure
+ * @val: SDI parameter value that is configured from user application
+ *
+ * This function takes a drm_property name and value given from user application
+ * and update the SDI structure property varabiles with the values.
+ * These values are later used to configure the SDI Rx IP.
+ *
+ * Return: 0 on success OR -EINVAL if setting property fails
+ */
+static int
+xlnx_sdi_atomic_set_property(struct drm_connector *connector,
+			     struct drm_connector_state *state,
+			     struct drm_property *property, uint64_t val)
+{
+	struct xlnx_sdi *sdi = connector_to_sdi(connector);
+
+	if (property == sdi->sdi_mode)
+		sdi->sdi_mod_prop_val = (unsigned int)val;
+	else if (property == sdi->sdi_data_strm)
+		sdi->sdi_data_strm_prop_val = (unsigned int)val;
+	else if (property == sdi->is_frac_prop)
+		sdi->is_frac_prop_val = !!val;
+	else
+		return -EINVAL;
+	return 0;
+}
+
+static int
+xlnx_sdi_atomic_get_property(struct drm_connector *connector,
+			     const struct drm_connector_state *state,
+			     struct drm_property *property, uint64_t *val)
+{
+	struct xlnx_sdi *sdi = connector_to_sdi(connector);
+
+	if (property == sdi->sdi_mode)
+		*val = sdi->sdi_mod_prop_val;
+	else if (property == sdi->sdi_data_strm)
+		*val =  sdi->sdi_data_strm_prop_val;
+	else if (property == sdi->is_frac_prop)
+		*val =  sdi->is_frac_prop_val;
+	else
+		return -EINVAL;
+
+	return 0;
+}
+
+/**
+ * xlnx_sdi_get_mode_id - Search for a video mode in the supported modes table
+ *
+ * @mode: mode being searched
+ *
+ * Return: mode id if mode is found OR -EINVAL otherwise
+ */
+static int xlnx_sdi_get_mode_id(struct drm_display_mode *mode)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(xlnx_sdi_modes); i++)
+		if (drm_mode_equal(&xlnx_sdi_modes[i].mode, mode))
+			return i;
+	return -EINVAL;
+}
+
+/**
+ * xlnx_sdi_drm_add_modes - Adds SDI supported modes
+ * @connector: pointer Xilinx SDI connector
+ *
+ * Return:	Count of modes added
+ *
+ * This function adds the SDI modes supported and returns its count
+ */
+static int xlnx_sdi_drm_add_modes(struct drm_connector *connector)
+{
+	int num_modes = 0;
+	u32 i;
+	struct drm_display_mode *mode;
+	struct drm_device *dev = connector->dev;
+
+	for (i = 0; i < ARRAY_SIZE(xlnx_sdi_modes); i++) {
+		const struct drm_display_mode *ptr = &xlnx_sdi_modes[i].mode;
+
+		mode = drm_mode_duplicate(dev, ptr);
+		if (mode) {
+			drm_mode_probed_add(connector, mode);
+			num_modes++;
+		}
+	}
+	return num_modes;
+}
+
+static enum drm_connector_status
+xlnx_sdi_detect(struct drm_connector *connector, bool force)
+{
+	return connector_status_connected;
+}
+
+static void xlnx_sdi_connector_destroy(struct drm_connector *connector)
+{
+	drm_connector_unregister(connector);
+	drm_connector_cleanup(connector);
+	connector->dev = NULL;
+}
+
+static const struct drm_connector_funcs xlnx_sdi_connector_funcs = {
+	.detect = xlnx_sdi_detect,
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	.destroy = xlnx_sdi_connector_destroy,
+	.atomic_duplicate_state	= drm_atomic_helper_connector_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
+	.reset = drm_atomic_helper_connector_reset,
+	.atomic_set_property = xlnx_sdi_atomic_set_property,
+	.atomic_get_property = xlnx_sdi_atomic_get_property,
+};
+
+static struct drm_encoder *
+xlnx_sdi_best_encoder(struct drm_connector *connector)
+{
+	return &(connector_to_sdi(connector)->encoder);
+}
+
+static int xlnx_sdi_get_modes(struct drm_connector *connector)
+{
+	return xlnx_sdi_drm_add_modes(connector);
+}
+
+static struct drm_connector_helper_funcs xlnx_sdi_connector_helper_funcs = {
+	.get_modes = xlnx_sdi_get_modes,
+	.best_encoder = xlnx_sdi_best_encoder,
+};
+
+/**
+ * xlnx_sdi_drm_connector_create_property -  create SDI connector properties
+ *
+ * @base_connector: pointer to Xilinx SDI connector
+ *
+ * This function takes the xilinx SDI connector component and defines
+ * the drm_property variables with their default values.
+ */
+static void
+xlnx_sdi_drm_connector_create_property(struct drm_connector *base_connector)
+{
+	struct drm_device *dev = base_connector->dev;
+	struct xlnx_sdi *sdi  = connector_to_sdi(base_connector);
+
+	sdi->is_frac_prop = drm_property_create_bool(dev, 1, "is_frac");
+	sdi->sdi_mode = drm_property_create_range(dev, 0,
+						  "sdi_mode", 0, 5);
+	sdi->sdi_data_strm = drm_property_create_range(dev, 0,
+						       "sdi_data_stream", 2, 8);
+}
+
+/**
+ * xlnx_sdi_drm_connector_attach_property -  attach SDI connector
+ * properties
+ *
+ * @base_connector: pointer to Xilinx SDI connector
+ */
+static void
+xlnx_sdi_drm_connector_attach_property(struct drm_connector *base_connector)
+{
+	struct xlnx_sdi *sdi = connector_to_sdi(base_connector);
+	struct drm_mode_object *obj = &base_connector->base;
+
+	if (sdi->sdi_mode)
+		drm_object_attach_property(obj, sdi->sdi_mode, 0);
+
+	if (sdi->sdi_data_strm)
+		drm_object_attach_property(obj, sdi->sdi_data_strm, 0);
+
+	if (sdi->is_frac_prop)
+		drm_object_attach_property(obj, sdi->is_frac_prop, 0);
+}
+
+static int xlnx_sdi_create_connector(struct drm_encoder *encoder)
+{
+	struct xlnx_sdi *sdi = encoder_to_sdi(encoder);
+	struct drm_connector *connector = &sdi->connector;
+	int ret;
+
+	connector->interlace_allowed = true;
+	connector->doublescan_allowed = true;
+
+	ret = drm_connector_init(encoder->dev, connector,
+				 &xlnx_sdi_connector_funcs,
+				 DRM_MODE_CONNECTOR_Unknown);
+	if (ret) {
+		dev_err(sdi->dev, "Failed to initialize connector with drm\n");
+		return ret;
+	}
+
+	drm_connector_helper_add(connector, &xlnx_sdi_connector_helper_funcs);
+	drm_connector_register(connector);
+	drm_connector_attach_encoder(connector, encoder);
+	xlnx_sdi_drm_connector_create_property(connector);
+	xlnx_sdi_drm_connector_attach_property(connector);
+
+	return 0;
+}
+
+/**
+ * xlnx_sdi_set_display_enable - Enables the SDI Tx IP core enable
+ * register bit
+ * @sdi: SDI structure having the updated user parameters
+ *
+ * This function takes the SDI strucure and enables the core enable bit
+ * of core configuration register.
+ */
+static void xlnx_sdi_set_display_enable(struct xlnx_sdi *sdi)
+{
+	u32 data;
+
+	data = xlnx_sdi_readl(sdi->base, XSDI_TX_RST_CTRL);
+	data |= XSDI_TX_CTRL_EN;
+	xlnx_sdi_writel(sdi->base, XSDI_TX_RST_CTRL, data);
+}
+
+/**
+ * xlnx_sdi_calc_st352_payld -  calculate the st352 payload
+ *
+ * @sdi: pointer to SDI Tx structure
+ * @mode: DRM display mode
+ *
+ * This function calculates the st352 payload to be configured.
+ * Please refer to SMPTE ST352 documents for it.
+ * Return:	return st352 payload
+ */
+static u32 xlnx_sdi_calc_st352_payld(struct xlnx_sdi *sdi,
+				     struct drm_display_mode *mode)
+{
+	u8 byt1, byt2;
+	u16 is_p;
+	int id;
+	u32 sdi_mode = sdi->sdi_mod_prop_val;
+	bool is_frac = sdi->is_frac_prop_val;
+	u32 byt3 = ST352_BYTE3;
+
+	id = xlnx_sdi_get_mode_id(mode);
+	dev_dbg(sdi->dev, "mode id: %d\n", id);
+	if (mode->hdisplay == 2048 || mode->hdisplay == 4096)
+		byt3 |= XST352_2048_SHIFT;
+	/* byte 2 calculation */
+	is_p = !(mode->flags & DRM_MODE_FLAG_INTERLACE);
+	byt2 = xlnx_sdi_modes[id].st352_byt2[is_frac];
+	if (sdi_mode == XSDI_MODE_3GB ||
+	    (mode->flags & DRM_MODE_FLAG_DBLSCAN) || is_p)
+		byt2 |= XST352_PROG_PIC;
+	if (is_p && mode->vtotal >= 1125)
+		byt2 |= XST352_PROG_TRANS;
+
+	/* byte 1 calculation */
+	byt1 = xlnx_sdi_modes[id].st352_byt1[sdi_mode];
+
+	return (ST352_BYTE4 << 24 | byt3 << 16 | byt2 << 8 | byt1);
+}
+
+static void xlnx_sdi_setup(struct xlnx_sdi *sdi)
+{
+	u32 reg;
+
+	dev_dbg(sdi->dev, "%s\n", __func__);
+
+	reg = xlnx_sdi_readl(sdi->base, XSDI_TX_MDL_CTRL);
+	reg |= XSDI_TX_CTRL_INS_CRC | XSDI_TX_CTRL_INS_ST352 |
+		XSDI_TX_CTRL_OVR_ST352 | XSDI_TX_CTRL_INS_SYNC_BIT |
+		XSDI_TX_CTRL_INS_EDH;
+	xlnx_sdi_writel(sdi->base, XSDI_TX_MDL_CTRL, reg);
+	xlnx_sdi_writel(sdi->base, XSDI_TX_IER_STAT, XSDI_IER_EN_MASK);
+	xlnx_sdi_writel(sdi->base, XSDI_TX_GLBL_IER, 1);
+	xlnx_stc_reset(sdi->base);
+}
+
+/**
+ * xlnx_sdi_encoder_atomic_mode_set -  drive the SDI timing parameters
+ *
+ * @encoder: pointer to Xilinx DRM encoder
+ * @crtc_state: DRM crtc state
+ * @connector_state: DRM connector state
+ *
+ * This function derives the SDI IP timing parameters from the timing
+ * values given to timing module.
+ */
+static void xlnx_sdi_encoder_atomic_mode_set(struct drm_encoder *encoder,
+					     struct drm_crtc_state *crtc_state,
+				  struct drm_connector_state *connector_state)
+{
+	struct xlnx_sdi *sdi = encoder_to_sdi(encoder);
+	struct drm_display_mode *adjusted_mode = &crtc_state->adjusted_mode;
+	struct videomode vm;
+	u32 payload, i;
+
+	xlnx_sdi_setup(sdi);
+	xlnx_sdi_set_config_parameters(sdi);
+
+	/* set st352 payloads */
+	payload = xlnx_sdi_calc_st352_payld(sdi, adjusted_mode);
+	dev_dbg(sdi->dev, "payload : %0x\n", payload);
+
+	for (i = 0; i < sdi->sdi_data_strm_prop_val / 2; i++) {
+		if (sdi->sdi_mod_prop_val == XSDI_MODE_3GB)
+			payload |= (i << 1) << XSDI_CH_SHIFT;
+		xlnx_sdi_set_payload_data(sdi, i, payload);
+	}
+
+	/* UHDSDI is fixed 2 pixels per clock, horizontal timings div by 2 */
+	vm.hactive = adjusted_mode->hdisplay / PIXELS_PER_CLK;
+	vm.hfront_porch = (adjusted_mode->hsync_start -
+			  adjusted_mode->hdisplay) / PIXELS_PER_CLK;
+	vm.hback_porch = (adjusted_mode->htotal -
+			 adjusted_mode->hsync_end) / PIXELS_PER_CLK;
+	vm.hsync_len = (adjusted_mode->hsync_end -
+		       adjusted_mode->hsync_start) / PIXELS_PER_CLK;
+
+	vm.vactive = adjusted_mode->vdisplay;
+	vm.vfront_porch = adjusted_mode->vsync_start -
+			  adjusted_mode->vdisplay;
+	vm.vback_porch = adjusted_mode->vtotal -
+			 adjusted_mode->vsync_end;
+	vm.vsync_len = adjusted_mode->vsync_end -
+		       adjusted_mode->vsync_start;
+	vm.flags = 0;
+	if (adjusted_mode->flags & DRM_MODE_FLAG_INTERLACE)
+		vm.flags |= DISPLAY_FLAGS_INTERLACED;
+	if (adjusted_mode->flags & DRM_MODE_FLAG_PHSYNC)
+		vm.flags |= DISPLAY_FLAGS_HSYNC_LOW;
+	if (adjusted_mode->flags & DRM_MODE_FLAG_PVSYNC)
+		vm.flags |= DISPLAY_FLAGS_VSYNC_LOW;
+
+	xlnx_stc_sig(sdi->base, &vm);
+}
+
+static void xlnx_sdi_commit(struct drm_encoder *encoder)
+{
+	struct xlnx_sdi *sdi = encoder_to_sdi(encoder);
+	long ret;
+
+	dev_dbg(sdi->dev, "%s\n", __func__);
+	xlnx_sdi_set_display_enable(sdi);
+	ret = wait_event_interruptible_timeout(sdi->wait_event,
+					       sdi->event_received,
+					       usecs_to_jiffies(GT_TIMEOUT));
+	if (!ret) {
+		dev_err(sdi->dev, "Timeout: GT interrupt not received\n");
+		return;
+	}
+	sdi->event_received = false;
+	/* enable sdi bridge, timing controller and Axi4s_vid_out_ctrl */
+	xlnx_sdi_en_bridge(sdi);
+	xlnx_stc_enable(sdi->base);
+	xlnx_sdi_en_axi4s(sdi);
+}
+
+static void xlnx_sdi_disable(struct drm_encoder *encoder)
+{
+	struct xlnx_sdi *sdi = encoder_to_sdi(encoder);
+
+	xlnx_sdi_set_display_disable(sdi);
+	xlnx_stc_disable(sdi->base);
+}
+
+static const struct drm_encoder_helper_funcs xlnx_sdi_encoder_helper_funcs = {
+	.atomic_mode_set	= xlnx_sdi_encoder_atomic_mode_set,
+	.enable			= xlnx_sdi_commit,
+	.disable		= xlnx_sdi_disable,
+};
+
+static const struct drm_encoder_funcs xlnx_sdi_encoder_funcs = {
+	.destroy = drm_encoder_cleanup,
+};
+
+static int xlnx_sdi_bind(struct device *dev, struct device *master,
+			 void *data)
+{
+	struct xlnx_sdi *sdi = dev_get_drvdata(dev);
+	struct drm_encoder *encoder = &sdi->encoder;
+	struct drm_device *drm_dev = data;
+	int ret;
+
+	/*
+	 * TODO: The possible CRTCs are 1 now as per current implementation of
+	 * SDI tx drivers. DRM framework can support more than one CRTCs and
+	 * SDI driver can be enhanced for that.
+	 */
+	encoder->possible_crtcs = 1;
+
+	drm_encoder_init(drm_dev, encoder, &xlnx_sdi_encoder_funcs,
+			 DRM_MODE_ENCODER_TMDS, NULL);
+
+	drm_encoder_helper_add(encoder, &xlnx_sdi_encoder_helper_funcs);
+
+	ret = xlnx_sdi_create_connector(encoder);
+	if (ret) {
+		dev_err(sdi->dev, "fail creating connector, ret = %d\n", ret);
+		drm_encoder_cleanup(encoder);
+	}
+	return ret;
+}
+
+static void xlnx_sdi_unbind(struct device *dev, struct device *master,
+			    void *data)
+{
+	struct xlnx_sdi *sdi = dev_get_drvdata(dev);
+
+	xlnx_sdi_set_display_disable(sdi);
+	xlnx_stc_disable(sdi->base);
+	drm_encoder_cleanup(&sdi->encoder);
+	drm_connector_cleanup(&sdi->connector);
+}
+
+static const struct component_ops xlnx_sdi_component_ops = {
+	.bind	= xlnx_sdi_bind,
+	.unbind	= xlnx_sdi_unbind,
+};
+
+static int xlnx_sdi_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	struct xlnx_sdi *sdi;
+	int ret, irq;
+
+	sdi = devm_kzalloc(dev, sizeof(*sdi), GFP_KERNEL);
+	if (!sdi)
+		return -ENOMEM;
+
+	sdi->dev = dev;
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	sdi->base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(sdi->base)) {
+		dev_err(dev, "failed to remap io region\n");
+		return PTR_ERR(sdi->base);
+	}
+	platform_set_drvdata(pdev, sdi);
+
+	/* disable interrupt */
+	xlnx_sdi_writel(sdi->base, XSDI_TX_GLBL_IER, 0);
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0)
+		return irq;
+
+	ret = devm_request_threaded_irq(sdi->dev, irq, NULL,
+					xlnx_sdi_irq_handler, IRQF_ONESHOT,
+					dev_name(sdi->dev), sdi);
+	if (ret < 0)
+		return ret;
+
+	/* initialize the wait queue for GT reset event */
+	init_waitqueue_head(&sdi->wait_event);
+
+	return component_add(dev, &xlnx_sdi_component_ops);
+}
+
+static int xlnx_sdi_remove(struct platform_device *pdev)
+{
+	component_del(&pdev->dev, &xlnx_sdi_component_ops);
+
+	return 0;
+}
+
+static const struct of_device_id xlnx_sdi_of_match[] = {
+	{ .compatible = "xlnx,sdi-tx"},
+	{ }
+};
+MODULE_DEVICE_TABLE(of, xlnx_sdi_of_match);
+
+static struct platform_driver sdi_tx_driver = {
+	.probe = xlnx_sdi_probe,
+	.remove = xlnx_sdi_remove,
+	.driver = {
+		.name = "xlnx-sdi-tx",
+		.of_match_table = xlnx_sdi_of_match,
+	},
+};
+
+module_platform_driver(sdi_tx_driver);
+
+MODULE_AUTHOR("Saurabh Sengar <saurabhs@xilinx.com>");
+MODULE_DESCRIPTION("Xilinx FPGA SDI Tx Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/xlnx/xlnx_sdi_modes.h b/drivers/gpu/drm/xlnx/xlnx_sdi_modes.h
new file mode 100644
index 000000000000..d4b55ac1cbf5
--- /dev/null
+++ b/drivers/gpu/drm/xlnx/xlnx_sdi_modes.h
@@ -0,0 +1,356 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Xilinx FPGA SDI modes timing values for various
+ * resolutions
+ *
+ * Copyright (c) 2017 Xilinx Pvt., Ltd
+ *
+ * Contacts: Saurabh Sengar <saurabhs@xilinx.com>
+ */
+
+#ifndef _XLNX_SDI_MODES_H_
+#define _XLNX_SDI_MODES_H_
+
+/**
+ * struct xlnx_sdi_display_config - SDI supported modes structure
+ * @mode: drm display mode
+ * @st352_byt2: st352 byte 2 value
+ *		index 0 : value for integral fps
+ *		index 1 : value for fractional fps
+ * @st352_byt1: st352 byte 1 value
+ *		index 0 : value for HD mode
+ *		index 1 : value for SD mode
+ *		index 2 : value for 3GA
+ *		index 3 : value for 3GB
+ *		index 4 : value for 6G
+ *		index 5 : value for 12G
+ */
+struct xlnx_sdi_display_config {
+	struct drm_display_mode mode;
+	u8 st352_byt2[2];
+	u8 st352_byt1[6];
+};
+
+/*
+ * xlnx_sdi_modes - SDI DRM modes
+ */
+static const struct xlnx_sdi_display_config xlnx_sdi_modes[] = {
+	/* 0 - dummy, VICs start at 1 */
+	{ },
+	/* SD: 720x480i@60Hz */
+	{{ DRM_MODE("720x480i", DRM_MODE_TYPE_DRIVER, 13500, 720, 739,
+		   801, 858, 0, 240, 244, 247, 262, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),
+		   .vrefresh = 60, }, {0x7, 0x6},
+		   {0x81, 0x81, 0x81, 0x81, 0x81, 0x81} },
+	/* SD: 720x576i@50Hz */
+	{{ DRM_MODE("720x576i", DRM_MODE_TYPE_DRIVER, 13500, 720, 732,
+		   795, 864, 0, 288, 290, 293, 312, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),
+		   .vrefresh = 50, }, {0x9, 0x9},
+		   {0x81, 0x81, 0x81, 0x81, 0x81, 0x81} },
+	/* HD: 1280x720@25Hz */
+	{{ DRM_MODE("1280x720", DRM_MODE_TYPE_DRIVER, 74250, 1280, 2250,
+		   2990, 3960, 0, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+		   .vrefresh = 25, }, {0x5, 0x5},
+		   {0x84, 0x84, 0x88, 0x84, 0x84, 0x84} },
+	/* HD: 1280x720@24Hz */
+	{{ DRM_MODE("1280x720", DRM_MODE_TYPE_DRIVER, 74250, 1280, 2250,
+		   3155, 4125, 0, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+		   .vrefresh = 24, }, {0x3, 0x2},
+		   {0x84, 0x84, 0x88, 0x84, 0x84, 0x84} },
+	/* HD: 1280x720@30Hz */
+	 {{ DRM_MODE("1280x720", DRM_MODE_TYPE_DRIVER, 74250, 1280, 2250,
+		   2330, 3300, 0, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+		   .vrefresh = 30, }, {0x7, 0x6},
+		   {0x84, 0x84, 0x88, 0x84, 0x84, 0x84} },
+	/* HD: 1280x720@50Hz */
+	{{ DRM_MODE("1280x720", DRM_MODE_TYPE_DRIVER, 74250, 1280, 1720,
+		   1760, 1980, 0, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+		   .vrefresh = 50, }, {0x9, 0x9},
+		   {0x84, 0x84, 0x88, 0x84, 0x84, 0x84} },
+	/* HD: 1280x720@60Hz */
+	{{ DRM_MODE("1280x720", DRM_MODE_TYPE_DRIVER, 74250, 1280, 1390,
+		   1430, 1650, 0, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+		   .vrefresh = 60, }, {0xB, 0xA},
+		   {0x84, 0x84, 0x88, 0x84, 0x84, 0x84} },
+	/* HD: 1920x1080@24Hz */
+	{{ DRM_MODE("1920x1080", DRM_MODE_TYPE_DRIVER, 74250, 1920, 2558,
+		   2602, 2750, 0, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+		   .vrefresh = 24, }, {0x3, 0x2},
+		   {0x85, 0x85, 0x89, 0x8A, 0xC1, 0xC1} },
+	/* HD: 1920x1080@25Hz */
+	{{ DRM_MODE("1920x1080", DRM_MODE_TYPE_DRIVER, 74250, 1920, 2448,
+		   2492, 2640, 0, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+		   .vrefresh = 25, }, {0x5, 0x5},
+		   {0x85, 0x85, 0x89, 0x8A, 0xC1, 0xC1} },
+	/* HD: 1920x1080@30Hz */
+	{{ DRM_MODE("1920x1080", DRM_MODE_TYPE_DRIVER, 74250, 1920, 2008,
+		   2052, 2200, 0, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+		   .vrefresh = 30, }, {0x7, 0x6},
+		   {0x85, 0x85, 0x89, 0x8A, 0xC1, 0xC1} },
+	/* HD: 1920x1080i@48Hz */
+	{{ DRM_MODE("1920x1080i", DRM_MODE_TYPE_DRIVER, 74250, 1920, 2291,
+		   2379, 2750, 0, 540, 542, 547, 562, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_INTERLACE),
+		   .vrefresh = 48, }, {0x3, 0x2},
+		   {0x85, 0x85, 0x89, 0x8A, 0xC1, 0xC1} },
+	/* HD: 1920x1080i@50Hz */
+	{{ DRM_MODE("1920x1080i", DRM_MODE_TYPE_DRIVER, 74250, 1920, 2448,
+		   2492, 2640, 0, 540, 542, 547, 562, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_INTERLACE),
+		   .vrefresh = 50, }, {0x5, 0x5},
+		   {0x85, 0x85, 0x89, 0x8A, 0xC1, 0xC1} },
+	/* HD: 1920x1080i@60Hz */
+	{{ DRM_MODE("1920x1080i", DRM_MODE_TYPE_DRIVER, 74250, 1920, 2008,
+		   2052, 2200, 0, 540, 542, 547, 562, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_INTERLACE),
+		   .vrefresh = 60, }, {0x7, 0x6},
+		   {0x85, 0x85, 0x89, 0x8A, 0xC1, 0xC1} },
+	/* HD: 1920x1080sf@24Hz */
+	{{ DRM_MODE("1920x1080sf", DRM_MODE_TYPE_DRIVER, 74250, 1920, 2291,
+		   2379, 2750, 0, 540, 542, 547, 562, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLSCAN),
+		   .vrefresh = 48, }, {0x3, 0x2},
+		   {0x85, 0x85, 0x89, 0x8A, 0xC1, 0xC1} },
+	/* HD: 1920x1080sf@25Hz */
+	{{ DRM_MODE("1920x1080sf", DRM_MODE_TYPE_DRIVER, 74250, 1920, 2448,
+		   2492, 2640, 0, 540, 542, 547, 562, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLSCAN),
+		   .vrefresh = 50, }, {0x5, 0x5},
+		   {0x85, 0x85, 0x89, 0x8A, 0xC1, 0xC1} },
+	/* HD: 1920x1080sf@30Hz */
+	{{ DRM_MODE("1920x1080sf", DRM_MODE_TYPE_DRIVER, 74250, 1920, 2008,
+		   2052, 2200, 0, 540, 542, 547, 562, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLSCAN),
+		   .vrefresh = 60, }, {0x7, 0x6},
+		   {0x85, 0x85, 0x89, 0x8A, 0xC1, 0xC1} },
+	/* HD: 2048x1080i@48Hz */
+	{{ DRM_MODE("2048x1080i", DRM_MODE_TYPE_DRIVER, 74250, 2048, 2377,
+		   2421, 2750, 0, 540, 542, 547, 562, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_INTERLACE),
+		   .vrefresh = 48, }, {0x3, 0x2},
+		   {0x85, 0x85, 0x89, 0x8A, 0xC1, 0xC1} },
+	/* HD: 2048x1080i@50Hz */
+	{{ DRM_MODE("2048x1080i", DRM_MODE_TYPE_DRIVER, 74250, 2048, 2322,
+		   2366, 2640, 0, 540, 542, 547, 562, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_INTERLACE),
+		   .vrefresh = 50, }, {0x5, 0x5},
+		   {0x85, 0x85, 0x89, 0x8A, 0xC1, 0xC1} },
+	/* HD: 2048x1080i@60Hz */
+	{{ DRM_MODE("2048x1080i", DRM_MODE_TYPE_DRIVER, 74250, 2048, 2114,
+		   2134, 2200, 0, 540, 542, 547, 562, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_INTERLACE),
+		   .vrefresh = 60, }, {0x7, 0x6},
+		   {0x85, 0x85, 0x89, 0x8A, 0xC1, 0xC1} },
+	/* HD: 2048x1080sf@24Hz */
+	{{ DRM_MODE("2048x1080sf", DRM_MODE_TYPE_DRIVER, 74250, 2048, 2377,
+		   2421, 2750, 0, 540, 542, 547, 562, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLSCAN),
+		   .vrefresh = 48, }, {0x3, 0x2},
+		   {0x85, 0x85, 0x89, 0x8A, 0xC1, 0xC1} },
+	/* HD: 2048x1080sf@25Hz */
+	{{ DRM_MODE("2048x1080sf", DRM_MODE_TYPE_DRIVER, 74250, 2048, 2322,
+		   2366, 2640, 0, 540, 542, 547, 562, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLSCAN),
+		   .vrefresh = 50, }, {0x5, 0x5},
+		   {0x85, 0x85, 0x89, 0x8A, 0xC1, 0xC1} },
+	/* HD: 2048x1080sf@30Hz */
+	{{ DRM_MODE("2048x1080sf", DRM_MODE_TYPE_DRIVER, 74250, 2048, 2114,
+		   2134, 2200, 0, 540, 542, 547, 562, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLSCAN),
+		   .vrefresh = 60, }, {0x7, 0x6},
+		   {0x85, 0x85, 0x89, 0x8A, 0xC1, 0xC1} },
+	/* HD: 2048x1080@30Hz */
+	{{ DRM_MODE("2048x1080", DRM_MODE_TYPE_DRIVER, 74250, 2048, 2114,
+		   2134, 2200, 0, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+		   .vrefresh = 30, }, {0x7, 0x6},
+		   {0x85, 0x85, 0x89, 0x8A, 0xC1, 0xC1} },
+	/* HD: 2048x1080@25Hz */
+	{{ DRM_MODE("2048x1080", DRM_MODE_TYPE_DRIVER, 74250, 2048, 2448,
+		   2492, 2640, 0, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+		   .vrefresh = 25, }, {0x5, 0x5},
+		   {0x85, 0x85, 0x89, 0x8A, 0xC1, 0xC1} },
+	/* HD: 2048x1080@24Hz */
+	{{ DRM_MODE("2048x1080", DRM_MODE_TYPE_DRIVER, 74250, 2048, 2558,
+		   2602, 2750, 0, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+		   .vrefresh = 24, }, {0x3, 0x2},
+		   {0x85, 0x85, 0x89, 0x8A, 0xC1, 0xC1} },
+	/* 3G: 1920x1080@48Hz */
+	{{ DRM_MODE("1920x1080", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2558,
+		   2602, 2750, 0, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+		   .vrefresh = 48, }, {0x8, 0x4},
+		   {0x85, 0x85, 0x89, 0x8A, 0xC1, 0xC1} },
+	/* 3G: 1920x1080@50Hz */
+	{{ DRM_MODE("1920x1080", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2448,
+		   2492, 2640, 0, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+		   .vrefresh = 50, }, {0x9, 0x9},
+		   {0x85, 0x85, 0x89, 0x8A, 0xC1, 0xC1} },
+	/* 3G: 1920x1080@60Hz */
+	{{ DRM_MODE("1920x1080", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2008,
+		   2052, 2200, 0, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+		   .vrefresh = 60, }, {0xB, 0xA},
+		   {0x85, 0x85, 0x89, 0x8A, 0xC1, 0xC1} },
+	/* 3G: 2048x1080@60Hz */
+	{{ DRM_MODE("2048x1080", DRM_MODE_TYPE_DRIVER, 148500, 2048, 2136,
+		   2180, 2200, 0, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+		   .vrefresh = 60, }, {0xB, 0xA},
+		   {0x85, 0x85, 0x89, 0x8A, 0xC1, 0xC1} },
+	/* 3G: 2048x1080@50Hz */
+	{{ DRM_MODE("2048x1080", DRM_MODE_TYPE_DRIVER, 148500, 2048, 2448,
+		   2492, 2640, 0, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+		   .vrefresh = 50, }, {0x9, 0x9},
+		   {0x85, 0x85, 0x89, 0x8A, 0xC1, 0xC1} },
+	/* 3G: 2048x1080@48Hz */
+	{{ DRM_MODE("2048x1080", DRM_MODE_TYPE_DRIVER, 148500, 2048, 2558,
+		   2602, 2750, 0, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+		   .vrefresh = 48, }, {0x8, 0x4},
+		   {0x85, 0x85, 0x89, 0x8A, 0xC1, 0xC1} },
+	/* 3G-B: 1920x1080i@96Hz */
+	{{ DRM_MODE("1920x1080i", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2291,
+		   2379, 2750, 0, 1080, 1084, 1094, 1124, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_INTERLACE),
+		   .vrefresh = 96, }, {0x8, 0x4},
+		   {0x85, 0x85, 0x89, 0x8A, 0xC1, 0xC1} },
+	/* 3G-B: 1920x1080i@100Hz */
+	{{ DRM_MODE("1920x1080i", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2448,
+		   2492, 2640, 0, 1080, 1084, 1094, 1124, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_INTERLACE),
+		   .vrefresh = 100, }, {0x9, 0x9},
+		   {0x85, 0x85, 0x89, 0x8A, 0xC1, 0xC1} },
+	/* 3G-B: 1920x1080i@120Hz */
+	{{ DRM_MODE("1920x1080i", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2008,
+		   2052, 2200, 0, 1080, 1084, 1094, 1124, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_INTERLACE),
+		   .vrefresh = 120, }, {0xB, 0xA},
+		   {0x85, 0x85, 0x89, 0x8A, 0xC1, 0xC1} },
+	/* 3G-B: 2048x1080i@96Hz */
+	{{ DRM_MODE("2048x1080i", DRM_MODE_TYPE_DRIVER, 148500, 2048, 2377,
+		   2421, 2750, 0, 1080, 1084, 1094, 1124, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_INTERLACE),
+		   .vrefresh = 96, }, {0x8, 0x4},
+		   {0x85, 0x85, 0x89, 0x8A, 0xC1, 0xC1} },
+	/* 3G-B: 2048x1080i@100Hz */
+	{{ DRM_MODE("2048x1080i", DRM_MODE_TYPE_DRIVER, 148500, 2048, 2322,
+		   2366, 2640, 0, 1080, 1084, 1094, 1124, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_INTERLACE),
+		   .vrefresh = 100, }, {0x9, 0x9},
+		   {0x85, 0x85, 0x89, 0x8A, 0xC1, 0xC1} },
+	/* 3G-B: 2048x1080i@120Hz */
+	{{ DRM_MODE("2048x1080i", DRM_MODE_TYPE_DRIVER, 148500, 2048, 2114,
+		   2134, 2200, 0, 1080, 1084, 1094, 1124, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_INTERLACE),
+		   .vrefresh = 120, }, {0xB, 0xA},
+		   {0x85, 0x85, 0x89, 0x8A, 0xC1, 0xC1} },
+	/* 6G: 3840x2160@30Hz */
+	{{ DRM_MODE("3840x2160", DRM_MODE_TYPE_DRIVER, 297000, 3840, 4016,
+		   4104, 4400, 0, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+		   .vrefresh = 30, }, {0x7, 0x6},
+		   {0x98, 0x98, 0x97, 0x98, 0xC0, 0xCE} },
+	/* 6G: 3840x2160@25Hz */
+	{{ DRM_MODE("3840x2160", DRM_MODE_TYPE_DRIVER, 297000, 3840, 4896,
+		   4984, 5280, 0, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+		   .vrefresh = 25, }, {0x5, 0x5},
+		   {0x98, 0x98, 0x97, 0x98, 0xC0, 0xCE} },
+	/* 6G: 3840x2160@24Hz */
+	{{ DRM_MODE("3840x2160", DRM_MODE_TYPE_DRIVER, 297000, 3840, 5116,
+		   5204, 5500, 0, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+		   .vrefresh = 24, }, {0x3, 0x2},
+		   {0x98, 0x98, 0x97, 0x98, 0xC0, 0xCE} },
+	/* 6G: 4096x2160@24Hz */
+	{{ DRM_MODE("4096x2160", DRM_MODE_TYPE_DRIVER, 296704, 4096, 5116,
+		   5204, 5500, 0, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+		   .vrefresh = 24, }, {0x3, 0x2},
+		   {0x98, 0x98, 0x97, 0x98, 0xC0, 0xCE} },
+	/* 6G: 4096x2160@25Hz */
+	{{ DRM_MODE("4096x2160", DRM_MODE_TYPE_DRIVER, 297000, 4096, 5064,
+		   5152, 5280, 0, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+		   .vrefresh = 25, }, {0x5, 0x5},
+		   {0x98, 0x98, 0x97, 0x98, 0xC0, 0xCE} },
+	/* 6G: 4096x2160@30Hz */
+	{{ DRM_MODE("4096x2160", DRM_MODE_TYPE_DRIVER, 296704, 4096, 4184,
+		   4272, 4400, 0, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+		   .vrefresh = 30, }, {0x7, 0x6},
+		   {0x98, 0x98, 0x97, 0x98, 0xC0, 0xCE} },
+	/* 12G: 3840x2160@48Hz */
+	{{ DRM_MODE("3840x2160", DRM_MODE_TYPE_DRIVER, 594000, 3840, 5116,
+		   5204, 5500, 0, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+		   .vrefresh = 48, }, {0x8, 0x4},
+		   {0x98, 0x98, 0x97, 0x98, 0xC0, 0xCE} },
+	/* 12G: 3840x2160@50Hz */
+	{{ DRM_MODE("3840x2160", DRM_MODE_TYPE_DRIVER, 594000, 3840, 4896,
+		   4984, 5280, 0, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+		   .vrefresh = 50, }, {0x9, 0x9},
+		   {0x98, 0x98, 0x97, 0x98, 0xC0, 0xCE} },
+	/* 12G: 3840x2160@60Hz */
+	{{ DRM_MODE("3840x2160", DRM_MODE_TYPE_DRIVER, 594000, 3840, 4016,
+		   4104, 4400, 0, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+		   .vrefresh = 60, }, {0xB, 0xA},
+		   {0x98, 0x98, 0x97, 0x98, 0xC0, 0xCE} },
+	/* 12G: 4096x2160@48Hz */
+	{{ DRM_MODE("4096x2160", DRM_MODE_TYPE_DRIVER, 594000, 4096, 5116,
+		   5204, 5500, 0, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+		   .vrefresh = 48, }, {0x8, 0x4},
+		   {0x98, 0x98, 0x97, 0x98, 0xC0, 0xCE} },
+	/* 12G: 4096x2160@50Hz */
+	{{ DRM_MODE("4096x2160", DRM_MODE_TYPE_DRIVER, 594000, 4096, 5064,
+		   5152, 5280, 0, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+		   .vrefresh = 50, }, {0x9, 0x9},
+		   {0x98, 0x98, 0x97, 0x98, 0xC0, 0xCE} },
+	/* 12G: 4096x2160@60Hz */
+	{{ DRM_MODE("4096x2160", DRM_MODE_TYPE_DRIVER, 593408, 4096, 4184,
+		   4272, 4400, 0, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+		   .vrefresh = 60, }, {0xB, 0xA},
+		   {0x98, 0x98, 0x97, 0x98, 0xC0, 0xCE} },
+};
+
+#endif /* _XLNX_SDI_MODES_H_ */
diff --git a/drivers/gpu/drm/xlnx/xlnx_sdi_timing.c b/drivers/gpu/drm/xlnx/xlnx_sdi_timing.c
new file mode 100644
index 000000000000..d69402c51265
--- /dev/null
+++ b/drivers/gpu/drm/xlnx/xlnx_sdi_timing.c
@@ -0,0 +1,370 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Xilinx FPGA SDI Tx timing controller driver
+ *
+ * Copyright (c) 2017 Xilinx Pvt., Ltd
+ *
+ * Contacts: Saurabh Sengar <saurabhs@xilinx.com>
+ */
+
+#include <drm/drmP.h>
+#include <linux/device.h>
+#include <video/videomode.h>
+#include "xlnx_sdi_timing.h"
+
+/* timing controller register offsets */
+#define XSTC_CTL	0x00
+#define XSTC_STATS	0x04
+#define XSTC_ERROR	0x08
+#define XSTC_GASIZE	0x60
+#define XSTC_GENC	0x68
+#define XSTC_GPOL	0x6c
+#define XSTC_GHSIZE	0x70
+#define XSTC_GVSIZE	0x74
+#define XSTC_GHSYNC	0x78
+#define XSTC_GVBH_F0	0x7c
+#define XSTC_GVSYNC_F0	0x80
+#define XSTC_GVSH_F0	0x84
+#define XSTC_GVBH_F1	0x88
+#define XSTC_GVSYNC_F1	0x8C
+#define XSTC_GVSH_F1	0x90
+#define XSTC_OFFSET	0x10000
+
+/* timing controller register bit */
+#define XSTC_CTL_FIP	BIT(6)	/* field id polarity */
+#define XSTC_CTL_ACP	BIT(5)	/* active chroma polarity */
+#define XSTC_CTL_AVP	BIT(4)	/* active video polarity */
+#define XSTC_CTL_HSP	BIT(3)	/* hori sync polarity */
+#define XSTC_CTL_VSP	BIT(2)	/* vert sync polarity */
+#define XSTC_CTL_HBP	BIT(1)	/* hori blank polarity */
+#define XSTC_CTL_VBP	BIT(0)	/* vert blank polarity */
+#define XSTC_CTL_FIPSS	BIT(26)	/* field id polarity source */
+#define XSTC_CTL_ACPSS	BIT(25)	/* active chroma polarity src */
+#define XSTC_CTL_AVPSS	BIT(24)	/* active video polarity src */
+#define XSTC_CTL_HSPSS	BIT(23)	/* hori sync polarity src */
+#define XSTC_CTL_VSPSS	BIT(22)	/* vert sync polarity src */
+#define XSTC_CTL_HBPSS	BIT(21)	/* hori blank polarity src */
+#define XSTC_CTL_VBPSS	BIT(20)	/* vert blank polarity src */
+#define XSTC_CTL_VCSS	BIT(18)	/* chroma src */
+#define XSTC_CTL_VASS	BIT(17)	/* vertical offset src */
+#define XSTC_CTL_VBSS	BIT(16)	/* vertical sync end src */
+#define XSTC_CTL_VSSS	BIT(15)	/* vertical sync start src */
+#define XSTC_CTL_VFSS	BIT(14)	/* vertical active size src */
+#define XSTC_CTL_VTSS	BIT(13)	/* vertical frame size src */
+#define XSTC_CTL_HBSS	BIT(11)	/* horiz sync end src */
+#define XSTC_CTL_HSSS	BIT(10)	/* horiz sync start src */
+#define XSTC_CTL_HFSS	BIT(9)	/* horiz active size src */
+#define XSTC_CTL_HTSS	BIT(8)	/* horiz frame size src */
+#define XSTC_CTL_GE	BIT(2)	/* timing generator enable */
+#define XSTC_CTL_RU	BIT(1)	/* timing register update */
+
+/* timing generator horizontal 1 */
+#define XSTC_GH1_BPSTART_MASK	GENMASK(28, 16)
+#define XSTC_GH1_BPSTART_SHIFT	16
+#define XSTC_GH1_SYNCSTART_MASK	GENMASK(12, 0)
+/* timing generator vertical 1 (filed 0) */
+#define XSTC_GV1_BPSTART_MASK	GENMASK(28, 16)
+#define XSTC_GV1_BPSTART_SHIFT	16
+#define XSTC_GV1_SYNCSTART_MASK	GENMASK(12, 0)
+/* timing generator/detector vblank/vsync horizontal offset registers */
+#define XSTC_XVXHOX_HEND_MASK	GENMASK(28, 16)
+#define XSTC_XVXHOX_HEND_SHIFT	16
+#define XSTC_XVXHOX_HSTART_MASK	GENMASK(12, 0)
+
+#define XSTC_GHFRAME_HSIZE	GENMASK(12, 0)
+#define XSTC_GVFRAME_HSIZE_F1	GENMASK(12, 0)
+#define XSTC_GA_ACTSIZE_MASK	GENMASK(12, 0)
+/* reset register bit definition */
+#define XSTC_RST		BIT(31)
+/* Interlaced bit in XSTC_GENC */
+#define XSTC_GENC_INTERL	BIT(6)
+
+/**
+ * struct xlnx_stc_polarity - timing signal polarity
+ *
+ * @field_id: field ID polarity
+ * @vblank: vblank polarity
+ * @vsync: vsync polarity
+ * @hblank: hblank polarity
+ * @hsync: hsync polarity
+ */
+struct xlnx_stc_polarity {
+	u8 field_id;
+	u8 vblank;
+	u8 vsync;
+	u8 hblank;
+	u8 hsync;
+};
+
+/**
+ * struct xlnx_stc_hori_off - timing signal horizontal offset
+ *
+ * @v0blank_hori_start: vblank horizontal start (field 0)
+ * @v0blank_hori_end: vblank horizontal end (field 0)
+ * @v0sync_hori_start: vsync horizontal start (field 0)
+ * @v0sync_hori_end: vsync horizontal end (field 0)
+ * @v1blank_hori_start: vblank horizontal start (field 1)
+ * @v1blank_hori_end: vblank horizontal end (field 1)
+ * @v1sync_hori_start: vsync horizontal start (field 1)
+ * @v1sync_hori_end: vsync horizontal end (field 1)
+ */
+struct xlnx_stc_hori_off {
+	u16 v0blank_hori_start;
+	u16 v0blank_hori_end;
+	u16 v0sync_hori_start;
+	u16 v0sync_hori_end;
+	u16 v1blank_hori_start;
+	u16 v1blank_hori_end;
+	u16 v1sync_hori_start;
+	u16 v1sync_hori_end;
+};
+
+/**
+ * xlnx_stc_writel - Memory mapped SDI Tx timing controller write
+ * @base:	Pointer to SDI Tx registers base
+ * @offset:	Register offset
+ * @val:	value to be written
+ *
+ * This function writes the value to SDI TX timing controller registers
+ */
+static inline void xlnx_stc_writel(void __iomem *base, int offset, u32 val)
+{
+	writel(val, base + XSTC_OFFSET + offset);
+}
+
+/**
+ * xlnx_stc_readl - Memory mapped timing controllerregister read
+ * @base:	Pointer to SDI Tx registers base
+ * @offset:	Register offset
+ *
+ * Return: The contents of the SDI Tx timing controller register
+ *
+ * This function returns the contents of the corresponding SDI Tx register.
+ */
+static inline u32 xlnx_stc_readl(void __iomem *base, int offset)
+{
+	return readl(base + XSTC_OFFSET + offset);
+}
+
+/**
+ * xlnx_stc_enable - Enable timing controller
+ * @base:	Base address of SDI Tx subsystem
+ *
+ * This function enables the SDI Tx subsystem's timing controller
+ */
+void xlnx_stc_enable(void __iomem *base)
+{
+	u32 reg;
+
+	reg = xlnx_stc_readl(base, XSTC_CTL);
+	xlnx_stc_writel(base, XSTC_CTL, reg | XSTC_CTL_GE);
+}
+
+/**
+ * xlnx_stc_disable - Disable timing controller
+ * @base:	Base address of SDI Tx subsystem
+ *
+ * This function disables the SDI Tx subsystem's timing controller
+ */
+void xlnx_stc_disable(void __iomem *base)
+{
+	u32 reg;
+
+	reg = xlnx_stc_readl(base, XSTC_CTL);
+	xlnx_stc_writel(base, XSTC_CTL, reg & ~XSTC_CTL_GE);
+}
+
+/**
+ * xlnx_stc_reset - Reset timing controller
+ * @base:	Base address of SDI Tx subsystem
+ *
+ * This function resets the SDI Tx subsystem's timing controller
+ */
+void xlnx_stc_reset(void __iomem *base)
+{
+	u32 reg;
+
+	xlnx_stc_writel(base, XSTC_CTL, XSTC_RST);
+
+	/* enable register update */
+	reg = xlnx_stc_readl(base, XSTC_CTL);
+	xlnx_stc_writel(base, XSTC_CTL, reg | XSTC_CTL_RU);
+}
+
+/**
+ * xlnx_stc_polarity - Configure timing signal polarity
+ * @base:	Base address of SDI Tx subsystem
+ * @polarity:	timing signal polarity data
+ *
+ * This function configure timing signal polarity
+ */
+static void xlnx_stc_polarity(void __iomem *base,
+			      struct xlnx_stc_polarity *polarity)
+{
+	u32 reg = 0;
+
+	reg = XSTC_CTL_ACP;
+	reg |= XSTC_CTL_AVP;
+	if (polarity->field_id)
+		reg |= XSTC_CTL_FIP;
+	if (polarity->vblank)
+		reg |= XSTC_CTL_VBP;
+	if (polarity->vsync)
+		reg |= XSTC_CTL_VSP;
+	if (polarity->hblank)
+		reg |= XSTC_CTL_HBP;
+	if (polarity->hsync)
+		reg |= XSTC_CTL_HSP;
+
+	xlnx_stc_writel(base, XSTC_GPOL, reg);
+}
+
+/**
+ * xlnx_stc_hori_off - Configure horzontal timing offset
+ * @base:	Base address of SDI Tx subsystem
+ * @hori_off:	horizontal offset configuration data
+ *
+ * This function configure horizontal offset
+ */
+static void xlnx_stc_hori_off(void __iomem *base,
+			      struct xlnx_stc_hori_off *hori_off)
+{
+	u32 reg;
+
+	/* Calculate and update Generator VBlank Hori field 0 */
+	reg = hori_off->v0blank_hori_start & XSTC_XVXHOX_HSTART_MASK;
+	reg |= (hori_off->v0blank_hori_end << XSTC_XVXHOX_HEND_SHIFT) &
+		XSTC_XVXHOX_HEND_MASK;
+	xlnx_stc_writel(base, XSTC_GVBH_F0, reg);
+
+	/* Calculate and update Generator VSync Hori field 0 */
+	reg = hori_off->v0sync_hori_start & XSTC_XVXHOX_HSTART_MASK;
+	reg |= (hori_off->v0sync_hori_end << XSTC_XVXHOX_HEND_SHIFT) &
+		XSTC_XVXHOX_HEND_MASK;
+	xlnx_stc_writel(base, XSTC_GVSH_F0, reg);
+
+	/* Calculate and update Generator VBlank Hori field 1 */
+	reg = hori_off->v1blank_hori_start & XSTC_XVXHOX_HSTART_MASK;
+	reg |= (hori_off->v1blank_hori_end << XSTC_XVXHOX_HEND_SHIFT) &
+		XSTC_XVXHOX_HEND_MASK;
+	xlnx_stc_writel(base, XSTC_GVBH_F1, reg);
+
+	/* Calculate and update Generator VBlank Hori field 1 */
+	reg =  hori_off->v1sync_hori_start & XSTC_XVXHOX_HSTART_MASK;
+	reg |= (hori_off->v1sync_hori_end << XSTC_XVXHOX_HEND_SHIFT) &
+		XSTC_XVXHOX_HEND_MASK;
+	xlnx_stc_writel(base, XSTC_GVSH_F1, reg);
+}
+
+/**
+ * xlnx_stc_src - Configure timing source
+ * @base:	Base address of SDI Tx subsystem
+ *
+ * This function configure timing source
+ */
+static void xlnx_stc_src(void __iomem *base)
+{
+	u32 reg;
+
+	reg = xlnx_stc_readl(base, XSTC_CTL);
+	reg |= XSTC_CTL_VCSS;
+	reg |= XSTC_CTL_VASS;
+	reg |= XSTC_CTL_VBSS;
+	reg |= XSTC_CTL_VSSS;
+	reg |= XSTC_CTL_VFSS;
+	reg |= XSTC_CTL_VTSS;
+	reg |= XSTC_CTL_HBSS;
+	reg |= XSTC_CTL_HSSS;
+	reg |= XSTC_CTL_HFSS;
+	reg |= XSTC_CTL_HTSS;
+	xlnx_stc_writel(base, XSTC_CTL, reg);
+}
+
+/**
+ * xlnx_stc_sig - Generates timing signal
+ * @base:	Base address of SDI Tx subsystem
+ * @vm:		video mode
+ *
+ * This function generated the timing for given vide mode
+ */
+void xlnx_stc_sig(void __iomem *base, struct videomode *vm)
+{
+	u32 reg;
+	u32 htotal, hactive, hsync_start, hbackporch_start;
+	u32 vtotal, vactive, vsync_start, vbackporch_start;
+	struct xlnx_stc_hori_off hori_off;
+	struct xlnx_stc_polarity polarity;
+
+	reg = xlnx_stc_readl(base, XSTC_CTL);
+	xlnx_stc_writel(base, XSTC_CTL, reg & ~XSTC_CTL_RU);
+
+	htotal = vm->hactive + vm->hfront_porch + vm->hsync_len +
+		 vm->hback_porch;
+	vtotal = vm->vactive + vm->vfront_porch + vm->vsync_len +
+		 vm->vback_porch;
+	hactive = vm->hactive;
+	vactive = vm->vactive;
+	hsync_start = vm->hactive + vm->hfront_porch;
+	vsync_start = vm->vactive + vm->vfront_porch;
+	hbackporch_start = hsync_start + vm->hsync_len;
+	vbackporch_start = vsync_start + vm->vsync_len;
+
+	DRM_DEBUG_DRIVER("ha: %d, va: %d\n", hactive, vactive);
+	DRM_DEBUG_DRIVER("hs: %d, hb: %d\n", hsync_start, hbackporch_start);
+	DRM_DEBUG_DRIVER("vs: %d, vb: %d\n", vsync_start, vbackporch_start);
+	DRM_DEBUG_DRIVER("ht: %d, vt: %d\n", htotal, vtotal);
+
+	reg = htotal & XSTC_GHFRAME_HSIZE;
+	xlnx_stc_writel(base, XSTC_GHSIZE, reg);
+	reg = vtotal & XSTC_GVFRAME_HSIZE_F1;
+	reg |= reg << XSTC_GV1_BPSTART_SHIFT;
+	xlnx_stc_writel(base, XSTC_GVSIZE, reg);
+	reg = hactive & XSTC_GA_ACTSIZE_MASK;
+	reg |= (vactive & XSTC_GA_ACTSIZE_MASK) << 16;
+	xlnx_stc_writel(base, XSTC_GASIZE, reg);
+	reg = hsync_start & XSTC_GH1_SYNCSTART_MASK;
+	reg |= (hbackporch_start << XSTC_GH1_BPSTART_SHIFT) &
+	       XSTC_GH1_BPSTART_MASK;
+	xlnx_stc_writel(base, XSTC_GHSYNC, reg);
+	reg = vsync_start & XSTC_GV1_SYNCSTART_MASK;
+	reg |= (vbackporch_start << XSTC_GV1_BPSTART_SHIFT) &
+	       XSTC_GV1_BPSTART_MASK;
+	xlnx_stc_writel(base, XSTC_GVSYNC_F0, reg);
+
+	hori_off.v0blank_hori_start = hactive;
+	hori_off.v0blank_hori_end = hactive;
+	hori_off.v0sync_hori_start = hsync_start;
+	hori_off.v0sync_hori_end = hsync_start;
+	hori_off.v1blank_hori_start = hactive;
+	hori_off.v1blank_hori_end = hactive;
+
+	if (vm->flags & DISPLAY_FLAGS_INTERLACED) {
+		hori_off.v1sync_hori_start = hsync_start - (htotal / 2);
+		hori_off.v1sync_hori_end = hsync_start - (htotal / 2);
+		xlnx_stc_writel(base, XSTC_GVSYNC_F1, reg);
+		reg = xlnx_stc_readl(base, XSTC_GENC)
+				     | XSTC_GENC_INTERL;
+		xlnx_stc_writel(base, XSTC_GENC, reg);
+	} else {
+		hori_off.v1sync_hori_start = hsync_start;
+		hori_off.v1sync_hori_end = hsync_start;
+		reg = xlnx_stc_readl(base, XSTC_GENC)
+				     & ~XSTC_GENC_INTERL;
+		xlnx_stc_writel(base, XSTC_GENC, reg);
+	}
+
+	xlnx_stc_hori_off(base, &hori_off);
+	/* set up polarity */
+	memset(&polarity, 0x0, sizeof(polarity));
+	polarity.hsync = !!(vm->flags & DISPLAY_FLAGS_HSYNC_LOW);
+	polarity.vsync = !!(vm->flags & DISPLAY_FLAGS_VSYNC_LOW);
+	polarity.hblank = !!(vm->flags & DISPLAY_FLAGS_HSYNC_LOW);
+	polarity.vblank = !!(vm->flags & DISPLAY_FLAGS_VSYNC_LOW);
+	polarity.field_id = !!(vm->flags & DISPLAY_FLAGS_INTERLACED);
+	xlnx_stc_polarity(base, &polarity);
+
+	xlnx_stc_src(base);
+
+	reg = xlnx_stc_readl(base, XSTC_CTL);
+	xlnx_stc_writel(base, XSTC_CTL, reg | XSTC_CTL_RU);
+}
diff --git a/drivers/gpu/drm/xlnx/xlnx_sdi_timing.h b/drivers/gpu/drm/xlnx/xlnx_sdi_timing.h
new file mode 100644
index 000000000000..4ca9f8972e0a
--- /dev/null
+++ b/drivers/gpu/drm/xlnx/xlnx_sdi_timing.h
@@ -0,0 +1,20 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Xilinx FPGA SDI Tx timing controller driver
+ *
+ * Copyright (c) 2017 Xilinx Pvt., Ltd
+ *
+ * Contacts: Saurabh Sengar <saurabhs@xilinx.com>
+ */
+
+#ifndef _XLNX_SDI_TIMING_H_
+#define _XLNX_SDI_TIMING_H_
+
+struct videomode;
+
+void xlnx_stc_enable(void __iomem *base);
+void xlnx_stc_disable(void __iomem *base);
+void xlnx_stc_reset(void __iomem *base);
+void xlnx_stc_sig(void __iomem *base, struct videomode *vm);
+
+#endif /* _XLNX_SDI_TIMING_H_ */
-- 
2.31.1

