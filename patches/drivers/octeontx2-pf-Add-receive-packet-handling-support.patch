From 151c1a4037684be54d58784e665a4b20e094a16f Mon Sep 17 00:00:00 2001
From: Sunil Goutham <sgoutham@marvell.com>
Date: Thu, 7 Feb 2019 13:22:19 +0530
Subject: [PATCH 044/767] octeontx2-pf: Add receive packet handling support

commit 227338a9e6adfdae68f4d052cf0ce0f328f643d1 from
git@git.assembla.com:cavium/WindRiver.linux.git

This patch adds support for processing CQE_RX queued for
a received packet, prepares an skb and handovers to stack.
Also refill receive buffers into NPA pool.

Change-Id: I267ed6a8896590c9378a4374ab1a36538f735cc2
Signed-off-by: Sunil Goutham <sgoutham@marvell.com>
Signed-off-by: Tomasz Duszynski <tduszynski@marvell.com>
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../marvell/octeontx2/nic/otx2_common.c       |   4 +-
 .../marvell/octeontx2/nic/otx2_common.h       |   3 +
 .../ethernet/marvell/octeontx2/nic/otx2_pf.c  |  17 ++
 .../marvell/octeontx2/nic/otx2_struct.h       | 159 ++++++++++++++++++
 .../marvell/octeontx2/nic/otx2_txrx.c         | 147 +++++++++++++++-
 .../marvell/octeontx2/nic/otx2_txrx.h         |  17 +-
 6 files changed, 340 insertions(+), 7 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.c
index be96e97b0aa4..f8ef700ac5c0 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.c
@@ -15,8 +15,8 @@
 #include "otx2_common.h"
 #include "otx2_struct.h"
 
-static dma_addr_t otx2_alloc_rbuf(struct otx2_nic *pfvf, struct otx2_pool *pool,
-				  gfp_t gfp)
+dma_addr_t otx2_alloc_rbuf(struct otx2_nic *pfvf, struct otx2_pool *pool,
+			   gfp_t gfp)
 {
 	dma_addr_t iova;
 
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h
index 9ca9656ff1be..b50bcdd51da6 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h
@@ -76,6 +76,7 @@ struct otx2_nic {
 	struct pci_dev		*pdev;
 	struct device		*dev;
 	struct net_device	*netdev;
+	void			*iommu_domain;
 
 	struct otx2_qset	qset;
 	struct otx2_hw		hw;
@@ -281,6 +282,8 @@ int otx2_config_nix(struct otx2_nic *pfvf);
 int otx2_config_nix_queues(struct otx2_nic *pfvf);
 int otx2_txschq_config(struct otx2_nic *pfvf, int lvl);
 int otx2_txsch_alloc(struct otx2_nic *pfvf);
+dma_addr_t otx2_alloc_rbuf(struct otx2_nic *pfvf, struct otx2_pool *pool,
+			   gfp_t gfp);
 
 /* Mbox handlers */
 void mbox_handler_msix_offset(struct otx2_nic *pfvf,
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c
index 71c06aac4c5b..db312b3ae444 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c
@@ -15,6 +15,7 @@
 #include <linux/of.h>
 #include <linux/if_vlan.h>
 #include <net/ip.h>
+#include <linux/iommu.h>
 
 #include "otx2_reg.h"
 #include "otx2_common.h"
@@ -593,6 +594,22 @@ static int otx2_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	if (err)
 		goto err_detach_rsrc;
 
+	/* NPA's pool is a stack to which SW frees buffer pointers via Aura.
+	 * HW allocates buffer pointer from stack and uses it for DMA'ing
+	 * ingress packet. In some scenarios HW can free back allocated buffer
+	 * pointers to pool. This makes it impossible for SW to maintain a
+	 * parallel list where physical addresses of buffer pointers (IOVAs)
+	 * given to HW can be saved for later reference.
+	 *
+	 * So the only way to convert Rx packet's buffer address is to use
+	 * IOMMU's iova_to_phys() handler which translates the address by
+	 * walking through the translation tables.
+	 *
+	 * So check if device is binded to IOMMU, otherwise translation is
+	 * not needed.
+	 */
+	pf->iommu_domain = iommu_get_domain_for_dev(dev);
+
 	netdev->netdev_ops = &otx2_netdev_ops;
 	err = register_netdev(netdev);
 	if (err) {
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_struct.h b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_struct.h
index be6c5a614f42..8fc156721bf2 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_struct.h
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_struct.h
@@ -27,6 +27,19 @@ enum nix_xqe_type {
 	NIX_XQE_TYPE_SEND      = 0x8,
 };
 
+/* NIX CQE/SQE subdescriptor types */
+enum nix_subdc {
+	NIX_SUBDC_NOP  = 0x0,
+	NIX_SUBDC_EXT  = 0x1,
+	NIX_SUBDC_CRC  = 0x2,
+	NIX_SUBDC_IMM  = 0x3,
+	NIX_SUBDC_SG   = 0x4,
+	NIX_SUBDC_MEM  = 0x5,
+	NIX_SUBDC_JUMP = 0x6,
+	NIX_SUBDC_WORK = 0x7,
+	NIX_SUBDC_SOD  = 0xf,
+};
+
 /* NIX CQE header structure */
 struct nix_cqe_hdr_s {
 #if defined(__BIG_ENDIAN_BITFIELD)
@@ -44,4 +57,150 @@ struct nix_cqe_hdr_s {
 #endif
 };
 
+/* NIX CQE RX parse structure */
+struct nix_rx_parse_s {
+#if defined(__BIG_ENDIAN_BITFIELD)  /* W0 */
+	u64 lhtype       : 4;
+	u64 lgtype       : 4;
+	u64 lftype       : 4;
+	u64 letype       : 4;
+	u64 ldtype       : 4;
+	u64 lctype       : 4;
+	u64 lbtype       : 4;
+	u64 latype       : 4;
+	u64 errcode      : 8;
+	u64 errlev       : 4;
+	u64 wqwd         : 1;
+	u64 express      : 1;
+	u64 rsvd_17      : 1;
+	u64 desc_sizem1  : 5;
+	u64 chan         : 12;
+#else
+	u64 chan         : 12;
+	u64 desc_sizem1  : 5;
+	u64 rsvd_17      : 1;
+	u64 express      : 1;
+	u64 wqwd         : 1;
+	u64 errlev       : 4;
+	u64 errcode      : 8;
+	u64 latype       : 4;
+	u64 lbtype       : 4;
+	u64 lctype       : 4;
+	u64 ldtype       : 4;
+	u64 letype       : 4;
+	u64 lftype       : 4;
+	u64 lgtype       : 4;
+	u64 lhtype       : 4;
+#endif
+#if defined(__BIG_ENDIAN_BITFIELD)  /* W1 */
+	u64 vtag1_tci    : 16;
+	u64 vtag0_tci    : 16;
+	u64 rsvd_95_94   : 2;
+	u64 pkind        : 6;
+	u64 vtag1_gone   : 1;
+	u64 vtag1_valid  : 1;
+	u64 vtag0_gone   : 1;
+	u64 vtag0_valid  : 1;
+	u64 l3b          : 1;
+	u64 l3m          : 1;
+	u64 l2b          : 1;
+	u64 l2m          : 1;
+	u64 pkt_lenm1    : 16;
+#else
+	u64 pkt_lenm1    : 16;
+	u64 l2m          : 1;
+	u64 l2b          : 1;
+	u64 l3m          : 1;
+	u64 l3b          : 1;
+	u64 vtag0_valid  : 1;
+	u64 vtag0_gone   : 1;
+	u64 vtag1_valid  : 1;
+	u64 vtag1_gone   : 1;
+	u64 pkind        : 6;
+	u64 rsvd_95_94   : 2;
+	u64 vtag0_tci    : 16;
+	u64 vtag1_tci    : 16;
+#endif
+#if defined(__BIG_ENDIAN_BITFIELD)  /* W2 */
+	u64 lhflags      : 8;
+	u64 lgflags      : 8;
+	u64 lfflags      : 8;
+	u64 leflags      : 8;
+	u64 ldflags      : 8;
+	u64 lcflags      : 8;
+	u64 lbflags      : 8;
+	u64 laflags      : 8;
+#else
+	u64 laflags      : 8;
+	u64 lbflags      : 8;
+	u64 lcflags      : 8;
+	u64 ldflags      : 8;
+	u64 leflags      : 8;
+	u64 lfflags      : 8;
+	u64 lgflags      : 8;
+	u64 lhflags      : 8;
+#endif
+#if defined(__BIG_ENDIAN_BITFIELD)  /* W3 */
+	u64 match_id     : 16;
+	u64 pb_aura      : 20;
+	u64 wqe_aura     : 20;
+	u64 eoh_ptr      : 8;
+#else
+	u64 eoh_ptr      : 8;
+	u64 wqe_aura     : 20;
+	u64 pb_aura      : 20;
+	u64 match_id     : 16;
+#endif
+#if defined(__BIG_ENDIAN_BITFIELD)  /* W4 */
+	u64 lhptr        : 8;
+	u64 lgptr        : 8;
+	u64 lfptr        : 8;
+	u64 leptr        : 8;
+	u64 ldptr        : 8;
+	u64 lcptr        : 8;
+	u64 lbptr        : 8;
+	u64 laptr        : 8;
+#else
+	u64 laptr        : 8;
+	u64 lbptr        : 8;
+	u64 lcptr        : 8;
+	u64 ldptr        : 8;
+	u64 leptr        : 8;
+	u64 lfptr        : 8;
+	u64 lgptr        : 8;
+	u64 lhptr        : 8;
+#endif
+#if defined(__BIG_ENDIAN_BITFIELD)	/* W5 */
+	u64 rsvd_383_341 : 43;
+	u64 flow_key_alg : 5;
+	u64 vtag1_ptr    : 8;
+	u64 vtag0_ptr    : 8;
+#else
+	u64 vtag0_ptr    : 8;
+	u64 vtag1_ptr    : 8;
+	u64 flow_key_alg : 5;
+	u64 rsvd_383_341 : 43;
+#endif
+	u64 rsvd_447_384;		/* W6 */
+};
+
+/* NIX CQE RX scatter/gather subdescriptor structure */
+struct nix_rx_sg_s {
+#if defined(__BIG_ENDIAN_BITFIELD)	/* W0 */
+	u64 subdc      : 4;
+	u64 rsvd_59_50 : 10;
+	u64 segs       : 2;
+	u64 seg3_size  : 16;
+	u64 seg2_size  : 16;
+	u64 seg1_size  : 16;
+#else
+	u64 seg1_size  : 16;
+	u64 seg2_size  : 16;
+	u64 seg3_size  : 16;
+	u64 segs       : 2;
+	u64 rsvd_59_50 : 10;
+	u64 subdc      : 4;
+#endif
+};
+
 #endif /* OTX2_STRUCT_H */
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_txrx.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_txrx.c
index e37667cebbab..b568900a6097 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_txrx.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_txrx.c
@@ -34,15 +34,144 @@ static inline u64 otx2_nix_cq_op_status(struct otx2_nic *pfvf, int cq_idx)
 	return status;
 }
 
+static inline unsigned int frag_num(unsigned int i)
+{
+#ifdef __BIG_ENDIAN
+	return (i & ~3) + 3 - (i & 3);
+#else
+	return i;
+#endif
+}
+
+static void otx2_skb_add_frag(struct otx2_nic *pfvf,
+			      struct sk_buff *skb, u64 iova, int len)
+{
+	struct page *page;
+	void *va;
+
+	iova -= OTX2_HEAD_ROOM;
+	va = phys_to_virt(otx2_iova_to_phys(pfvf->iommu_domain, iova));
+	page = virt_to_page(va);
+	skb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, page,
+			va - page_address(page), len, RCV_FRAG_LEN);
+
+	dma_unmap_page_attrs(pfvf->dev, iova, RCV_FRAG_LEN,
+			     DMA_FROM_DEVICE, DMA_ATTR_SKIP_CPU_SYNC);
+}
+
+static inline struct sk_buff *
+otx2_get_rcv_skb(struct otx2_nic *pfvf, u64 iova, int len, int apad)
+{
+	struct sk_buff *skb;
+	void *va;
+
+	iova -= OTX2_HEAD_ROOM;
+	va = phys_to_virt(otx2_iova_to_phys(pfvf->iommu_domain, iova));
+	skb = build_skb(va, RCV_FRAG_LEN);
+	if (!skb) {
+		put_page(virt_to_page(va));
+		return NULL;
+	}
+
+	skb_reserve(skb, apad + OTX2_HEAD_ROOM);
+	skb_put(skb, len);
+
+	dma_unmap_page_attrs(pfvf->dev, iova - apad, RCV_FRAG_LEN,
+			     DMA_FROM_DEVICE, DMA_ATTR_SKIP_CPU_SYNC);
+	prefetch(skb->data);
+	return skb;
+}
+
+static void otx2_rcv_pkt_handler(struct otx2_nic *pfvf,
+				 struct otx2_cq_queue *cq, void *cqe,
+				 int *pool_ptrs)
+{
+	struct nix_cqe_hdr_s *cqe_hdr = (struct nix_cqe_hdr_s *)cqe;
+	struct otx2_qset *qset = &pfvf->qset;
+	struct nix_rx_parse_s *parse;
+	struct sk_buff *skb = NULL;
+	struct nix_rx_sg_s *sg;
+	void *start, *end;
+	int seg, len;
+	u16 *sg_lens;
+	u64 *iova;
+
+	/* CQE_HDR_S for a Rx pkt is always followed by RX_PARSE_S */
+	parse = (struct nix_rx_parse_s *)(cqe + sizeof(*cqe_hdr));
+	/* Check for errors */
+	if (parse->errlev || parse->errcode) {
+		dev_info(pfvf->dev,
+			 "RQ%d: Error pkt received errlev %x errcode %x\n",
+			 cq->cint_idx, parse->errlev, parse->errcode);
+		return;
+	}
+
+	start = cqe + sizeof(*cqe_hdr) + sizeof(*parse);
+	end = start + ((parse->desc_sizem1 + 1) * 16);
+
+	/* Run through the each NIX_RX_SG_S subdc and frame the skb */
+	while ((start + sizeof(*sg)) < end) {
+		sg = (struct nix_rx_sg_s *)start;
+		/* For a 128byte size CQE, NIX_RX_IMM_S is never expected */
+		if (sg->subdc != NIX_SUBDC_SG) {
+			dev_err(pfvf->dev, "RQ%d: Unexpected SUBDC %d\n",
+				cq->cq_idx, sg->subdc);
+			break;
+		}
+
+		if (!sg->segs) {
+			dev_err(pfvf->dev, "RQ%d: Zero segments in NIX_RX_SG_S\n",
+				cq->cq_idx);
+			break;
+		}
+
+		sg_lens = (void *)sg;
+		iova = (void *)sg + sizeof(*sg);
+
+		for (seg = 0; seg < sg->segs; seg++) {
+			len = sg_lens[frag_num(seg)];
+			/* Starting IOVA's 2:0 bits give alignment
+			 * bytes after which packet data starts.
+			 */
+			if (!skb)
+				skb = otx2_get_rcv_skb(pfvf, *iova,
+						       len, *iova & 0x07);
+			else
+				otx2_skb_add_frag(pfvf, skb, *iova, len);
+			iova++;
+			(*pool_ptrs)++;
+		}
+
+		/* When SEGS = 1, only one IOVA is followed by NIX_RX_SG_S.
+		 * When SEGS >= 2, three IOVAs will follow NIX_RX_SG_S,
+		 * irrespective of whether 2 SEGS are valid or all 3.
+		 */
+		if (sg->segs == 1)
+			start += sizeof(*sg) + sizeof(u64);
+		else
+			start += sizeof(*sg) + (3 * sizeof(u64));
+	}
+
+	if (!skb)
+		return;
+
+	skb_record_rx_queue(skb, cq->cq_idx);
+	skb->protocol = eth_type_trans(skb, pfvf->netdev);
+
+	napi_gro_receive(&qset->napi[cq->cint_idx].napi, skb);
+}
+
 #define CQE_ADDR(CQ, idx) ((CQ)->cqe_base + ((CQ)->cqe_size * (idx)))
 
 static int otx2_napi_handler(struct otx2_cq_queue *cq, struct otx2_nic *pfvf,
 			     int budget)
 {
-	int processed_cqe = 0, cq_head, cq_tail;
+	struct otx2_pool *rbpool = cq->rbpool;
+	int processed_cqe = 0, workdone = 0;
+	int cq_head, cq_tail, pool_ptrs = 0;
 	struct nix_cqe_hdr_s *cqe_hdr;
-	int workdone = 0;
 	u64 cq_status;
+	s64 bufptr;
 
 	cq_status = otx2_nix_cq_op_status(pfvf, cq->cq_idx);
 	cq_head = (cq_status >> 20) & 0xFFFFF;
@@ -65,6 +194,7 @@ static int otx2_napi_handler(struct otx2_cq_queue *cq, struct otx2_nic *pfvf,
 		switch (cqe_hdr->cqe_type) {
 		case NIX_XQE_TYPE_RX:
 			/* Receive packet handler*/
+			otx2_rcv_pkt_handler(pfvf, cq, cqe_hdr, &pool_ptrs);
 			workdone++;
 			break;
 		}
@@ -74,6 +204,19 @@ static int otx2_napi_handler(struct otx2_cq_queue *cq, struct otx2_nic *pfvf,
 	otx2_write64(pfvf, NIX_LF_CQ_OP_DOOR,
 		     ((u64)cq->cq_idx << 32) | processed_cqe);
 
+	if (!pool_ptrs)
+		return 0;
+
+	/* Refill pool with new buffers */
+	while (pool_ptrs) {
+		bufptr = otx2_alloc_rbuf(pfvf, rbpool, GFP_ATOMIC);
+		if (bufptr <= 0)
+			break;
+		otx2_aura_freeptr(pfvf, cq->cq_idx, bufptr + OTX2_HEAD_ROOM);
+		pool_ptrs--;
+	}
+	otx2_get_page(rbpool);
+
 	return workdone;
 }
 
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_txrx.h b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_txrx.h
index 66c5e66c4071..deffaf881f13 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_txrx.h
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_txrx.h
@@ -11,9 +11,11 @@
 #ifndef OTX2_TXRX_H
 #define OTX2_TXRX_H
 
-#define LBK_CHAN_BASE  0x000
-#define SDP_CHAN_BASE  0x700
-#define CGX_CHAN_BASE  0x800
+#include <linux/iommu.h>
+
+#define LBK_CHAN_BASE	0x000
+#define SDP_CHAN_BASE	0x700
+#define CGX_CHAN_BASE	0x800
 
 #define DMA_BUFFER_LEN	1536 /* In multiples of 128bytes */
 #define OTX2_DATA_ALIGN(X)	ALIGN(X, OTX2_ALIGN)
@@ -62,5 +64,14 @@ struct otx2_qset {
 	struct otx2_cq_queue	*cq;
 };
 
+/* Translate IOVA to physical address */
+static inline u64 otx2_iova_to_phys(void *iommu_domain, dma_addr_t dma_addr)
+{
+	/* Translation is installed only when IOMMU is present */
+	if (iommu_domain)
+		return iommu_iova_to_phys(iommu_domain, dma_addr);
+	return dma_addr;
+}
+
 int otx2_poll(struct napi_struct *napi, int budget);
 #endif /* OTX2_TXRX_H */
-- 
2.31.1

