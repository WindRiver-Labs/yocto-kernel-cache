From 01275beaf6ef4fc15d12fcdd75564d6152941b46 Mon Sep 17 00:00:00 2001
From: Shijith Thotton <sthotton@marvell.com>
Date: Thu, 22 Oct 2020 13:43:15 +0530
Subject: [PATCH 0917/1921] octeontx2-af: enhance SSO FLR for CN10K

CN10K has support for event prefetching and scheduled LMTST. Prefetched
events should be flushed out during an FLR. No schedule feature is
discontinued from CN10K onwards.

Signed-off-by: Shijith Thotton <sthotton@marvell.com>
Change-Id: Ic13aa4711fd634a89a6d24eb8062a05058ec947f
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/kernel/linux/+/38571
Reviewed-by: Jerin Jacob Kollanukkaran <jerinj@marvell.com>
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Tested-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Signed-off-by: Sunil Goutham <sgoutham@marvell.com>
[WK: The original patch got from Marvell sdk11.21.09]
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 .../ethernet/marvell/octeontx2/af/rvu_reg.h   |  11 ++
 .../ethernet/marvell/octeontx2/af/rvu_sso.c   | 134 ++++++++++++++----
 2 files changed, 118 insertions(+), 27 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_reg.h b/drivers/net/ethernet/marvell/octeontx2/af/rvu_reg.h
index bf6a615ec768..50db2684295e 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_reg.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_reg.h
@@ -481,6 +481,7 @@
 #define SSO_AF_HWGRPX_TS_PC(a)		(0x200080 | (a) << 12)
 #define SSO_AF_HWGRPX_DS_PC(a)		(0x200090 | (a) << 12)
 #define SSO_AF_HWGRPX_DQ_PC(a)		(0x2000A0 | (a) << 12)
+#define SSO_AF_HWGRPX_LS_PC(a)		(0x2000C0 | (a) << 12)
 #define SSO_AF_HWGRPX_PAGE_CNT(a)	(0x200100 | (a) << 12)
 #define SSO_AF_IU_ACCNTX_CFG(a)		(0x50000 | (a) << 3)
 #define SSO_AF_IU_ACCNTX_RST(a)		(0x60000 | (a) << 3)
@@ -493,6 +494,7 @@
 #define SSO_AF_HWSX_ARB(a)		(0x400100 | (a) << 12)
 #define SSO_AF_HWSX_INV(a)		(0x400180 | (a) << 12)
 #define SSO_AF_HWSX_GMCTL(a)		(0x400200 | (a) << 12)
+#define SSO_AF_HWSX_LSW_CFG(a)		(0x400300 | (a) << 12)
 #define SSO_AF_HWSX_SX_GRPMSKX(a, b, c) \
 				(0x400400 | (a) << 12 | (b) << 5 | (c) << 3)
 #define SSO_AF_TAQX_LINK(a)		(0xc00000 | (a) << 3)
@@ -517,6 +519,8 @@
 #define SSO_AF_BFPN_DIGESTX(a)		(0x900400 | (a) << 3)
 #define SSO_AF_GRPDIS_DIGESTX(a)	(0x900600 | (a) << 3)
 
+#define SSO_AF_CONST1_NO_NSCHED		BIT_ULL(34)
+#define SSO_AF_CONST1_LSW		BIT_ULL(36)
 #define SSO_AF_IAQ_FREE_CNT_MASK	0x3FFFull
 #define SSO_AF_IAQ_RSVD_FREE_MASK	0x3FFFull
 #define SSO_AF_IAQ_RSVD_FREE_SHIFT	16
@@ -566,6 +570,7 @@
 
 #define SSO_HWGRP_AW_STS_TPTR_VLD	BIT_ULL(8)
 #define SSO_HWGRP_AW_STS_NPA_FETCH	BIT_ULL(9)
+#define SSO_HWGRP_AW_STS_TPTR_NEXT_VLD	BIT_ULL(10)
 #define SSO_HWGRP_AW_STS_XAQ_BUFSC_MASK	0x7ull
 #define SSO_HWGRP_AW_STS_INIT_STS	0x18ull
 
@@ -598,6 +603,7 @@
 #define SSOW_LF_GWS_INT_ENA_W1C		(0x118ull)
 #define SSOW_LF_GWS_TAG			(0x200ull)
 #define SSOW_LF_GWS_WQP			(0x210ull)
+#define SSOW_LF_GWS_PRF_TAG		(0x400ull)
 #define SSOW_LF_GWS_OP_GET_WORK		(0x600ull)
 #define SSOW_LF_GWS_OP_SWTAG_FLUSH	(0x800ull)
 #define SSOW_LF_GWS_OP_DESCHED		(0x880ull)
@@ -607,6 +613,11 @@
 #define SSO_TT_EMPTY			(0x3)
 #define SSOW_LF_GWS_INT_MASK		(0x7FF)
 #define SSOW_LF_GWS_MAX_NW_TIM		(BIT_ULL(10) - 1)
+#define SSOW_LF_GWS_OP_GET_WORK_WAIT	BIT_ULL(16)
+#define SSOW_LF_GWS_OP_GET_WORK_GROUPED	BIT_ULL(18)
+#define SSOW_LF_GWS_TAG_PEND_DESCHED	BIT_ULL(58)
+#define SSOW_LF_GWS_TAG_PEND_SWITCH	BIT_ULL(62)
+#define SSOW_LF_GWS_TAG_PEND_GET_WORK	BIT_ULL(63)
 
 /* TIM */
 #define TIM_AF_CONST			(0x90)
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_sso.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_sso.c
index 6380c4f0e381..156f9b5720ee 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_sso.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_sso.c
@@ -248,18 +248,81 @@ static void rvu_sso_ggrp_taq_flush(struct rvu *rvu, u16 pcifunc, int lf,
 	kfree(tim_lf);
 }
 
-int rvu_sso_lf_teardown(struct rvu *rvu, u16 pcifunc, int lf, int slot)
+static void rvu_sso_clean_nscheduled(struct rvu *rvu, int lf)
 {
-	int ssow_lf, iue, blkaddr, ssow_blkaddr, err;
 	struct sso_rsrc *sso = &rvu->hw->sso;
+	int blkaddr, ssow_blkaddr, iue;
+	u64 wqp, reg, op_clr_nsched;
+
+	blkaddr = rvu_get_blkaddr(rvu, BLKTYPE_SSO, 0);
+	ssow_blkaddr = rvu_get_blkaddr(rvu, BLKTYPE_SSOW, 0);
+	op_clr_nsched = (ssow_blkaddr << 28) |
+			SSOW_AF_BAR2_ALIASX(0, SSOW_LF_GWS_OP_CLR_NSCHED0);
+	for (iue = 0; iue < sso->sso_iue; iue++) {
+		reg = rvu_read64(rvu, blkaddr, SSO_AF_IENTX_GRP(iue));
+		if (SSO_AF_HWGRPX_IUEX_NOSCHED(lf, reg)) {
+			wqp = rvu_read64(rvu, blkaddr, SSO_AF_IENTX_WQP(iue));
+			rvu_sso_store_pair(wqp, iue,
+					   rvu->afreg_base + op_clr_nsched);
+		}
+	}
+}
+
+static void rvu_ssow_clean_prefetch(struct rvu *rvu, int slot)
+{
+	int ssow_blkaddr, err;
+	u64 val, reg;
+
+	ssow_blkaddr = rvu_get_blkaddr(rvu, BLKTYPE_SSOW, 0);
+	err = rvu_poll_reg(rvu, ssow_blkaddr,
+			   SSOW_AF_BAR2_ALIASX(slot, SSOW_LF_GWS_PRF_TAG),
+			   SSOW_LF_GWS_TAG_PEND_GET_WORK, true);
+	if (err)
+		dev_warn(rvu->dev,
+			 "SSOW_LF_GWS_PRF_TAG[PEND_GET_WORK] not cleared\n");
+
+	reg = rvu_read64(rvu, ssow_blkaddr,
+			 SSOW_AF_BAR2_ALIASX(slot, SSOW_LF_GWS_PRF_TAG));
+	if (((reg >> 32) & SSO_TT_EMPTY) != SSO_TT_EMPTY) {
+		val = slot; /* GGRP ID */
+		val |= SSOW_LF_GWS_OP_GET_WORK_GROUPED;
+		val |= SSOW_LF_GWS_OP_GET_WORK_WAIT;
+		rvu_write64(rvu, ssow_blkaddr,
+			    SSOW_AF_BAR2_ALIASX(slot, SSOW_LF_GWS_OP_GET_WORK),
+			    val);
+		err = rvu_poll_reg(rvu, ssow_blkaddr,
+				   SSOW_AF_BAR2_ALIASX(slot,
+						       SSOW_LF_GWS_PENDSTATE),
+				   SSOW_LF_GWS_TAG_PEND_GET_WORK, true);
+		if (err)
+			dev_warn(rvu->dev,
+				 "SSOW_LF_GWS_PENDSTATE[PEND_GET_WORK] not cleared\n");
+
+		rvu_write64(rvu, ssow_blkaddr,
+			    SSOW_AF_BAR2_ALIASX(slot,
+						SSOW_LF_GWS_OP_SWTAG_FLUSH),
+			    0x0);
+	}
+}
+
+int rvu_sso_lf_teardown(struct rvu *rvu, u16 pcifunc, int lf, int slot)
+{
+	int ssow_lf, blkaddr, ssow_blkaddr, err;
+	bool has_prefetch, has_nsched, has_lsw;
 	struct rvu_hwinfo *hw = rvu->hw;
 	u64 aq_cnt, ds_cnt, cq_ds_cnt;
-	u64 reg, add, wqp, val;
+	u64 reg, add, val;
 
 	blkaddr = rvu_get_blkaddr(rvu, BLKTYPE_SSO, 0);
 	if (blkaddr < 0)
 		return SSO_AF_ERR_LF_INVALID;
 
+	/* Read hardware capabilities */
+	reg = rvu_read64(rvu, blkaddr, SSO_AF_CONST1);
+	has_lsw = reg & SSO_AF_CONST1_LSW;
+	has_nsched = !(reg & SSO_AF_CONST1_NO_NSCHED);
+	has_prefetch = is_rvu_otx2(rvu) ? 0 : 1;
+
 	/* Enable BAR2 ALIAS for this pcifunc. */
 	reg = BIT_ULL(16) | pcifunc;
 	rvu_write64(rvu, blkaddr, SSO_AF_BAR2_SEL, reg);
@@ -295,13 +358,16 @@ int rvu_sso_lf_teardown(struct rvu *rvu, u16 pcifunc, int lf, int slot)
 		    SSOW_AF_BAR2_ALIASX(0, SSOW_LF_GWS_INT),
 		    SSOW_LF_GWS_INT_MASK);
 
+	if (has_lsw)
+		rvu_write64(rvu, blkaddr, SSO_AF_HWSX_LSW_CFG(lf), 0x0);
+
 	/* Prepare WS for GW operations. */
 	rvu_poll_reg(rvu, ssow_blkaddr, SSOW_AF_BAR2_ALIASX(0, SSOW_LF_GWS_TAG),
-		     BIT_ULL(63), true);
+		     SSOW_LF_GWS_TAG_PEND_GET_WORK, true);
 
 	reg = rvu_read64(rvu, ssow_blkaddr,
 			 SSOW_AF_BAR2_ALIASX(0, SSOW_LF_GWS_TAG));
-	if (reg & BIT_ULL(62))
+	if (reg & SSOW_LF_GWS_TAG_PEND_SWITCH)
 		rvu_write64(rvu, ssow_blkaddr,
 			    SSOW_AF_BAR2_ALIASX(0, SSOW_LF_GWS_OP_DESCHED), 0);
 	else if (((reg >> 32) & SSO_TT_EMPTY) != SSO_TT_EMPTY)
@@ -311,6 +377,12 @@ int rvu_sso_lf_teardown(struct rvu *rvu, u16 pcifunc, int lf, int slot)
 
 	rvu_write64(rvu, ssow_blkaddr,
 		    SSOW_AF_BAR2_ALIASX(0, SSOW_LF_GWS_OP_GWC_INVAL), 0);
+	rvu_write64(rvu, ssow_blkaddr,
+		    SSOW_AF_BAR2_ALIASX(0, SSOW_LF_GWS_NW_TIM),
+		    SSOW_LF_GWS_MAX_NW_TIM);
+
+	if (has_prefetch)
+		rvu_ssow_clean_prefetch(rvu, slot);
 
 	/* Disable add work. */
 	rvu_write64(rvu, blkaddr, SSO_AF_BAR2_ALIASX(slot, SSO_LF_GGRP_QCTL),
@@ -318,16 +390,8 @@ int rvu_sso_lf_teardown(struct rvu *rvu, u16 pcifunc, int lf, int slot)
 
 	/* HRM 14.13.4 (4) */
 	/* Clean up nscheduled IENT let the work flow. */
-	for (iue = 0; iue < sso->sso_iue; iue++) {
-		reg = rvu_read64(rvu, blkaddr, SSO_AF_IENTX_GRP(iue));
-		if (SSO_AF_HWGRPX_IUEX_NOSCHED(lf, reg)) {
-			wqp = rvu_read64(rvu, blkaddr, SSO_AF_IENTX_WQP(iue));
-			rvu_sso_store_pair(wqp, iue, rvu->afreg_base +
-					   ((ssow_blkaddr << 28) |
-					    SSOW_AF_BAR2_ALIASX(0,
-						  SSOW_LF_GWS_OP_CLR_NSCHED0)));
-		}
-	}
+	if (has_nsched)
+		rvu_sso_clean_nscheduled(rvu, lf);
 
 	/* HRM 14.13.4 (6) */
 	/* Drain all the work using grouped gw. */
@@ -339,13 +403,9 @@ int rvu_sso_lf_teardown(struct rvu *rvu, u16 pcifunc, int lf, int slot)
 			       SSO_AF_BAR2_ALIASX(slot, SSO_LF_GGRP_INT_CNT));
 	cq_ds_cnt &= SSO_LF_GGRP_INT_CNT_MASK;
 
-	val  = slot;		/* GGRP ID */
-	val |= BIT_ULL(18);	/* Grouped */
-	val |= BIT_ULL(16);	/* WAIT */
-
-	rvu_write64(rvu, ssow_blkaddr,
-		    SSOW_AF_BAR2_ALIASX(0, SSOW_LF_GWS_NW_TIM),
-		    SSOW_LF_GWS_MAX_NW_TIM);
+	val  = slot; /* GGRP ID */
+	val |= SSOW_LF_GWS_OP_GET_WORK_GROUPED;
+	val |= SSOW_LF_GWS_OP_GET_WORK_WAIT;
 
 	while (aq_cnt || cq_ds_cnt || ds_cnt) {
 		rvu_write64(rvu, ssow_blkaddr,
@@ -355,7 +415,7 @@ int rvu_sso_lf_teardown(struct rvu *rvu, u16 pcifunc, int lf, int slot)
 			reg = rvu_read64(rvu, ssow_blkaddr,
 					 SSOW_AF_BAR2_ALIASX(0,
 							     SSOW_LF_GWS_TAG));
-		} while (reg & BIT_ULL(63));
+		} while (reg & SSOW_LF_GWS_TAG_PEND_GET_WORK);
 		if (((reg >> 32) & SSO_TT_EMPTY) != SSO_TT_EMPTY)
 			rvu_write64(rvu, ssow_blkaddr,
 				    SSOW_AF_BAR2_ALIASX(0,
@@ -419,6 +479,10 @@ int rvu_sso_lf_teardown(struct rvu *rvu, u16 pcifunc, int lf, int slot)
 	if ((reg & 0xFFF) == pcifunc)
 		rvu_write64(rvu, blkaddr, SSO_AF_ERR2, SSO_AF_ERR2_MASK);
 
+	reg = rvu_read64(rvu, blkaddr, SSO_AF_UNMAP_INFO3);
+	if ((reg & 0xFFF) == pcifunc)
+		rvu_write64(rvu, blkaddr, SSO_AF_ERR2, SSO_AF_ERR2_MASK);
+
 	rvu_write64(rvu, blkaddr, SSO_AF_POISONX(lf / 64), lf % 64);
 	rvu_write64(rvu, blkaddr, SSO_AF_IU_ACCNTX_RST(lf), 0x1);
 
@@ -433,7 +497,13 @@ int rvu_sso_lf_teardown(struct rvu *rvu, u16 pcifunc, int lf, int slot)
 	reg = rvu_read64(rvu, blkaddr, SSO_AF_HWGRPX_AW_CFG(lf));
 	reg = (reg & ~SSO_HWGRP_AW_CFG_RWEN) | SSO_HWGRP_AW_CFG_XAQ_BYP_DIS;
 	rvu_write64(rvu, blkaddr, SSO_AF_HWGRPX_AW_CFG(lf), reg);
-
+	if (has_prefetch) {
+		reg = rvu_read64(rvu, blkaddr, SSO_AF_HWGRPX_AW_STATUS(lf));
+		if (reg & SSO_HWGRP_AW_STS_TPTR_NEXT_VLD) {
+			rvu_write64(rvu, blkaddr, SSO_AF_HWGRPX_AW_STATUS(lf),
+				    SSO_HWGRP_AW_STS_TPTR_NEXT_VLD);
+		}
+	}
 	reg = rvu_read64(rvu, blkaddr, SSO_AF_HWGRPX_AW_STATUS(lf));
 	if (reg & SSO_HWGRP_AW_STS_TPTR_VLD) {
 		/* aura will be torn down, no need to free the pointer. */
@@ -470,6 +540,8 @@ int rvu_sso_lf_teardown(struct rvu *rvu, u16 pcifunc, int lf, int slot)
 	rvu_write64(rvu, blkaddr, SSO_AF_HWGRPX_WA_PC(lf), 0x0);
 	rvu_write64(rvu, blkaddr, SSO_AF_HWGRPX_TS_PC(lf), 0x0);
 	rvu_write64(rvu, blkaddr, SSO_AF_HWGRPX_DS_PC(lf), 0x0);
+	if (has_lsw)
+		rvu_write64(rvu, blkaddr, SSO_AF_HWGRPX_LS_PC(lf), 0x0);
 	rvu_write64(rvu, blkaddr, SSO_AF_HWGRPX_XAQ_LIMIT(lf), 0x0);
 	rvu_write64(rvu, blkaddr, SSO_AF_HWGRPX_IU_ACCNT(lf), 0x0);
 
@@ -513,6 +585,7 @@ int rvu_ssow_lf_teardown(struct rvu *rvu, u16 pcifunc, int lf, int slot)
 {
 	struct sso_rsrc *sso = &rvu->hw->sso;
 	int blkaddr, ssow_blkaddr;
+	bool has_prefetch;
 	u64 reg, grpmsk;
 
 	blkaddr = rvu_get_blkaddr(rvu, BLKTYPE_SSO, 0);
@@ -523,6 +596,9 @@ int rvu_ssow_lf_teardown(struct rvu *rvu, u16 pcifunc, int lf, int slot)
 	if (ssow_blkaddr < 0)
 		return SSOW_AF_ERR_LF_INVALID;
 
+	/* Read hardware capabilities */
+	has_prefetch = is_rvu_otx2(rvu) ? 0 : 1;
+
 	/* Enable BAR2 alias access. */
 	reg = BIT_ULL(16) | pcifunc;
 	rvu_write64(rvu, ssow_blkaddr, SSOW_AF_BAR2_SEL, reg);
@@ -539,12 +615,13 @@ int rvu_ssow_lf_teardown(struct rvu *rvu, u16 pcifunc, int lf, int slot)
 	/* Wait till waitw/desched completes. */
 	rvu_poll_reg(rvu, ssow_blkaddr,
 		     SSOW_AF_BAR2_ALIASX(slot, SSOW_LF_GWS_PENDSTATE),
-		     BIT_ULL(63) | BIT_ULL(58), true);
+		     SSOW_LF_GWS_TAG_PEND_GET_WORK |
+		     SSOW_LF_GWS_TAG_PEND_DESCHED, true);
 
 	reg = rvu_read64(rvu, ssow_blkaddr,
 			 SSOW_AF_BAR2_ALIASX(slot, SSOW_LF_GWS_TAG));
 	/* Switch Tag Pending */
-	if (reg & BIT_ULL(62))
+	if (reg & SSOW_LF_GWS_TAG_PEND_SWITCH)
 		rvu_write64(rvu, ssow_blkaddr,
 			    SSOW_AF_BAR2_ALIASX(slot, SSOW_LF_GWS_OP_DESCHED),
 			    0x0);
@@ -558,7 +635,10 @@ int rvu_ssow_lf_teardown(struct rvu *rvu, u16 pcifunc, int lf, int slot)
 	/* Wait for desched to complete. */
 	rvu_poll_reg(rvu, ssow_blkaddr,
 		     SSOW_AF_BAR2_ALIASX(slot, SSOW_LF_GWS_PENDSTATE),
-		     BIT_ULL(58), true);
+		     SSOW_LF_GWS_TAG_PEND_DESCHED, true);
+
+	if (has_prefetch)
+		rvu_ssow_clean_prefetch(rvu, slot);
 
 	rvu_write64(rvu, ssow_blkaddr,
 		    SSOW_AF_BAR2_ALIASX(0, SSOW_LF_GWS_NW_TIM), 0x0);
-- 
2.31.1

