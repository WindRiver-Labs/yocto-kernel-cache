From 289e81723ab7146244e133304d980d8d7dd0d675 Mon Sep 17 00:00:00 2001
From: Linu Cherian <lcherian@marvell.com>
Date: Thu, 13 Dec 2018 19:27:00 +0530
Subject: [PATCH 027/767] octeontx2-af: Get PF macaddress from firmware

commit 54680c2a05bc3cf149d5df13cc21469f45649722 from
git@git.assembla.com:cavium/WindRiver.linux.git

- Support for getting macaddress from firmware through cgx fw interface
- Initialize all cgx mapped PFs with macaddress obtained from
  firmware

Change-Id: I6254cf0a1e4a1c3190654678b63f89f873171a78
Signed-off-by: Linu Cherian <lcherian@marvell.com>
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../net/ethernet/marvell/octeontx2/af/cgx.c   | 29 +++++++++++++++++++
 .../net/ethernet/marvell/octeontx2/af/cgx.h   |  1 +
 .../ethernet/marvell/octeontx2/af/rvu_cgx.c   |  6 ++++
 3 files changed, 36 insertions(+)

diff --git a/drivers/net/ethernet/marvell/octeontx2/af/cgx.c b/drivers/net/ethernet/marvell/octeontx2/af/cgx.c
index 569f7532a5b8..9b4cb17f186b 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/cgx.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/cgx.c
@@ -72,6 +72,7 @@ static char *cgx_lmactype_string[LMAC_MODE_MAX];
 
 /* CGX PHY management internal APIs */
 static int cgx_fwi_link_change(struct cgx *cgx, int lmac_id, bool en);
+static int cgx_fwi_get_macaddr(struct cgx *cgx, int lmac_id, u8 *dst);
 
 /* Supported devices */
 static const struct pci_device_id cgx_id_table[] = {
@@ -197,6 +198,18 @@ u64 cgx_lmac_addr_get(u8 cgx_id, u8 lmac_id)
 }
 EXPORT_SYMBOL(cgx_lmac_addr_get);
 
+/* Gets mac address from firmware for each cgx mapped PF */
+int cgx_get_pfmacaddr(void *cgxd, u8 lmac_id, u8 *macdst)
+{
+	struct cgx *cgx = cgxd;
+
+	if (!cgx || lmac_id >= cgx->lmac_count)
+		return -ENODEV;
+
+	return cgx_fwi_get_macaddr(cgx, lmac_id, macdst);
+}
+EXPORT_SYMBOL(cgx_get_pfmacaddr);
+
 int cgx_set_pkind(void *cgxd, u8 lmac_id, int pkind)
 {
 	struct cgx *cgx = cgxd;
@@ -637,6 +650,22 @@ int cgx_lmac_evh_unregister(void *cgxd, int lmac_id)
 }
 EXPORT_SYMBOL(cgx_lmac_evh_unregister);
 
+static int cgx_fwi_get_macaddr(struct cgx *cgx, int lmac_id, u8 *dst)
+{
+	u64 req = 0, resp, mac;
+	int err;
+
+	req = FIELD_SET(CMDREG_ID, CGX_CMD_GET_MAC_ADDR, req);
+
+	err = cgx_fwi_cmd_generic(req, &resp, cgx, lmac_id);
+	if (!err) {
+		mac = FIELD_GET(RESP_MAC_ADDR, resp);
+		memcpy(dst, (u8 *)&mac, 6);
+	}
+
+	return err;
+}
+
 static int cgx_fwi_link_change(struct cgx *cgx, int lmac_id, bool enable)
 {
 	u64 req = 0;
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/cgx.h b/drivers/net/ethernet/marvell/octeontx2/af/cgx.h
index 206dc5dc1df8..3d70be102f06 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/cgx.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/cgx.h
@@ -106,6 +106,7 @@ int cgx_get_rx_stats(void *cgxd, int lmac_id, int idx, u64 *rx_stat);
 int cgx_lmac_rx_tx_enable(void *cgxd, int lmac_id, bool enable);
 int cgx_lmac_addr_set(u8 cgx_id, u8 lmac_id, u8 *mac_addr);
 u64 cgx_lmac_addr_get(u8 cgx_id, u8 lmac_id);
+int cgx_get_pfmacaddr(void *cgxd, u8 lmac_id, u8 *macdst);
 void cgx_lmac_promisc_config(int cgx_id, int lmac_id, bool enable);
 int cgx_lmac_internal_loopback(void *cgxd, int lmac_id, bool enable);
 int cgx_get_link_info(void *cgxd, int lmac_id,
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_cgx.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_cgx.c
index a5dc8445a117..ccd9cbe6593b 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_cgx.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_cgx.c
@@ -99,6 +99,12 @@ static int rvu_map_cgx_lmac_pf(struct rvu *rvu)
 		for (lmac = 0; lmac < lmac_cnt; lmac++, pf++) {
 			rvu->pf2cgxlmac_map[pf] = cgxlmac_id_to_bmap(cgx, lmac);
 			rvu->cgxlmac2pf_map[CGX_OFFSET(cgx) + lmac] = 1 << pf;
+			/* Get mac address for the CGX mapped PF */
+			if (cgx_get_pfmacaddr(rvu_cgx_pdata(cgx, rvu), lmac,
+					  rvu->pf[pf].mac_addr))
+				dev_dbg(rvu->dev,
+					"pf %d: Failed to get MAC from firmware\n",
+					pf);
 			free_pkind = rvu_alloc_rsrc(&pkind->rsrc);
 			pkind->pfchan_map[free_pkind] = ((pf) & 0x3F) << 16;
 			rvu->cgx_mapped_pfs++;
-- 
2.31.1

