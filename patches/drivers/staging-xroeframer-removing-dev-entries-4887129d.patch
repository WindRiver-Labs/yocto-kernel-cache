From c5b7781bea20f66824162407a132844244fd8c73 Mon Sep 17 00:00:00 2001
From: Vasileios Bimpikas <vasileios.bimpikas@xilinx.com>
Date: Thu, 24 Jan 2019 10:13:11 +0000
Subject: [PATCH 1160/1851] staging: xroeframer: removing /dev/ entries

commit f47f1af61c35a77215b14a23f6a305b172dcf458 from
https://github.com/Xilinx/linux-xlnx.git

This commit removes /dev/xroe/stats & /dev/xroe/radio_ctrl as they have
been converted to sysfs entries & separate driver, respectively.

Signed-off-by: Vasileios Bimpikas <vasileios.bimpikas@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
State: not-upstreamable
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 drivers/staging/xroeframer/roe_radio_ctrl.h | 183 --------
 drivers/staging/xroeframer/xroe_framer.c    | 471 +-------------------
 drivers/staging/xroeframer/xroe_framer.h    |  14 +-
 3 files changed, 7 insertions(+), 661 deletions(-)
 delete mode 100644 drivers/staging/xroeframer/roe_radio_ctrl.h

diff --git a/drivers/staging/xroeframer/roe_radio_ctrl.h b/drivers/staging/xroeframer/roe_radio_ctrl.h
deleted file mode 100644
index bdf09d3e9e91..000000000000
--- a/drivers/staging/xroeframer/roe_radio_ctrl.h
+++ /dev/null
@@ -1,183 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Copyright (C) 2018 Xilinx, Inc.
- *
- * Vasileios Bimpikas <vasileios.bimpikas@xilinx.com>
- */
-/*-----------------------------------------------------------------------------
- * C Header bank BASE definitions
- *-----------------------------------------------------------------------------
- */
-#define ROE_RADIO_CFG_BASE_ADDR 0x0 /* 0 */
-#define ROE_RADIO_SOURCE_BASE_ADDR 0x4096 /* 4096 */
-
-/*-----------------------------------------------------------------------------
- * C Header bank register definitions for bank roe_radio_cfg
- * with prefix cfg_ @ address 0x0
- *-----------------------------------------------------------------------------
- */
-/* Type = roInt */
-#define CFG_RADIO_ID_ADDR 0x0 /* 0 */
-#define CFG_RADIO_ID_MASK 0x4294967295 /* 4294967295 */
-#define CFG_RADIO_ID_OFFSET 0x0 /* 0 */
-#define CFG_RADIO_ID_WIDTH 0x32 /* 32 */
-#define CFG_RADIO_ID_DEFAULT 0x1179649 /* 1179649 */
-
-/* Type = rw */
-#define CFG_TIMEOUT_ENABLE_ADDR 0x4 /* 4 */
-#define CFG_TIMEOUT_ENABLE_MASK 0x1 /* 1 */
-#define CFG_TIMEOUT_ENABLE_OFFSET 0x0 /* 0 */
-#define CFG_TIMEOUT_ENABLE_WIDTH 0x1 /* 1 */
-#define CFG_TIMEOUT_ENABLE_DEFAULT 0x0 /* 0 */
-
-/* Type = ro */
-#define CFG_TIMEOUT_STATUS_ADDR 0x8 /* 8 */
-#define CFG_TIMEOUT_STATUS_MASK 0x1 /* 1 */
-#define CFG_TIMEOUT_STATUS_OFFSET 0x0 /* 0 */
-#define CFG_TIMEOUT_STATUS_WIDTH 0x1 /* 1 */
-#define CFG_TIMEOUT_STATUS_DEFAULT 0x1 /* 1 */
-
-/* Type = rw */
-#define CFG_TIMEOUT_VALUE_ADDR 0x12 /* 12 */
-#define CFG_TIMEOUT_VALUE_MASK 0x4095 /* 4095 */
-#define CFG_TIMEOUT_VALUE_OFFSET 0x0 /* 0 */
-#define CFG_TIMEOUT_VALUE_WIDTH 0x12 /* 12 */
-#define CFG_TIMEOUT_VALUE_DEFAULT 0x128 /* 128 */
-
-/* Type = rw */
-#define CFG_GPIO_CDC_LEDMODE2_ADDR 0x16 /* 16 */
-#define CFG_GPIO_CDC_LEDMODE2_MASK 0x1 /* 1 */
-#define CFG_GPIO_CDC_LEDMODE2_OFFSET 0x0 /* 0 */
-#define CFG_GPIO_CDC_LEDMODE2_WIDTH 0x1 /* 1 */
-#define CFG_GPIO_CDC_LEDMODE2_DEFAULT 0x0 /* 0 */
-
-/* Type = rw */
-#define CFG_GPIO_CDC_LEDGPIO_ADDR 0x16 /* 16 */
-#define CFG_GPIO_CDC_LEDGPIO_MASK 0x48 /* 48 */
-#define CFG_GPIO_CDC_LEDGPIO_OFFSET 0x4 /* 4 */
-#define CFG_GPIO_CDC_LEDGPIO_WIDTH 0x2 /* 2 */
-#define CFG_GPIO_CDC_LEDGPIO_DEFAULT 0x0 /* 0 */
-
-/* Type = roSig */
-#define CFG_GPIO_CDC_DIPSTATUS_ADDR 0x20 /* 20 */
-#define CFG_GPIO_CDC_DIPSTATUS_MASK 0x255 /* 255 */
-#define CFG_GPIO_CDC_DIPSTATUS_OFFSET 0x0 /* 0 */
-#define CFG_GPIO_CDC_DIPSTATUS_WIDTH 0x8 /* 8 */
-#define CFG_GPIO_CDC_DIPSTATUS_DEFAULT 0x0 /* 0 */
-
-/* Type = wPlsH */
-#define CFG_SW_TRIGGER_ADDR 0x32 /* 32 */
-#define CFG_SW_TRIGGER_MASK 0x1 /* 1 */
-#define CFG_SW_TRIGGER_OFFSET 0x0 /* 0 */
-#define CFG_SW_TRIGGER_WIDTH 0x1 /* 1 */
-#define CFG_SW_TRIGGER_DEFAULT 0x0 /* 0 */
-
-/* Type = rw */
-#define CFG_RADIO_CDC_ENABLE_ADDR 0x36 /* 36 */
-#define CFG_RADIO_CDC_ENABLE_MASK 0x1 /* 1 */
-#define CFG_RADIO_CDC_ENABLE_OFFSET 0x0 /* 0 */
-#define CFG_RADIO_CDC_ENABLE_WIDTH 0x1 /* 1 */
-#define CFG_RADIO_CDC_ENABLE_DEFAULT 0x0 /* 0 */
-
-/* Type = roSig */
-#define CFG_RADIO_CDC_ERROR_ADDR 0x36 /* 36 */
-#define CFG_RADIO_CDC_ERROR_MASK 0x2 /* 2 */
-#define CFG_RADIO_CDC_ERROR_OFFSET 0x1 /* 1 */
-#define CFG_RADIO_CDC_ERROR_WIDTH 0x1 /* 1 */
-#define CFG_RADIO_CDC_ERROR_DEFAULT 0x0 /* 0 */
-
-/* Type = roSig */
-#define CFG_RADIO_CDC_STATUS_ADDR 0x36 /* 36 */
-#define CFG_RADIO_CDC_STATUS_MASK 0x4 /* 4 */
-#define CFG_RADIO_CDC_STATUS_OFFSET 0x2 /* 2 */
-#define CFG_RADIO_CDC_STATUS_WIDTH 0x1 /* 1 */
-#define CFG_RADIO_CDC_STATUS_DEFAULT 0x0 /* 0 */
-
-/* Type = rw */
-#define CFG_RADIO_CDC_LOOPBACK_ADDR 0x40 /* 40 */
-#define CFG_RADIO_CDC_LOOPBACK_MASK 0x1 /* 1 */
-#define CFG_RADIO_CDC_LOOPBACK_OFFSET 0x0 /* 0 */
-#define CFG_RADIO_CDC_LOOPBACK_WIDTH 0x1 /* 1 */
-#define CFG_RADIO_CDC_LOOPBACK_DEFAULT 0x0 /* 0 */
-
-/* Type = rw */
-#define CFG_RADIO_SINK_ENABLE_ADDR 0x44 /* 44 */
-#define CFG_RADIO_SINK_ENABLE_MASK 0x1 /* 1 */
-#define CFG_RADIO_SINK_ENABLE_OFFSET 0x0 /* 0 */
-#define CFG_RADIO_SINK_ENABLE_WIDTH 0x1 /* 1 */
-#define CFG_RADIO_SINK_ENABLE_DEFAULT 0x1 /* 1 */
-
-/* Type = roSig */
-#define CFG_RADIO_CDC_ERROR_31_0_ADDR 0x48 /* 48 */
-#define CFG_RADIO_CDC_ERROR_31_0_MASK 0x4294967295 /* 4294967295 */
-#define CFG_RADIO_CDC_ERROR_31_0_OFFSET 0x0 /* 0 */
-#define CFG_RADIO_CDC_ERROR_31_0_WIDTH 0x32 /* 32 */
-#define CFG_RADIO_CDC_ERROR_31_0_DEFAULT 0x0 /* 0 */
-
-/* Type = roSig */
-#define CFG_RADIO_CDC_ERROR_63_32_ADDR 0x52 /* 52 */
-#define CFG_RADIO_CDC_ERROR_63_32_MASK 0x4294967295 /* 4294967295 */
-#define CFG_RADIO_CDC_ERROR_63_32_OFFSET 0x0 /* 0 */
-#define CFG_RADIO_CDC_ERROR_63_32_WIDTH 0x32 /* 32 */
-#define CFG_RADIO_CDC_ERROR_63_32_DEFAULT 0x0 /* 0 */
-
-/* Type = roSig */
-#define CFG_RADIO_CDC_ERROR_95_64_ADDR 0x56 /* 56 */
-#define CFG_RADIO_CDC_ERROR_95_64_MASK 0x4294967295 /* 4294967295 */
-#define CFG_RADIO_CDC_ERROR_95_64_OFFSET 0x0 /* 0 */
-#define CFG_RADIO_CDC_ERROR_95_64_WIDTH 0x32 /* 32 */
-#define CFG_RADIO_CDC_ERROR_95_64_DEFAULT 0x0 /* 0 */
-
-/* Type = roSig */
-#define CFG_RADIO_CDC_ERROR_127_96_ADDR 0x60 /* 60 */
-#define CFG_RADIO_CDC_ERROR_127_96_MASK 0x4294967295 /* 4294967295 */
-#define CFG_RADIO_CDC_ERROR_127_96_OFFSET 0x0 /* 0 */
-#define CFG_RADIO_CDC_ERROR_127_96_WIDTH 0x32 /* 32 */
-#define CFG_RADIO_CDC_ERROR_127_96_DEFAULT 0x0 /* 0 */
-
-/* Type = roSig */
-#define CFG_RADIO_CDC_STATUS_31_0_ADDR 0x64 /* 64 */
-#define CFG_RADIO_CDC_STATUS_31_0_MASK 0x4294967295 /* 4294967295 */
-#define CFG_RADIO_CDC_STATUS_31_0_OFFSET 0x0 /* 0 */
-#define CFG_RADIO_CDC_STATUS_31_0_WIDTH 0x32 /* 32 */
-#define CFG_RADIO_CDC_STATUS_31_0_DEFAULT 0x0 /* 0 */
-
-/* Type = roSig */
-#define CFG_RADIO_CDC_STATUS_63_32_ADDR 0x68 /* 68 */
-#define CFG_RADIO_CDC_STATUS_63_32_MASK 0x4294967295 /* 4294967295 */
-#define CFG_RADIO_CDC_STATUS_63_32_OFFSET 0x0 /* 0 */
-#define CFG_RADIO_CDC_STATUS_63_32_WIDTH 0x32 /* 32 */
-#define CFG_RADIO_CDC_STATUS_63_32_DEFAULT 0x0 /* 0 */
-
-/* Type = roSig */
-#define CFG_RADIO_CDC_STATUS_95_64_ADDR 0x72 /* 72 */
-#define CFG_RADIO_CDC_STATUS_95_64_MASK 0x4294967295 /* 4294967295 */
-#define CFG_RADIO_CDC_STATUS_95_64_OFFSET 0x0 /* 0 */
-#define CFG_RADIO_CDC_STATUS_95_64_WIDTH 0x32 /* 32 */
-#define CFG_RADIO_CDC_STATUS_95_64_DEFAULT 0x0 /* 0 */
-
-/* Type = roSig */
-#define CFG_RADIO_CDC_STATUS_127_96_ADDR 0x76 /* 76 */
-#define CFG_RADIO_CDC_STATUS_127_96_MASK 0x4294967295 /* 4294967295 */
-#define CFG_RADIO_CDC_STATUS_127_96_OFFSET 0x0 /* 0 */
-#define CFG_RADIO_CDC_STATUS_127_96_WIDTH 0x32 /* 32 */
-#define CFG_RADIO_CDC_STATUS_127_96_DEFAULT 0x0 /* 0 */
-
-/*-----------------------------------------------------------------------------
- * C Header bank register definitions for bank roe_radio_source
- * with prefix fram_ @ address 0x1000
- *-----------------------------------------------------------------------------
- */
-/* Type = rwpdef */
-#define FRAM_PACKET_SIZE_ADDR 0x4096 /* 4096 */
-#define FRAM_PACKET_SIZE_MASK 0x65535 /* 65535 */
-#define FRAM_PACKET_SIZE_OFFSET 0x0 /* 0 */
-#define FRAM_PACKET_SIZE_WIDTH 0x16 /* 16 */
-#define FRAM_PACKET_SIZE_DEFAULT 0x0 /* 0 */
-
-/* Type = rwpdef */
-#define FRAM_PAUSE_SIZE_ADDR 0x4100 /* 4100 */
-#define FRAM_PAUSE_SIZE_MASK 0x255 /* 255 */
-#define FRAM_PAUSE_SIZE_OFFSET 0x0 /* 0 */
-#define FRAM_PAUSE_SIZE_WIDTH 0x8 /* 8 */
-#define FRAM_PAUSE_SIZE_DEFAULT 0x0 /* 0 */
diff --git a/drivers/staging/xroeframer/xroe_framer.c b/drivers/staging/xroeframer/xroe_framer.c
index dff42e0f99ed..dba7c69b010f 100644
--- a/drivers/staging/xroeframer/xroe_framer.c
+++ b/drivers/staging/xroeframer/xroe_framer.c
@@ -21,28 +21,13 @@
 #include "xroe_framer.h"
 
 #define DRIVER_NAME "framer"
-/* IOCTL commands */
-/* Use 0xF5 as magic number */
-#define XROE_FRAMER_MAGIC_NUMBER	0xF5
-#define XROE_FRAMER_IOSET		_IOW(XROE_FRAMER_MAGIC_NUMBER, 0, u32)
-#define XROE_FRAMER_IOGET		_IOR(XROE_FRAMER_MAGIC_NUMBER, 1, u32)
 
-static dev_t first, second, third;
-static struct cdev c_dev, stats_dev, radio_ctrl_dev;
-static struct class *cl;
 /*
  * TODO: to be made static as well, so that multiple instances can be used. As
  * of now, the "lp" structure is shared among the multiple source files
  */
 struct framer_local *lp;
-static void __iomem *radio_ctrl;
 static struct platform_driver framer_driver;
-/* TODO: to be removed from the header file and resort that main file
- * not to need them. Also swap const and static.
- */
-const static struct file_operations framer_fops;
-const static struct file_operations stats_ops;
-const static struct file_operations radio_ctrl_fops;
 /*
  * TODO: placeholder for the IRQ once it's been implemented
  * in the framer block
@@ -66,130 +51,20 @@ static int framer_probe(struct platform_device *pdev)
 	struct resource *r_mem; /* IO mem resources */
 	struct resource *r_irq;
 	struct device *dev = &pdev->dev;
-	struct device *parent_xroe_device = NULL;
-	struct device *stats_device = NULL;
-	struct device *radio_ctrl_device = NULL;
 	int rc = 0;
 
 	dev_dbg(dev, "Device Tree Probing\n");
-	/* Get iospace for the device */
-	/*
-	 * TODO: Use platform_get_resource_byname() instead when the DT entry
-	 * of the framer block has been finalised (when framer gets out of
-	 * the development stage).
-	 */
-	r_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!r_mem) {
-		dev_err(dev, "invalid address\n");
-		return -ENODEV;
-	}
-
 	lp = devm_kzalloc(&pdev->dev, sizeof(*lp), GFP_KERNEL);
 	if (!lp)
 		return -ENOMEM;
 
-	dev_set_drvdata(dev, lp);
-	lp->mem_start = r_mem->start;
-	lp->mem_end = r_mem->end;
-
-	if (!devm_request_mem_region(dev, lp->mem_start,
-				     lp->mem_end - lp->mem_start + 1,
-				     DRIVER_NAME)) {
-		dev_err(dev, "Couldn't lock memory region at %p\n",
-			(void *)lp->mem_start);
-		return -EBUSY;
-	}
-
-	lp->base_addr = devm_ioremap(dev,
-				     lp->mem_start,
-				     lp->mem_end - lp->mem_start + 1);
-	if (!lp->base_addr) {
-		dev_err(dev, "framer: Could not allocate iomem\n");
-		return -EIO;
-	}
-	rc = alloc_chrdev_region(&first, 0, 1, "xroe");
-	if (rc < 0) {
-		pr_err("Allocating XROE framer failed\n");
-		return rc;
-	}
-	cl = class_create(THIS_MODULE, "chardrv");
-	if (IS_ERR(cl)) {
-		pr_err("Class create failed\n");
-		unregister_chrdev_region(first, 1);
-		return PTR_ERR(cl);
-	}
-	parent_xroe_device = device_create(cl, NULL, first, NULL, "xroe!ip");
-	if (IS_ERR(parent_xroe_device)) {
-		pr_err("Device create failed\n");
-		class_destroy(cl);
-		unregister_chrdev_region(first, 1);
-		return PTR_ERR(parent_xroe_device);
-	}
-	cdev_init(&c_dev, &framer_fops);
-	rc = cdev_add(&c_dev, first, 1);
-	if (rc < 0) {
-		pr_err("Device add failed\n");
-		device_destroy(cl, first);
-		class_destroy(cl);
-		unregister_chrdev_region(first, 1);
-		return rc;
-	}
+	/* Get iospace for the device */
+	r_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	lp->base_addr = devm_ioremap_resource(&pdev->dev, r_mem);
+	if (IS_ERR(lp->base_addr))
+		return PTR_ERR(lp->base_addr);
 
-	/* Register "/dev/xroefram/stats" device */
-	rc = alloc_chrdev_region(&second, 0, 1, "xroe");
-	if (rc < 0) {
-		pr_err("Allocating xroe stats failed\n");
-		return rc;
-	}
-	stats_device = device_create(cl, parent_xroe_device, second, NULL,
-				     "xroe!stats");
-	if (IS_ERR(stats_device)) {
-		pr_err("Stats device create failed\n");
-		class_destroy(cl);
-		unregister_chrdev_region(second, 1);
-		return PTR_ERR(stats_device);
-	}
-	cdev_init(&stats_dev, &stats_ops);
-	rc = cdev_add(&stats_dev, second, 1);
-	if (rc < 0) {
-		pr_err("Stats device add failed\n");
-		device_destroy(cl, second);
-		class_destroy(cl);
-		unregister_chrdev_region(second, 1);
-		return rc;
-	}
-	/* Register "/dev/xroefram/radio_ctrl" device */
-	/*
-	 * TODO: Remove hardcoded address & size and read them from DT
-	 * once the radio_ctrl device has been properly implemented in the DT
-	 */
-	radio_ctrl = ioremap(RADIO_CTRL_BASE, RADIO_CTRL_SIZE);
-	if (IS_ERR(radio_ctrl)) {
-		pr_err("Mapping Radio Control failed\n");
-		return PTR_ERR(radio_ctrl);
-	}
-	rc = alloc_chrdev_region(&third, 0, 1, "xroe");
-	if (rc < 0) {
-		pr_err("Allocating xroe radio_ctrl failed\n");
-		return rc;
-	}
-	radio_ctrl_device = device_create(cl, parent_xroe_device, third,
-					  NULL, "xroe!radio_ctrl");
-	if (IS_ERR(radio_ctrl_device)) {
-		pr_err("radio_ctrl device create failed\n");
-		class_destroy(cl);
-		unregister_chrdev_region(third, 1);
-		return PTR_ERR(radio_ctrl_device);
-	}
-	cdev_init(&radio_ctrl_dev, &radio_ctrl_fops);
-	rc = cdev_add(&radio_ctrl_dev, third, 1);
-	if (rc < 0) {
-		pr_err("radio_ctrl device add failed\n");
-		device_destroy(cl, third);
-		class_destroy(cl);
-		unregister_chrdev_region(third, 1);
-		return rc;
-	}
+	dev_set_drvdata(dev, lp);
 	xroe_sysfs_init();
 	/* Get IRQ for the device */
 	/*
@@ -220,309 +95,6 @@ static int framer_probe(struct platform_device *pdev)
 	return rc;
 }
 
-/**
- * framer_read - Reads from the framer block and copies to user
- * @f:		The file opened by the user
- * @len:	The number of bytes to be read
- * @off:	The offset from the framer's base address
- * @buf:	The buffer containing the bytes read from the framer
- *
- * Returns a byte-by-byte read from the framer block for the provided
- * length and offset
- *
- * Return: The number of bytes read on success, 0 if the input offset
- * is off memory limits or -EFAULT if the copy_to_user() fails
- */
-static ssize_t framer_read(struct file *f,
-			   char __user *buf, size_t len, loff_t *off)
-{
-	int i;
-	u8 byte;
-	size_t framer_size = (size_t)(lp->mem_end - lp->mem_start);
-
-	if (*off >= framer_size)
-		return 0;
-	if (*off + len > framer_size)
-		len = framer_size - *off;
-
-	for (i = 0; i < len; i++) {
-		byte = ioread8((u8 *)lp->base_addr + *off + i);
-		if (copy_to_user(buf + i, &byte, 1))
-			return -EFAULT;
-	}
-	*off += len;
-
-	return len;
-}
-
-/**
- * framer_write - Copies from the user and writes to the framer block
- * @f:		The file opened by the user
- * @len:	The number of bytes to be read
- * @off:	The offset from the framer's base address
- * @buf:	The buffer containing the bytes to be written to the framer
- *
- * Returns a byte-by-byte read from the framer block for the provided
- * length and offset
- *
- * Return: The number of bytes read on success, 0 if the input offset
- * is off memory limits or -EFAULT if the copy_from_user() fails
- */
-static ssize_t framer_write(struct file *f, const char __user *buf,
-			    size_t len, loff_t *off)
-{
-	int i;
-	u8 byte;
-	size_t framer_size = (size_t)(lp->mem_end - (lp->mem_start));
-
-	if (*off >= framer_size)
-		return 0;
-	if (*off + len > framer_size)
-		len = framer_size - *off;
-	for (i = 0; i < len; i++) {
-		if (copy_from_user(&byte, buf + i, 1))
-			return -EFAULT;
-
-		iowrite8(byte, (u8 *)lp->base_addr + *off + i);
-	}
-	*off += len;
-
-	return len;
-}
-
-/**
- * framer_ioctl - Provides ioctl access to the XROE framer
- * @f:				The file opened by the user
- * @cmd:			The ioctl command passed from the user
- * @ioctl_param:	The parameter(s) passed from the user.
- *					Here, a structure of 2 uint32_t
- *					pointers to offset from the base addess
- *					and a value
- *
- * Copies two pointers from the user, pointing to an address offset and a value.
- * The command passed also from the user is switched, and after performing a
- * range check on the offset, the value is either being read or written
- *
- * Return: 0 on success or a negative errno on error.
- */
-static long framer_ioctl(struct file *f, unsigned int cmd,
-			 unsigned long ioctl_param)
-{
-	struct ioctl_arguments *args = kmalloc(sizeof(*args), GFP_KERNEL);
-	int ret = 0;
-	u32 offset;
-	size_t framer_size = (size_t)(lp->mem_end - (lp->mem_start));
-
-	switch (cmd) {
-	case XROE_FRAMER_IOSET: /* Write */
-		if (copy_from_user(args, (void *)ioctl_param,
-				   sizeof(struct ioctl_arguments))) {
-			ret = -EFAULT;
-			break;
-		}
-		offset = *args->offset;
-		ret = utils_check_address_offset(offset, framer_size);
-		if (ret)
-			break;
-
-		iowrite32(*args->value, (u8 *)lp->base_addr + (loff_t)offset);
-		break;
-
-	case XROE_FRAMER_IOGET: /* Read */
-		if (copy_from_user(args, (void *)ioctl_param,
-				   sizeof(struct ioctl_arguments))) {
-			ret = EFAULT;
-			break;
-		}
-		offset = *args->offset;
-		ret = utils_check_address_offset(offset, framer_size);
-		if (ret)
-			break;
-
-		*args->value = ioread32((u8 *)lp->base_addr + (loff_t)offset);
-		break;
-
-	default:
-		ret = -EPERM; /* Operation not permitted */
-		break;
-	}
-
-	kfree(args);
-	return ret;
-}
-
-/**
- * stats_read - Reads from the stats block and copies to user
- * @f:		The file opened by the user
- * @len:	The number of bytes to be read
- * @off:	The offset from the stats' base address
- * @buf:	The buffer containing the bytes read from the stats
- *
- * Returns a byte-by-byte read from the stats block for the provided
- * length and offset
- *
- * Return: The number of bytes read on success, 0 if the input offset
- * is off memory limits or -EFAULT if the copy_to_user() fails
- */
-static ssize_t stats_read(struct file *f, char __user *buf, size_t len,
-			  loff_t *off)
-{
-	int i;
-	u8 byte;
-
-	if (*off >= STATS_SIZE)
-		return 0;
-	if (*off + len > STATS_SIZE)
-		len = STATS_SIZE - *off;
-
-	for (i = 0; i < len; i++) {
-		byte = ioread8((u8 *)lp->base_addr + *off + i + STATS_BASE);
-		if (copy_to_user(buf + i, &byte, 1))
-			return -EFAULT;
-	}
-	*off += len;
-
-	return len;
-}
-
-/**
- * stats_ioctl - Provides ioctl access to the XROE stats
- * @f:				The file opened by the user
- * @cmd:			The ioctl command passed from the user
- * @ioctl_param:	The parameter(s) passed from the user.
- *					Here, a structure of 2 uint32_t pointers
- *					to offset from the base addess
- *					and a value
- *
- * Copies two pointers from the user, pointing to an address offset and a value.
- * The command passed also from the user is switched, and after performing a
- * range check on the offset, the value is either being read or written
- *
- * Return: 0 on success or a negative errno on error.
- */
-static long stats_ioctl(struct file *f, unsigned int cmd,
-			unsigned long ioctl_param)
-{
-	struct ioctl_arguments *args = kmalloc(sizeof(*args), GFP_KERNEL);
-	int ret = 0;
-	u32 offset;
-	size_t stats_size = STATS_SIZE;
-
-	switch (cmd) {
-	case XROE_FRAMER_IOGET: /* Read */
-		if (copy_from_user(args, (void *)ioctl_param,
-				   sizeof(struct ioctl_arguments))) {
-			ret = -EFAULT;
-			break;
-		}
-		offset = *args->offset - STATS_BASE;
-		ret = utils_check_address_offset(offset, stats_size);
-		if (ret)
-			break;
-		*args->value = ioread32((u8 *)lp->base_addr + (loff_t)offset +
-		STATS_BASE);
-		break;
-	case XROE_FRAMER_IOSET: /* Write - not permitted on the stats device */
-	default:
-		ret = -EPERM; /* Operation not permitted */
-		break;
-	}
-
-	kfree(args);
-	return ret;
-}
-
-/**
- * radio_ctrl_read - Reads from the radio control block and copies to user
- * @f:		The file opened by the user
- * @len:	The number of bytes to be read
- * @off:	The offset from the radio control's base address
- * @buf:	The buffer containing the bytes read from
- *			the radio control device
- *
- * Returns a byte-by-byte read from the radio control device block
- * for the provided length and offset
- *
- * Return: The number of bytes read on success, 0 if the input offset
- * is off memory limits or -EFAULT if the copy_to_user() fails
- */
-static ssize_t radio_ctrl_read(struct file *f, char __user *buf, size_t len,
-			       loff_t *off)
-{
-	int i;
-	u8 byte;
-
-	if (*off >= RADIO_CTRL_SIZE)
-		return 0;
-	if (*off + len > RADIO_CTRL_SIZE)
-		len = RADIO_CTRL_SIZE - *off;
-
-	for (i = 0; i < len; i++) {
-		byte = ioread8((u8 *)radio_ctrl + *off + i);
-		if (copy_to_user(buf + i, &byte, 1))
-			return -EFAULT;
-	}
-	*off += len;
-
-	return len;
-}
-
-/**
- * radio_ctrl_read - Copies from the user and writes to the radio control
- * @f:		The file opened by the user
- * @len:	The number of bytes to be read
- * @off:	The offset from the radio control's base address
- * @buf:	The buffer containing the bytes read
- *			from the radio control device
- *
- * Performs a byte-by-byte write to the radio control device for the
- * provided length and offset
- *
- * Return: The number of bytes read on success, 0 if the input offset
- * is off memory limits or -EFAULT if the copy_from_user() fails
- */
-static ssize_t radio_ctrl_write(struct file *f, const char __user *buf,
-				size_t len, loff_t *off)
-{
-	int i;
-	u8 byte;
-
-	if (*off >= RADIO_CTRL_SIZE)
-		return 0;
-
-	if (*off + len > RADIO_CTRL_SIZE)
-		len = RADIO_CTRL_SIZE - *off;
-
-	for (i = 0; i < len; i++) {
-		if (copy_from_user(&byte, buf + i, 1))
-			return -EFAULT;
-		iowrite8(byte, (u8 *)radio_ctrl + *off + i);
-	}
-	*off += len;
-
-	return len;
-}
-
-/**
- * utils_check_address_offset - Offset range check
- * @offset:			The address offset to be checked
- * @device_size:	The device's address range
- *
- * Checks a given offset against the given device's range and then checks
- * if it's even or not
- *
- * Return: 0 on success or a negative errno on error.
- */
-int utils_check_address_offset(u32 offset, size_t device_size)
-{
-	if (offset >= device_size)
-		return -ENXIO; /* No such device or address */
-	else if (offset % 2 != 0)
-		return -EINVAL; /* Invalid argument */
-
-	return 0;
-}
-
 /**
  * framer_init - Registers the driver
  *
@@ -543,7 +115,6 @@ static int __init framer_init(void)
 	return ret;
 }
 
-/* TODO: Fix kernel-doc warning for the documentation of this function */
 /**
  * framer_exit - Destroys the driver
  *
@@ -554,17 +125,6 @@ static int __init framer_init(void)
 static void __exit framer_exit(void)
 {
 	xroe_sysfs_exit();
-	cdev_del(&radio_ctrl_dev);
-	device_destroy(cl, third);
-	cdev_del(&stats_dev);
-	device_destroy(cl, second);
-	cdev_del(&c_dev);
-	device_destroy(cl, first);
-	class_destroy(cl);
-	unregister_chrdev_region(third, 1);
-	unregister_chrdev_region(second, 1);
-	unregister_chrdev_region(first, 2);
-	iounmap(radio_ctrl);
 	platform_driver_unregister(&framer_driver);
 	pr_info("XROE Framer exit\n");
 }
@@ -590,25 +150,6 @@ static struct platform_driver framer_driver = {
 	.probe = framer_probe,
 };
 
-const static struct file_operations framer_fops = {
-	.owner = THIS_MODULE,
-	.read = framer_read,
-	.write = framer_write,
-	.unlocked_ioctl = framer_ioctl
-};
-
-const static struct file_operations stats_ops = {
-	.owner = THIS_MODULE,
-	.read = stats_read,
-	.unlocked_ioctl = stats_ioctl
-};
-
-const static struct file_operations radio_ctrl_fops = {
-	.owner = THIS_MODULE,
-	.read = radio_ctrl_read,
-	.write = radio_ctrl_write
-};
-
 MODULE_LICENSE("GPL v2");
 MODULE_AUTHOR("Xilinx Inc.");
 MODULE_DESCRIPTION("framer - Xilinx Radio over Ethernet Framer driver");
diff --git a/drivers/staging/xroeframer/xroe_framer.h b/drivers/staging/xroeframer/xroe_framer.h
index fb215d9ddc5a..03b8bb39095c 100644
--- a/drivers/staging/xroeframer/xroe_framer.h
+++ b/drivers/staging/xroeframer/xroe_framer.h
@@ -1,4 +1,4 @@
-// SPDX-License-Identifier: GPL-2.0
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Copyright (C) 2018 Xilinx, Inc.
  *
@@ -25,13 +25,6 @@
 #include <linux/uaccess.h>
 #include <uapi/linux/stat.h> /* S_IRUSR, S_IWUSR */
 
-/* TODO: Remove hardcoded addresses once the subsequent, individual devices
- * ("stats" & "radio_ctrl") have been properly implemented in the DT
- */
-#define STATS_BASE 0x0000C000
-#define STATS_SIZE 0x00000050
-#define RADIO_CTRL_BASE 0xA0060000
-#define RADIO_CTRL_SIZE 0x0000FFFF
 /* TODO: Remove hardcoded value of number of Ethernet ports and read the value
  * from the device tree.
  */
@@ -51,11 +44,6 @@ struct framer_local {
 	void __iomem *base_addr;
 };
 
-struct ioctl_arguments {
-	 u32 *offset;
-	 u32 *value;
-};
-
 int xroe_sysfs_init(void);
 int xroe_sysfs_ipv4_init(void);
 int xroe_sysfs_ipv6_init(void);
-- 
2.31.1

