From c84330e978f98373bd61af9d3f47a7edb1f1577c Mon Sep 17 00:00:00 2001
From: Maruthi Srinivas Bayyavarapu <maruthi.srinivas.bayyavarapu@xilinx.com>
Date: Tue, 25 Sep 2018 23:23:34 +0530
Subject: [PATCH 0124/1851] ASoC: xlnx: Reset S2MM for next channel status
 update

commit cd56fdc2874a8574cfe26c3a3027a4769139db6d from
https://github.com/Xilinx/linux-xlnx.git

For the same input stream, after the end of audio capture usecase,
unless S2MM path is reset, next audio capture usecase will not get channel
status update. Added S2MM reset during close callback.

Signed-off-by: Maruthi Srinivas Bayyavarapu <maruthi.srinivas.bayyavarapu@xilinx.com>
Reviewed-by: Hyun Kwon <hyun.kwon@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
State: pending
Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
---
 sound/soc/xilinx/xlnx_formatter_pcm.c | 21 +++++++
 sound/soc/xilinx/xlnx_pl_snd_card.c   | 91 +++++++++++++++++++++++----
 sound/soc/xilinx/xlnx_snd_common.h    |  5 ++
 3 files changed, 106 insertions(+), 11 deletions(-)

diff --git a/sound/soc/xilinx/xlnx_formatter_pcm.c b/sound/soc/xilinx/xlnx_formatter_pcm.c
index f55aec499b44..c7e1cc5e2a8f 100644
--- a/sound/soc/xilinx/xlnx_formatter_pcm.c
+++ b/sound/soc/xilinx/xlnx_formatter_pcm.c
@@ -354,6 +354,7 @@ static irqreturn_t xlnx_s2mm_irq_handler(int irq, void *arg)
 
 static int xlnx_formatter_pcm_open(struct snd_pcm_substream *substream)
 {
+	int err;
 	u32 val, data_format_mode;
 	u32 ch_count_mask, ch_count_shift, data_xfer_mode, data_xfer_shift;
 	struct xlnx_pcm_stream_param *stream_data;
@@ -408,6 +409,15 @@ static int xlnx_formatter_pcm_open(struct snd_pcm_substream *substream)
 	snd_soc_set_runtime_hwparams(substream, &xlnx_pcm_hardware);
 	runtime->private_data = stream_data;
 
+	/* Resize the period size divisible by 64 */
+	err = snd_pcm_hw_constraint_step(runtime, 0,
+					 SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 64);
+	if (err) {
+		dev_err(component->dev,
+			"unable to set constraint on period bytes\n");
+		return err;
+	}
+
 	/* enable interrupt on complete */
 	val = readl(stream_data->mmio + XLNX_AUD_CTRL);
 	val |= AUD_CTRL_IOC_IRQ_MASK;
@@ -430,6 +440,9 @@ static int xlnx_formatter_pcm_close(struct snd_pcm_substream *substream)
 
 	kfree(stream_data);
 
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		xlnx_formatter_pcm_reset(stream_data->mmio + XLNX_S2MM_OFFSET);
+
 	return 0;
 }
 
@@ -456,12 +469,14 @@ static int xlnx_formatter_pcm_hw_params(struct snd_pcm_substream *substream,
 	int status;
 	u64 size;
 	struct audio_params *aes_params;
+	struct pl_card_data *prv;
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct xlnx_pcm_stream_param *stream_data = runtime->private_data;
 	struct snd_soc_pcm_runtime *prtd = substream->private_data;
 	struct snd_soc_component *component = snd_soc_rtdcom_lookup(prtd,
 								    DRV_NAME);
 	struct xlnx_pcm_drv_data *adata = dev_get_drvdata(component->dev);
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 
 	aes_params = kzalloc(sizeof(*aes_params), GFP_KERNEL);
 	if (!aes_params)
@@ -554,6 +569,12 @@ static int xlnx_formatter_pcm_hw_params(struct snd_pcm_substream *substream,
 	bytes_per_ch = DIV_ROUND_UP(params_period_bytes(params), active_ch);
 	writel(bytes_per_ch, stream_data->mmio + XLNX_BYTES_PER_CH);
 
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		prv = snd_soc_card_get_drvdata(rtd->card);
+		writel(prv->mclk_ratio,
+		       stream_data->mmio + XLNX_AUD_FS_MULTIPLIER);
+	}
+
 	return 0;
 }
 
diff --git a/sound/soc/xilinx/xlnx_pl_snd_card.c b/sound/soc/xilinx/xlnx_pl_snd_card.c
index 36120e825b6c..3786c7d79656 100644
--- a/sound/soc/xilinx/xlnx_pl_snd_card.c
+++ b/sound/soc/xilinx/xlnx_pl_snd_card.c
@@ -5,6 +5,7 @@
  * Copyright (C) 2018 Xilinx, Inc.
  */
 
+#include <linux/clk.h>
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/of_device.h>
@@ -45,6 +46,7 @@ static int xlnx_i2s_card_hw_params(struct snd_pcm_substream *substream,
 {
 	int ret, clk_div;
 	u32 ch, data_width, sample_rate;
+	struct pl_card_data *prv;
 
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
@@ -53,19 +55,54 @@ static int xlnx_i2s_card_hw_params(struct snd_pcm_substream *substream,
 	data_width = params_width(params);
 	sample_rate = params_rate(params);
 
-	/*
-	 * Supports only a fixed combination of 48khz, 24 bits/sample,
-	 * 2 channels.
-	 */
-	if (ch != 2 || data_width != 24 || sample_rate != 48000)
+	/* only 2 channels supported */
+	if (ch != 2)
 		return -EINVAL;
 
-	/*
-	 * For the fixed Mclk, I2S_CLOCK_RATIO of 384 is ued to get 48KHz.
-	 * Ex. For a master clock(MCLK) of 18.43MHz and to get 48KHz
-	 * sampling rate, Mclk/srate = 384.
-	 */
-	clk_div = DIV_ROUND_UP(I2S_CLOCK_RATIO, ch * data_width);
+	prv = snd_soc_card_get_drvdata(rtd->card);
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		switch (sample_rate) {
+		case 5512:
+		case 8000:
+		case 11025:
+		case 16000:
+		case 22050:
+		case 32000:
+		case 44100:
+		case 48000:
+		case 64000:
+		case 88200:
+		case 96000:
+			prv->mclk_ratio = 384;
+			break;
+		default:
+			return -EINVAL;
+		}
+	} else {
+		switch (sample_rate) {
+		case 32000:
+		case 44100:
+		case 48000:
+		case 88200:
+		case 96000:
+			prv->mclk_ratio = 384;
+			break;
+		case 64000:
+		case 176400:
+		case 192000:
+			prv->mclk_ratio = 192;
+			break;
+		default:
+			return -EINVAL;
+		}
+	}
+
+	prv->mclk_val = prv->mclk_ratio * sample_rate;
+	ret = clk_set_rate(prv->mclk, prv->mclk_val);
+	if (ret)
+		return ret;
+
+	clk_div = DIV_ROUND_UP(prv->mclk_ratio, 2 * ch * data_width);
 	ret = snd_soc_dai_set_clkdiv(cpu_dai, 0, clk_div);
 
 	return ret;
@@ -156,6 +193,8 @@ static int xlnx_snd_probe(struct platform_device *pdev)
 	u32 i;
 	int ret, audio_interface;
 	struct snd_soc_dai_link *dai;
+	struct pl_card_data *prv;
+	struct platform_device *iface_pdev;
 
 	struct snd_soc_card *card = &xlnx_card;
 	struct device_node **node = pdev->dev.platform_data;
@@ -175,6 +214,12 @@ static int xlnx_snd_probe(struct platform_device *pdev)
 	if (!card->dai_link)
 		return -ENOMEM;
 
+	prv = devm_kzalloc(card->dev,
+			   sizeof(struct pl_card_data),
+			   GFP_KERNEL);
+	if (!prv)
+		return -ENOMEM;
+
 	card->num_links = 0;
 	for (i = XLNX_PLAYBACK; i < XLNX_MAX_PATHS; i++) {
 		struct device_node *pnode = of_parse_phandle(node[i],
@@ -184,7 +229,24 @@ static int xlnx_snd_probe(struct platform_device *pdev)
 			of_node_put(pnode);
 			return -ENODEV;
 		}
+
+		/*
+		 * Check for either playback or capture is enough, as
+		 * same clock is used for both.
+		 */
+		if (i == XLNX_PLAYBACK) {
+			iface_pdev = of_find_device_by_node(pnode);
+			if (!iface_pdev) {
+				of_node_put(pnode);
+				return -ENODEV;
+			}
+
+			prv->mclk = devm_clk_get(&iface_pdev->dev, "aud_mclk");
+			if (IS_ERR(prv->mclk))
+				return PTR_ERR(prv->mclk);
+		}
 		of_node_put(pnode);
+
 		dai = &card->dai_link[i];
 		audio_interface = find_link(node[i], i);
 		switch (audio_interface) {
@@ -193,6 +255,7 @@ static int xlnx_snd_probe(struct platform_device *pdev)
 			dai->platforms->of_node = pnode;
 			dai->cpus->of_node = node[i];
 			card->num_links++;
+			snd_soc_card_set_drvdata(card, prv);
 			dev_dbg(card->dev, "%s registered\n",
 				card->dai_link[i].name);
 			break;
@@ -202,6 +265,9 @@ static int xlnx_snd_probe(struct platform_device *pdev)
 			if (i == XLNX_CAPTURE)
 				dai->codecs->of_node = node[i];
 			card->num_links++;
+			/* TODO: support multiple sampling rates */
+			prv->mclk_ratio = 384;
+			snd_soc_card_set_drvdata(card, prv);
 			dev_dbg(card->dev, "%s registered\n",
 				card->dai_link[i].name);
 			break;
@@ -210,6 +276,9 @@ static int xlnx_snd_probe(struct platform_device *pdev)
 			dai->platforms->of_node = pnode;
 			dai->codecs->of_node = node[i];
 			card->num_links++;
+			/* TODO: support multiple sampling rates */
+			prv->mclk_ratio = 384;
+			snd_soc_card_set_drvdata(card, prv);
 			dev_dbg(card->dev, "%s registered\n",
 				card->dai_link[i].name);
 			break;
diff --git a/sound/soc/xilinx/xlnx_snd_common.h b/sound/soc/xilinx/xlnx_snd_common.h
index ab3c82a0e122..e93c1d83d0e3 100644
--- a/sound/soc/xilinx/xlnx_snd_common.h
+++ b/sound/soc/xilinx/xlnx_snd_common.h
@@ -14,4 +14,9 @@ enum {
 	XLNX_MAX_PATHS
 };
 
+struct pl_card_data {
+	u32 mclk_val;
+	u32 mclk_ratio;
+	struct clk *mclk;
+};
 #endif /* _XLNX_SND_COMMON_H */
-- 
2.31.1

