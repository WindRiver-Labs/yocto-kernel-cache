From 2b9b68e83f187f054ed5042b7efa095e162fc216 Mon Sep 17 00:00:00 2001
From: Limeng <Meng.Li@windriver.com>
Date: Wed, 8 Apr 2020 18:50:29 +0800
Subject: [PATCH] drivers: pci: pcie-designware-host: release resource when
 pcie initializes failed

When there is no pcie device connected with imx6 platform, there will
be below kmemleak:
[<c7c6ebb9>] pci_add_resource_offset+0x24/0x5c
[<9a9fdc5e>] devm_of_pci_get_host_bridge_resources+0xac/0x28c
[<943cef99>] dw_pcie_host_init+0xb8/0x4f8
[<6a1eb53d>] imx_pcie_probe+0x8a8/0xa50
[<a1a48243>] platform_drv_probe+0x50/0x9c
[<561fafac>] really_probe+0x1f8/0x2c8
[<147e879e>] driver_probe_device+0x148/0x160
[<0e31cbb4>] bus_for_each_drv+0xa8/0xc0
Because pcie link up is not established, and return failed. But the
resource added by function pci_add_resource(). So, release these
resources manually.
In additional, release resource at the point where function invoking
returns error.

Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 .../pci/controller/dwc/pcie-designware-host.c | 24 +++++++++++++++----
 1 file changed, 19 insertions(+), 5 deletions(-)

diff --git a/drivers/pci/controller/dwc/pcie-designware-host.c b/drivers/pci/controller/dwc/pcie-designware-host.c
index 15625462edfe..eb1c0257adb5 100644
--- a/drivers/pci/controller/dwc/pcie-designware-host.c
+++ b/drivers/pci/controller/dwc/pcie-designware-host.c
@@ -364,8 +364,10 @@ int dw_pcie_host_init(struct pcie_port *pp)
 		return ret;
 
 	ret = devm_request_pci_bus_resources(dev, &bridge->windows);
-	if (ret)
+	if (ret) {
+		bridge->dev.release(&bridge->dev);
 		return ret;
+	}
 
 	/* Get the I/O and memory ranges from DT */
 	resource_list_for_each_entry_safe(win, tmp, &bridge->windows) {
@@ -408,6 +410,7 @@ int dw_pcie_host_init(struct pcie_port *pp)
 						pp->cfg->start,
 						resource_size(pp->cfg));
 		if (!pci->dbi_base) {
+			bridge->dev.release(&bridge->dev);
 			dev_err(dev, "Error with ioremap\n");
 			return -ENOMEM;
 		}
@@ -419,6 +422,7 @@ int dw_pcie_host_init(struct pcie_port *pp)
 		pp->va_cfg0_base = devm_pci_remap_cfgspace(dev,
 					pp->cfg0_base, pp->cfg0_size);
 		if (!pp->va_cfg0_base) {
+			bridge->dev.release(&bridge->dev);
 			dev_err(dev, "Error with ioremap in function\n");
 			return -ENOMEM;
 		}
@@ -429,6 +433,7 @@ int dw_pcie_host_init(struct pcie_port *pp)
 						pp->cfg1_base,
 						pp->cfg1_size);
 		if (!pp->va_cfg1_base) {
+			bridge->dev.release(&bridge->dev);
 			dev_err(dev, "Error with ioremap\n");
 			return -ENOMEM;
 		}
@@ -451,6 +456,7 @@ int dw_pcie_host_init(struct pcie_port *pp)
 
 			if (pp->num_vectors > MAX_MSI_IRQS ||
 			    pp->num_vectors == 0) {
+			    bridge->dev.release(&bridge->dev);
 				dev_err(dev,
 					"Invalid number of vectors\n");
 				return -EINVAL;
@@ -461,8 +467,10 @@ int dw_pcie_host_init(struct pcie_port *pp)
 			pp->msi_irq_chip = &dw_pci_msi_bottom_irq_chip;
 
 			ret = dw_pcie_allocate_domains(pp);
-			if (ret)
+			if (ret) {
+				bridge->dev.release(&bridge->dev);
 				return ret;
+			}
 
 			if (pp->msi_irq)
 				irq_set_chained_handler_and_data(pp->msi_irq,
@@ -470,15 +478,19 @@ int dw_pcie_host_init(struct pcie_port *pp)
 							    pp);
 		} else {
 			ret = pp->ops->msi_host_init(pp);
-			if (ret < 0)
+			if (ret < 0) {
+				bridge->dev.release(&bridge->dev);
 				return ret;
+			}
 		}
 	}
 
 	if (pp->ops->host_init) {
 		ret = pp->ops->host_init(pp);
-		if (ret)
+		if (ret) {
+			bridge->dev.release(&bridge->dev);
 			goto err_free_msi;
+		}
 	}
 
 	pp->root_bus_nr = pp->busn->start;
@@ -491,8 +503,10 @@ int dw_pcie_host_init(struct pcie_port *pp)
 	bridge->swizzle_irq = pci_common_swizzle;
 
 	ret = pci_scan_root_bus_bridge(bridge);
-	if (ret)
+	if (ret) {
+		bridge->dev.release(&bridge->dev);
 		goto err_free_msi;
+	}
 
 	pp->root_bus = bridge->bus;
 
-- 
2.17.1

