From 0cb9a126bd7109c797640aa156f4fec5b6ac8616 Mon Sep 17 00:00:00 2001
From: Dave Gerlach <d-gerlach@ti.com>
Date: Fri, 2 Nov 2018 16:00:47 +0530
Subject: [PATCH 07/51] ARM: OMAP2+: timer: Extend pending interrupt ACK for
 gic

commit cf7167b4c01694165c4c8983a99235aef55c82a4 from
https://git.ti.com/cgit/processor-sdk/processor-sdk-linux/?h=processor-sdk-linux-01.00.00

The current implementation for preventing timer interrupts from
breaking suspend fully fixes the issue on am335x but the GIC present on
am437x cannot be directly acked using only the irqchip calls as is done
for am335x but requires an additional step.

Calling irqchip->irq_eoi only writes to the GIC_CPU_EOI register but for
an interrupt to be properly cleared by the GIC, a read from
GIC_CPU_INTACK must come first.  The only place the irq-gic driver reads
this is in the actual interrupt handler so we cannot access it from the
driver.

To get around this, let's map the GIC_CPU_BASE and read the
GIC_CPU_INTACK register ourselves before calling irq_eoi to properly ack
late timer interrupts that show up during suspend on am437x.

Signed-off-by: Dave Gerlach <d-gerlach@ti.com>
Signed-off-by: Xiaolei Wang <xiaolei.wang@windriver.com>
---
 arch/arm/mach-omap2/timer.c | 27 +++++++++++++++++++++++++++
 1 file changed, 27 insertions(+)

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 6b0a09b58c87..d2109177ac7c 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -33,6 +33,7 @@
 #include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/irq.h>
+#include <linux/irqchip/arm-gic.h>
 #include <linux/clocksource.h>
 #include <linux/clockchips.h>
 #include <linux/slab.h>
@@ -61,6 +62,10 @@
 #define INCREMENTER_DENUMERATOR_RELOAD_OFFSET		0x14
 #define NUMERATOR_DENUMERATOR_MASK			0xfffff000
 
+#define AM43XX_GIC_CPU_BASE				0x48240100
+
+static void __iomem *gic_cpu_base;
+
 /* Clockevent code */
 
 static struct omap_dm_timer clkev;
@@ -131,11 +136,29 @@ static int omap2_gp_timer_set_periodic(struct clock_event_device *evt)
 	return 0;
 }
 
+static int omap_clkevt_late_ack_init(void)
+{
+	gic_cpu_base = ioremap(AM43XX_GIC_CPU_BASE, SZ_4K);
+
+	if (!gic_cpu_base)
+		return -ENOMEM;
+
+	return 0;
+}
+
 static void omap_clkevt_late_ack(void)
 {
+	u32 val;
+
 	if (!clkev_irq_chip)
 		return;
 
+	/*
+	 * For the gic to properly clear an interrupt it must be read
+	 * from INTACK register
+	 */
+	if (gic_cpu_base)
+		val = readl_relaxed(gic_cpu_base + GIC_CPU_INTACK);
 	if (clkev_irq_chip->irq_ack)
 		clkev_irq_chip->irq_ack(&clkev_irq_desc->irq_data);
 	if (clkev_irq_chip->irq_eoi)
@@ -426,8 +449,12 @@ static void __init omap2_gp_clockevent_init(int gptimer_id,
 		clkev_irq_desc = irq_to_desc(clkev.irq);
 		if (clkev_irq_desc)
 			clkev_irq_chip = irq_desc_get_chip(clkev_irq_desc);
+
 	}
 
+	if (soc_is_am437x())
+		omap_clkevt_late_ack_init();
+
 	pr_info("OMAP clockevent source: %s at %lu Hz\n", clockevent_gpt.name,
 		clkev.rate);
 }
-- 
2.17.1

