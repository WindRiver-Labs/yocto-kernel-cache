From 626a0b33429c214c380e152b324bfacc7e436205 Mon Sep 17 00:00:00 2001
From: Dave Gerlach <d-gerlach@ti.com>
Date: Fri, 2 Nov 2018 16:00:46 +0530
Subject: [PATCH 06/51] ARM: OMAP2+: timer: Ack pending interrupt during
 suspend

commit 339b07fb3cad5f893be7eec749e32630dc1e195e from
https://git.ti.com/cgit/processor-sdk/processor-sdk-linux/?h=processor-sdk-linux-01.00.00

It is possible that when suspending the clock event timer it will generate
an interrupt just before their suspend is completed, but after interrupts have
been disabled. In this case any pending interrupts will prevent suspend, so
ACK the timer interrupt to avoid this.

Signed-off-by: Dave Gerlach <d-gerlach@ti.com>
Signed-off-by: Tero Kristo <t-kristo@ti.com>
Signed-off-by: Xiaolei Wang <xiaolei.wang@windriver.com>
---
 arch/arm/mach-omap2/timer.c | 27 +++++++++++++++++++++++++++
 1 file changed, 27 insertions(+)

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 07bea84c5d6e..6b0a09b58c87 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -68,6 +68,8 @@ static struct clock_event_device clockevent_gpt;
 
 /* Clockevent hwmod for am335x and am437x suspend */
 static struct omap_hwmod *clockevent_gpt_hwmod;
+static struct irq_chip *clkev_irq_chip;
+static struct irq_desc *clkev_irq_desc;
 
 /* Clockesource hwmod for am437x suspend */
 static struct omap_hwmod *clocksource_gpt_hwmod;
@@ -129,11 +131,32 @@ static int omap2_gp_timer_set_periodic(struct clock_event_device *evt)
 	return 0;
 }
 
+static void omap_clkevt_late_ack(void)
+{
+	if (!clkev_irq_chip)
+		return;
+
+	if (clkev_irq_chip->irq_ack)
+		clkev_irq_chip->irq_ack(&clkev_irq_desc->irq_data);
+	if (clkev_irq_chip->irq_eoi)
+		clkev_irq_chip->irq_eoi(&clkev_irq_desc->irq_data);
+
+	clkev_irq_chip->irq_unmask(&clkev_irq_desc->irq_data);
+}
+
 static void omap_clkevt_idle(struct clock_event_device *unused)
 {
 	if (!clockevent_gpt_hwmod)
 		return;
 
+	/*
+	 * It is possible for a late interrupt to be generated which will
+	 * cause a suspend failure. Let's ack it here both in the timer
+	 * and the interrupt controller to avoid this.
+	 */
+	__omap_dm_timer_write_status(&clkev, OMAP_TIMER_INT_OVERFLOW);
+	omap_clkevt_late_ack();
+
 	omap_hwmod_idle(clockevent_gpt_hwmod);
 }
 
@@ -399,6 +422,10 @@ static void __init omap2_gp_clockevent_init(int gptimer_id,
 
 		clockevent_gpt_hwmod =
 			omap_hwmod_lookup(clockevent_gpt.name);
+
+		clkev_irq_desc = irq_to_desc(clkev.irq);
+		if (clkev_irq_desc)
+			clkev_irq_chip = irq_desc_get_chip(clkev_irq_desc);
 	}
 
 	pr_info("OMAP clockevent source: %s at %lu Hz\n", clockevent_gpt.name,
-- 
2.17.1

