From eabf2fbfbf01b53d0d4431cd39ce659bd04e462e Mon Sep 17 00:00:00 2001
From: Graham Moore <grmoore@opensource.altera.com>
Date: Fri, 27 Jan 2017 06:18:57 -0600
Subject: [PATCH 021/151] FogBugz #284482-1: A10 cache coherency is different
 than A5/C5.

commit  c4cdab38f5cfff9ef34884934e14181c1ba42eb0 from
https://github.com/altera-opensource/linux-socfpga.git
branch is socfpga-5.4.64-lts

dma: pl330: This patch adds the necessary code changes to address
the differences in A5/C5 and A10 related to how the PL330 works.
A5/C5 requires DMA microcode to reside in uncached memory and A10
requires DMA microcode to reside in cached memory.

Signed-off-by: Vince Bridgers <vbridger@opensource.altera.com>
Signed-off-by: Graham Moore <grmoore@opensource.altera.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
Integrated-by: Jun Zhang <jun.zhang@windriver.com>
---
 drivers/dma/pl330.c | 53 +++++++++++++++++++++++++++++++++++----------
 1 file changed, 41 insertions(+), 12 deletions(-)

diff --git a/drivers/dma/pl330.c b/drivers/dma/pl330.c
index 56f9fabc99c4..fab5647bdb87 100644
--- a/drivers/dma/pl330.c
+++ b/drivers/dma/pl330.c
@@ -468,6 +468,8 @@ struct pl330_dmac {
 
 	/* Size of MicroCode buffers for each channel. */
 	unsigned mcbufsz;
+	/* True if microcode must reside in cached memory. */
+	bool microcode_cached;
 	/* ioremap'ed address of PL330 registers. */
 	void __iomem	*base;
 	/* Populated by the PL330 core driver during pl330_add */
@@ -1895,19 +1897,45 @@ static int dmac_alloc_threads(struct pl330_dmac *pl330)
 	return 0;
 }
 
+static void *alloc_pl330_microcode_mem(struct pl330_dmac *pl330)
+{
+        int chans = pl330->pcfg.num_chan;
+
+        if (pl330->microcode_cached) {
+                pl330->mcode_cpu = kzalloc(chans * pl330->mcbufsz,
+                                           GFP_KERNEL);
+                pl330->mcode_bus = virt_to_phys(pl330->mcode_cpu);
+        } else
+                pl330->mcode_cpu =
+                        dma_alloc_coherent(pl330->ddma.dev,
+                                           chans * pl330->mcbufsz,
+                                           &pl330->mcode_bus, GFP_KERNEL);
+
+        return pl330->mcode_cpu;
+}
+
+static void free_pl330_microcode_mem(struct pl330_dmac *pl330)
+{
+        int chans = pl330->pcfg.num_chan;
+
+        if (pl330->microcode_cached)
+                kfree(pl330->mcode_cpu);
+        else
+                dma_free_attrs(pl330->ddma.dev,
+                                  chans * pl330->mcbufsz,
+                                  pl330->mcode_cpu, pl330->mcode_bus,
+				  DMA_ATTR_PRIVILEGED);
+}
+
 static int dmac_alloc_resources(struct pl330_dmac *pl330)
 {
-	int chans = pl330->pcfg.num_chan;
 	int ret;
 
 	/*
 	 * Alloc MicroCode buffer for 'chans' Channel threads.
 	 * A channel's buffer offset is (Channel_Id * MCODE_BUFF_PERCHAN)
 	 */
-	pl330->mcode_cpu = dma_alloc_attrs(pl330->ddma.dev,
-				chans * pl330->mcbufsz,
-				&pl330->mcode_bus, GFP_KERNEL,
-				DMA_ATTR_PRIVILEGED);
+	pl330->mcode_cpu = alloc_pl330_microcode_mem(pl330);
 	if (!pl330->mcode_cpu) {
 		dev_err(pl330->ddma.dev, "%s:%d Can't allocate memory!\n",
 			__func__, __LINE__);
@@ -1918,9 +1946,7 @@ static int dmac_alloc_resources(struct pl330_dmac *pl330)
 	if (ret) {
 		dev_err(pl330->ddma.dev, "%s:%d Can't to create channels for DMAC!\n",
 			__func__, __LINE__);
-		dma_free_coherent(pl330->ddma.dev,
-				chans * pl330->mcbufsz,
-				pl330->mcode_cpu, pl330->mcode_bus);
+		free_pl330_microcode_mem(pl330);
 		return ret;
 	}
 
@@ -1999,9 +2025,7 @@ static void pl330_del(struct pl330_dmac *pl330)
 	/* Free DMAC resources */
 	dmac_free_threads(pl330);
 
-	dma_free_coherent(pl330->ddma.dev,
-		pl330->pcfg.num_chan * pl330->mcbufsz, pl330->mcode_cpu,
-		pl330->mcode_bus);
+	free_pl330_microcode_mem(pl330);
 }
 
 /* forward declaration */
@@ -3012,7 +3036,12 @@ pl330_probe(struct amba_device *adev, const struct amba_id *id)
 
 	pl330->mcbufsz = 0;
 
-	/* get quirk */
+	if (adev->dev.of_node)
+		pl330->microcode_cached =
+			of_property_read_bool(adev->dev.of_node,
+					      "microcode-cached");
+
+ 	/* get quirk */
 	for (i = 0; i < ARRAY_SIZE(of_quirks); i++)
 		if (of_property_read_bool(np, of_quirks[i].quirk))
 			pl330->quirks |= of_quirks[i].id;
-- 
2.26.1

