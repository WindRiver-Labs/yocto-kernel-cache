From e13dc4ca22ba2f5dd2d15f39b518c602d8b07025 Mon Sep 17 00:00:00 2001
From: Thor Thayer <thor.thayer@linux.intel.com>
Date: Mon, 23 Dec 2019 11:04:11 -0600
Subject: [PATCH 061/151] HSD #1707131464: EDAC/altera: Add S10 SDRAM ECC check
 for legacy U-Boot

commit  d3c1438311e55d77a7a20923d7c9abc167d86231 from
https://github.com/altera-opensource/linux-socfpga.git
branch is socfpga-5.4.64-lts

A bug in U-Boot causes a crash during SDRAM boot if ECC is
not enabled in the bitstream but is enabled in the Linux
config.[1]

Memory mapped read of the ECC Enabled bit was only enabled
if U-Boot determined ECC was enabled in the bitstream.

The Linux driver checks the ECC enable bit using a memory map
read. In the ECC disabled bitstream case, U-Boot didn't
enable ECC register memory map reads and since they are not
allowed this results in a crash.

This patch always reads the ECC Enable register through an
SMC call which is always allowed and will work with legacy
and current U-Boot.

[1] https://lkml.org/lkml/2019/11/29/366

Fixes: Commit 08f08bfb7b4c ("EDAC, altera: Merge Stratix10 into the Arria10 SDRAM probe routine")

Signed-off-by: Thor Thayer <thor.thayer@linux.intel.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
Integrated-by: Jun Zhang <jun.zhang@windriver.com>
---
 drivers/edac/altera_edac.c | 40 +++++++++++++++++++++++++++++++++++++-
 1 file changed, 39 insertions(+), 1 deletion(-)

diff --git a/drivers/edac/altera_edac.c b/drivers/edac/altera_edac.c
index c2447618e7d7..1b4f6df82eec 100644
--- a/drivers/edac/altera_edac.c
+++ b/drivers/edac/altera_edac.c
@@ -1076,8 +1076,46 @@ static int __init __maybe_unused altr_init_a10_ecc_device_type(char *compat)
 
 #ifdef CONFIG_EDAC_ALTERA_SDRAM
 
+/*
+ * A legacy U-Boot bug only enabled memory mapped access to the ECC Enable
+ * register if ECC is enabled. Linux checks the ECC Enable register to
+ * determine ECC status.
+ * Use an SMC call (which always works) to determine ECC enablement.
+ */
+static int altr_s10_sdram_check_ecc_deps(struct altr_edac_device_dev *device)
+{
+	const struct edac_device_prv_data *prv = device->data;
+	unsigned long sdram_ecc_addr;
+	struct arm_smccc_res result;
+	struct device_node *np;
+	phys_addr_t sdram_addr;
+	u32 read_reg;
+	int ret;
+
+	np = of_find_compatible_node(NULL, NULL, "altr,sdr-ctl");
+	if (!np)
+		goto sdram_err;
+
+	sdram_addr = of_translate_address(np, of_get_address(np, 0,
+							     NULL, NULL));
+	of_node_put(np);
+	sdram_ecc_addr = (unsigned long)sdram_addr + prv->ecc_en_ofst;
+	arm_smccc_smc(INTEL_SIP_SMC_REG_READ, sdram_ecc_addr,
+		      0, 0, 0, 0, 0, 0, &result);
+	read_reg = (unsigned int)result.a1;
+	ret = (int)result.a0;
+	if (!ret && (read_reg & prv->ecc_enable_mask))
+		return 0;
+
+sdram_err:
+	edac_printk(KERN_ERR, EDAC_DEVICE,
+		    "%s: No ECC present or ECC disabled.\n",
+		    device->edac_dev_name);
+	return -ENODEV;
+}
+
 static const struct edac_device_prv_data s10_sdramecc_data = {
-	.setup = altr_check_ecc_deps,
+	.setup = altr_s10_sdram_check_ecc_deps,
 	.ce_clear_mask = ALTR_S10_ECC_SERRPENA,
 	.ue_clear_mask = ALTR_S10_ECC_DERRPENA,
 	.ecc_enable_mask = ALTR_S10_ECC_EN,
-- 
2.26.1

