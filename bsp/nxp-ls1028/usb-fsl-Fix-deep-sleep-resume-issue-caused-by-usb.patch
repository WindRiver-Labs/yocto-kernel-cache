From 64b69dbbec5ee2c9da222303c31d1057b1338e00 Mon Sep 17 00:00:00 2001
From: Ramneek Mehresh <ramneek.mehresh@freescale.com>
Date: Wed, 26 Nov 2014 22:59:05 +0530
Subject: [PATCH 371/741] usb: fsl: Fix deep-sleep resume issue caused by usb

commit ee852cbf35c28540591d9109917b102f2232ec9a from
http://source.codeaurora.org/external/qoriq/qoriq-components/linux

usb ip driver needs to save and restore all registers including
phy registers across deep-sleep. This is required since latest
changes in u-boot code doesn't re-init usb phy anymore during
deep-sleep resume

Signed-off-by: Ramneek Mehresh <ramneek.mehresh@freescale.com>
Signed-off-by: Suresh Gupta <suresh.gupta@freescale.com>
Signed-off-by: Nikhil Badola <nikhil.badola@freescale.com>
Signed-off-by: yinbo.zhu <yinbo.zhu@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/usb/host/ehci-fsl.c | 62 ++++++++++++++++++++++++++++---------
 1 file changed, 48 insertions(+), 14 deletions(-)

diff --git a/drivers/usb/host/ehci-fsl.c b/drivers/usb/host/ehci-fsl.c
index 7eb03848e2aa..47fbf3114ef9 100644
--- a/drivers/usb/host/ehci-fsl.c
+++ b/drivers/usb/host/ehci-fsl.c
@@ -28,6 +28,39 @@
 #include "ehci.h"
 #include "ehci-fsl.h"
 
+#define FSL_USB_PHY_ADDR       0xffe214000
+
+struct ccsr_usb_port_ctrl {
+	u32     ctrl;
+	u32     drvvbuscfg;
+	u32     pwrfltcfg;
+	u32     sts;
+	u8      res_14[0xc];
+	u32     bistcfg;
+	u32     biststs;
+	u32     abistcfg;
+	u32     abiststs;
+	u8      res_30[0x10];
+	u32     xcvrprg;
+	u32     anaprg;
+	u32     anadrv;
+	u32     anasts;
+};
+
+struct ccsr_usb_phy {
+	u32     id;
+	struct ccsr_usb_port_ctrl port1;
+	u8      res_50[0xc];
+	u32     tvr;
+	u32     pllprg[4];
+	u8      res_70[0x4];
+	u32     anaccfg;
+	u32     dbg;
+	u8      res_7c[0x4];
+	struct ccsr_usb_port_ctrl port2;
+	u8      res_dc[0x334];
+};
+
 #define DRIVER_DESC "Freescale EHCI Host controller driver"
 #define DRV_NAME "ehci-fsl"
 
@@ -501,9 +534,9 @@ static int ehci_fsl_setup(struct usb_hcd *hcd)
 }
 
 
-
-
 #ifdef CONFIG_PM
+void __iomem *phy_reg;
+
 /* save usb registers */
 static int ehci_fsl_save_context(struct usb_hcd *hcd)
 {
@@ -511,11 +544,11 @@ static int ehci_fsl_save_context(struct usb_hcd *hcd)
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
 	void __iomem *non_ehci = hcd->regs;
 
-	ehci_fsl->saved_regs = kzalloc(sizeof(struct ehci_regs), GFP_KERNEL);
-	if (!ehci_fsl->saved_regs)
-		return -ENOMEM;
-	_memcpy_fromio(ehci_fsl->saved_regs, ehci->regs,
-					sizeof(struct ehci_regs));
+	phy_reg = ioremap(FSL_USB_PHY_ADDR, sizeof(struct ccsr_usb_phy));
+	_memcpy_fromio((void *)&ehci_fsl->saved_phy_regs, phy_reg,
+			sizeof(struct ccsr_usb_phy));
+	_memcpy_fromio((void *)&ehci_fsl->saved_regs, ehci->regs,
+			sizeof(struct ehci_regs));
 	ehci_fsl->usb_ctrl = in_be32(non_ehci + FSL_SOC_USB_CTRL);
 	return 0;
 
@@ -528,13 +561,14 @@ static int ehci_fsl_restore_context(struct usb_hcd *hcd)
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
 	void __iomem *non_ehci = hcd->regs;
 
-	if (ehci_fsl->saved_regs) {
-		_memcpy_toio(ehci->regs, ehci_fsl->saved_regs,
-						sizeof(struct ehci_regs));
-		out_be32(non_ehci + FSL_SOC_USB_CTRL, ehci_fsl->usb_ctrl);
-		kfree(ehci_fsl->saved_regs);
-		ehci_fsl->saved_regs = NULL;
-	}
+	if (phy_reg)
+		_memcpy_toio(phy_reg, (void *)&ehci_fsl->saved_phy_regs,
+				sizeof(struct ccsr_usb_phy));
+
+	_memcpy_toio(ehci->regs, (void *)&ehci_fsl->saved_regs,
+				sizeof(struct ehci_regs));
+	iowrite32be(ehci_fsl->usb_ctrl, non_ehci + FSL_SOC_USB_CTRL);
+
 	return 0;
 }
 
-- 
2.17.1

