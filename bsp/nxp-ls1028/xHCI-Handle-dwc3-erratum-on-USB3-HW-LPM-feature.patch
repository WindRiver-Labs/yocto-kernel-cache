From fc365d893d9936685fbaf7f507c5ee3f1fb7c42e Mon Sep 17 00:00:00 2001
From: Ran Wang <ran.wang_1@nxp.com>
Date: Fri, 5 Jan 2018 15:40:40 +0800
Subject: [PATCH 358/741] xHCI: Handle dwc3 erratum on USB3 HW LPM feature.

commit 4d92ba9633c328a6636a168e8062651431296c65 from
http://source.codeaurora.org/external/qoriq/qoriq-components/linux

Synopsys STARS ticket: 90000969472(A-010131)

Description: This erratum is applicable for the USB 3.0 Super
Speed host mode operation. When the U2 timer expires while in
U1 mode, the USB 3.0 controller completes a U1->U2 entry operation
lasting three mac3_clk (24 ns). If the xHCI driver issues a
U3 request during this operation, thecontroller drops this request.

Impact: The controller ignores the request when the xHCI driver
programs the U3 entry (PORTSC.PLS = U3).

Workaround:
1. Before initiating U3 entry, save PORTPMSC.
2. Disable U2 entry by programming PORTPMSC[U2 Timeout] = h'FF.
3. After U3 entry, re-enable the U2 timer by programming PORTPMSC
with the value saved in Step 1.

Signed-off-by: Ran Wang <ran.wang_1@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/usb/host/xhci-hub.c  | 22 ++++++++++++++++++++++
 drivers/usb/host/xhci-plat.c |  7 +++++++
 2 files changed, 29 insertions(+)

diff --git a/drivers/usb/host/xhci-hub.c b/drivers/usb/host/xhci-hub.c
index 1711113d1eb8..ac6253d85e66 100644
--- a/drivers/usb/host/xhci-hub.c
+++ b/drivers/usb/host/xhci-hub.c
@@ -671,6 +671,18 @@ void xhci_set_link_state(struct xhci_hcd *xhci, struct xhci_port *port,
 {
 	u32 temp;
 	u32 portsc;
+	u32 portpmsc_u2_backup = 0;
+
+        /* Backup U2 timeout info before initiating U3 entry erratum A-010131 */
+        if (xhci->shared_hcd->speed >= HCD_USB3 &&
+                        link_state == USB_SS_PORT_LS_U3 &&
+                        (xhci->quirks & XHCI_DIS_U1U2_WHEN_U3)) {
+                portpmsc_u2_backup = readl(port->addr + PORTPMSC);
+                portpmsc_u2_backup &= PORT_U2_TIMEOUT_MASK;
+                temp = readl(port->addr + PORTPMSC);
+                temp |= PORT_U2_TIMEOUT_MASK;
+                writel(temp, port->addr + PORTPMSC);
+        }
 
 	portsc = readl(port->addr);
 	temp = xhci_port_state_to_neutral(portsc);
@@ -678,6 +690,16 @@ void xhci_set_link_state(struct xhci_hcd *xhci, struct xhci_port *port,
 	temp |= PORT_LINK_STROBE | link_state;
 	writel(temp, port->addr);
 
+        /* Restore U2 timeout info after U3 entry complete */
+        if (xhci->shared_hcd->speed >= HCD_USB3 &&
+                        link_state == USB_SS_PORT_LS_U3 &&
+                        (xhci->quirks & XHCI_DIS_U1U2_WHEN_U3)) {
+                temp = readl(port->addr + PORTPMSC);
+                temp &= ~PORT_U2_TIMEOUT_MASK;
+                temp |= portpmsc_u2_backup;
+                writel(temp, port->addr + PORTPMSC);
+        }
+
 	xhci_dbg(xhci, "Set port %d-%d link state, portsc: 0x%x, write 0x%x",
 		 port->rhub->hcd->self.busnum, port->hcd_portnum + 1,
 		 portsc, temp);
diff --git a/drivers/usb/host/xhci-plat.c b/drivers/usb/host/xhci-plat.c
index 998241f5fce3..1720b0010d9a 100644
--- a/drivers/usb/host/xhci-plat.c
+++ b/drivers/usb/host/xhci-plat.c
@@ -281,6 +281,13 @@ static int xhci_plat_probe(struct platform_device *pdev)
 	/* imod_interval is the interrupt moderation value in nanoseconds. */
 	xhci->imod_interval = 40000;
 
+	if (device_property_read_bool(sysdev, "usb3-lpm-capable")) {
+		xhci->quirks |= XHCI_LPM_SUPPORT;
+		if (device_property_read_bool(sysdev,
+					"snps,dis-u1u2-when-u3-quirk"))
+			xhci->quirks |= XHCI_DIS_U1U2_WHEN_U3;
+	}
+
 	/* Iterate over all parent nodes for finding quirks */
 	for (tmpdev = &pdev->dev; tmpdev; tmpdev = tmpdev->parent) {
 
-- 
2.17.1

