From 47feb413af538d36a1f55bf8fba8f6e1e500afcf Mon Sep 17 00:00:00 2001
From: Yangbo Lu <yangbo.lu@nxp.com>
Date: Mon, 2 Sep 2019 15:33:16 +0800
Subject: [PATCH 631/741] sdk_fman: add an option for RTC (1588 timer)
 initialization and APIs

commit ceff25240d7af1c67323d7fb6936acfd637355c1 from
http://source.codeaurora.org/external/qoriq/qoriq-components/linux

The RTC (1588 timer) could be managed by either ptp_qoriq driver
or sdk_fman RTC driver. So add an option for sdk_fman RTC
(1588 timer) initialization and APIs, and the option is only
available when ptp_qoriq driver isn't enabled.

Signed-off-by: Yangbo Lu <yangbo.lu@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 .../net/ethernet/freescale/sdk_fman/Kconfig   |  8 +++++++
 .../sdk_fman/Peripherals/FM/Makefile          |  3 ++-
 .../freescale/sdk_fman/Peripherals/FM/fm.c    |  4 ++++
 .../src/inc/wrapper/lnxwrp_fsl_fman.h         | 22 +++++++++++++++++++
 .../sdk_fman/src/wrapper/lnxwrp_fm.c          | 18 ++++++++++-----
 5 files changed, 49 insertions(+), 6 deletions(-)

diff --git a/drivers/net/ethernet/freescale/sdk_fman/Kconfig b/drivers/net/ethernet/freescale/sdk_fman/Kconfig
index d98c0989005a..fcae38c4d23a 100644
--- a/drivers/net/ethernet/freescale/sdk_fman/Kconfig
+++ b/drivers/net/ethernet/freescale/sdk_fman/Kconfig
@@ -49,6 +49,14 @@ config FMAN_V3L
 endchoice
 endmenu
 
+config FSL_SDK_FMAN_RTC_API
+	bool "FMan RTC (1588 timer) APIs"
+	depends on !PTP_1588_CLOCK_QORIQ
+	default n
+	---help---
+		This option enables RTC (1588 timer) initialization and APIs support.
+		It is not available if ptp_qoriq driver is used for RTC (1588 timer).
+
 config FMAN_MIB_CNT_OVF_IRQ_EN
 	bool "Enable the dTSEC MIB counters overflow interrupt"
 	default n
diff --git a/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/Makefile b/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/Makefile
index 619f6608f5d1..65e8344d185e 100644
--- a/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/Makefile
+++ b/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/Makefile
@@ -19,5 +19,6 @@ obj-y		+= Pcd/
 obj-y		+= SP/
 obj-y		+= Port/
 obj-y		+= HC/
-obj-y		+= Rtc/
 obj-y		+= MACSEC/
+
+obj-$(CONFIG_FSL_SDK_FMAN_RTC_API)	+= Rtc/
diff --git a/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/fm.c b/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/fm.c
index a870b47e88bd..4a10c9e0108a 100644
--- a/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/fm.c
+++ b/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/fm.c
@@ -602,8 +602,10 @@ do {                                    \
         FM_G_CALL_10G_MAC_ISR(0);
     if (pending & INTR_EN_10G_MAC1)
         FM_G_CALL_10G_MAC_ISR(1);
+#ifdef CONFIG_FSL_SDK_FMAN_RTC_API
     if (pending & INTR_EN_TMR)
         p_Fm->intrMng[e_FM_EV_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_TMR].h_SrcHandle);
+#endif
 }
 
 #if (DPAA_VERSION >= 11)
@@ -4318,8 +4320,10 @@ void FM_EventIsr(t_Handle h_Fm)
         p_Fm->intrMng[e_FM_EV_PRS].f_Isr(p_Fm->intrMng[e_FM_EV_PRS].h_SrcHandle);
     if (pending & INTR_EN_PLCR)
         p_Fm->intrMng[e_FM_EV_PLCR].f_Isr(p_Fm->intrMng[e_FM_EV_PLCR].h_SrcHandle);
+#ifdef CONFIG_FSL_SDK_FMAN_RTC_API
     if (pending & INTR_EN_TMR)
             p_Fm->intrMng[e_FM_EV_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_TMR].h_SrcHandle);
+#endif
 
     /* MAC events may belong to different partitions */
     if (pending & INTR_EN_1G_MAC0)
diff --git a/drivers/net/ethernet/freescale/sdk_fman/src/inc/wrapper/lnxwrp_fsl_fman.h b/drivers/net/ethernet/freescale/sdk_fman/src/inc/wrapper/lnxwrp_fsl_fman.h
index c50031cfd032..d4183dcc693c 100644
--- a/drivers/net/ethernet/freescale/sdk_fman/src/inc/wrapper/lnxwrp_fsl_fman.h
+++ b/drivers/net/ethernet/freescale/sdk_fman/src/inc/wrapper/lnxwrp_fsl_fman.h
@@ -792,6 +792,7 @@ int fm_mac_set_rx_pause_frames(
 int fm_mac_set_tx_pause_frames(struct fm_mac_dev *fm_mac_dev,
 					     bool en);
 
+#ifdef CONFIG_FSL_SDK_FMAN_RTC_API
 int fm_rtc_enable(struct fm *fm_dev);
 
 int fm_rtc_disable(struct fm *fm_dev);
@@ -809,6 +810,27 @@ int fm_rtc_set_alarm(struct fm *fm_dev, uint32_t id,
 
 int fm_rtc_set_fiper(struct fm *fm_dev, uint32_t id,
 		uint64_t fiper);
+#else
+static inline int fm_rtc_enable(struct fm *fm_dev) { return 0; }
+
+static inline int fm_rtc_disable(struct fm *fm_dev) { return 0; }
+
+static inline int fm_rtc_get_cnt(struct fm *fm_dev, uint64_t *ts) { return 0; }
+
+static inline int fm_rtc_set_cnt(struct fm *fm_dev, uint64_t ts) { return 0; }
+
+static inline int fm_rtc_get_drift(struct fm *fm_dev, uint32_t *drift)
+{ return 0; }
+
+static inline int fm_rtc_set_drift(struct fm *fm_dev, uint32_t drift)
+{ return 0; }
+
+static inline int fm_rtc_set_alarm(struct fm *fm_dev, uint32_t id,
+				   uint64_t time) { return 0; }
+
+static inline int fm_rtc_set_fiper(struct fm *fm_dev, uint32_t id,
+				   uint64_t fiper) { return 0; }
+#endif
 
 int fm_mac_set_wol(struct fm_port *port, struct fm_mac_dev *fm_mac_dev,
 			bool en);
diff --git a/drivers/net/ethernet/freescale/sdk_fman/src/wrapper/lnxwrp_fm.c b/drivers/net/ethernet/freescale/sdk_fman/src/wrapper/lnxwrp_fm.c
index 08c94e36f871..b0d25a22a0eb 100755
--- a/drivers/net/ethernet/freescale/sdk_fman/src/wrapper/lnxwrp_fm.c
+++ b/drivers/net/ethernet/freescale/sdk_fman/src/wrapper/lnxwrp_fm.c
@@ -683,11 +683,7 @@ static t_LnxWrpFmDev * ReadFmDevTreeNode (struct platform_device *of_dev)
         }
     }
 
-/* DPAA PTP timer was managed by ptp_qoriq driver in drivers/ptp/.
- * We will no longer manage it in sdk_fman driver and use related
- * APIs.
- */
-#if 0
+#ifdef CONFIG_FSL_SDK_FMAN_RTC_API
     /* Get the RTC base address and size */
     memset(ids, 0, sizeof(ids));
     if (WARN_ON(strlen("ptp-timer") >= sizeof(ids[0].name)))
@@ -925,6 +921,7 @@ static t_Error ConfigureFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
     if (SYS_RegisterIoMap((uint64_t)p_LnxWrpFmDev->fmMuramBaseAddr, (uint64_t)p_LnxWrpFmDev->fmMuramPhysBaseAddr, p_LnxWrpFmDev->fmMuramMemSize) != E_OK)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM MURAM memory map"));
 
+#ifdef CONFIG_FSL_SDK_FMAN_RTC_API
     if (p_LnxWrpFmDev->fmRtcPhysBaseAddr)
     {
         dev_res = __devm_request_region(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->res, p_LnxWrpFmDev->fmRtcPhysBaseAddr, p_LnxWrpFmDev->fmRtcMemSize, "fman-ptp-timer");
@@ -938,6 +935,7 @@ static t_Error ConfigureFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
         if (SYS_RegisterIoMap((uint64_t)p_LnxWrpFmDev->fmRtcBaseAddr, (uint64_t)p_LnxWrpFmDev->fmRtcPhysBaseAddr, p_LnxWrpFmDev->fmRtcMemSize) != E_OK)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM-RTC memory map"));
     }
+#endif
 
 #if (DPAA_VERSION >= 11)
     if (p_LnxWrpFmDev->fmVspPhysBaseAddr) {
@@ -1171,6 +1169,7 @@ static t_Error InitFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
          * FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_MURAM_ECC,FALSE);*/
     }
 
+#ifdef CONFIG_FSL_SDK_FMAN_RTC_API
     if (p_LnxWrpFmDev->fmRtcBaseAddr)
     {
         t_FmRtcParams   fmRtcParam;
@@ -1189,6 +1188,7 @@ static t_Error InitFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
         if (FM_RTC_Init(p_LnxWrpFmDev->h_RtcDev) != E_OK)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM-RTC"));
     }
+#endif
 
     return E_OK;
 }
@@ -1203,8 +1203,10 @@ static void FreeFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
 
     FreeFmPcdDev(p_LnxWrpFmDev);
 
+#ifdef CONFIG_FSL_SDK_FMAN_RTC_API
     if (p_LnxWrpFmDev->h_RtcDev)
 	FM_RTC_Free(p_LnxWrpFmDev->h_RtcDev);
+#endif
 
     if (p_LnxWrpFmDev->h_Dev)
         FM_Free(p_LnxWrpFmDev->h_Dev);
@@ -1212,12 +1214,14 @@ static void FreeFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
     if (p_LnxWrpFmDev->h_MuramDev)
         FM_MURAM_Free(p_LnxWrpFmDev->h_MuramDev);
 
+#ifdef CONFIG_FSL_SDK_FMAN_RTC_API
     if (p_LnxWrpFmDev->fmRtcBaseAddr)
     {
         SYS_UnregisterIoMap(p_LnxWrpFmDev->fmRtcBaseAddr);
         devm_iounmap(p_LnxWrpFmDev->dev, UINT_TO_PTR(p_LnxWrpFmDev->fmRtcBaseAddr));
         __devm_release_region(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->res, p_LnxWrpFmDev->fmRtcPhysBaseAddr, p_LnxWrpFmDev->fmRtcMemSize);
     }
+#endif
     SYS_UnregisterIoMap(p_LnxWrpFmDev->fmMuramBaseAddr);
     devm_iounmap(p_LnxWrpFmDev->dev, UINT_TO_PTR(p_LnxWrpFmDev->fmMuramBaseAddr));
     __devm_release_region(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->res, p_LnxWrpFmDev->fmMuramPhysBaseAddr, p_LnxWrpFmDev->fmMuramMemSize);
@@ -1447,6 +1451,7 @@ void * fm_get_handle(struct fm *fm)
 }
 EXPORT_SYMBOL(fm_get_handle);
 
+#ifdef CONFIG_FSL_SDK_FMAN_RTC_API
 void * fm_get_rtc_handle(struct fm *fm)
 {
     t_LnxWrpFmDev       *p_LnxWrpFmDev = (t_LnxWrpFmDev*)fm;
@@ -1454,6 +1459,7 @@ void * fm_get_rtc_handle(struct fm *fm)
     return (void *)p_LnxWrpFmDev->h_RtcDev;
 }
 EXPORT_SYMBOL(fm_get_rtc_handle);
+#endif
 
 struct fm_port * fm_port_bind (struct device *fm_port_dev)
 {
@@ -2037,6 +2043,7 @@ int fm_mac_set_tx_pause_frames(struct fm_mac_dev *fm_mac_dev,
 #endif
 EXPORT_SYMBOL(fm_mac_set_tx_pause_frames);
 
+#ifdef CONFIG_FSL_SDK_FMAN_RTC_API
 int fm_rtc_enable(struct fm *fm_dev)
 {
 	int			 _errno;
@@ -2193,6 +2200,7 @@ int fm_rtc_disable_interrupt(struct fm *fm_dev, uint32_t events)
 }
 EXPORT_SYMBOL(fm_rtc_disable_interrupt);
 #endif
+#endif /* CONFIG_FSL_SDK_FMAN_RTC_API */
 
 int fm_mac_set_wol(struct fm_port *port, struct fm_mac_dev *fm_mac_dev, bool en)
 {
-- 
2.17.1

