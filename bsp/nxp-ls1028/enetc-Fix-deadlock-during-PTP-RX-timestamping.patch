From 52224f7c12337eb30fc33a1b4d2dbc6773cb2258 Mon Sep 17 00:00:00 2001
From: Vladimir Oltean <vladimir.oltean@nxp.com>
Date: Tue, 8 Oct 2019 14:42:06 +0300
Subject: [PATCH 677/741] enetc: Fix deadlock during PTP RX timestamping

commit 48c27bb2473d1bd727ff80b94750677c6457225f from
http://source.codeaurora.org/external/qoriq/qoriq-components/linux

The following call path leads to a dead lock:

enetc_clean_rx_ring
-> takes spin lock on &enetc_gregs
-> calls enetc_get_offloads
   -> calls enetc_get_rx_tstamp
      -> calls enetc_rd (which is a macro to enetc_rd_reg which is a
         macro to enetc_rd_reg_wa)
         -> takes a second spin lock on &enetc_gregs.

The solution is to use a register access macro that does not take the
global spin lock, as it is already held by the time enetc_get_rx_tstamp
is called.

Longer term, the register access helpers should be better annotated to
catch these issues automatically.

Fixes: 6907d6d1d1cc ("enetc: WA for MDIO register access issue")
Cc: Alex Marginean <alexandru.marginean@nxp.com>
Cc: Claudiu Manoil <claudiu.manoil@nxp.com>
Cc: Yangbo Lu <yangbo.lu@nxp.com>
Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/net/ethernet/freescale/enetc/enetc.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/drivers/net/ethernet/freescale/enetc/enetc.c b/drivers/net/ethernet/freescale/enetc/enetc.c
index 0fe28445a0b3..b6a41a907497 100644
--- a/drivers/net/ethernet/freescale/enetc/enetc.c
+++ b/drivers/net/ethernet/freescale/enetc/enetc.c
@@ -521,6 +521,7 @@ static int enetc_refill_rx_ring(struct enetc_bdr *rx_ring, const int buff_cnt)
 }
 
 #ifdef CONFIG_FSL_ENETC_HW_TIMESTAMPING
+/* Must be called with &enetc_gregs spinlock held */
 static void enetc_get_rx_tstamp(struct net_device *ndev,
 				union enetc_rx_bd *rxbd,
 				struct sk_buff *skb)
@@ -532,8 +533,8 @@ static void enetc_get_rx_tstamp(struct net_device *ndev,
 	u64 tstamp;
 
 	if (le16_to_cpu(rxbd->r.flags) & ENETC_RXBD_FLAG_TSTMP) {
-		lo = enetc_rd(hw, ENETC_SICTR0);
-		hi = enetc_rd(hw, ENETC_SICTR1);
+		lo = enetc_rd_reg_hot(hw->reg + ENETC_SICTR0);
+		hi = enetc_rd_reg_hot(hw->reg + ENETC_SICTR1);
 		tstamp_lo = le32_to_cpu(rxbd->r.tstamp);
 		if (lo <= tstamp_lo)
 			hi -= 1;
-- 
2.17.1

