From 716b515a5450b6de860815d80f2a25ecf0b6d34e Mon Sep 17 00:00:00 2001
From: "yinbo.zhu" <yinbo.zhu@nxp.com>
Date: Thu, 7 Sep 2017 11:40:45 +0800
Subject: [PATCH 378/741] usb: host: Implement workaround for Erratum A-009611

commit a834107b5288b46e2ae742f79fb1180e516a0f2d from
http://source.codeaurora.org/external/qoriq/qoriq-components/linux

This is a occasional problem where the software issues an End
Transfer command while a USB transfer is in progress,
resulting in the TxFIFO  being flushed when the lower layer is
waiting for data, causing the super speed (ss) transmit to get
blocked. If the End Transfer command is issued on an IN
endpoint to flush out the pending transfers when the same IN
endpoint is doing transfers on the USB, then depending upon
the timing of the End Transfer (and the resulting internal
flush),the lower layer (U3PTL/U3MAC) could get stuck waiting
for data indefinitely. This blocks the transmission path on
the SS, and no DP/ACK/ERDY/DEVNOTIF packets can be sent from
the device. Impact: If this issue happens and the transmission
gets blocked, then the USB host aborts and
resets/re-enumerates the device. This unblocks the transmitt
engine and the device functions normally.

Workaround: Software must wait for all existing TRBs to
complete before issuing End transfer command.

Configs Affected:
LS1088-48A-R1.0, LS2081A-R1.1, LS2088-48A-R1.0,
LS2088-48A-R1.1, LX2160-2120-2080A-R1.

Signed-off-by: yinbo zhu <yinbo.zhu@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/usb/dwc3/core.c      |  2 ++
 drivers/usb/dwc3/core.h      |  3 +++
 drivers/usb/dwc3/host.c      |  3 +++
 drivers/usb/host/xhci-plat.c |  4 ++++
 drivers/usb/host/xhci.c      | 25 +++++++++++++++++++------
 drivers/usb/host/xhci.h      |  1 +
 6 files changed, 32 insertions(+), 6 deletions(-)

diff --git a/drivers/usb/dwc3/core.c b/drivers/usb/dwc3/core.c
index d7772b511de0..33d6e981165f 100644
--- a/drivers/usb/dwc3/core.c
+++ b/drivers/usb/dwc3/core.c
@@ -1296,6 +1296,8 @@ static void dwc3_get_properties(struct dwc3 *dwc)
 
 	dwc->quirk_reverse_in_out = device_property_read_bool(dev,
 				"snps,quirk_reverse_in_out");
+	dwc->quirk_stop_transfer_in_block = device_property_read_bool(dev,
+				"snps,quirk_stop_transfer_in_block");
 	dwc->tx_de_emphasis_quirk = device_property_read_bool(dev,
 				"snps,tx_de_emphasis_quirk");
 	dwc->disable_devinit_u1u2_quirk = device_property_read_bool(dev,
diff --git a/drivers/usb/dwc3/core.h b/drivers/usb/dwc3/core.h
index abf45dc7cb34..e58812e818a0 100644
--- a/drivers/usb/dwc3/core.h
+++ b/drivers/usb/dwc3/core.h
@@ -1030,6 +1030,8 @@ struct dwc3_scratchpad_array {
  * 	3	- Reserved
  * @disable_devinit_u1u2_quirk: disable device-initiated U1/U2 request.
  * @quirk_reverse_in_out: prevent tx fifo reverse the data direction
+ * @quirk_stop_transfer_in_block: prevent block transmission from being
+ *				interrupted
  * @dis_metastability_quirk: set to disable metastability quirk.
  * @imod_interval: set the interrupt moderation interval in 250ns
  *                 increments or 0 to disable.
@@ -1216,6 +1218,7 @@ struct dwc3 {
 	unsigned		tx_de_emphasis:2;
 	unsigned		disable_devinit_u1u2_quirk:1;
 	unsigned        quirk_reverse_in_out:1;
+	unsigned        quirk_stop_transfer_in_block:1;
 
 	unsigned		dis_metastability_quirk:1;
 
diff --git a/drivers/usb/dwc3/host.c b/drivers/usb/dwc3/host.c
index e9a9a4e32b79..74f4021eb1cb 100644
--- a/drivers/usb/dwc3/host.c
+++ b/drivers/usb/dwc3/host.c
@@ -93,6 +93,9 @@ int dwc3_host_init(struct dwc3 *dwc)
 	if (dwc->quirk_reverse_in_out)
 		props[prop_idx++].name = "quirk-reverse-in-out";
 
+	if (dwc->quirk_stop_transfer_in_block)
+		props[prop_idx++].name = "quirk-stop-transfer-in-block";
+
 	if (dwc->usb3_lpm_capable)
 		props[prop_idx++].name = "usb3-lpm-capable";
 
diff --git a/drivers/usb/host/xhci-plat.c b/drivers/usb/host/xhci-plat.c
index 147a182ee159..bd39ee6b8128 100644
--- a/drivers/usb/host/xhci-plat.c
+++ b/drivers/usb/host/xhci-plat.c
@@ -297,6 +297,10 @@ static int xhci_plat_probe(struct platform_device *pdev)
 		if (device_property_read_bool(&pdev->dev, "quirk-reverse-in-out"))
 			xhci->quirks |= XHCI_REVERSE_IN_OUT;
 
+		if (device_property_read_bool(&pdev->dev,
+					"quirk-stop-transfer-in-block"))
+			xhci->quirks |= XHCI_STOP_TRANSFER_IN_BLOCK;
+
 		if (device_property_read_bool(&pdev->dev, "quirk-broken-port-ped"))
 			xhci->quirks |= XHCI_BROKEN_PORT_PED;
 
diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c
index d3dd7264c928..60fe91794364 100644
--- a/drivers/usb/host/xhci.c
+++ b/drivers/usb/host/xhci.c
@@ -1692,13 +1692,26 @@ static int xhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 			ret = -ENOMEM;
 			goto done;
 		}
-		ep->ep_state |= EP_STOP_CMD_PENDING;
-		ep->stop_cmd_timer.expires = jiffies +
+		/*
+		 *erratum A-009611: Issuing an End Transfer command on an IN
+		 *endpoint. when a transfer is in progress on USB blocks the
+		 *transmission.
+		 *Workaround: Software must wait for all existing TRBs to
+		 *complete before issuing End transfer command.
+		 */
+		if ((ep_ring->enqueue == ep_ring->dequeue &&
+				(xhci->quirks & XHCI_STOP_TRANSFER_IN_BLOCK)) ||
+				!(xhci->quirks & XHCI_STOP_TRANSFER_IN_BLOCK)) {
+			ep->ep_state |= EP_STOP_CMD_PENDING;
+			ep->stop_cmd_timer.expires = jiffies +
 			XHCI_STOP_EP_CMD_TIMEOUT * HZ;
-		add_timer(&ep->stop_cmd_timer);
-		xhci_queue_stop_endpoint(xhci, command, urb->dev->slot_id,
-					 ep_index, 0);
-		xhci_ring_cmd_db(xhci);
+			add_timer(&ep->stop_cmd_timer);
+			xhci_queue_stop_endpoint(xhci, command,
+					urb->dev->slot_id,
+					ep_index, 0);
+			xhci_ring_cmd_db(xhci);
+		}
+
 	}
 done:
 	spin_unlock_irqrestore(&xhci->lock, flags);
diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index e760fde91a9f..f41ed2632407 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1867,6 +1867,7 @@ struct xhci_hcd {
 #define XHCI_SNPS_BROKEN_SUSPEND    BIT_ULL(35)
 #define XHCI_DIS_U1U2_WHEN_U3  BIT_ULL(33)
 #define XHCI_REVERSE_IN_OUT     BIT_ULL(36)
+#define XHCI_STOP_TRANSFER_IN_BLOCK    BIT_ULL(37)
 
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
-- 
2.17.1

