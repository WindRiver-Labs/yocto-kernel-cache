From dd54d16394b8dc9af3e219470defa694a36355ff Mon Sep 17 00:00:00 2001
From: Camelia Groza <camelia.groza@nxp.com>
Date: Mon, 9 Dec 2019 17:18:02 +0200
Subject: [PATCH 706/741] sdk_dpaa: ceetm: enable building as a module

commit 0294047df14da09d0ea283f1da6fb8a5364bdd85 from
http://source.codeaurora.org/external/qoriq/qoriq-components/linux

Refactor the code to remove references to the undefined qdisc_lookup symbol.
Export the ceetm_tx symbol and fixup the Makefile.

Signed-off-by: Camelia Groza <camelia.groza@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 .../net/ethernet/freescale/sdk_dpaa/Makefile  |  4 +-
 .../freescale/sdk_dpaa/dpaa_eth_ceetm.c       | 49 ++++++++++++++-----
 2 files changed, 40 insertions(+), 13 deletions(-)

diff --git a/drivers/net/ethernet/freescale/sdk_dpaa/Makefile b/drivers/net/ethernet/freescale/sdk_dpaa/Makefile
index 9bcd36cf4faa..33c1c7652b13 100644
--- a/drivers/net/ethernet/freescale/sdk_dpaa/Makefile
+++ b/drivers/net/ethernet/freescale/sdk_dpaa/Makefile
@@ -17,9 +17,11 @@ endif
 ifeq ($(CONFIG_FSL_DPAA_1588),y)
 fsl_dpa-objs += dpaa_1588.o
 endif
+
 ifeq ($(CONFIG_FSL_DPAA_CEETM),y)
 ccflags-y += -I$(srctree)/drivers/net/ethernet/freescale/sdk_fman/src/wrapper
-fsl_dpa-objs += dpaa_eth_ceetm.o
+obj-$(CONFIG_FSL_SDK_DPAA_ETH) += fsl_ceetm.o
+fsl_ceetm-objs += dpaa_eth_ceetm.o
 endif
 
 fsl_mac-objs += mac.o mac-api.o
diff --git a/drivers/net/ethernet/freescale/sdk_dpaa/dpaa_eth_ceetm.c b/drivers/net/ethernet/freescale/sdk_dpaa/dpaa_eth_ceetm.c
index 7d77c24f15d7..afd456b51150 100644
--- a/drivers/net/ethernet/freescale/sdk_dpaa/dpaa_eth_ceetm.c
+++ b/drivers/net/ethernet/freescale/sdk_dpaa/dpaa_eth_ceetm.c
@@ -34,6 +34,8 @@
 #include "dpaa_eth_ceetm.h"
 
 #define DPA_CEETM_DESCRIPTION "FSL DPAA CEETM qdisc"
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_DESCRIPTION(DPA_CEETM_DESCRIPTION);
 
 const struct nla_policy ceetm_policy[TCA_CEETM_MAX + 1] = {
 	[TCA_CEETM_COPT] = { .len = sizeof(struct tc_ceetm_copt) },
@@ -813,8 +815,8 @@ static int ceetm_init_prio(struct Qdisc *sch, struct ceetm_qdisc *priv,
 	int err;
 	unsigned int i;
 	struct ceetm_class *parent_cl, *child_cl;
-	struct Qdisc *parent_qdisc;
 	struct net_device *dev = qdisc_dev(sch);
+	struct Qdisc *root_qdisc = dev->qdisc;
 
 	pr_debug(KBUILD_BASENAME " : %s : qdisc %X\n", __func__, sch->handle);
 
@@ -823,14 +825,18 @@ static int ceetm_init_prio(struct Qdisc *sch, struct ceetm_qdisc *priv,
 		return -EINVAL;
 	}
 
-	parent_qdisc = qdisc_lookup(dev, TC_H_MAJ(sch->parent));
-	if (strcmp(parent_qdisc->ops->id, ceetm_qdisc_ops.id)) {
+	if (TC_H_MAJ(sch->parent) != TC_H_MAJ(root_qdisc->handle)) {
+		pr_err("CEETM: a prio ceetm qdiscs can be added only under a root ceetm class\n");
+		return -EINVAL;
+	}
+
+	if (strcmp(root_qdisc->ops->id, ceetm_qdisc_ops.id)) {
 		pr_err("CEETM: a ceetm qdisc can not be attached to other qdisc/class types\n");
 		return -EINVAL;
 	}
 
 	/* Obtain the parent root ceetm_class */
-	parent_cl = ceetm_find(sch->parent, parent_qdisc);
+	parent_cl = ceetm_find(sch->parent, root_qdisc);
 
 	if (!parent_cl || parent_cl->type != CEETM_ROOT) {
 		pr_err("CEETM: a prio ceetm qdiscs can be added only under a root ceetm class\n");
@@ -904,8 +910,8 @@ static int ceetm_init_wbfs(struct Qdisc *sch, struct ceetm_qdisc *priv,
 	int err, group_b, small_group;
 	unsigned int i, id, prio_a, prio_b;
 	struct ceetm_class *parent_cl, *child_cl, *root_cl;
-	struct Qdisc *parent_qdisc;
-	struct ceetm_qdisc *parent_priv;
+	struct Qdisc *root_qdisc, *parent_qdisc = NULL;
+	struct ceetm_qdisc *root_priv;
 	struct net_device *dev = qdisc_dev(sch);
 
 	pr_debug(KBUILD_BASENAME " : %s : qdisc %X\n", __func__, sch->handle);
@@ -916,16 +922,36 @@ static int ceetm_init_wbfs(struct Qdisc *sch, struct ceetm_qdisc *priv,
 		return -EINVAL;
 	}
 
-	/* Obtain the parent prio ceetm qdisc */
-	parent_qdisc = qdisc_lookup(dev, TC_H_MAJ(sch->parent));
-	if (strcmp(parent_qdisc->ops->id, ceetm_qdisc_ops.id)) {
+	root_qdisc = dev->qdisc;
+
+	if (strcmp(root_qdisc->ops->id, ceetm_qdisc_ops.id)) {
 		pr_err("CEETM: a ceetm qdisc can not be attached to other qdisc/class types\n");
 		return -EINVAL;
 	}
 
+	root_priv = qdisc_priv(root_qdisc);
+
+	/* Obtain the root ceetm class and the parent prio ceetm qdisc */
+	for (i = 0; i < root_priv->clhash.hashsize; i++) {
+		hlist_for_each_entry(root_cl, &root_priv->clhash.hash[i],
+				     common.hnode) {
+			if (root_cl->root.child &&
+			    (TC_H_MAJ(root_cl->root.child->handle) ==
+			    TC_H_MAJ(sch->parent))) {
+				parent_qdisc = root_cl->root.child;
+				break;
+			}
+		}
+	}
+
+	if (!parent_qdisc ||
+	    strcmp(parent_qdisc->ops->id, ceetm_qdisc_ops.id)) {
+		pr_err("CEETM: a wbfs ceetm qdiscs can be added only under a prio ceetm class\n");
+		return -EINVAL;
+	}
+
 	/* Obtain the parent prio ceetm class */
 	parent_cl = ceetm_find(sch->parent, parent_qdisc);
-	parent_priv = qdisc_priv(parent_qdisc);
 
 	if (!parent_cl || parent_cl->type != CEETM_PRIO) {
 		pr_err("CEETM: a wbfs ceetm qdiscs can be added only under a prio ceetm class\n");
@@ -949,8 +975,6 @@ static int ceetm_init_wbfs(struct Qdisc *sch, struct ceetm_qdisc *priv,
 		return -EINVAL;
 	}
 
-	/* Obtain the parent root ceetm class */
-	root_cl = parent_priv->prio.parent;
 	if ((root_cl->root.wbfs_grp_a && root_cl->root.wbfs_grp_b) ||
 	    root_cl->root.wbfs_grp_large) {
 		pr_err("CEETM: no more wbfs classes are available\n");
@@ -2055,6 +2079,7 @@ int __hot ceetm_tx(struct sk_buff *skb, struct net_device *net_dev)
 	dev_kfree_skb_any(skb);
 	return NET_XMIT_SUCCESS;
 }
+EXPORT_SYMBOL(ceetm_tx);
 
 static int __init ceetm_register(void)
 {
-- 
2.17.1

