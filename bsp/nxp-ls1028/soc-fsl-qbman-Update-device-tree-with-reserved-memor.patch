From 4ffbd5903932432dd352a49e19f5598172940fc9 Mon Sep 17 00:00:00 2001
From: Roy Pledge <roy.pledge@nxp.com>
Date: Tue, 30 Apr 2019 14:17:05 -0400
Subject: [PATCH 521/741] soc/fsl/qbman: Update device tree with reserved
 memory

commit 55784545a21c6ee5e307e101bb935d820c7ffe12 from
http://source.codeaurora.org/external/qoriq/qoriq-components/linux

When using the reserved memory node in the device tree there are
two options - dynamic or static. If a dynamic allocation was
selected (where the kernel selects the address for the allocation)
convert it to a static allocation by inserting the reg property.
This will ensure the same memory is reused after a kexec()

Signed-off-by: Roy Pledge <roy.pledge@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/soc/fsl/qbman/dpaa_sys.c | 59 +++++++++++++++++++-------------
 1 file changed, 35 insertions(+), 24 deletions(-)

diff --git a/drivers/soc/fsl/qbman/dpaa_sys.c b/drivers/soc/fsl/qbman/dpaa_sys.c
index 04a7b223a4f3..c1315ec64c9a 100644
--- a/drivers/soc/fsl/qbman/dpaa_sys.c
+++ b/drivers/soc/fsl/qbman/dpaa_sys.c
@@ -37,41 +37,52 @@
 int qbman_init_private_mem(struct device *dev, int idx, dma_addr_t *addr,
 				size_t *size)
 {
-	int ret;
 	struct device_node *mem_node;
-	u64 size64;
 	struct reserved_mem *rmem;
+        struct property *prop;
+        int len, err;
+        __be32 *res_array;
 
-	ret = of_reserved_mem_device_init_by_idx(dev, dev->of_node, idx);
-	if (ret) {
-		dev_err(dev,
-			"of_reserved_mem_device_init_by_idx(%d) failed 0x%x\n",
-			idx, ret);
-		return -ENODEV;
-	}
 	mem_node = of_parse_phandle(dev->of_node, "memory-region", idx);
-	if (mem_node) {
-		ret = of_property_read_u64(mem_node, "size", &size64);
-		if (ret) {
-			dev_err(dev, "of_address_to_resource fails 0x%x\n",
-			        ret);
-			return -ENODEV;
-		}
-		*size = size64;
-	} else {
+	if (!mem_node) {	
 		dev_err(dev, "No memory-region found for index %d\n", idx);
 		return -ENODEV;
 	}
 
         rmem = of_reserved_mem_lookup(mem_node);
+        if (!rmem) {
+                dev_err(dev, "of_reserved_mem_lookup() returned NULL\n");
+                return -ENODEV;
+        }
         *addr = rmem->base;
-
+	*size = rmem->size;
 	/*
-	 * Disassociate the reserved memory area from the device
-	 * because a device can only have one DMA memory area. This
-	 * should be fine since the memory is allocated and initialized
-	 * and only ever accessed by the QBMan device from now on
+         * Check if the reg property exists - if not insert the node
+         * so upon kexec() the same memory region address will be preserved.
+         * This is needed because QBMan HW does not allow the base address/
+         * size to be modified once set.
 	 */
-	of_reserved_mem_device_release(dev);
+        prop = of_find_property(mem_node, "reg", &len);
+        if (!prop) {
+                prop = devm_kzalloc(dev, sizeof(*prop), GFP_KERNEL);
+                if (!prop)
+                        return -ENOMEM;
+                prop->value = res_array = devm_kzalloc(dev, sizeof(__be32) * 4,
+                                                       GFP_KERNEL);
+                if (!prop->value)
+                        return -ENOMEM;
+                res_array[0] = cpu_to_be32(upper_32_bits(*addr));
+                res_array[1] = cpu_to_be32(lower_32_bits(*addr));
+                res_array[2] = cpu_to_be32(upper_32_bits(*size));
+                res_array[3] = cpu_to_be32(lower_32_bits(*size));
+                prop->length = sizeof(__be32) * 4;
+                prop->name = devm_kstrdup(dev, "reg", GFP_KERNEL);
+                if (!prop->name)
+                        return -ENOMEM;
+                err = of_add_property(mem_node, prop);
+                if (err)
+                        return err;
+        }
+	
 	return 0;
 }
-- 
2.17.1

