From 5a56351687ee23b7577f18fe3660ead786a00487 Mon Sep 17 00:00:00 2001
From: Wen He <wen.he_1@nxp.com>
Date: Sun, 5 May 2019 15:09:30 +0800
Subject: [PATCH 503/741] drm/imx/hdp: Add the Display Transmitter Controller
 driver support for ls1028a

commit 270b923aa6bddb9be0fed4b2cf8d76332111f7f8 from
http://source.codeaurora.org/external/qoriq/qoriq-components/linux

This patch add the driver support for ls1028a Display Transmitter Controller.

Now DTC on ls1028a has the following features in this patch:
- Support Display resolution up to 4k@60, the following resolutions are also
supported.
        - 1080p@60, 720p@60, 480p@60;
- Support Display Port interface.
- Support manual specify monitor supported resloutions list in dts node.
- Support detect connector hotplug events.
- Doesn't support the EDID function.

Signed-off-by: Alison Wang <alison.wang@nxp.com>
Signed-off-by: Jiafei Pan <jiafei.pan@nxp.com>
Signed-off-by: Wen He <wen.he_1@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/gpu/drm/imx/Kconfig       |   6 +-
 drivers/gpu/drm/imx/Makefile      |   1 +
 drivers/gpu/drm/imx/hdp/imx-hdp.c | 482 +++++++++++++++++++++++++++---
 drivers/gpu/drm/imx/hdp/imx-hdp.h |  24 ++
 4 files changed, 463 insertions(+), 50 deletions(-)

diff --git a/drivers/gpu/drm/imx/Kconfig b/drivers/gpu/drm/imx/Kconfig
index 207bf7409dfb..d5ac70600e8b 100644
--- a/drivers/gpu/drm/imx/Kconfig
+++ b/drivers/gpu/drm/imx/Kconfig
@@ -5,8 +5,8 @@ config DRM_IMX
 	select VIDEOMODE_HELPERS
 	select DRM_GEM_CMA_HELPER
 	select DRM_KMS_CMA_HELPER
-	depends on DRM && (ARCH_MXC || ARCH_MULTIPLATFORM || COMPILE_TEST)
-	depends on IMX_IPUV3_CORE
+	depends on DRM && (ARCH_MXC || ARCH_LAYERSCAPE || ARCH_MULTIPLATFORM || COMPILE_TEST)
+	depends on IMX_IPUV3_CORE || DRM_MALI_DISPLAY
 	help
 	  enable i.MX graphics support
 
@@ -39,3 +39,5 @@ config DRM_IMX_HDMI
 	depends on DRM_IMX
 	help
 	  Choose this if you want to use HDMI on i.MX6.
+
+source "drivers/gpu/drm/imx/hdp/Kconfig"
diff --git a/drivers/gpu/drm/imx/Makefile b/drivers/gpu/drm/imx/Makefile
index ab6c83caceb7..884f7e8f166b 100644
--- a/drivers/gpu/drm/imx/Makefile
+++ b/drivers/gpu/drm/imx/Makefile
@@ -10,3 +10,4 @@ obj-$(CONFIG_DRM_IMX_LDB) += imx-ldb.o
 
 obj-$(CONFIG_DRM_IMX_IPUV3)	+= imx-ipuv3-crtc.o
 obj-$(CONFIG_DRM_IMX_HDMI) += dw_hdmi-imx.o
+obj-$(CONFIG_DRM_IMX_HDP) += hdp/
diff --git a/drivers/gpu/drm/imx/hdp/imx-hdp.c b/drivers/gpu/drm/imx/hdp/imx-hdp.c
index 4778a5d5c0c6..245052bb1b37 100644
--- a/drivers/gpu/drm/imx/hdp/imx-hdp.c
+++ b/drivers/gpu/drm/imx/hdp/imx-hdp.c
@@ -72,6 +72,36 @@ static void imx_hdp_state_init(struct imx_hdp *hdp)
 	state->edp = hdp->is_edp;
 }
 
+static void ls1028a_pixel_link_mux(state_struct *state,
+				   const struct drm_display_mode *mode)
+{
+	struct imx_hdp *hdp = state_to_imx_hdp(state);
+	u32 val;
+
+	if (mode->hdisplay == 3840
+	    && mode->vdisplay == 2160)
+		val = 0x0402002c;
+	else if (mode->hdisplay == 1920
+		 && mode->vdisplay == 1080)
+		val = 0x1002002c;
+	else if (mode->hdisplay == 1280
+		 && mode->vdisplay == 720)
+		val = 0x2002002c;
+	else if (mode->hdisplay == 720
+		 && mode->vdisplay == 480)
+		val = 0x5802002c;
+	else
+		/* Set deafault pixel clock to 1080p*/
+		val = 0x1002002c;
+
+	writel(val, hdp->mem.ss_base + CSR_PLLDIG_PLLDV);
+
+	/* Recommend register set for PLL Divider */
+	writel(0x40000000, hdp->mem.ss_base + CSR_PLLDIG_PLLFM);
+	writel(0x40030000, hdp->mem.ss_base + CSR_PLLDIG_PLLFD);
+	writel(0x44000000, hdp->mem.ss_base + CSR_PLLDIG_PLLCAL1);
+	writel(0x0005002b, hdp->mem.ss_base + CSR_PLLDIG_PLLCAL2);
+}
 static void imx8qm_pixel_link_mux(state_struct *state,
 				  const struct drm_display_mode *mode)
 {
@@ -89,6 +119,7 @@ static void imx8qm_pixel_link_mux(state_struct *state,
 	writel(val, hdp->mem.ss_base + CSR_PIXEL_LINK_MUX_CTL);
 }
 
+#ifndef CONFIG_ARCH_LAYERSCAPE
 static int imx8qm_pixel_link_validate(state_struct *state)
 {
 	struct imx_hdp *hdp = state_to_imx_hdp(state);
@@ -245,6 +276,137 @@ void imx8mq_phy_reset(sc_ipc_t ipcHndl, struct hdp_mem *mem, u8 reset)
 
 	return;
 }
+#endif
+
+static const struct of_device_id scfg_device_ids[] = {
+	{ .compatible = "fsl,ls1028a-scfg", },
+	{}
+};
+
+void ls1028a_phy_reset(uint32_t ipcHndl, struct hdp_mem *mem, u8 reset)
+{
+	struct device_node *scfg_node;
+	void __iomem *scfg_base = NULL;
+
+	scfg_node = of_find_matching_node(NULL, scfg_device_ids);
+	if (scfg_node)
+		scfg_base = of_iomap(scfg_node, 0);
+
+	iowrite32(reset, scfg_base + EDP_PHY_RESET);
+}
+
+int ls1028a_clock_init(struct hdp_clks *clks)
+{
+	struct imx_hdp *hdp = clks_to_imx_hdp(clks);
+	struct device *dev = hdp->dev;
+
+	clks->clk_ipg = devm_clk_get(dev, "clk_ipg");
+	if (IS_ERR(clks->clk_ipg)) {
+		dev_warn(dev, "failed to get dp ipg clk\n");
+		return PTR_ERR(clks->clk_ipg);
+	}
+
+	clks->clk_core = devm_clk_get(dev, "clk_core");
+	if (IS_ERR(clks->clk_core)) {
+		dev_warn(dev, "failed to get hdp core clk\n");
+		return PTR_ERR(clks->clk_core);
+	}
+
+	clks->clk_pxl = devm_clk_get(dev, "clk_pxl");
+	if (IS_ERR(clks->clk_pxl)) {
+		dev_warn(dev, "failed to get pxl clk\n");
+		return PTR_ERR(clks->clk_pxl);
+	}
+
+	clks->clk_pxl_mux = devm_clk_get(dev, "clk_pxl_mux");
+	if (IS_ERR(clks->clk_pxl_mux)) {
+		dev_warn(dev, "failed to get pxl mux clk\n");
+		return PTR_ERR(clks->clk_pxl_mux);
+	}
+
+	clks->clk_pxl_link = devm_clk_get(dev, "clk_pxl_link");
+	if (IS_ERR(clks->clk_pxl_mux)) {
+		dev_warn(dev, "failed to get pxl link clk\n");
+		return PTR_ERR(clks->clk_pxl_link);
+	}
+
+	if (IS_ERR(clks->clk_apb)) {
+		dev_warn(dev, "failed to get apb clk\n");
+		return PTR_ERR(clks->clk_apb);
+	}
+
+	clks->clk_vif = devm_clk_get(dev, "clk_vif");
+	if (IS_ERR(clks->clk_vif)) {
+		dev_warn(dev, "failed to get vif clk\n");
+		return PTR_ERR(clks->clk_vif);
+	}
+
+	return true;
+
+}
+
+int ls1028a_pixel_clock_enable(struct hdp_clks *clks)
+{
+	struct imx_hdp *hdp = clks_to_imx_hdp(clks);
+	struct device *dev = hdp->dev;
+	int ret;
+
+	ret = clk_prepare_enable(clks->clk_pxl);
+	if (ret < 0) {
+		dev_err(dev, "%s, pre clk pxl error\n", __func__);
+		return ret;
+	}
+	ret = clk_prepare_enable(clks->clk_pxl_mux);
+	if (ret < 0) {
+		dev_err(dev, "%s, pre clk pxl mux error\n", __func__);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(clks->clk_pxl_link);
+	if (ret < 0) {
+		dev_err(dev, "%s, pre clk pxl link error\n", __func__);
+		return ret;
+	}
+	ret = clk_prepare_enable(clks->clk_vif);
+	if (ret < 0) {
+		dev_err(dev, "%s, pre clk vif error\n", __func__);
+		return ret;
+	}
+	return ret;
+
+}
+
+void ls1028a_pixel_clock_disable(struct hdp_clks *clks)
+{
+	clk_disable_unprepare(clks->clk_vif);
+	clk_disable_unprepare(clks->clk_pxl);
+	clk_disable_unprepare(clks->clk_pxl_link);
+	clk_disable_unprepare(clks->clk_pxl_mux);
+}
+
+int ls1028a_ipg_clock_enable(struct hdp_clks *clks)
+{
+	int ret;
+	struct imx_hdp *hdp = clks_to_imx_hdp(clks);
+	struct device *dev = hdp->dev;
+
+	ret = clk_prepare_enable(clks->clk_ipg);
+	if (ret < 0) {
+		dev_err(dev, "%s, pre clk_ipg error\n", __func__);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(clks->clk_apb);
+	if (ret < 0) {
+		dev_err(dev, "%s, pre clk apb error\n", __func__);
+		return ret;
+	}
+	return ret;
+}
+
+void ls1028a_ipg_clock_disable(struct hdp_clks *clks)
+{
+}
 
 int imx8qm_clock_init(struct hdp_clks *clks)
 {
@@ -523,7 +685,11 @@ void imx8qm_ipg_clock_set_rate(struct hdp_clks *clks)
 	if (hdp->is_digpll_dp_pclock)
 		desired_rate = PLL_1188MHZ;
 	else
-		desired_rate = PLL_800MHZ;
+#ifndef CONFIG_ARCH_LAYERSCAPE
+		desired_rate =  PLL_800MHZ;
+#else
+		desired_rate = PLL_675MHZ;
+#endif
 
 	/* hdmi/dp ipg/core clock */
 	clk_rate = clk_get_rate(clks->dig_pll);
@@ -548,7 +714,11 @@ void imx8qm_ipg_clock_set_rate(struct hdp_clks *clks)
 
 static u8 imx_hdp_link_rate(struct drm_display_mode *mode)
 {
+#ifndef CONFIG_ARCH_LAYERSCAPE
 	if (mode->clock < 297000)
+#else
+	if (mode->clock < 74250)
+#endif
 		return AFE_LINK_RATE_1_6;
 	else if (mode->clock > 297000)
 		return AFE_LINK_RATE_5_4;
@@ -618,7 +788,9 @@ static void imx_hdp_bridge_enable(struct drm_bridge *bridge)
 	 * to another 8-bit mode, or from 8-bit to 10-bit, we can safely do it
 	 * all the time.
 	 */
+#ifndef CONFIG_ARCH_LAYERSCAPE
 	if (cpu_is_imx8mq())
+#endif
 		imx_hdp_call(hdp, pixel_engine_reset, &hdp->state);
 }
 
@@ -650,6 +822,10 @@ imx_hdp_connector_detect(struct drm_connector *connector, bool force)
 static int imx_hdp_default_video_modes(struct drm_connector *connector)
 {
 	struct drm_display_mode *mode;
+#ifdef CONFIG_ARCH_LAYERSCAPE
+	struct imx_hdp *hdp = container_of(connector, struct imx_hdp,
+					   connector);
+#endif
 	int i;
 
 	for (i = 0; i < ARRAY_SIZE(edid_cea_modes); i++) {
@@ -657,6 +833,10 @@ static int imx_hdp_default_video_modes(struct drm_connector *connector)
 		if (!mode)
 			return -EINVAL;
 		drm_mode_copy(mode, &edid_cea_modes[i]);
+#ifdef CONFIG_ARCH_LAYERSCAPE
+		if (hdp->num_res != 0 && edid_cea_modes_enabled[i] == 0)
+			continue;
+#endif
 		mode->type |= DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
 		drm_mode_probed_add(connector, mode);
 	}
@@ -903,6 +1083,26 @@ static int imx8qm_hdp_swrite(struct hdp_mem *mem,
 	return 0;
 }
 
+static int ls1028a_hdp_read(struct hdp_mem *mem, unsigned int addr,
+			    unsigned int *value)
+{
+	unsigned int temp;
+	void *tmp_addr = mem->regs_base + addr;
+
+	temp = __raw_readl((unsigned int *)tmp_addr);
+	*value = temp;
+	return 0;
+}
+
+static int ls1028a_hdp_write(struct hdp_mem *mem, unsigned int addr,
+			     unsigned int value)
+{
+	void *tmp_addr = mem->regs_base + addr;
+
+	__raw_writel(value, (unsigned int *)tmp_addr);
+	return 0;
+}
+
 static struct hdp_rw_func imx8qm_rw = {
 	.read_reg = imx8qm_hdp_read,
 	.write_reg = imx8qm_hdp_write,
@@ -919,12 +1119,15 @@ static struct hdp_ops imx8qm_dp_ops = {
 	.mode_set = dp_mode_set,
 	.get_edid_block = dp_get_edid_block,
 	.get_hpd_state = dp_get_hpd_state,
+#ifndef CONFIG_ARCH_LAYERSCAPE
 	.phy_reset = imx8qm_phy_reset,
 	.pixel_link_validate = imx8qm_pixel_link_validate,
 	.pixel_link_invalidate = imx8qm_pixel_link_invalidate,
 	.pixel_link_sync_ctrl_enable = imx8qm_pixel_link_sync_ctrl_enable,
 	.pixel_link_sync_ctrl_disable = imx8qm_pixel_link_sync_ctrl_disable,
+#endif
 	.pixel_link_mux = imx8qm_pixel_link_mux,
+
 	.clock_init = imx8qm_clock_init,
 	.ipg_clock_set_rate = imx8qm_ipg_clock_set_rate,
 	.ipg_clock_enable = imx8qm_ipg_clock_enable,
@@ -939,6 +1142,7 @@ static struct hdp_ops imx8qm_hdmi_ops = {
 	.fw_load = hdp_fw_load,
 #endif
 	.fw_init = hdp_fw_init,
+#ifndef CONFIG_ARCH_LAYERSCAPE
 	.phy_init = hdmi_phy_init_ss28fdsoi,
 	.mode_set = hdmi_mode_set_ss28fdsoi,
 	.get_edid_block = hdmi_get_edid_block,
@@ -949,6 +1153,7 @@ static struct hdp_ops imx8qm_hdmi_ops = {
 	.pixel_link_invalidate = imx8qm_pixel_link_invalidate,
 	.pixel_link_sync_ctrl_enable = imx8qm_pixel_link_sync_ctrl_enable,
 	.pixel_link_sync_ctrl_disable = imx8qm_pixel_link_sync_ctrl_disable,
+#endif
 	.pixel_link_mux = imx8qm_pixel_link_mux,
 
 	.clock_init = imx8qm_clock_init,
@@ -978,6 +1183,7 @@ static struct hdp_rw_func imx8mq_rw = {
 };
 
 static struct hdp_ops imx8mq_ops = {
+#ifndef CONFIG_ARCH_LAYERSCAPE
 	.fw_init = hdp_fw_check,
 	.phy_init = hdmi_phy_init_t28hpc,
 	.mode_set = hdmi_mode_set_t28hpc,
@@ -987,6 +1193,7 @@ static struct hdp_ops imx8mq_ops = {
 	.write_hdr_metadata = hdmi_write_hdr_metadata,
 	.pixel_clock_range = pixel_clock_range_t28hpc,
 	.pixel_engine_reset = hdmi_phy_pix_engine_reset_t28hpc,
+#endif
 };
 
 static struct hdp_devtype imx8mq_hdmi_devtype = {
@@ -999,7 +1206,9 @@ static struct hdp_ops imx8mq_dp_ops = {
 	.mode_set = dp_mode_set,
 	.get_edid_block = dp_get_edid_block,
 	.get_hpd_state = dp_get_hpd_state,
+#ifndef CONFIG_ARCH_LAYERSCAPE
 	.phy_reset = imx8mq_phy_reset,
+#endif
 };
 
 static struct hdp_devtype imx8mq_dp_devtype = {
@@ -1008,11 +1217,40 @@ static struct hdp_devtype imx8mq_dp_devtype = {
 };
 
 
+static struct hdp_rw_func ls1028a_rw = {
+	.read_reg = ls1028a_hdp_read,
+	.write_reg = ls1028a_hdp_write,
+};
+
+static struct hdp_ops ls1028a_dp_ops = {
+#ifdef DEBUG_FW_LOAD
+	.fw_load = hdp_fw_load,
+#endif
+	.fw_init = hdp_fw_init,
+	.phy_init = dp_phy_init_t28hpc,
+	.mode_set = dp_mode_set,
+	.get_edid_block = dp_get_edid_block,
+	.get_hpd_state = dp_get_hpd_state,
+	.phy_reset = ls1028a_phy_reset,
+	.pixel_link_mux = ls1028a_pixel_link_mux,
+	.clock_init = ls1028a_clock_init,
+	.ipg_clock_enable = ls1028a_ipg_clock_enable,
+	.ipg_clock_disable = ls1028a_ipg_clock_disable,
+	.pixel_clock_set_rate = imx8qm_dp_pixel_clock_set_rate,
+	.pixel_clock_enable = ls1028a_pixel_clock_enable,
+	.pixel_clock_disable = ls1028a_pixel_clock_disable,
+};
+
+static struct hdp_devtype ls1028a_dp_devtype = {
+	.ops = &ls1028a_dp_ops,
+	.rw = &ls1028a_rw,
+};
 static const struct of_device_id imx_hdp_dt_ids[] = {
 	{ .compatible = "fsl,imx8qm-hdmi", .data = &imx8qm_hdmi_devtype},
 	{ .compatible = "fsl,imx8qm-dp", .data = &imx8qm_dp_devtype},
 	{ .compatible = "fsl,imx8mq-hdmi", .data = &imx8mq_hdmi_devtype},
 	{ .compatible = "fsl,imx8mq-dp", .data = &imx8mq_dp_devtype},
+	{ .compatible = "fsl,ls1028a-dp", .data = &ls1028a_dp_devtype},
 	{ }
 };
 MODULE_DEVICE_TABLE(of, imx_hdp_dt_ids);
@@ -1034,11 +1272,17 @@ static void hotplug_work_func(struct work_struct *work)
 				   &edid_cea_modes[g_default_mode]))
 			imx_hdp_mode_setup(hdp, &hdp->video.pre_mode);
 		DRM_INFO("HDMI/DP Cable Plug In\n");
-		enable_irq(hdp->irq[HPD_IRQ_OUT]);
+#ifdef CONFIG_ARCH_LAYERSCAPE
+		if (hdp->is_hpd_irq)
+#endif
+			enable_irq(hdp->irq[HPD_IRQ_OUT]);
 	} else if (connector->status == connector_status_disconnected) {
 		/* Cable Disconnedted  */
 		DRM_INFO("HDMI/DP Cable Plug Out\n");
-		enable_irq(hdp->irq[HPD_IRQ_IN]);
+#ifdef CONFIG_ARCH_LAYERSCAPE
+		if (hdp->is_hpd_irq)
+#endif
+			enable_irq(hdp->irq[HPD_IRQ_IN]);
 	}
 }
 
@@ -1054,6 +1298,76 @@ static irqreturn_t imx_hdp_irq_thread(int irq, void *data)
 	return IRQ_HANDLED;
 }
 
+static int imx_hdp_hpd_thread(void *data)
+{
+	struct imx_hdp *hdp = data;
+
+	mod_delayed_work(system_wq, &hdp->hotplug_work,
+			msecs_to_jiffies(HOTPLUG_DEBOUNCE_MS));
+
+	return 0;
+}
+
+static int parse_enable_res(const char *resolution)
+{
+	const char *name;
+	unsigned int namelen;
+	int xres = 0, yres = 0, refresh = 0;
+	int i;
+	bool is_digi = false;
+
+	name = resolution;
+	namelen = strlen(name);
+	for (i = namelen-1; i >= 0; i--) {
+		switch (name[i]) {
+		case '@':
+			if (is_digi) {
+				refresh = simple_strtol(&name[i+1], NULL, 10);
+				is_digi = false;
+			}
+			break;
+		case 'x':
+			if (is_digi) {
+				yres = simple_strtol(&name[i+1], NULL, 10);
+				is_digi = false;
+			}
+			break;
+		case '0' ... '9':
+			is_digi = true;
+			break;
+		default:
+			DRM_WARN("Enable resolution %s failed\n", resolution);
+			break;
+		}
+	}
+	if (i < 0 && is_digi) {
+		char *ch;
+
+		xres = simple_strtol(name, &ch, 10);
+		if (*ch != 'x')
+			goto done;
+	} else
+		goto done;
+
+
+	for (i = 0; i < ARRAY_SIZE(edid_cea_modes); i++) {
+		if (edid_cea_modes[i].hdisplay == xres &&
+				edid_cea_modes[i].vdisplay == yres &&
+				edid_cea_modes[i].vrefresh == refresh) {
+			edid_cea_modes_enabled[i] = 1;
+			DRM_INFO("Resolution %dx%d@%d is enabled\n",
+							xres, yres, refresh);
+		}
+	}
+
+	return 0;
+
+done:
+	DRM_WARN("Enable resolution %s failed\n", resolution);
+
+	return 1;
+}
+
 static int imx_hdp_imx_bind(struct device *dev, struct device *master,
 			    void *data)
 {
@@ -1067,6 +1381,11 @@ static int imx_hdp_imx_bind(struct device *dev, struct device *master,
 	struct drm_bridge *bridge;
 	struct drm_connector *connector;
 	struct resource *res;
+#ifdef CONFIG_ARCH_LAYERSCAPE
+	struct task_struct *hpd_thread;
+	const char *resolution;
+	int i;
+#endif
 	u8 hpd;
 	int ret;
 
@@ -1084,18 +1403,26 @@ static int imx_hdp_imx_bind(struct device *dev, struct device *master,
 
 	mutex_init(&hdp->mutex);
 
-	hdp->irq[HPD_IRQ_IN] =
-		platform_get_irq_byname(pdev, "plug_in");
-	if (hdp->irq[HPD_IRQ_IN] < 0)
-		dev_info(&pdev->dev, "No plug_in irq number\n");
+	hdp->is_hpd_irq = true;
+#ifdef CONFIG_ARCH_LAYERSCAPE
+	hdp->is_hpd_irq = of_property_read_bool(pdev->dev.of_node,
+						"fsl,hpd_irq");
+	if (hdp->is_hpd_irq)
+#endif
+	{       hdp->irq[HPD_IRQ_IN] =
+			platform_get_irq_byname(pdev, "plug_in");
+		if (hdp->irq[HPD_IRQ_IN] < 0)
+			dev_info(&pdev->dev, "No plug_in irq number\n");
 
-	hdp->irq[HPD_IRQ_OUT] =
-		platform_get_irq_byname(pdev, "plug_out");
-	if (hdp->irq[HPD_IRQ_OUT] < 0)
-		dev_info(&pdev->dev, "No plug_out irq number\n");
+		hdp->irq[HPD_IRQ_OUT] =
+			platform_get_irq_byname(pdev, "plug_out");
+		if (hdp->irq[HPD_IRQ_OUT] < 0)
+			dev_info(&pdev->dev, "No plug_out irq number\n");
+	}
 
 	mutex_init(&hdp->mem.mutex);
 
+#ifndef CONFIG_ARCH_LAYERSCAPE
 	/* register map */
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	hdp->mem.regs_base = devm_ioremap_resource(dev, res);
@@ -1115,15 +1442,59 @@ static int imx_hdp_imx_bind(struct device *dev, struct device *master,
 	hdp->mem.rst_base = devm_ioremap_resource(dev, res);
 	if (IS_ERR(hdp->mem.rst_base))
 		dev_warn(dev, "Failed to get HDP RESET base register\n");
+#else
+
+	/* multimeida register map */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	hdp->mem.ss_base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(hdp->mem.ss_base)) {
+		dev_err(dev, "Failed to get Multimedia PLL base register\n");
+		return -EINVAL;
+	}
+
+	/* register map */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	hdp->mem.regs_base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(hdp->mem.regs_base)) {
+		dev_err(dev, "Failed to get HDP CTRL base register\n");
+		return -EINVAL;
+	}
 
+#endif
 
 	hdp->is_edp = of_property_read_bool(pdev->dev.of_node, "fsl,edp");
 
 	hdp->no_edid = of_property_read_bool(pdev->dev.of_node, "fsl,no_edid");
-
+#ifndef CONFIG_ARCH_LAYERSCAPE
 	/* EDID function is not supported by iMX8QM A0 */
 	if (cpu_is_imx8qm() && (imx8_get_soc_revision() < B0_SILICON_ID))
 		hdp->no_edid = true;
+#else
+	if (hdp->no_edid && of_property_read_bool(pdev->dev.of_node,
+								"resolution")) {
+		hdp->num_res = of_property_count_strings(pdev->dev.of_node,
+								"resolution");
+		if (hdp->num_res < 0) {
+			hdp->num_res = 0;
+		} else
+			for (i = 0; i < hdp->num_res; i++) {
+				ret = of_property_read_string_index(
+						pdev->dev.of_node,
+						"resolution", i, &resolution);
+				if (ret) {
+					dev_warn(dev, "Resolution index %d property read error:%d\n",
+							i, ret);
+					hdp->num_res = 0;
+					break;
+				}
+				ret = parse_enable_res(resolution);
+				if (ret) {
+					hdp->num_res = 0;
+					break;
+				}
+			}
+	}
+#endif
 
 
 	ret = of_property_read_u32(pdev->dev.of_node,
@@ -1157,6 +1528,7 @@ static int imx_hdp_imx_bind(struct device *dev, struct device *master,
 	hdp->rw = devtype->rw;
 	hdp->bpc = 8;
 	hdp->format = PXL_RGB;
+	hdp->ipcHndl = 0;
 
 	imx_hdp_state_init(hdp);
 
@@ -1228,7 +1600,13 @@ static int imx_hdp_imx_bind(struct device *dev, struct device *master,
 
 	encoder->bridge = bridge;
 
+#ifndef CONFIG_ARCH_LAYERSCAPE
 	hdp->connector.polled = DRM_CONNECTOR_POLL_HPD;
+#else
+	/* There is no interrupt for hotplug on ls1028a platform */
+	hdp->connector.polled = DRM_CONNECTOR_POLL_CONNECT |
+		DRM_CONNECTOR_POLL_DISCONNECT;
+#endif
 	/* connector */
 	drm_connector_helper_add(connector,
 				 &imx_hdp_connector_helper_funcs);
@@ -1246,44 +1624,52 @@ static int imx_hdp_imx_bind(struct device *dev, struct device *master,
 	/* Check cable states before enable irq */
 	imx_hdp_call(hdp, get_hpd_state, &hdp->state, &hpd);
 
-	/* Enable Hotplug Detect IRQ thread */
-	if (hdp->irq[HPD_IRQ_IN] > 0) {
-		irq_set_status_flags(hdp->irq[HPD_IRQ_IN],
-				     IRQ_NOAUTOEN);
-		ret = devm_request_threaded_irq(dev,
-						hdp->irq[HPD_IRQ_IN],
-						NULL,
-						imx_hdp_irq_thread,
-						IRQF_ONESHOT,
-						dev_name(dev),
-						hdp);
-		if (ret) {
-			dev_err(&pdev->dev, "can't claim irq %d\n",
-				hdp->irq[HPD_IRQ_IN]);
-			goto err_irq;
+	if (hdp->is_hpd_irq) {
+		/* Enable Hotplug Detect IRQ thread */
+		if (hdp->irq[HPD_IRQ_IN] > 0) {
+			irq_set_status_flags(hdp->irq[HPD_IRQ_IN],
+					     IRQ_NOAUTOEN);
+			ret = devm_request_threaded_irq(dev,
+							hdp->irq[HPD_IRQ_IN],
+							NULL,
+							imx_hdp_irq_thread,
+							IRQF_ONESHOT,
+							dev_name(dev),
+							hdp);
+			if (ret) {
+				dev_err(&pdev->dev, "can't claim irq %d\n",
+					hdp->irq[HPD_IRQ_IN]);
+				goto err_irq;
+			}
+			/* Cable Disconnedted, enable Plug in IRQ */
+			if (hpd == 0)
+				enable_irq(hdp->irq[HPD_IRQ_IN]);
 		}
-		/* Cable Disconnedted, enable Plug in IRQ */
-		if (hpd == 0)
-			enable_irq(hdp->irq[HPD_IRQ_IN]);
-	}
-	if (hdp->irq[HPD_IRQ_OUT] > 0) {
-		irq_set_status_flags(hdp->irq[HPD_IRQ_OUT],
-				     IRQ_NOAUTOEN);
-		ret = devm_request_threaded_irq(dev,
-						hdp->irq[HPD_IRQ_OUT],
-						NULL,
-						imx_hdp_irq_thread,
-						IRQF_ONESHOT,
-						dev_name(dev),
-						hdp);
-		if (ret) {
-			dev_err(&pdev->dev, "can't claim irq %d\n",
-				hdp->irq[HPD_IRQ_OUT]);
-			goto err_irq;
+		if (hdp->irq[HPD_IRQ_OUT] > 0) {
+			irq_set_status_flags(hdp->irq[HPD_IRQ_OUT],
+					     IRQ_NOAUTOEN);
+			ret = devm_request_threaded_irq(dev,
+							hdp->irq[HPD_IRQ_OUT],
+							NULL,
+							imx_hdp_irq_thread,
+							IRQF_ONESHOT,
+							dev_name(dev),
+							hdp);
+			if (ret) {
+				dev_err(&pdev->dev, "can't claim irq %d\n",
+					hdp->irq[HPD_IRQ_OUT]);
+				goto err_irq;
+			}
+			/* Cable Connected, enable Plug out IRQ */
+			if (hpd == 1)
+				enable_irq(hdp->irq[HPD_IRQ_OUT]);
 		}
-		/* Cable Connected, enable Plug out IRQ */
-		if (hpd == 1)
-			enable_irq(hdp->irq[HPD_IRQ_OUT]);
+	} else {
+		hpd_thread = kthread_create(imx_hdp_hpd_thread, hdp, "hdp-hpd");
+		if (IS_ERR(hpd_thread))
+			dev_err(&pdev->dev, "failed  create hpd thread\n");
+
+			wake_up_process(hpd_thread);
 	}
 
 	return 0;
diff --git a/drivers/gpu/drm/imx/hdp/imx-hdp.h b/drivers/gpu/drm/imx/hdp/imx-hdp.h
index e50c787c4534..7364b310928c 100644
--- a/drivers/gpu/drm/imx/hdp/imx-hdp.h
+++ b/drivers/gpu/drm/imx/hdp/imx-hdp.h
@@ -15,7 +15,9 @@
 #include <drm/drm_crtc_helper.h>
 #include <drm/drm_edid.h>
 #include <drm/drm_encoder_slave.h>
+#ifndef CONFIG_ARCH_LAYERSCAPE
 #include <soc/imx8/sc/sci.h>
+#endif
 
 #include <drm/drm_dp_helper.h>
 #include "../../../../mxc/hdp/all.h"
@@ -24,6 +26,7 @@
 #undef DEBUG_FW_LOAD
 #define PLL_1188MHZ (1188000000)
 #define PLL_800MHZ (800000000)
+#define PLL_675MHZ (675000000)
 
 #define HDP_TX_SS_LIS_BASE   0x0000
 #define HDP_TX_SS_CSR_BASE   0x1000
@@ -53,6 +56,15 @@
 #define VIC_MODE_96_50Hz 96
 #define VIC_MODE_97_60Hz 97
 
+#ifdef CONFIG_ARCH_LAYERSCAPE
+#define EDP_PHY_RESET	0x230
+#define CSR_PLLDIG_PLLDV 0x28
+#define CSR_PLLDIG_PLLFM 0x2c
+#define CSR_PLLDIG_PLLFD 0x30
+#define CSR_PLLDIG_PLLCAL1 0x38
+#define CSR_PLLDIG_PLLCAL2 0x3c
+#endif
+
 /**
  * imx_hdp_call - Calls a struct imx hdp_operations operation on
  *	an entity
@@ -86,7 +98,11 @@ struct hdp_ops {
 			 int format, int color_depth, int max_link);
 	int (*get_edid_block)(void *data, u8 *buf, u32 block, size_t len);
 	int (*get_hpd_state)(state_struct *state, u8 *hpd);
+#ifndef CONFIG_ARCH_LAYERSCAPE
 	void (*phy_reset)(sc_ipc_t ipcHndl, struct hdp_mem *mem, u8 reset);
+#else
+	void (*phy_reset)(uint32_t ipcHndl, struct hdp_mem *mem, u8 reset);
+#endif
 	int (*pixel_link_validate)(state_struct *state);
 	int (*pixel_link_invalidate)(state_struct *state);
 	int (*pixel_link_sync_ctrl_enable)(state_struct *state);
@@ -194,6 +210,10 @@ struct imx_hdp {
 	u8 is_edp;
 	u8 is_digpll_dp_pclock;
 	u8 no_edid;
+#ifdef CONFIG_ARCH_LAYERSCAPE
+	u8 is_hpd_irq;
+	int num_res;
+#endif
 	u32 lane_mapping;
 	u32 edp_link_rate;
 	u32 edp_num_lanes;
@@ -209,7 +229,11 @@ struct imx_hdp {
 	struct drm_dp_link dp_link;
 	S_LINK_STAT lkstat;
 	ENUM_AFE_LINK_RATE link_rate;
+#ifndef CONFIG_ARCH_LAYERSCAPE
 	sc_ipc_t ipcHndl;
+#else
+	uint32_t ipcHndl;
+#endif
 	u32 mu_id;
 	u32 dual_mode;
 	struct hdp_ops *ops;
-- 
2.17.1

