From 124617e3b9be4560d9284aab82823de171e6721f Mon Sep 17 00:00:00 2001
From: Chuanhua Han <chuanhua.han@nxp.com>
Date: Mon, 12 Aug 2019 11:45:17 +0800
Subject: [PATCH 562/741] ACPI: support for NXP i2c controller

commit 8b697a0a0058f35c0baeb9033f7006860f9f2ea8 from
http://source.codeaurora.org/external/qoriq/qoriq-components/linux

Enable NXP i2c controller to boot with ACPI

Signed-off-by: Meenakshi Aggarwal <meenakshi.aggarwal@nxp.com>
Signed-off-by: Udit Kumar <udit.kumar@nxp.com>
Signed-off-by: Chuanhua Han <chuanhua.han@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/acpi/acpi_apd.c      |  6 ++++++
 drivers/i2c/busses/i2c-imx.c | 15 +++++++++++++++
 2 files changed, 21 insertions(+)

diff --git a/drivers/acpi/acpi_apd.c b/drivers/acpi/acpi_apd.c
index ff47317d8ef1..a257b63c14d5 100644
--- a/drivers/acpi/acpi_apd.c
+++ b/drivers/acpi/acpi_apd.c
@@ -165,6 +165,11 @@ static const struct apd_device_desc thunderx2_i2c_desc = {
 	.fixed_clk_rate = 125000000,
 };
 
+static const struct apd_device_desc nxp_i2c_desc = {
+        .setup = acpi_apd_setup,
+        .fixed_clk_rate = 350000000,
+};
+
 static const struct apd_device_desc hip08_spi_desc = {
 	.setup = acpi_apd_setup,
 	.fixed_clk_rate = 250000000,
@@ -237,6 +242,7 @@ static const struct acpi_device_id acpi_apd_device_ids[] = {
 	{ "CAV9007",  APD_ADDR(thunderx2_i2c_desc) },
 	{ "HISI02A1", APD_ADDR(hip07_i2c_desc) },
 	{ "HISI02A2", APD_ADDR(hip08_i2c_desc) },
+	{ "NXP0001", APD_ADDR(nxp_i2c_desc) },
 	{ "HISI0173", APD_ADDR(hip08_spi_desc) },
 #endif
 	{ }
diff --git a/drivers/i2c/busses/i2c-imx.c b/drivers/i2c/busses/i2c-imx.c
index f7739f6a2d31..82d7c49b8571 100644
--- a/drivers/i2c/busses/i2c-imx.c
+++ b/drivers/i2c/busses/i2c-imx.c
@@ -46,6 +46,7 @@
 #include <linux/pm_runtime.h>
 #include <linux/sched.h>
 #include <linux/slab.h>
+#include <linux/acpi.h>
 #include <linux/gpio.h>
 #include <linux/of_address.h>
 #include <linux/of.h>
@@ -316,6 +317,12 @@ static const struct of_device_id i2c_imx_dt_ids[] = {
 };
 MODULE_DEVICE_TABLE(of, i2c_imx_dt_ids);
 
+static const struct acpi_device_id i2c_imx_acpi_ids[] = {
+	{"NXP0001", .driver_data = (kernel_ulong_t)&vf610_i2c_hwdata},
+	{ }
+};
+MODULE_DEVICE_TABLE(acpi, i2c_imx_acpi_ids);
+
 static inline int is_imx1_i2c(struct imx_i2c_struct *i2c_imx)
 {
 	return i2c_imx->hwdata->devtype == IMX1_I2C;
@@ -1240,6 +1247,9 @@ static int i2c_imx_probe(struct platform_device *pdev)
 {
 	const struct of_device_id *of_id = of_match_device(i2c_imx_dt_ids,
 							   &pdev->dev);
+	const struct acpi_device_id *acpi_id =
+					acpi_match_device(i2c_imx_acpi_ids,
+							  &pdev->dev);
 	struct imx_i2c_struct *i2c_imx;
 	struct resource *res;
 	struct imxi2c_platform_data *pdata = dev_get_platdata(&pdev->dev);
@@ -1267,6 +1277,9 @@ static int i2c_imx_probe(struct platform_device *pdev)
 
 	if (of_id)
 		i2c_imx->hwdata = of_id->data;
+	else if (acpi_id)
+		i2c_imx->hwdata = (struct imx_i2c_hwdata *)
+				acpi_id->driver_data;
 	else
 		i2c_imx->hwdata = (struct imx_i2c_hwdata *)
 				platform_get_device_id(pdev)->driver_data;
@@ -1279,6 +1292,7 @@ static int i2c_imx_probe(struct platform_device *pdev)
 	i2c_imx->adapter.nr		= pdev->id;
 	i2c_imx->adapter.dev.of_node	= pdev->dev.of_node;
 	i2c_imx->base			= base;
+	ACPI_COMPANION_SET(&i2c_imx->adapter.dev, ACPI_COMPANION(&pdev->dev));
 
 	/* Get I2C clock */
 	i2c_imx->clk = devm_clk_get(&pdev->dev, NULL);
@@ -1447,6 +1461,7 @@ static struct platform_driver i2c_imx_driver = {
 		.name = DRIVER_NAME,
 		.pm = I2C_IMX_PM_OPS,
 		.of_match_table = i2c_imx_dt_ids,
+		.acpi_match_table = ACPI_PTR(i2c_imx_acpi_ids),
 	},
 	.id_table = imx_i2c_devtype,
 };
-- 
2.17.1

