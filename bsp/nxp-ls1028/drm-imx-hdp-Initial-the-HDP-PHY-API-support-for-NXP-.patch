From 05edc0f5f136409ea344edbdb55c2c3d76e80470 Mon Sep 17 00:00:00 2001
From: Wen He <wen.he_1@nxp.com>
Date: Fri, 26 Apr 2019 15:35:30 +0800
Subject: [PATCH 501/741] drm/imx/hdp: Initial the HDP PHY API support for
 NXP's platform

commit 2124c8137b849f6b328ad9cd56fa6765ee1d0062 from
http://source.codeaurora.org/external/qoriq/qoriq-components/linux

This patch add the Display port protocols API support for NXP's
platform. The HD Display Controller IP API supports one (or more)
of the following protocols.

- eDP / DisplayPort-Transmitter (Source device)
- HDCP-Transmitter
- HDCP-Receiver
- HDMI-Transmitter (Source device)
- CDN API version: 1.0.37

Signed-off-by: Sandor Yu <Sandor.yu@nxp.com>
Signed-off-by: Alison Wang <alison.wang@nxp.com>
Signed-off-by: Wen He <wen.he_1@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/Kconfig                        |   2 +
 drivers/Makefile                       |   1 +
 drivers/mxc/Kconfig                    |  12 +
 drivers/mxc/Makefile                   |   1 +
 drivers/mxc/hdp/API_AFE.c              |  96 +++
 drivers/mxc/hdp/API_AFE.h              |  74 ++
 drivers/mxc/hdp/API_AVI.c              | 166 +++++
 drivers/mxc/hdp/API_AVI.h              |  27 +
 drivers/mxc/hdp/API_Audio.c            | 412 +++++++++++
 drivers/mxc/hdp/API_Audio.h            | 129 ++++
 drivers/mxc/hdp/API_DPTX.c             | 931 +++++++++++++++++++++++++
 drivers/mxc/hdp/API_DPTX.h             | 428 ++++++++++++
 drivers/mxc/hdp/API_General.c          | 476 +++++++++++++
 drivers/mxc/hdp/API_General.h          | 228 ++++++
 drivers/mxc/hdp/API_HDCP.c             | 429 ++++++++++++
 drivers/mxc/hdp/API_HDCP.h             | 233 +++++++
 drivers/mxc/hdp/API_HDMITX.c           | 469 +++++++++++++
 drivers/mxc/hdp/API_HDMITX.h           | 135 ++++
 drivers/mxc/hdp/API_HDMI_Audio.c       | 125 ++++
 drivers/mxc/hdp/API_HDMI_Audio.h       |  39 ++
 drivers/mxc/hdp/API_Infoframe.c        | 116 +++
 drivers/mxc/hdp/API_Infoframe.h        |  33 +
 drivers/mxc/hdp/Kconfig                |   2 +
 drivers/mxc/hdp/Makefile               |  11 +
 drivers/mxc/hdp/address.h              |  78 +++
 drivers/mxc/hdp/aif_pckt2smp.h         | 138 ++++
 drivers/mxc/hdp/all.h                  |  31 +
 drivers/mxc/hdp/apb_cfg.h              | 155 ++++
 drivers/mxc/hdp/clock_meters.h         | 127 ++++
 drivers/mxc/hdp/dptx_framer.h          | 342 +++++++++
 drivers/mxc/hdp/dptx_stream.h          | 178 +++++
 drivers/mxc/hdp/general_handler.h      | 136 ++++
 drivers/mxc/hdp/hdcp.h                 |  22 +
 drivers/mxc/hdp/hdcp2.h                | 261 +++++++
 drivers/mxc/hdp/hdcp_tran.h            | 226 ++++++
 drivers/mxc/hdp/hdmi.h                 |  92 +++
 drivers/mxc/hdp/mailBox.h              |  86 +++
 drivers/mxc/hdp/mhl_hdtx_top.h         | 190 +++++
 drivers/mxc/hdp/opcodes.h              |  86 +++
 drivers/mxc/hdp/sink_aif_encoder.h     | 367 ++++++++++
 drivers/mxc/hdp/sink_car.h             | 168 +++++
 drivers/mxc/hdp/sink_clk_meters.h      | 241 +++++++
 drivers/mxc/hdp/sink_core.h            | 117 ++++
 drivers/mxc/hdp/sink_mhl_hd.h          | 418 +++++++++++
 drivers/mxc/hdp/sink_pif.h             | 160 +++++
 drivers/mxc/hdp/sink_vif.h             | 285 ++++++++
 drivers/mxc/hdp/source_aif_decoder.h   | 422 +++++++++++
 drivers/mxc/hdp/source_aif_smpl2pckt.h |  83 +++
 drivers/mxc/hdp/source_car.h           | 143 ++++
 drivers/mxc/hdp/source_phy.h           | 150 ++++
 drivers/mxc/hdp/source_pif.h           | 140 ++++
 drivers/mxc/hdp/source_vif.h           |  63 ++
 drivers/mxc/hdp/util.c                 | 343 +++++++++
 drivers/mxc/hdp/util.h                 | 369 ++++++++++
 54 files changed, 10192 insertions(+)
 create mode 100755 drivers/mxc/Kconfig
 create mode 100755 drivers/mxc/Makefile
 create mode 100644 drivers/mxc/hdp/API_AFE.c
 create mode 100644 drivers/mxc/hdp/API_AFE.h
 create mode 100644 drivers/mxc/hdp/API_AVI.c
 create mode 100644 drivers/mxc/hdp/API_AVI.h
 create mode 100644 drivers/mxc/hdp/API_Audio.c
 create mode 100644 drivers/mxc/hdp/API_Audio.h
 create mode 100644 drivers/mxc/hdp/API_DPTX.c
 create mode 100644 drivers/mxc/hdp/API_DPTX.h
 create mode 100644 drivers/mxc/hdp/API_General.c
 create mode 100644 drivers/mxc/hdp/API_General.h
 create mode 100644 drivers/mxc/hdp/API_HDCP.c
 create mode 100644 drivers/mxc/hdp/API_HDCP.h
 create mode 100644 drivers/mxc/hdp/API_HDMITX.c
 create mode 100644 drivers/mxc/hdp/API_HDMITX.h
 create mode 100644 drivers/mxc/hdp/API_HDMI_Audio.c
 create mode 100644 drivers/mxc/hdp/API_HDMI_Audio.h
 create mode 100644 drivers/mxc/hdp/API_Infoframe.c
 create mode 100644 drivers/mxc/hdp/API_Infoframe.h
 create mode 100644 drivers/mxc/hdp/Kconfig
 create mode 100644 drivers/mxc/hdp/Makefile
 create mode 100644 drivers/mxc/hdp/address.h
 create mode 100644 drivers/mxc/hdp/aif_pckt2smp.h
 create mode 100644 drivers/mxc/hdp/all.h
 create mode 100644 drivers/mxc/hdp/apb_cfg.h
 create mode 100644 drivers/mxc/hdp/clock_meters.h
 create mode 100644 drivers/mxc/hdp/dptx_framer.h
 create mode 100644 drivers/mxc/hdp/dptx_stream.h
 create mode 100644 drivers/mxc/hdp/general_handler.h
 create mode 100644 drivers/mxc/hdp/hdcp.h
 create mode 100644 drivers/mxc/hdp/hdcp2.h
 create mode 100644 drivers/mxc/hdp/hdcp_tran.h
 create mode 100644 drivers/mxc/hdp/hdmi.h
 create mode 100644 drivers/mxc/hdp/mailBox.h
 create mode 100644 drivers/mxc/hdp/mhl_hdtx_top.h
 create mode 100644 drivers/mxc/hdp/opcodes.h
 create mode 100644 drivers/mxc/hdp/sink_aif_encoder.h
 create mode 100644 drivers/mxc/hdp/sink_car.h
 create mode 100644 drivers/mxc/hdp/sink_clk_meters.h
 create mode 100644 drivers/mxc/hdp/sink_core.h
 create mode 100644 drivers/mxc/hdp/sink_mhl_hd.h
 create mode 100644 drivers/mxc/hdp/sink_pif.h
 create mode 100644 drivers/mxc/hdp/sink_vif.h
 create mode 100644 drivers/mxc/hdp/source_aif_decoder.h
 create mode 100644 drivers/mxc/hdp/source_aif_smpl2pckt.h
 create mode 100644 drivers/mxc/hdp/source_car.h
 create mode 100644 drivers/mxc/hdp/source_phy.h
 create mode 100644 drivers/mxc/hdp/source_pif.h
 create mode 100644 drivers/mxc/hdp/source_vif.h
 create mode 100644 drivers/mxc/hdp/util.c
 create mode 100644 drivers/mxc/hdp/util.h

diff --git a/drivers/Kconfig b/drivers/Kconfig
index e8231663f201..b09f1bf9e4c5 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -114,6 +114,8 @@ source "drivers/mmc/Kconfig"
 
 source "drivers/memstick/Kconfig"
 
+source "drivers/mxc/Kconfig"
+
 source "drivers/leds/Kconfig"
 
 source "drivers/accessibility/Kconfig"
diff --git a/drivers/Makefile b/drivers/Makefile
index 28b030d7988d..a9f4e3a6561c 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -129,6 +129,7 @@ obj-$(CONFIG_PM_OPP)		+= opp/
 obj-$(CONFIG_CPU_FREQ)		+= cpufreq/
 obj-$(CONFIG_CPU_IDLE)		+= cpuidle/
 obj-y				+= mmc/
+obj-y				+= mxc/
 obj-$(CONFIG_MEMSTICK)		+= memstick/
 obj-$(CONFIG_NEW_LEDS)		+= leds/
 obj-$(CONFIG_INFINIBAND)	+= infiniband/
diff --git a/drivers/mxc/Kconfig b/drivers/mxc/Kconfig
new file mode 100755
index 000000000000..b6256f7284d2
--- /dev/null
+++ b/drivers/mxc/Kconfig
@@ -0,0 +1,12 @@
+# drivers/mxc/Kconfig
+
+if ARCH_LAYERSCAPE
+
+menu "MXC support drivers"
+
+# drivers common to MXC and LS1028A go here:
+source "drivers/mxc/hdp/Kconfig"
+
+endmenu
+
+endif
diff --git a/drivers/mxc/Makefile b/drivers/mxc/Makefile
new file mode 100755
index 000000000000..eb9f9c9739b7
--- /dev/null
+++ b/drivers/mxc/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_MX8_HDP)	+= hdp/
diff --git a/drivers/mxc/hdp/API_AFE.c b/drivers/mxc/hdp/API_AFE.c
new file mode 100644
index 000000000000..b268a5f5715a
--- /dev/null
+++ b/drivers/mxc/hdp/API_AFE.c
@@ -0,0 +1,96 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * API_AFE.c
+ *
+ ******************************************************************************
+ */
+
+#include "address.h"
+#include "API_AFE.h"
+#include "API_General.h"
+
+void Afe_write(state_struct *state, u32 offset, u16 val)
+{
+	CDN_API_STATUS sts;
+
+	sts =
+	    CDN_API_General_Write_Register_blocking(state,
+						    ADDR_AFE + (offset << 2),
+						    val);
+
+	if (sts != CDN_OK) {
+		pr_err
+		    ("CDN_API_General_Write_Register_blocking(0x%.8X, 0x%.8X) returned %d\n",
+		     offset, val, (int)sts);
+	}
+}
+
+u16 Afe_read(state_struct *state, u32 offset)
+{
+	GENERAL_Read_Register_response resp;
+	CDN_API_STATUS sts;
+
+	sts =
+	    CDN_API_General_Read_Register_blocking(state,
+						   ADDR_AFE + (offset << 2),
+						   &resp);
+
+	if (sts != CDN_OK) {
+		pr_err
+		    ("CDN_API_General_Read_Register_blocking(0x%.8X) returned %d\n",
+		     offset, (int)sts);
+	}
+	return resp.val;
+}
+
+void set_field_value(reg_field_t *reg_field, u32 value)
+{
+	u8 length;
+	u32 max_value;
+	u32 trunc_val;
+
+	length = (reg_field->msb - reg_field->lsb + 1);
+
+	max_value = (1 << length) - 1;
+	if (value > max_value) {
+		trunc_val = value;
+		trunc_val &= (1 << length) - 1;
+		pr_err("set_field_value() Error! Specified value (0x%0X)\
+				exceeds field capacity - it will by truncated to\
+				0x%0X (%0d-bit field - max value: %0d dec)\n",
+				value, trunc_val, length, max_value);
+	} else {
+		pr_info("set_field_value() Setting field to 0x%0X\n", value);
+		reg_field->value = value;
+	}
+}
+
+int set_reg_value(reg_field_t reg_field)
+{
+	return reg_field.value << reg_field.lsb;
+}
+
+u8 AFE_check_rate_supported(ENUM_AFE_LINK_RATE rate)
+{
+	switch (rate) {
+	case AFE_LINK_RATE_1_6:
+	case AFE_LINK_RATE_2_1:
+	case AFE_LINK_RATE_2_4:
+	case AFE_LINK_RATE_2_7:
+	case AFE_LINK_RATE_3_2:
+	case AFE_LINK_RATE_4_3:
+	case AFE_LINK_RATE_5_4:
+		return 1;
+	default:
+		return 0;
+	}
+}
diff --git a/drivers/mxc/hdp/API_AFE.h b/drivers/mxc/hdp/API_AFE.h
new file mode 100644
index 000000000000..f799e6baf343
--- /dev/null
+++ b/drivers/mxc/hdp/API_AFE.h
@@ -0,0 +1,74 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * API_AFE.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef API_AFE_H_
+#define API_AFE_H_
+
+#include "util.h"
+
+typedef enum {
+	AFE_LINK_RATE_1_6 = 0x6,
+	AFE_LINK_RATE_2_1 = 0x8,
+	AFE_LINK_RATE_2_4 = 0x9,
+	AFE_LINK_RATE_2_7 = 0xA,
+	AFE_LINK_RATE_3_2 = 0xC,
+	AFE_LINK_RATE_4_3 = 0x10,
+	AFE_LINK_RATE_5_4 = 0x14,
+	AFE_LINK_RATE_8_1 = 0x1A,
+} ENUM_AFE_LINK_RATE;
+
+/*
+ * Some of the PHY programming sequences
+ * depend on the reference clock frequency.
+ * Variable of this type is used to control
+ * the programming flow.
+ */
+typedef enum {
+	REFCLK_24MHZ,
+	REFCLK_27MHZ
+} REFCLK_FREQ;
+
+typedef enum {
+	CLK_RATIO_1_1,
+	CLK_RATIO_5_4,
+	CLK_RATIO_3_2,
+	CLK_RATIO_2_1,
+	CLK_RATIO_1_2,
+	CLK_RATIO_5_8,
+	CLK_RATIO_3_4
+} clk_ratio_t;
+
+typedef struct {
+	u32 value;
+	u8 lsb;
+	u8 msb;
+} reg_field_t;
+
+unsigned char AFE_check_rate_supported(ENUM_AFE_LINK_RATE rate);
+void Afe_write(state_struct *state, u32 offset, u16 val);
+u16 Afe_read(state_struct *state, u32 offset);
+void AFE_init(state_struct *state, int num_lanes,
+	      ENUM_AFE_LINK_RATE link_rate);
+void afe_init_t28hpc(state_struct *state, int num_lanes,
+	      ENUM_AFE_LINK_RATE link_rate);
+void AFE_power(state_struct *state, int num_lanes,
+	       ENUM_AFE_LINK_RATE link_rate);
+void afe_power_t28hpc(state_struct *state, int num_lanes,
+	       ENUM_AFE_LINK_RATE link_rate);
+void set_field_value(reg_field_t *reg_field, u32 value);
+int set_reg_value(reg_field_t reg_field);
+
+#endif
diff --git a/drivers/mxc/hdp/API_AVI.c b/drivers/mxc/hdp/API_AVI.c
new file mode 100644
index 000000000000..8c6e2a816490
--- /dev/null
+++ b/drivers/mxc/hdp/API_AVI.c
@@ -0,0 +1,166 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * API_AVI.c
+ *
+ ******************************************************************************
+ */
+
+#include "API_AVI.h"
+#include "API_Infoframe.h"
+
+CDN_API_STATUS CDN_API_Set_AVI(state_struct *state,
+			       struct drm_display_mode *mode,
+			       VIC_PXL_ENCODING_FORMAT colorMode,
+			       BT_TYPE ITUver)
+{
+	u32 active_slot = mode->htotal - mode->hdisplay;
+	u32 line_width = mode->htotal;
+	u32 Hactive = line_width - active_slot + 1;
+	u32 Vactive = mode->hdisplay + 1;
+
+	u32 Hactive_l = Hactive - 256 * ((u32) Hactive / 256);
+	u32 Hactive_h = Hactive / 256;
+	u32 Vactive_l = Vactive - 256 * ((u32) Vactive / 256);
+	u32 Vactive_h = Vactive / 256;
+
+	u32 packet_type = 0x82;
+	u32 packet_version = 0x2;
+	u32 packet_len = 0xD;
+	u32 packet_Y = 0;
+	u32 packet_C = 0;
+	u32 packet_R = 0;
+	u32 packet_VIC = 0;
+	u32 packet_PR = 0;
+	u32 packet_buf[18 / sizeof(u32)];
+	u8 *packet = (u8 *) &packet_buf[0];
+	u32 packet_HB0 = 0;
+	u32 packet_HB1 = 0;
+	u32 packet_HB2 = 0;
+	u32 packet_PB0 = 0;
+	u32 packet_PB1 = 0;
+	u32 packet_PB2 = 0;
+	u32 packet_PB3 = 0;
+	u32 packet_PB4 = 0;
+	u32 packet_PB5 = 0;
+	u32 packet_PB6 = 0;
+	u32 packet_PB7 = 0;
+	u32 packet_PB8 = 0;
+	u32 packet_PB9 = 0;
+	u32 packet_PB10 = 0;
+	u32 packet_PB11 = 0;
+	u32 packet_PB12 = 0;
+	u32 packet_PB13 = 0;
+	u32 PB1_13_chksum = 0;
+	u32 packet_chksum = 0;
+
+	u32 packet_A0 = 1;
+	u32 packet_B = 0;
+	u32 packet_S = 0;
+	/* Picture Scsaling */
+	u32 packet_SC = 0;
+	/* Aspect Ratio: Nodata=0 4:3=1 16:9=2 */
+	u32 packet_M = 0;
+	/* Quantization Range Default=0 Limited Range=0x1 FullRange=0x2 Reserved 0x3 */
+	u32 packet_Q = 0;
+	/* Quantization Range 0=Limited Range  FullRange=0x1 Reserved 0x3/2 */
+	u32 packet_YQ = 0;
+	/* Extended Colorimetry xvYCC601=0x0 xvYCC709=1 All other Reserved */
+	u32 packet_EC = 0;
+	/* IT content nodata=0 ITcontent=1 */
+	u32 packet_IT = 0;
+	/* Content Type */
+	u32 packet_CN = 0;
+
+	/*
+	 * Active Format Aspec Ratio:
+	 * Same As Picture = 0x8 4:3(Center)=0x9 16:9=0xA 14:9=0xB
+	 */
+	if (mode->picture_aspect_ratio == HDMI_PICTURE_ASPECT_4_3)
+		packet_R = 9;
+	else if (mode->picture_aspect_ratio == HDMI_PICTURE_ASPECT_16_9)
+		packet_R = 0xa;
+	else
+		packet_R = 8;
+
+	/* Video Code (CEA) */
+	packet_VIC = drm_match_cea_mode(mode);
+	/* Pixel Repetition 0 ... 9 (1-10) */
+	packet_PR = 0;
+
+	if (colorMode == PXL_RGB)
+		packet_Y = 0;
+	else if (colorMode == YCBCR_4_4_4)
+		packet_Y = 2;
+	else if (colorMode == YCBCR_4_2_2)
+		packet_Y = 1;
+	else if (colorMode == YCBCR_4_2_0)
+		packet_Y = 3;
+
+	/* Colorimetry:  Nodata=0 IT601=1 ITU709=2 */
+	if (ITUver == BT_601)
+		packet_C = 1;
+	else if (ITUver == BT_709)
+		packet_C = 2;
+	else
+		packet_C = 0;
+
+	packet_HB0 = packet_type;
+	packet_HB1 = packet_version;
+	packet_HB2 = packet_len;
+
+	packet_PB1 = 32 * packet_Y + 16 * packet_A0 + 4 * packet_B + packet_S;
+	packet_PB2 = 64 * packet_C + 16 * packet_M + packet_R;
+	packet_PB3 =
+	    128 * packet_IT + 16 * packet_EC + 4 * packet_Q + packet_SC;
+	packet_PB4 = packet_VIC;
+	packet_PB5 = 64 * packet_YQ + 16 * packet_CN + packet_PR;
+	packet_PB6 = 0;
+	packet_PB7 = 0;
+	packet_PB8 = Vactive_l;
+	packet_PB9 = Vactive_h;
+	packet_PB10 = 0;
+	packet_PB11 = 0;
+	packet_PB12 = Hactive_l;
+	packet_PB13 = Hactive_h;
+
+	PB1_13_chksum =
+	    (packet_HB0 + packet_HB1 + packet_HB2 + packet_PB1 + packet_PB2 +
+	     packet_PB3 + packet_PB4 + packet_PB5 + packet_PB6 + packet_PB7 +
+	     packet_PB8 + packet_PB9 + packet_PB10 + packet_PB11 + packet_PB12 +
+	     packet_PB13);
+	packet_chksum =
+	    256 - (PB1_13_chksum - 256 * ((u32) PB1_13_chksum / 256));
+	packet_PB0 = packet_chksum;
+
+	packet[0] = 0;
+	packet[1] = packet_HB0;
+	packet[2] = packet_HB1;
+	packet[3] = packet_HB2;
+	packet[4] = packet_PB0;
+	packet[5] = packet_PB1;
+	packet[6] = packet_PB2;
+	packet[7] = packet_PB3;
+	packet[8] = packet_PB4;
+	packet[9] = packet_PB5;
+	packet[10] = packet_PB6;
+	packet[11] = packet_PB7;
+	packet[12] = packet_PB8;
+	packet[13] = packet_PB9;
+	packet[14] = packet_PB10;
+	packet[15] = packet_PB11;
+	packet[16] = packet_PB12;
+	packet[17] = packet_PB13;
+
+	CDN_API_InfoframeSet(state, 0, packet_len, &packet_buf[0], packet_type);
+
+	return CDN_OK;
+}
diff --git a/drivers/mxc/hdp/API_AVI.h b/drivers/mxc/hdp/API_AVI.h
new file mode 100644
index 000000000000..b52fad0b7bb6
--- /dev/null
+++ b/drivers/mxc/hdp/API_AVI.h
@@ -0,0 +1,27 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * API_AVI.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef API_AVI_H_
+#define API_AVI_H_
+
+#include "API_General.h"
+
+CDN_API_STATUS CDN_API_Set_AVI(state_struct *state,
+			       struct drm_display_mode *mode,
+			       VIC_PXL_ENCODING_FORMAT colorMode,
+			       BT_TYPE ITUver);
+
+#endif /* API_AVI_H_ */
diff --git a/drivers/mxc/hdp/API_Audio.c b/drivers/mxc/hdp/API_Audio.c
new file mode 100644
index 000000000000..4cb73e6de473
--- /dev/null
+++ b/drivers/mxc/hdp/API_Audio.c
@@ -0,0 +1,412 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * API_Audio.c
+ *
+ ******************************************************************************
+ */
+#include "address.h"
+#include "aif_pckt2smp.h"
+#include "API_Audio.h"
+#include "API_HDMI_Audio.h"
+#include "API_DPTX.h"
+#include "API_General.h"
+#include "clock_meters.h"
+#include "dptx_stream.h"
+#include "dptx_framer.h"
+#include "source_aif_decoder.h"
+#include "source_aif_smpl2pckt.h"
+#include "source_car.h"
+#include "util.h"
+
+CDN_API_STATUS CDN_API_AudioMute(state_struct *state, AUDIO_MUTE_MODE mode)
+{
+	return (CDN_API_General_Write_Field
+		(state, ADDR_DPTX_STREAM + (DP_VB_ID << 2), 4, 1,
+		 (1 - mode) << 4));
+}
+
+CDN_API_STATUS CDN_API_AudioMute_blocking(state_struct *state,
+					  AUDIO_MUTE_MODE mode)
+{
+	internal_block_function(&state->mutex, CDN_API_AudioMute(state, mode));
+}
+
+CDN_API_STATUS CDN_API_AudioMode(state_struct *state, AUDIO_MODE mode)
+{
+	return (CDN_API_General_Write_Register
+		(state, ADDR_DPTX_FRAMER + (AUDIO_PACK_CONTROL << 2),
+		 F_AUDIO_PACK_EN(mode)));
+}
+
+CDN_API_STATUS CDN_API_AudioMode_blocking(state_struct *state, AUDIO_MODE mode)
+{
+	internal_block_function(&state->mutex, CDN_API_AudioMode(state, mode));
+}
+
+CDN_API_STATUS CDN_API_AudioConfigCore(state_struct *state,
+				       AUDIO_TYPE audioType, int numOfChannels,
+				       AUDIO_FREQ freq, int lanes,
+				       AUDIO_WIDTH width)
+{
+	int i;
+	int lanesParam;
+	u32 I2S_DEC_PORT_EN_Val;
+
+	if (numOfChannels == 2) {
+		if (lanes == 1)
+			lanesParam = 1;
+		else
+			lanesParam = 3;
+	} else
+		lanesParam = 0;
+
+	if (audioType == AUDIO_TYPE_I2S) {
+		cdn_apb_write(state,
+			      ADDR_SOURCE_AIF_DECODER + (AUDIO_SRC_CNFG << 2),
+			      0x20000);
+		cdn_apb_write(state,
+			      ADDR_SOURCE_AIF_SMPL2PCKT + (FIFO_CNTL << 2), 2);
+		cdn_apb_write(state,
+			      ADDR_SOURCE_AIF_SMPL2PCKT + (SMPL2PKT_CNFG << 2),
+			      F_MAX_NUM_CH(numOfChannels - 1) |
+			      F_NUM_OF_I2S_PORTS((numOfChannels / 2) - 1) |
+				  (1 << 8) | (lanesParam << 11));
+
+		if (numOfChannels == 2)
+			I2S_DEC_PORT_EN_Val = 1;
+		else if (numOfChannels == 4)
+			I2S_DEC_PORT_EN_Val = 3;
+		else
+			I2S_DEC_PORT_EN_Val = 0xF;
+
+		/* 24 bit configuration + number of channels according to config */
+		cdn_apb_write(state,
+			      ADDR_SOURCE_AIF_DECODER + (AUDIO_SRC_CNFG << 2),
+			      0x01000 | F_AUDIO_SAMPLE_WIDTH(width) |
+			      F_AUDIO_CH_NUM(numOfChannels - 1) |
+			      F_I2S_DEC_PORT_EN(I2S_DEC_PORT_EN_Val));
+
+		for (i = 0; i < (numOfChannels + 1) / 2; i++) {
+			cdn_apb_write(state, ADDR_SOURCE_AIF_DECODER +
+				      ((STTS_BIT_CH01 + i) << 2),
+				      F_WORD_LENGTH_CH0(0x2) |
+				      F_WORD_LENGTH_CH1(0x2) |
+				      F_CHANNEL_NUM_CH0(i * 2) |
+				      F_CHANNEL_NUM_CH1((i * 2) + 1));
+		}
+
+		/*set ch status bits */
+		switch (freq) {
+
+		case AUDIO_FREQ_32:
+			cdn_apb_write(state, ADDR_SOURCE_AIF_DECODER +
+				      (COM_CH_STTS_BITS << 2),
+				      4 | F_SAMPLING_FREQ(0x3) |
+				      F_ORIGINAL_SAMP_FREQ(0xC));
+			break;
+		case AUDIO_FREQ_192:
+			cdn_apb_write(state, ADDR_SOURCE_AIF_DECODER +
+				      (COM_CH_STTS_BITS << 2),
+				      4 | F_SAMPLING_FREQ(0xE) |
+				      F_ORIGINAL_SAMP_FREQ(0x1));
+			break;
+
+		case AUDIO_FREQ_48:
+			cdn_apb_write(state, ADDR_SOURCE_AIF_DECODER +
+				      (COM_CH_STTS_BITS << 2),
+				      4 | F_SAMPLING_FREQ(0x2) |
+				      F_ORIGINAL_SAMP_FREQ(0xD));
+			break;
+		case AUDIO_FREQ_96:
+			cdn_apb_write(state, ADDR_SOURCE_AIF_DECODER +
+				      (COM_CH_STTS_BITS << 2),
+				      4 | F_SAMPLING_FREQ(0xA) |
+				      F_ORIGINAL_SAMP_FREQ(0x5));
+			break;
+		case AUDIO_FREQ_44_1:
+			cdn_apb_write(state, ADDR_SOURCE_AIF_DECODER +
+				      (COM_CH_STTS_BITS << 2),
+				      4 | F_SAMPLING_FREQ(0x0) |
+				      F_ORIGINAL_SAMP_FREQ(0xF));
+			break;
+		case AUDIO_FREQ_88_2:
+			cdn_apb_write(state, ADDR_SOURCE_AIF_DECODER +
+				      (COM_CH_STTS_BITS << 2),
+				      4 | F_SAMPLING_FREQ(0x8) |
+				      F_ORIGINAL_SAMP_FREQ(0x7));
+			break;
+		case AUDIO_FREQ_176_4:
+			cdn_apb_write(state, ADDR_SOURCE_AIF_DECODER +
+				      (COM_CH_STTS_BITS << 2),
+				      4 | F_SAMPLING_FREQ(0xC) |
+				      F_ORIGINAL_SAMP_FREQ(0x3));
+			break;
+		}
+
+		/* Enable I2S encoder */
+		cdn_apb_write(state,
+			      ADDR_SOURCE_AIF_DECODER + (AUDIO_SRC_CNTL << 2), 2);
+		/* Enable smpl2pkt */
+		cdn_apb_write(state,
+			      ADDR_SOURCE_AIF_SMPL2PCKT + (SMPL2PKT_CNTL << 2), 2);
+	} else {
+
+		/* set spidif 2c en */
+		cdn_apb_write(state,
+			      ADDR_SOURCE_AIF_DECODER + (SPDIF_CTRL_ADDR << 2),
+			      0x1F0707);
+		cdn_apb_write(state,
+			      ADDR_SOURCE_AIF_SMPL2PCKT + (FIFO_CNTL << 2), 2);
+		cdn_apb_write(state,
+			      ADDR_SOURCE_AIF_SMPL2PCKT + (SMPL2PKT_CNFG << 2),
+			      0x101 | (lanesParam << 11));
+		cdn_apb_write(state,
+			      ADDR_SOURCE_AIF_SMPL2PCKT + (SMPL2PKT_CNTL << 2), 2);
+		cdn_apb_write(state,
+			      ADDR_SOURCE_AIF_DECODER + (SPDIF_CTRL_ADDR << 2),
+			      0x3F0707);
+	}
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_AudioConfigCore_blocking(state_struct *state,
+						AUDIO_TYPE audioType,
+						int numOfChannels,
+						AUDIO_FREQ freq, int lanes,
+						AUDIO_WIDTH width)
+{
+	internal_block_function(&state->mutex, CDN_API_AudioConfigCore
+				(state, audioType, numOfChannels, freq, lanes,
+				 width));
+}
+
+CDN_API_STATUS CDN_API_AudioAutoConfig(state_struct *state,
+				       AUDIO_TYPE audioType, int numOfChannels,
+				       AUDIO_FREQ freq, int lanes,
+				       AUDIO_WIDTH width,
+				       CDN_PROTOCOL_TYPE protocol, int ncts,
+				       AUDIO_MUTE_MODE mode)
+{
+
+	CDN_API_STATUS ret = CDN_BSY;
+	u32 REF_CYC_Val;
+
+	switch (state->tmp) {
+	case 0:
+		if (protocol == CDN_DPTX) {
+			ret =
+			    CDN_API_General_Write_Register(state,
+							   ADDR_DPTX_FRAMER +
+							   (AUDIO_PACK_STATUS <<
+							    2), 0x11 << 16);
+		} else {
+			ret = CDN_OK;
+		}
+		break;
+
+	case 1:
+		if (protocol == CDN_DPTX) {
+			REF_CYC_Val = 0x8000;
+			ret =
+			    CDN_API_General_Write_Register(state,
+							   ADDR_CLOCK_METERS +
+							   (CM_LANE_CTRL << 2),
+							   REF_CYC_Val);
+		} else {
+			/* hdmi mode */
+			ret =
+			    CDN_API_General_Write_Register(state,
+							   ADDR_CLOCK_METERS +
+							   (CM_CTRL << 2), 8);
+
+		}
+		break;
+	case 2:
+		if ((protocol == CDN_HDMITX_TYPHOON)
+		    || (protocol == CDN_HDMITX_KIRAN)) {
+			ret =
+			    CDN_API_General_Write_Register(state,
+							   ADDR_CLOCK_METERS +
+							   (CM_I2S_CTRL << 2),
+							   ncts | 0x4000000);
+		} else {
+			ret = CDN_OK;
+		}
+
+		break;
+
+	case 3:
+		if ((protocol == CDN_HDMITX_TYPHOON)
+		    || (protocol == CDN_HDMITX_KIRAN)) {
+			ret = CDN_OK;
+		} else {
+			/* in dptx set audio on in dp framer */
+			ret = CDN_API_AudioMode(state, 1);
+		}
+		break;
+
+	case 4:
+		/* set car audio on _not reset */
+		if (protocol == CDN_DPTX) {
+			/* TODO DK: try to merge case 3 and 4 */
+			ret = CDN_OK;
+		} else {
+			ret = CDN_OK;
+		}
+		break;
+
+	case 5:
+		if ((protocol == CDN_DPTX) && (audioType != AUDIO_TYPE_I2S)) {
+			ret =
+			    CDN_API_General_Write_Register(state,
+							   ADDR_SOURCE_CAR +
+							   (SOURCE_AIF_CAR <<
+							    2), 0xff);
+		} else {
+			ret = CDN_OK;
+		}
+		break;
+	case 6:
+		if (protocol == CDN_DPTX) {
+			ret =
+			    CDN_API_General_Write_Register(state,
+							   ADDR_CLOCK_METERS +
+							   (CM_CTRL << 2), 0);
+		} else {
+			ret = CDN_OK;
+		}
+		break;
+
+	case 7:
+		ret =
+		    CDN_API_AudioConfigCore(state, audioType, numOfChannels,
+					    freq, lanes, width);
+		break;
+	case 8:
+		if ((protocol == CDN_HDMITX_TYPHOON)
+		    || (protocol == CDN_HDMITX_KIRAN)) {
+			CDN_API_HDMI_AudioSetInfoFrame(state, mode, audioType,
+						       numOfChannels, freq,
+						       lanes, ncts);
+		}
+		ret = CDN_OK;
+		break;
+
+	}
+	if (!state->tmp && ret == CDN_STARTED)
+		return CDN_STARTED;
+	switch (ret) {
+	case CDN_OK:
+		state->tmp++;
+		break;
+	case CDN_STARTED:
+		return CDN_BSY;
+	default:
+		return ret;
+	}
+	if (state->tmp == 9) {
+		state->tmp = 0;
+		return CDN_OK;
+	}
+	return CDN_BSY;
+
+}
+
+CDN_API_STATUS CDN_API_AudioAutoConfig_blocking(state_struct *state,
+						AUDIO_TYPE audioType,
+						int numOfChannels,
+						AUDIO_FREQ freq, int lanes,
+						AUDIO_WIDTH width,
+						CDN_PROTOCOL_TYPE protocol,
+						int ncts, AUDIO_MUTE_MODE mode)
+{
+	internal_block_function(&state->mutex, CDN_API_AudioAutoConfig
+				(state, audioType, numOfChannels, freq, lanes,
+				 width, protocol, ncts, mode));
+}
+
+CDN_API_STATUS CDN_API_AudioOff(state_struct *state, AUDIO_TYPE audioType)
+{
+	CDN_API_STATUS ret = CDN_BSY;
+
+	switch (state->tmp) {
+	case 0:
+		cdn_apb_write(state,
+			      ADDR_SOURCE_AIF_DECODER + (SPDIF_CTRL_ADDR << 2),
+			      0x1F0707);
+		cdn_apb_write(state,
+			      ADDR_SOURCE_AIF_DECODER + (AUDIO_SRC_CNTL << 2),
+			      0);
+		cdn_apb_write(state,
+			      ADDR_SOURCE_AIF_DECODER + (AUDIO_SRC_CNFG << 2),
+			      0);
+		cdn_apb_write(state,
+			      ADDR_SOURCE_AIF_DECODER + (AUDIO_SRC_CNTL << 2),
+			      1);
+		cdn_apb_write(state,
+			      ADDR_SOURCE_AIF_DECODER + (AUDIO_SRC_CNTL << 2),
+			      0);
+		cdn_apb_write(state,
+			      ADDR_SOURCE_AIF_SMPL2PCKT + (SMPL2PKT_CNTL << 2),
+			      0);
+		cdn_apb_write(state,
+			      ADDR_SOURCE_AIF_SMPL2PCKT + (SMPL2PKT_CNTL << 2),
+			      1);
+		cdn_apb_write(state,
+			      ADDR_SOURCE_AIF_SMPL2PCKT + (SMPL2PKT_CNTL << 2),
+			      0);
+		cdn_apb_write(state,
+			      ADDR_SOURCE_AIF_SMPL2PCKT + (FIFO_CNTL << 2), 1);
+		cdn_apb_write(state,
+			      ADDR_SOURCE_AIF_SMPL2PCKT + (FIFO_CNTL << 2), 0);
+		ret = CDN_OK;
+
+		break;
+	case 1:
+		ret =
+		    CDN_API_General_Write_Register(state, ADDR_SOURCE_CAR +
+						   (SOURCE_AIF_CAR << 2), 0x5f);
+		break;
+	case 2:
+		ret =
+		    CDN_API_General_Write_Register(state, ADDR_SOURCE_CAR +
+						   (SOURCE_AIF_CAR << 2), 0x0f);
+		break;
+	case 3:
+		ret = CDN_OK;
+		break;
+	}
+
+	if (!state->tmp && ret == CDN_STARTED)
+		return CDN_STARTED;
+	switch (ret) {
+	case CDN_OK:
+		state->tmp++;
+		break;
+	case CDN_STARTED:
+		return CDN_BSY;
+	default:
+		return ret;
+	}
+	if (state->tmp == 4) {
+		state->tmp = 0;
+		return CDN_OK;
+	}
+	return CDN_BSY;
+}
+
+CDN_API_STATUS CDN_API_AudioOff_blocking(state_struct *state,
+					 AUDIO_TYPE audioType)
+{
+	internal_block_function(&state->mutex,
+				CDN_API_AudioOff(state, audioType));
+}
diff --git a/drivers/mxc/hdp/API_Audio.h b/drivers/mxc/hdp/API_Audio.h
new file mode 100644
index 000000000000..02126f0d7ec2
--- /dev/null
+++ b/drivers/mxc/hdp/API_Audio.h
@@ -0,0 +1,129 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * API_Audio.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef API_AUDIO_H_
+#define API_AUDIO_H_
+
+#include "API_General.h"
+/**
+ * \addtogroup AUDIO_API
+ * \{
+ */
+typedef enum {
+	AUDIO_TYPE_I2S,
+	AUDIO_TYPE_SPIDIF_INTERNAL,
+	AUDIO_TYPE_SPIDIF_EXTERNAL,
+} AUDIO_TYPE;
+
+typedef enum {
+	AUDIO_FREQ_32,
+	AUDIO_FREQ_48,
+	AUDIO_FREQ_96,
+	AUDIO_FREQ_192,
+	AUDIO_FREQ_44_1,
+	AUDIO_FREQ_88_2,
+	AUDIO_FREQ_176_4,
+} AUDIO_FREQ;
+
+typedef enum {
+	AUDIO_WIDTH_16,
+	AUDIO_WIDTH_24,
+	AUDIO_WIDTH_32,
+} AUDIO_WIDTH;
+
+typedef enum {
+	AUDIO_MODE_OFF,
+	AUDIO_MODE_ON
+} AUDIO_MODE;
+
+typedef enum {
+	AUDIO_MUTE_MODE_MUTE,
+	AUDIO_MUTE_MODE_UNMUTE
+} AUDIO_MUTE_MODE;
+
+/**
+ * \brief mute or unmute audio
+ */
+CDN_API_STATUS CDN_API_AudioMute(state_struct *state, AUDIO_MUTE_MODE mode);
+
+/**
+ * \brief blocking version of #CDN_API_AudioMute
+ */
+CDN_API_STATUS CDN_API_AudioMute_blocking(state_struct *state,
+					  AUDIO_MUTE_MODE mode);
+
+/**
+ * \brief start playing audio with the input parameters
+    ncts and mode are relevant only in HDMI TX mode , not relevant for DPTX mode
+ */
+CDN_API_STATUS CDN_API_AudioAutoConfig(state_struct *state,
+				       AUDIO_TYPE audioType, int numOfChannels,
+				       AUDIO_FREQ freq, int lanes,
+				       AUDIO_WIDTH width,
+				       CDN_PROTOCOL_TYPE protocol, int ncts,
+				       AUDIO_MUTE_MODE mode);
+
+/**
+ * \brief blocking version of #CDN_API_AudioAutoConfig
+ */
+CDN_API_STATUS CDN_API_AudioAutoConfig_blocking(state_struct *state,
+						AUDIO_TYPE audioType,
+						int numOfChannels,
+						AUDIO_FREQ freq, int lanes,
+						AUDIO_WIDTH width,
+						CDN_PROTOCOL_TYPE protocol,
+						int ncts, AUDIO_MUTE_MODE mode);
+
+/**
+ * \brief audio off (use it to stop current audio and start new one using CDN_API_AudioAutoConfig)
+ */
+CDN_API_STATUS CDN_API_AudioOff(state_struct *state, AUDIO_TYPE audioType);
+
+/**
+ * \brief blocking version of #CDN_API_AudioOff
+ */
+CDN_API_STATUS CDN_API_AudioOff_blocking(state_struct *state,
+					 AUDIO_TYPE audioType);
+
+/**
+ * \brief internal function to set audio on or off inside internal registers
+ */
+CDN_API_STATUS CDN_API_AudioMode(state_struct *state, AUDIO_MODE mode);
+
+/**
+ * \brief blocking version of #CDN_API_AudioMode
+ */
+CDN_API_STATUS CDN_API_AudioMode_blocking(state_struct *state,
+					  AUDIO_MODE mode);
+
+/**
+ * \brief internal function to set audio core registers
+ */
+CDN_API_STATUS CDN_API_AudioConfigCore(state_struct *state,
+				       AUDIO_TYPE audioType, int numOfChannels,
+				       AUDIO_FREQ freq, int lanes,
+				       AUDIO_WIDTH width);
+
+/**
+ * \brief blocking version of #CDN_API_AudioConfigCore
+ */
+CDN_API_STATUS CDN_API_AudioConfigCore_blocking(state_struct *state,
+						AUDIO_TYPE audioType,
+						int numOfChannels,
+						AUDIO_FREQ freq, int lanes,
+						AUDIO_WIDTH width);
+
+#endif
diff --git a/drivers/mxc/hdp/API_DPTX.c b/drivers/mxc/hdp/API_DPTX.c
new file mode 100644
index 000000000000..f047b48c3cff
--- /dev/null
+++ b/drivers/mxc/hdp/API_DPTX.c
@@ -0,0 +1,931 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * API_DPTX.c
+ *
+ ******************************************************************************
+ */
+#include "API_DPTX.h"
+#include "util.h"
+#include "opcodes.h"
+#include "address.h"
+#include "dptx_stream.h"
+#include "dptx_framer.h"
+#include "source_vif.h"
+
+CDN_API_STATUS CDN_API_DPTX_Read_DPCD(state_struct *state, int numOfBytes,
+				      int addr, DPTX_Read_DPCD_response *resp,
+				      CDN_BUS_TYPE bus_type)
+{
+	CDN_API_STATUS ret;
+
+	if (!state->running) {
+		internal_tx_mkfullmsg(state, MB_MODULE_ID_DP_TX, DPTX_READ_DPCD,
+				      2, 2, numOfBytes, 3, addr);
+		state->bus_type = bus_type;
+		state->rxEnable = 1;
+		return CDN_STARTED;
+	}
+	internal_process_messages(state);
+	ret = internal_test_rx_head(state, MB_MODULE_ID_DP_TX,
+				   DPTX_DPCD_READ_RESP);
+	if (ret != CDN_OK) {
+		state->running = 0;
+		return ret;
+	}
+	/* Clean most significant bytes in members of structure used for response. */
+	resp->size = 0;
+	resp->addr = 0;
+	internal_readmsg(state, 3,
+			 2, &resp->size, 3, &resp->addr, 0, &resp->buff);
+	state->running = 0;
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_DPTX_Read_DPCD_blocking(state_struct *state,
+					       int numOfBytes, int addr,
+					       DPTX_Read_DPCD_response *resp,
+					       CDN_BUS_TYPE bus_type)
+{
+	internal_block_function(&state->mutex, CDN_API_DPTX_Read_DPCD
+				(state, numOfBytes, addr, resp, bus_type));
+}
+
+CDN_API_STATUS CDN_API_DPTX_Read_EDID(state_struct *state, u8 segment,
+				      u8 extension,
+				      DPTX_Read_EDID_response *resp)
+{
+	CDN_API_STATUS ret;
+
+	if (!state->running) {
+		if (!internal_apb_available(state))
+			return CDN_BSY;
+		internal_tx_mkfullmsg(state, MB_MODULE_ID_DP_TX, DPTX_GET_EDID,
+				      2, 1, segment, 1, extension);
+		state->rxEnable = 1;
+		state->bus_type = CDN_BUS_TYPE_APB;
+		return CDN_STARTED;
+	}
+	internal_process_messages(state);
+	ret = internal_test_rx_head(state, MB_MODULE_ID_DP_TX,
+				   DPTX_GET_EDID);
+	if (ret != CDN_OK)
+		return ret;
+	internal_readmsg(state, 3,
+			 1, &resp->size, 1, &resp->blockNo, 0, &resp->buff);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_DPTX_Read_EDID_blocking(state_struct *state, u8 segment,
+					       u8 extension,
+					       DPTX_Read_EDID_response *resp)
+{
+	internal_block_function(&state->mutex, CDN_API_DPTX_Read_EDID
+				(state, segment, extension, resp));
+}
+
+CDN_API_STATUS CDN_API_DPTX_SetHostCap(state_struct *state, u8 maxLinkRate,
+				       u8 lanesCount_SSC,
+				       u8 maxVoltageSwing,
+				       u8 maxPreemphasis,
+				       u8 testPatternsSupported,
+				       u8 fastLinkTraining,
+				       u8 laneMapping, u8 enchanced)
+{
+	/* fifth bit of lanesCount_SSC is used to declare eDP. */
+	state->edp = ((lanesCount_SSC >> 5) & 1);
+	if (!state->running) {
+		if (!internal_apb_available(state))
+			return CDN_BSY;
+		internal_tx_mkfullmsg(state, MB_MODULE_ID_DP_TX,
+				      DPTX_SET_HOST_CAPABILITIES, 8, 1,
+				      maxLinkRate, 1, lanesCount_SSC, 1,
+				      maxVoltageSwing, 1, maxPreemphasis, 1,
+				      testPatternsSupported, 1,
+				      fastLinkTraining, 1, laneMapping, 1,
+				      enchanced);
+		state->bus_type = CDN_BUS_TYPE_APB;
+		return CDN_STARTED;
+	}
+	internal_process_messages(state);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_DPTX_SetHostCap_blocking(state_struct *state,
+						u8 maxLinkRate,
+						u8 lanesCount_SSC,
+						u8 maxVoltageSwing,
+						u8 maxPreemphasis,
+						u8 testPatternsSupported,
+						u8 fastLinkTraining,
+						u8 laneMapping, u8 enchanced)
+{
+	internal_block_function(&state->mutex, CDN_API_DPTX_SetHostCap
+				(state, maxLinkRate, lanesCount_SSC,
+				 maxVoltageSwing, maxPreemphasis,
+				 testPatternsSupported, fastLinkTraining,
+				 laneMapping, enchanced));
+}
+
+CDN_API_STATUS CDN_API_DPTX_SetPowerMode(state_struct *state,
+					 CDN_API_PWR_MODE mode)
+{
+	if (!state->running) {
+		if (!internal_apb_available(state))
+			return CDN_BSY;
+		internal_tx_mkfullmsg(state, MB_MODULE_ID_DP_TX,
+				      DPTX_SET_POWER_MNG, 1, 1, mode);
+		state->bus_type = CDN_BUS_TYPE_APB;
+		return CDN_STARTED;
+	}
+	internal_process_messages(state);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_DPTX_SetPowerMode_blocking(state_struct *state,
+						  CDN_API_PWR_MODE mode)
+{
+	internal_block_function(&state->mutex,
+				CDN_API_DPTX_SetPowerMode(state, mode));
+}
+
+CDN_API_STATUS CDN_API_DPTX_Control(state_struct *state, u32 mode)
+{
+	if (!state->running) {
+		if (!internal_apb_available(state))
+			return CDN_BSY;
+		internal_tx_mkfullmsg(state, MB_MODULE_ID_DP_TX,
+				      DPTX_TRAINING_CONTROL, 1, 1, mode);
+		state->bus_type = CDN_BUS_TYPE_APB;
+		return CDN_STARTED;
+	}
+	internal_process_messages(state);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_DPTX_Control_blocking(state_struct *state, u32 mode)
+{
+	internal_block_function(&state->mutex,
+				CDN_API_DPTX_Control(state, mode));
+}
+
+CDN_API_STATUS CDN_API_DPTX_EDP_Training(state_struct *state,
+					 u8 mode, ENUM_AFE_LINK_RATE linkRate,
+					 u8 rateId)
+{
+	if (AFE_check_rate_supported(linkRate) == 0)
+		return CDN_ERROR_NOT_SUPPORTED;
+
+	if (!state->running) {
+		if (!internal_apb_available(state))
+			return CDN_BSY;
+		internal_tx_mkfullmsg(state, MB_MODULE_ID_DP_TX,
+				      DPTX_EDP_RATE_TRAINING, 3,
+				      1, mode,
+				      1, (u8)linkRate,
+				      1, rateId);
+		state->bus_type = CDN_BUS_TYPE_APB;
+		return CDN_STARTED;
+	}
+	internal_process_messages(state);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_DPTX_EDP_Training_blocking(state_struct *state, u8 mode,
+						  ENUM_AFE_LINK_RATE linkRate,
+						  u8 rateId)
+{
+	internal_block_function(&state->mutex,
+				CDN_API_DPTX_EDP_Training(state, mode,
+							  linkRate, rateId));
+}
+
+CDN_API_STATUS CDN_API_DPTX_Write_DPCD(state_struct *state, u32 numOfBytes,
+				       u32 addr, u8 *buff,
+				       DPTX_Write_DPCD_response *resp,
+				       CDN_BUS_TYPE bus_type)
+{
+	CDN_API_STATUS ret;
+
+	if (!state->running) {
+		if (!internal_apb_available(state))
+			return CDN_BSY;
+		internal_tx_mkfullmsg(state, MB_MODULE_ID_DP_TX,
+				      DPTX_WRITE_DPCD, 3, 2, numOfBytes, 3,
+				      addr, -numOfBytes, buff);
+		state->rxEnable = 1;
+		state->bus_type = bus_type;
+		return CDN_STARTED;
+	}
+	internal_process_messages(state);
+	ret = internal_test_rx_head(state, MB_MODULE_ID_DP_TX,
+				   DPTX_DPCD_WRITE_RESP);
+	if (ret != CDN_OK)
+		return ret;
+	internal_readmsg(state, 2, 2, &resp->size, 3, &resp->addr);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_DPTX_Write_DPCD_blocking(state_struct *state,
+						u32 numOfBytes, u32 addr,
+						u8 *buff,
+						DPTX_Write_DPCD_response *resp,
+						CDN_BUS_TYPE bus_type)
+{
+	internal_block_function(&state->mutex, CDN_API_DPTX_Write_DPCD
+				(state, numOfBytes, addr, buff, resp,
+				 bus_type));
+}
+
+CDN_API_STATUS CDN_API_DPTX_Read_Register(state_struct *state, u8 base,
+					  u8 regNo,
+					  DPTX_Read_Register_response *resp)
+{
+	u16 addr = (base << 8) + (regNo << 2);
+	CDN_API_STATUS ret;
+
+	if (!state->running) {
+		if (!internal_apb_available(state))
+			return CDN_BSY;
+		internal_tx_mkfullmsg(state, MB_MODULE_ID_DP_TX,
+				      DPTX_READ_REGISTER, 1, 2, addr);
+		state->bus_type = CDN_BUS_TYPE_APB;
+		state->rxEnable = 1;
+		return CDN_STARTED;
+	}
+	internal_process_messages(state);
+	ret = internal_test_rx_head(state, MB_MODULE_ID_DP_TX,
+				   DPTX_READ_REGISTER_RESP);
+	if (ret != CDN_OK)
+		return ret;
+	internal_readmsg(state, 3,
+			 1, &resp->base, 1, &resp->regNo, 4, &resp->val);
+	resp->regNo >>= 2;
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_DPTX_Read_Register_blocking(state_struct *state,
+						   u8 base, u8 regNo,
+						   DPTX_Read_Register_response *resp)
+{
+	internal_block_function(&state->mutex, CDN_API_DPTX_Read_Register
+				(state, base, regNo, resp));
+}
+
+CDN_API_STATUS CDN_API_DPTX_Write_Register(state_struct *state, u8 base,
+					   u8 regNo, u32 val)
+{
+	u16 addr = (base << 8) + (regNo << 2);
+
+	if (!state->running) {
+		if (!internal_apb_available(state))
+			return CDN_BSY;
+		internal_tx_mkfullmsg(state, MB_MODULE_ID_DP_TX,
+				      DPTX_WRITE_REGISTER, 2, 2, addr, 4, val);
+		state->bus_type = CDN_BUS_TYPE_APB;
+		return CDN_STARTED;
+	}
+	internal_process_messages(state);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_DPTX_Write_Register_blocking(state_struct *state,
+						    u8 base, u8 regNo, u32 val)
+{
+	internal_block_function(&state->mutex, CDN_API_DPTX_Write_Register
+				(state, base, regNo, val));
+}
+
+CDN_API_STATUS CDN_API_DPTX_Write_Field(state_struct *state, u8 base, u8 regNo,
+					u8 startBit, u8 bitsNo, u32 val)
+{
+	u16 addr = (base << 8) + (regNo << 2);
+
+	if (!state->running) {
+		if (!internal_apb_available(state))
+			return CDN_BSY;
+		internal_tx_mkfullmsg(state, MB_MODULE_ID_DP_TX,
+				      DPTX_WRITE_FIELD, 4, 2, addr, 1, startBit,
+				      1, bitsNo, 4, val);
+		state->bus_type = CDN_BUS_TYPE_APB;
+		return CDN_STARTED;
+	}
+	internal_process_messages(state);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_DPTX_Write_Field_blocking(state_struct *state, u8 base,
+						 u8 regNo,
+						 u8 startBit,
+						 u8 bitsNo, u32 val)
+{
+	internal_block_function(&state->mutex, CDN_API_DPTX_Write_Field
+				(state, base, regNo, startBit, bitsNo, val));
+}
+
+CDN_API_STATUS CDN_API_DPTX_EnableEvent(state_struct *state, bool hpd,
+					bool training)
+{
+	uint8_t events = 0;
+
+	if (!state->running) {
+		if (!internal_apb_available(state))
+			return CDN_BSY;
+
+		events |= (hpd ? 1 << DP_TX_EVENT_ENABLE_HPD_BIT : 0);
+		events |= (training ? 1 << DP_TX_EVENT_ENABLE_TRAINING_BIT : 0);
+
+		internal_tx_mkfullmsg(state, MB_MODULE_ID_DP_TX, DPTX_ENABLE_EVENT, 2, 1, events, 4, 0);
+
+		state->bus_type = CDN_BUS_TYPE_APB;
+
+		return CDN_STARTED;
+	}
+
+	internal_process_messages(state);
+
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_DPTX_EnableEvent_blocking(state_struct *state, bool hpd,
+						 bool training)
+{
+	internal_block_function(&state->mutex,
+				CDN_API_DPTX_EnableEvent(state, hpd, training));
+}
+
+CDN_API_STATUS CDN_API_DPTX_ReadEvent(state_struct *state, u8 *LinkeventId,
+				      u8 *HPDevents)
+{
+	CDN_API_STATUS ret;
+
+	if (!state->running) {
+		if (!internal_apb_available(state))
+			return CDN_BSY;
+		internal_tx_mkfullmsg(state, MB_MODULE_ID_DP_TX,
+				      DPTX_READ_EVENT, 0);
+		state->rxEnable = 1;
+		state->bus_type = CDN_BUS_TYPE_APB;
+		return CDN_STARTED;
+	}
+	internal_process_messages(state);
+	ret = internal_test_rx_head(state, MB_MODULE_ID_DP_TX,
+				   DPTX_READ_EVENT);
+	if (ret != CDN_OK)
+		return ret;
+	internal_readmsg(state, 2, 1, HPDevents, 1, LinkeventId);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_DPTX_ReadEvent_blocking(state_struct *state,
+					       u8 *LinkeventId, u8 *HPDevents)
+{
+	internal_block_function(&state->mutex, CDN_API_DPTX_ReadEvent
+				(state, LinkeventId, HPDevents));
+}
+
+CDN_API_STATUS CDN_API_DPTX_Set_VIC(state_struct *state,
+				    const struct drm_display_mode *mode,
+				    int bitsPerPixel,
+				    VIC_NUM_OF_LANES NumOfLanes,
+				    VIC_SYMBOL_RATE rate,
+				    VIC_PXL_ENCODING_FORMAT pxlencformat,
+				    STEREO_VIDEO_ATTR steroVidAttr,
+				    BT_TYPE bt_type, int TU)
+{
+	int min_link_rate;
+	int bitsPerPixelCalc;
+	int TU_SIZE_reg = 34;
+	int val, val_f, val2, val2_f;
+	u32 lineThresh;
+	u32 pixelClockFreq;
+	u32 MSA_MISC_Param, tempForMisc, tempForMisc2;
+	u32 oddEvenV_Total;
+	u32 DP_FRAMER_SP_Param;
+	u32 DP_FRONT_BACK_PORCH_Param;
+	u32 DP_BYTE_COUNT_Param;
+	u32 MSA_HORIZONTAL_0_Param;
+	u32 MSA_HORIZONTAL_1_Param;
+	u32 MSA_VERTICAL_0_Param;
+	u32 MSA_VERTICAL_1_Param;
+	u32 DP_HORIZONTAL_ADDR_Param;
+	u32 DP_VERTICAL_0_ADDR_Param;
+	u32 DP_VERTICAL_1_ADDR_Param;
+	u32 DP_FRAMER_PXL_REPR_Param;
+	u32 HSYNC2VSYNC_POL_CTRL_Param = 0;
+	u32 BND_HSYNC2VSYNC_Param = 0;
+	u32 DP_FRAMER_TU_Param;
+	u32 tu_vs_diff = 0;
+	VIC_COLOR_DEPTH colorDepth;
+	CDN_API_STATUS ret = CDN_OK;
+
+	if (pxlencformat == YCBCR_4_2_2)
+		bitsPerPixelCalc = bitsPerPixel * 2;
+	else if (pxlencformat == YCBCR_4_2_0)
+		bitsPerPixelCalc = bitsPerPixel * 3 / 2;
+	else
+		bitsPerPixelCalc = bitsPerPixel * 3;
+
+	/* KHz */
+	pixelClockFreq = mode->clock;
+
+	/* KHz */
+	min_link_rate = rate * 995;
+	rate *= 1000;
+
+	val = TU_SIZE_reg * pixelClockFreq * bitsPerPixelCalc;
+	val_f = val / (NumOfLanes * rate * 8);
+	val /= NumOfLanes * rate * 8;
+
+	val2 = TU_SIZE_reg * pixelClockFreq * bitsPerPixelCalc;
+	val2_f = val2 / (NumOfLanes * min_link_rate * 8);
+	val2 /= NumOfLanes * min_link_rate * 8;
+
+	/* find optimum value for the TU_SIZE */
+
+	while (((val == 1) || (TU_SIZE_reg - val < 2) || (val != val2)
+		|| (val_f % 1000 > 850) || (val2_f % 1000 > 850)
+		|| (val_f % 1000 < 100) || (val2_f % 1000 < 100))
+	       && (TU_SIZE_reg < 64)) {
+		TU_SIZE_reg += 2;
+
+		val = TU_SIZE_reg * pixelClockFreq * bitsPerPixelCalc;
+		val_f = val / (NumOfLanes * rate * 8);
+		val /= NumOfLanes * rate * 8;
+
+		val2 = TU_SIZE_reg * pixelClockFreq * bitsPerPixelCalc;
+		val2_f = val2 / (NumOfLanes * min_link_rate * 8);
+		val2 /= NumOfLanes * min_link_rate * 8;
+	}
+
+	/* calculate the fixed valid symbols */
+	val = TU_SIZE_reg * pixelClockFreq * bitsPerPixelCalc;
+	val /= NumOfLanes * rate * 8;
+
+	if (val > 64)
+		return CDN_ERROR_NOT_SUPPORTED;
+
+	DP_FRAMER_TU_Param = (TU_SIZE_reg << 8) + val + (1 << 15);
+
+	tu_vs_diff = 0;
+	if ((TU_SIZE_reg - val) <= 3)
+		tu_vs_diff = TU_SIZE_reg - val;
+
+	/* LINE_THRESH set according to zeev presantation */
+	lineThresh =
+	    ((val + 1) * NumOfLanes - ((pixelClockFreq / rate) * (val + 1) *
+				       (bitsPerPixelCalc / 8) -
+				       (bitsPerPixelCalc / 8))) /
+	    ((bitsPerPixelCalc * NumOfLanes) / 8);
+	lineThresh += 2;
+
+	DP_FRAMER_SP_Param =
+		((mode->flags & DRM_MODE_FLAG_INTERLACE) ? 4 : 0) +
+		((mode->flags & DRM_MODE_FLAG_NHSYNC) ? 2 : 0) +
+		((mode->flags & DRM_MODE_FLAG_NVSYNC) ? 1 : 0);
+	DP_FRONT_BACK_PORCH_Param =
+		mode->htotal - mode->hsync_end +
+		((mode->hsync_start - mode->hdisplay) << 16);
+
+	DP_BYTE_COUNT_Param = mode->hdisplay * (bitsPerPixelCalc) / 8;
+
+	MSA_HORIZONTAL_0_Param =
+	    mode->htotal + ((mode->htotal - mode->hsync_start) << 16);
+
+	MSA_HORIZONTAL_1_Param =
+	    mode->hsync_end - mode->hsync_start +
+	    ((mode->flags & DRM_MODE_FLAG_NHSYNC ? 1 : 0) << 15) +
+	    (mode->hdisplay << 16);
+
+	MSA_VERTICAL_0_Param =
+	    (mode->flags & DRM_MODE_FLAG_INTERLACE ?
+	     (mode->vtotal / 2) : mode->vtotal) +
+	    ((mode->vtotal - mode->vsync_start) << 16);
+
+	MSA_VERTICAL_1_Param =
+	    (mode->vsync_end - mode->vsync_start +
+		 ((mode->flags & DRM_MODE_FLAG_NVSYNC ? 1 : 0) << 15)) +
+		((mode->flags & DRM_MODE_FLAG_INTERLACE ?
+		  mode->vdisplay / 2 : mode->vdisplay) << 16);
+
+	DP_HORIZONTAL_ADDR_Param = (mode->hdisplay << 16) + mode->hsync_end -
+		mode->hsync_start;
+
+	DP_VERTICAL_0_ADDR_Param =
+	    (mode->flags & DRM_MODE_FLAG_INTERLACE ?
+	     (mode->vtotal / 2) : mode->vtotal) -
+	    (mode->vtotal - mode->vdisplay) +
+	    ((mode->vtotal - mode->vsync_start) << 16);
+
+	DP_VERTICAL_1_ADDR_Param =
+	    mode->flags & DRM_MODE_FLAG_INTERLACE ?
+	    (mode->vtotal / 2) : mode->vtotal;
+
+	if (mode->flags & DRM_MODE_FLAG_INTERLACE)
+		BND_HSYNC2VSYNC_Param = 0x3020;
+	else
+		BND_HSYNC2VSYNC_Param = 0x2000;
+
+	if (mode->flags & DRM_MODE_FLAG_NHSYNC)
+		HSYNC2VSYNC_POL_CTRL_Param |= F_HPOL(1);
+
+	if (mode->flags & DRM_MODE_FLAG_NVSYNC)
+		HSYNC2VSYNC_POL_CTRL_Param |= F_VPOL(1);
+
+	switch (bitsPerPixel) {
+	case 6:
+		colorDepth = BCS_6;
+		break;
+	case 8:
+		colorDepth = BCS_8;
+		break;
+	case 10:
+		colorDepth = BCS_10;
+		break;
+	case 12:
+		colorDepth = BCS_12;
+		break;
+	case 16:
+		colorDepth = BCS_16;
+		break;
+	default:
+		colorDepth = BCS_8;
+	};
+
+	DP_FRAMER_PXL_REPR_Param = (pxlencformat << 8) + colorDepth;
+
+	switch (pxlencformat) {
+	case PXL_RGB:		/*0x1 */
+		tempForMisc = 0;
+		break;
+	case YCBCR_4_4_4:	/*0x2 */
+		tempForMisc = 6 + 8 * (bt_type);
+		break;
+	case YCBCR_4_2_2:	/*0x4 */
+		tempForMisc = 5 + 8 * (bt_type);
+		break;
+	case YCBCR_4_2_0:	/*0x8 */
+		tempForMisc = 5;
+		break;
+
+	case Y_ONLY:		/*0x10 */
+		tempForMisc = 0;
+		break;
+	default:
+		tempForMisc = 0;
+	};
+
+	switch (bitsPerPixel) {
+	case 6:
+		tempForMisc2 = 0;
+		break;
+
+	case 8:
+		tempForMisc2 = 1;
+		break;
+
+	case 10:
+		tempForMisc2 = 2;
+		break;
+
+	case 12:
+		tempForMisc2 = 3;
+		break;
+
+	case 16:
+		tempForMisc2 = 4;
+		break;
+	default:
+		tempForMisc2 = 1;
+
+	};
+
+	oddEvenV_Total = mode->vtotal % 2;
+	oddEvenV_Total = 1 - oddEvenV_Total;
+	oddEvenV_Total = oddEvenV_Total << 8;
+	MSA_MISC_Param =
+	    ((tempForMisc * 2) + (32 * tempForMisc2) +
+	     ((pxlencformat == Y_ONLY ? 1 : 0) << 14) +
+	     ((oddEvenV_Total) *
+	      (mode->flags & DRM_MODE_FLAG_INTERLACE ? 1 : 0)));
+
+	/* 420 has different parameters, enable VSS SDP */
+	if (pxlencformat == YCBCR_4_2_0)
+		MSA_MISC_Param = 1 << 14;
+
+	switch (state->tmp) {
+	case 0:
+		ret =
+		    CDN_API_DPTX_Write_Register(state, BASE_SOURCE_VIF,
+						BND_HSYNC2VSYNC,
+						BND_HSYNC2VSYNC_Param);
+		break;
+	case 1:
+		ret =
+		    CDN_API_DPTX_Write_Register(state, BASE_SOURCE_VIF,
+						HSYNC2VSYNC_POL_CTRL,
+						HSYNC2VSYNC_POL_CTRL_Param);
+		break;
+	case 2:
+		ret =
+		    CDN_API_DPTX_Write_Register(state, BASE_DPTX_STREAM,
+						DP_FRAMER_TU,
+						DP_FRAMER_TU_Param);
+		break;
+	case 3:
+		ret =
+		    CDN_API_DPTX_Write_Register(state, BASE_DPTX_STREAM,
+						DP_FRAMER_PXL_REPR,
+						DP_FRAMER_PXL_REPR_Param);
+		break;
+	case 4:
+		ret =
+		    CDN_API_DPTX_Write_Register(state, BASE_DPTX_STREAM,
+						DP_FRAMER_SP,
+						DP_FRAMER_SP_Param);
+		break;
+	case 5:
+		ret =
+		    CDN_API_DPTX_Write_Register(state, BASE_DPTX_STREAM,
+						DP_FRONT_BACK_PORCH,
+						DP_FRONT_BACK_PORCH_Param);
+		break;
+	case 6:
+		ret =
+		    CDN_API_DPTX_Write_Register(state, BASE_DPTX_STREAM,
+						DP_BYTE_COUNT,
+						DP_BYTE_COUNT_Param);
+		break;
+	case 7:
+		ret =
+		    CDN_API_DPTX_Write_Register(state, BASE_DPTX_STREAM,
+						MSA_HORIZONTAL_0,
+						MSA_HORIZONTAL_0_Param);
+		break;
+	case 8:
+		ret =
+		    CDN_API_DPTX_Write_Register(state, BASE_DPTX_STREAM,
+						MSA_HORIZONTAL_1,
+						MSA_HORIZONTAL_1_Param);
+		break;
+	case 9:
+		ret =
+		    CDN_API_DPTX_Write_Register(state, BASE_DPTX_STREAM,
+						MSA_VERTICAL_0,
+						MSA_VERTICAL_0_Param);
+		break;
+	case 10:
+		ret =
+		    CDN_API_DPTX_Write_Register(state, BASE_DPTX_STREAM,
+						MSA_VERTICAL_1,
+						MSA_VERTICAL_1_Param);
+		break;
+	case 11:
+		ret =
+		    CDN_API_DPTX_Write_Register(state, BASE_DPTX_STREAM,
+						MSA_MISC, MSA_MISC_Param);
+		break;
+	case 12:
+		ret =
+		    CDN_API_DPTX_Write_Register(state, BASE_DPTX_STREAM,
+						STREAM_CONFIG, 1);
+		break;
+	case 13:
+		ret =
+		    CDN_API_DPTX_Write_Register(state, BASE_DPTX_STREAM,
+						DP_HORIZONTAL,
+						DP_HORIZONTAL_ADDR_Param);
+		break;
+	case 14:
+		ret =
+		    CDN_API_DPTX_Write_Register(state, BASE_DPTX_STREAM,
+						DP_VERTICAL_0,
+						DP_VERTICAL_0_ADDR_Param);
+		break;
+	case 15:
+		ret =
+		    CDN_API_DPTX_Write_Register(state, BASE_DPTX_STREAM,
+						DP_VERTICAL_1,
+						DP_VERTICAL_1_ADDR_Param);
+		break;
+	case 16:
+		ret =
+		    CDN_API_DPTX_Write_Field(state, BASE_DPTX_STREAM, DP_VB_ID,
+					     2, 1,
+					     ((mode->flags &
+					       DRM_MODE_FLAG_INTERLACE ? 1 : 0)
+					      << 2));
+		break;
+	case 17:
+		ret =
+		    CDN_API_DPTX_Write_Register(state, BASE_DPTX_STREAM,
+						LINE_THRESH, lineThresh);
+		break;
+	case 18:
+		ret =
+		    CDN_API_DPTX_Write_Register(state, BASE_DPTX_STREAM,
+						RATE_GOVERNOR_STATUS,
+						tu_vs_diff << 8);
+		break;
+	}
+	if (!state->tmp && ret == CDN_STARTED)
+		return CDN_STARTED;
+	switch (ret) {
+	case CDN_OK:
+		state->tmp++;
+		break;
+	case CDN_STARTED:
+		return CDN_BSY;
+	default:
+		return ret;
+	}
+	if (state->tmp == 19) {
+		state->tmp = 0;
+		return CDN_OK;
+	}
+	return CDN_BSY;
+}
+
+CDN_API_STATUS CDN_API_DPTX_Set_VIC_blocking(state_struct *state,
+					     const struct drm_display_mode *mode,
+					     int bitsPerPixel,
+					     VIC_NUM_OF_LANES NumOfLanes,
+					     VIC_SYMBOL_RATE rate,
+					     VIC_PXL_ENCODING_FORMAT
+					     pxlencformat,
+					     STEREO_VIDEO_ATTR steroVidAttr,
+					     BT_TYPE bt_type, int TU)
+{
+	internal_block_function(&state->mutex, CDN_API_DPTX_Set_VIC
+				(state, mode, bitsPerPixel, NumOfLanes, rate,
+				 pxlencformat, steroVidAttr, bt_type, TU));
+}
+
+CDN_API_STATUS CDN_API_DPTX_SetVideo(state_struct *state, u8 mode)
+{
+	internal_macro_command_tx(state, MB_MODULE_ID_DP_TX, DPTX_SET_VIDEO,
+				  CDN_BUS_TYPE_APB, 1, 1, mode);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_DPTX_SetVideo_blocking(state_struct *state, u8 mode)
+{
+	internal_block_function(&state->mutex,
+				CDN_API_DPTX_SetVideo(state, mode));
+}
+
+CDN_API_STATUS CDN_API_DPTX_ReadLinkStat(state_struct *state,
+					 S_LINK_STAT *stat)
+{
+	internal_macro_command_txrx(state, MB_MODULE_ID_DP_TX,
+				    DPTX_READ_LINK_STAT, CDN_BUS_TYPE_APB, 0);
+	internal_readmsg(state, 10, 1, &stat->rate, 1, &stat->lanes, 1,
+			 &stat->swing[0], 1, &stat->preemphasis[0], 1,
+			 &stat->swing[1], 1, &stat->preemphasis[1], 1,
+			 &stat->swing[2], 1, &stat->preemphasis[2], 1,
+			 &stat->swing[3], 1, &stat->preemphasis[3]);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_DPTX_ReadLinkStat_blocking(state_struct *state,
+						  S_LINK_STAT *stat)
+{
+	internal_block_function(&state->mutex,
+				CDN_API_DPTX_ReadLinkStat(state, stat));
+}
+
+CDN_API_STATUS CDN_API_DPTX_TrainingControl(state_struct *state, u8 val)
+{
+	internal_macro_command_tx(state, MB_MODULE_ID_DP_TX,
+				  DPTX_TRAINING_CONTROL, CDN_BUS_TYPE_APB, 1, 1,
+				  val);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_DPTX_TrainingControl_blocking(state_struct *state,
+						     u8 val)
+{
+	internal_block_function(&state->mutex,
+				CDN_API_DPTX_TrainingControl(state, val));
+}
+
+CDN_API_STATUS CDN_API_DPTX_GetLastAuxStatus(state_struct *state, u8 *resp)
+{
+	internal_macro_command_txrx(state, MB_MODULE_ID_DP_TX,
+				    DPTX_GET_LAST_AUX_STAUS, CDN_BUS_TYPE_APB,
+				    0);
+	internal_readmsg(state, 1, 1, resp);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_DPTX_GetLastAuxStatus_blocking(state_struct *state,
+						      u8 *resp)
+{
+	internal_block_function(&state->mutex,
+				CDN_API_DPTX_GetLastAuxStatus(state, resp));
+}
+
+CDN_API_STATUS CDN_API_DPTX_GetHpdStatus(state_struct *state, u8 *resp)
+{
+	internal_macro_command_txrx(state, MB_MODULE_ID_DP_TX, DPTX_HPD_STATE,
+				    CDN_BUS_TYPE_APB, 0);
+	internal_readmsg(state, 1, 1, resp);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_DPTX_GetHpdStatus_blocking(state_struct *state,
+						  u8 *resp)
+{
+
+	internal_block_function(&state->mutex,
+				CDN_API_DPTX_GetHpdStatus(state, resp));
+}
+
+CDN_API_STATUS CDN_API_DPTX_ForceLanes(state_struct *state, u8 linkRate,
+				       u8 numOfLanes,
+				       u8 voltageSwing_l0,
+				       u8 preemphasis_l0,
+				       u8 voltageSwing_l1,
+				       u8 preemphasis_l1,
+				       u8 voltageSwing_l2,
+				       u8 preemphasis_l2,
+				       u8 voltageSwing_l3,
+				       u8 preemphasis_l3, u8 pattern, u8 ssc)
+{
+	if (!state->running) {
+		if (!internal_apb_available(state))
+			return CDN_BSY;
+		internal_tx_mkfullmsg(state, MB_MODULE_ID_DP_TX,
+				      DPTX_FORCE_LANES, 12, 1, linkRate, 1,
+				      numOfLanes, 1, voltageSwing_l0, 1,
+				      preemphasis_l0, 1, voltageSwing_l1, 1,
+				      preemphasis_l1, 1, voltageSwing_l2, 1,
+				      preemphasis_l2, 1, voltageSwing_l3, 1,
+				      preemphasis_l3, 1, pattern, 1, ssc);
+		state->bus_type = CDN_BUS_TYPE_APB;
+		return CDN_STARTED;
+	}
+	internal_process_messages(state);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_DPTX_ForceLanes_blocking(state_struct *state,
+						u8 linkRate, u8 numOfLanes,
+						u8 voltageSwing_l0,
+						u8 preemphasis_l0,
+						u8 voltageSwing_l1,
+						u8 preemphasis_l1,
+						u8 voltageSwing_l2,
+						u8 preemphasis_l2,
+						u8 voltageSwing_l3,
+						u8 preemphasis_l3, u8 pattern,
+						u8 ssc)
+{
+	internal_block_function(&state->mutex, CDN_API_DPTX_ForceLanes_blocking
+				(state, linkRate, numOfLanes, voltageSwing_l0,
+				 preemphasis_l0, voltageSwing_l1,
+				 preemphasis_l1, voltageSwing_l2,
+				 preemphasis_l2, voltageSwing_l3,
+				 preemphasis_l3, pattern, ssc));
+}
+
+CDN_API_STATUS CDN_API_DPTX_SetDbg(state_struct *state, uint32_t dbg_cfg)
+{
+	uint8_t buf[sizeof(uint32_t)];
+
+	if (!state->running) {
+		if (!internal_apb_available(state))
+			return CDN_BSY;
+
+		buf[0] = (uint8_t) (dbg_cfg);
+		buf[1] = (uint8_t) (dbg_cfg >> 8);
+		buf[2] = (uint8_t) (dbg_cfg >> 16);
+		buf[3] = (uint8_t) (dbg_cfg >> 24);
+
+		internal_tx_mkfullmsg(state, MB_MODULE_ID_DP_TX, DPTX_DBG_SET,
+				      1, -sizeof(buf), buf);
+
+		state->bus_type = CDN_BUS_TYPE_APB;
+
+		return CDN_STARTED;
+	}
+
+	internal_process_messages(state);
+
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_DPTX_SetDbg_blocking(state_struct *state,
+					    uint32_t dbg_cfg)
+{
+	internal_block_function(&state->mutex,
+				CDN_API_DPTX_SetDbg(state, dbg_cfg));
+}
diff --git a/drivers/mxc/hdp/API_DPTX.h b/drivers/mxc/hdp/API_DPTX.h
new file mode 100644
index 000000000000..ae2820c46d0f
--- /dev/null
+++ b/drivers/mxc/hdp/API_DPTX.h
@@ -0,0 +1,428 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * API_DPTX.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef _API_DPTX_H_
+#define _API_DPTX_H_
+
+#include "API_General.h"
+#include "API_AFE.h"
+
+#define MAX_NUM_OF_EVENTS 4
+
+/* Flags for CDN_API_DPTX_SetDbg */
+#define DPTX_DBG_SET_PWR_SKIP_SLEEP (1 << 0)
+#define DPTX_DBG_SET_ALT_CIPHER_ADDR (1 << 1)
+
+/**
+ * \addtogroup DP_TX_API
+ * \{
+ */
+typedef u8 CDN_API_PWR_MODE;
+typedef u32 CDN_EVENT;
+
+/**
+ * reply data struct for CDN_API_DPTX_READ_EDID
+ * please note, buff will point to internal api buffer, user must copy it for later use
+ */
+typedef struct {
+	u8 *buff;
+	u8 size;
+	u8 blockNo;
+} DPTX_Read_EDID_response;
+/**
+ *  \brief Cadence API for DP TX to get RX EDID
+ *  \param [in] segment - EDID segment to read
+ *  \param [in] extension - EDID extension to read
+ *  \param [out] resp - pointer to store response
+ *   buffer , please note, buff will point to internal api buffer, user must copy it for later use
+ *  \return status
+ *
+ */
+CDN_API_STATUS CDN_API_DPTX_Read_EDID(state_struct *state, u8 segment,
+				      u8 extension,
+				      DPTX_Read_EDID_response *resp);
+/**
+ * \brief blocking version of #CDN_API_DPTX_Read_EDID
+ */
+CDN_API_STATUS CDN_API_DPTX_Read_EDID_blocking(state_struct *state, u8 segment,
+					       u8 extension,
+					       DPTX_Read_EDID_response *resp);
+
+/**
+ *  \brief Cadence API for DP TX to set power mode of sink
+ *
+ *  \param [in] mode  - power mode
+ *  \return status
+ *
+ */
+CDN_API_STATUS CDN_API_DPTX_SetPowerMode(state_struct *state,
+					 CDN_API_PWR_MODE mode);
+/**
+ * \brief blocking version of #CDN_API_DPTX_SetPowerMode
+ */
+CDN_API_STATUS CDN_API_DPTX_SetPowerMode_blocking(state_struct *state,
+						  CDN_API_PWR_MODE mode);
+
+/**
+ *  \brief Cadence API for DP TX to set Host capabilities
+ *
+ *  \param [in] maxLinkRate Max link rate-> 0x06=1.62Gbps 0x0A=2.7Gbps 0x14=5.4Gbps 0x1E=8.1Gbps
+ *  \param [in] lanesCount_SSC bit 0-3 lanes count, bit 4 SSC
+ *  \param [in] maxVoltageSwing - - max supported VoltageSwing
+ *  \param [in] maxPreemphasis - max supported Preemphasis
+ *  \param [in] testPatternsSupported -which test patern supportrd by phy
+ *  \param [in] fastLinkTraining - is it fast link training
+ *  \param [in] laneMapping - line mapping for USB type C
+ *  \param [in] enchanced - enchanced mode
+ *  \return status
+ *
+ */
+CDN_API_STATUS CDN_API_DPTX_SetHostCap(state_struct *state, u8 maxLinkRate,
+				       u8 lanesCount_SSC,
+				       u8 maxVoltageSwing,
+				       u8 maxPreemphasis,
+				       u8 testPatternsSupported,
+				       u8 fastLinkTraining,
+				       u8 laneMapping, u8 enchanced);
+/**
+ * \brief blocking version of #CDN_API_DPTX_SetHostCap
+ */
+CDN_API_STATUS CDN_API_DPTX_SetHostCap_blocking(state_struct *state,
+						u8 maxLinkRate,
+						u8 lanesCount_SSC,
+						u8 maxVoltageSwing,
+						u8 maxPreemphasis,
+						u8 testPatternsSupported,
+						u8 fastLinkTraining,
+						u8 laneMapping, u8 enchanced);
+
+/**
+ * reply data struct for #CDN_API_DPTX_READ_DPCD
+ */
+typedef struct {
+    /** buffer where data will be stored, will become invalid after next call to API */
+	u8 *buff;
+	int addr;
+	int size;
+} DPTX_Read_DPCD_response;
+/**
+ *  \brief Cadence API for DP TX to read DPCD
+ *
+ *  \param [in] numOfBytes - num of bytes to read
+ *  \param [in] addr - address to read from
+ *  \param [out] resp - pointer to store response
+ *  \return status
+ *
+ */
+CDN_API_STATUS CDN_API_DPTX_Read_DPCD(state_struct *state, int numOfBytes,
+				      int addr, DPTX_Read_DPCD_response *resp,
+				      CDN_BUS_TYPE bus_type);
+/**
+ * blocking version of #CDN_API_DPTX_READ_DPCD
+ */
+CDN_API_STATUS CDN_API_DPTX_Read_DPCD_blocking(state_struct *state,
+					       int numOfBytes, int addr,
+					       DPTX_Read_DPCD_response *resp,
+					       CDN_BUS_TYPE bus_type);
+
+/**
+ * reply data struct for CDN_API_DPTX_WRITE_DPCD
+ */
+typedef struct {
+	int addr;
+	int size;
+} DPTX_Write_DPCD_response;
+/**
+ *  \brief Cadence API for DP TX to write DPCD
+ *
+ *  \param [in] numOfBytes - num of bytes to write
+ *  \param [in] addr - address to write
+ *  \param [in] buff - with the data to write
+ *  \param [out] resp - pointer to store response
+ *  \return status
+ *
+ */
+CDN_API_STATUS CDN_API_DPTX_Write_DPCD(state_struct *state, u32 numOfBytes,
+				       u32 addr, u8 *buff,
+				       DPTX_Write_DPCD_response *resp,
+				       CDN_BUS_TYPE bus_type);
+/**
+ * blocking version of #CDN_API_DPTX_WRITE_DPCD
+ */
+CDN_API_STATUS CDN_API_DPTX_Write_DPCD_blocking(state_struct *state,
+						u32 numOfBytes, u32 addr,
+						u8 *buff,
+						DPTX_Write_DPCD_response *resp,
+						CDN_BUS_TYPE bus_type);
+
+/**
+ * DPTX_Read_Register response struct
+ */
+typedef struct {
+	u8 base;
+	u8 regNo;
+	u32 val;
+} DPTX_Read_Register_response;
+/**
+ * \brief Cadence API for DP TX to read register
+ *
+ * \param [in] base - bank numeber (MSB of bank base address)
+ * \param [in] regNo - register number
+ * \param [out] resp - pointer to store response
+ * \return status
+ *
+ * this function will return #CDN_ERR if value of base is incorrect
+ */
+CDN_API_STATUS CDN_API_DPTX_Read_Register(state_struct *state, u8 base,
+					  u8 regNo,
+					  DPTX_Read_Register_response *resp);
+/**
+ * blocking version of #CDN_API_DPTX_READ_REGISTER
+ */
+CDN_API_STATUS CDN_API_DPTX_Read_Register_blocking(state_struct *state,
+						   u8 base, u8 regNo,
+						   DPTX_Read_Register_response *
+						   resp);
+
+/**
+ * \brief Cadence API for DP TX write register
+ *
+ * \param [in] base - bank numeber (MSB of bank base address)
+ * \param [in] regNo - register number
+ * \param [in] val - value to write
+ * \return status
+ *
+ * this function will return #CDN_ERR if value of base is incorrect
+ */
+CDN_API_STATUS CDN_API_DPTX_Write_Register(state_struct *state, u8 base,
+					   u8 regNo, u32 val);
+/**
+ * blocking version of #CDN_API_DPTX_Write_Register
+ */
+CDN_API_STATUS CDN_API_DPTX_Write_Register_blocking(state_struct *state,
+						    u8 base, u8 regNo, u32 val);
+
+/**
+ * \brief Cadence API for DP TX write register
+ *
+ * \param [in] base - bank numeber (MSB of bank base address)
+ * \param [in] regNo - register number
+ * \param [in] startBit - first bit to write
+ * \param [in] bitsNo - number of bits to write
+ * \param [in] val - value to write
+ * \return status
+ *
+ * this function will return #CDN_ERR if value of base is incorrect
+ */
+CDN_API_STATUS CDN_API_DPTX_Write_Field(state_struct *state, u8 base, u8 regNo,
+					u8 startBit, u8 bitsNo, u32 val);
+/**
+ * blocking version of #CDN_API_DPTX_Write_Field
+ */
+CDN_API_STATUS CDN_API_DPTX_Write_Field_blocking(state_struct *state, u8 base,
+						 u8 regNo,
+						 u8 startBit,
+						 u8 bitsNo, u32 val);
+
+/* TODO doxygen of DPTX_CONTROL API */
+CDN_API_STATUS CDN_API_DPTX_Control(state_struct *state, u32 mode);
+/**
+ * blocking version of #CDN_API_DPTX_Control
+ */
+CDN_API_STATUS CDN_API_DPTX_Control_blocking(state_struct *state, u32 mode);
+
+/**
+  * \brief Performs Fast Link Training, using LINK_RATE_SET DPCD register.
+  * \param [in] mode - 0 to stop training, 1 to start it, 2 to restart it.
+  * \param [in] linkRate - Link Rate to be used for training.
+  * \param [in] rateId - index of selected Link Rate in DPCd registers.
+  *
+  * Performs Fast Link Training, selecting Link Rate using LINK_RATE_SET DPCD
+  * register, characteristic to Embedded DisplayPort (eDP) v1.4 standard.
+  * If requested link rate is not supported by DPTX, function will return error
+  * code CDN_ERROR_NOT_SUPPORTED, and will take no further action.
+  * rateId is used to select, which Link Rate supported by sink (enumerated in
+  * SUPPORTED_LINK_RATES DPCD registers) is equal to rate requested. This value
+  * will be written to first 3 bits of LINK_RATE_SET DPCD registers. Allowed
+  * range is 0-7. If it is not known beforehand, SUPPORTED_LINK_RATES DPCD
+  * registers may be read by an upper layer, and then used to determine the
+  * correct value to use.
+  */
+CDN_API_STATUS CDN_API_DPTX_EDP_Training(state_struct *state, u8 mode,
+					 ENUM_AFE_LINK_RATE linkRate,
+					 u8 rateId);
+
+/**
+ * blocking version of #CDN_API_DPTX_EDP_Training
+ */
+CDN_API_STATUS CDN_API_DPTX_EDP_Training_blocking(state_struct *state, u8 mode,
+						  ENUM_AFE_LINK_RATE linkRate,
+						  u8 rateId);
+
+/**
+  * \brief send DPX_ENABLE_EVENT command
+  */
+CDN_API_STATUS CDN_API_DPTX_EnableEvent(state_struct *state, bool hpd,
+					bool training);
+
+/**
+ * blocking version of #CDN_API_DPTX_EnableEvent
+ */
+CDN_API_STATUS CDN_API_DPTX_EnableEvent_blocking(state_struct *state, bool hpd,
+						 bool training);
+
+/**
+ * \brief send DPTX_READ_EVENT_REQUEST command
+ */
+CDN_API_STATUS CDN_API_DPTX_ReadEvent(state_struct *state, u8 *LinkeventId,
+				      u8 *HPDevents);
+
+/**
+ * blocking version of #CDN_API_DPTX_ReadEvent
+ */
+CDN_API_STATUS CDN_API_DPTX_ReadEvent_blocking(state_struct *state,
+					       u8 *LinkeventId,
+					       u8 *HPDevents);
+
+/**
+ * \brief set vic mode according to vic table, the input are video parameters
+ */
+CDN_API_STATUS CDN_API_DPTX_Set_VIC(state_struct *state,
+				    const struct drm_display_mode *mode,
+				    int bitsPerPixel,
+				    VIC_NUM_OF_LANES NumOfLanes,
+				    VIC_SYMBOL_RATE rate,
+				    VIC_PXL_ENCODING_FORMAT pxlencformat,
+				    STEREO_VIDEO_ATTR steroVidAttr,
+				    BT_TYPE bt_type, int TU);
+
+/**
+ * blocking version of #CDN_API_DPTX_Set_VIC
+ */
+CDN_API_STATUS CDN_API_DPTX_Set_VIC_blocking(state_struct *state,
+					     const struct drm_display_mode *mode,
+					     int bitsPerPixel,
+					     VIC_NUM_OF_LANES NumOfLanes,
+					     VIC_SYMBOL_RATE rate,
+					     VIC_PXL_ENCODING_FORMAT
+					     pxlencformat,
+					     STEREO_VIDEO_ATTR steroVidAttr,
+					     BT_TYPE bt_type, int TU);
+
+/**
+ * \brief turn on or off the video
+ */
+CDN_API_STATUS CDN_API_DPTX_SetVideo(state_struct *state, u8 mode);
+
+/**
+ * \brief blocking version of  CDN_API_DPTX_SetVideo
+ */
+CDN_API_STATUS CDN_API_DPTX_SetVideo_blocking(state_struct *state, u8 mode);
+/**
+ * \brief blocking version of #CDN_API_DPTX_SetAudio
+ */
+CDN_API_STATUS CDN_API_DPTX_SetAudio_blocking(state_struct *state, u8 mode);
+
+typedef struct {
+	u8 rate;
+	u8 lanes;
+	u8 swing[4];
+	u8 preemphasis[4];
+} S_LINK_STAT;
+
+/**
+ * \brief get current link status (rate, num of lanes etc), user may read it after get link finish event
+ */
+CDN_API_STATUS CDN_API_DPTX_ReadLinkStat(state_struct *state,
+					 S_LINK_STAT *stat);
+
+/**
+ * \brief blocking version of #CDN_API_DPTX_ReadLinkStat
+ */
+CDN_API_STATUS CDN_API_DPTX_ReadLinkStat_blocking(state_struct *state,
+						  S_LINK_STAT *stat);
+
+/**
+ * \brief start link training
+ */
+CDN_API_STATUS CDN_API_DPTX_TrainingControl(state_struct *state, u8 val);
+/**
+ * \brief blocking version of #CDN_API_DPTX_TrainingControl
+ */
+CDN_API_STATUS CDN_API_DPTX_TrainingControl_blocking(state_struct *state,
+						     u8 val);
+
+/**
+ * \brief check if last auxilary transaction succedd
+ */
+CDN_API_STATUS CDN_API_DPTX_GetLastAuxStatus(state_struct *state, u8 *resp);
+/**
+ * \brief blocking version of #CDN_API_DPTX_GetLastAuxStatus
+ */
+CDN_API_STATUS CDN_API_DPTX_GetLastAuxStatus_blocking(state_struct *state,
+						      u8 *resp);
+
+/**
+ * \brief get current hpd status
+ */
+
+CDN_API_STATUS CDN_API_DPTX_GetHpdStatus(state_struct *state, u8 *resp);
+/**
+ * \brief blocking version of #CDN_API_DPTX_GetHpdStatus
+ */
+CDN_API_STATUS CDN_API_DPTX_GetHpdStatus_blocking(state_struct *state,
+						  u8 *resp);
+
+/**
+ * \brief force the lanes to specific swing or preemphasis, with SSc or without to pattern (0=PRBS7 or 1=D10.2) for CTS or debug phy purpose
+ */
+CDN_API_STATUS CDN_API_DPTX_ForceLanes(state_struct *state, u8 linkRate,
+				       u8 numOfLanes,
+				       u8 voltageSwing_l0,
+				       u8 preemphasis_l0,
+				       u8 voltageSwing_l1,
+				       u8 preemphasis_l1,
+				       u8 voltageSwing_l2,
+				       u8 preemphasis_l2,
+				       u8 voltageSwing_l3,
+				       u8 preemphasis_l3, u8 pattern, u8 ssc);
+
+/**
+ * \brief blocking version of #CDN_API_DPTX_ForceLanes
+ */
+CDN_API_STATUS CDN_API_DPTX_ForceLanes_blocking(state_struct *state,
+						u8 linkRate, u8 numOfLanes,
+						u8 voltageSwing_l0,
+						u8 preemphasis_l0,
+						u8 voltageSwing_l1,
+						u8 preemphasis_l1,
+						u8 voltageSwing_l2,
+						u8 preemphasis_l2,
+						u8 voltageSwing_l3,
+						u8 preemphasis_l3, u8 pattern,
+						u8 ssc);
+
+/**
+ * \brief Sets DP TX debug related features.
+ */
+CDN_API_STATUS CDN_API_DPTX_SetDbg(state_struct *state, u32 dbg_cfg);
+
+/**
+ * \brief blocking version of #CDN_API_DPTX_SetDbg
+ */
+CDN_API_STATUS CDN_API_DPTX_SetDbg_blocking(state_struct *state, u32 dbg_cfg);
+
+#endif
diff --git a/drivers/mxc/hdp/API_General.c b/drivers/mxc/hdp/API_General.c
new file mode 100644
index 000000000000..cd750cecf3ba
--- /dev/null
+++ b/drivers/mxc/hdp/API_General.c
@@ -0,0 +1,476 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * API_General.c
+ *
+ ******************************************************************************
+ */
+
+#include "API_General.h"
+#include "util.h"
+#include "address.h"
+#include "apb_cfg.h"
+#include "opcodes.h"
+#include "general_handler.h"
+
+static u32 alive;
+
+CDN_API_STATUS CDN_API_LoadFirmware(state_struct *state, u8 *iMem,
+				    int imemSize, u8 *dMem, int dmemSize)
+{
+	int i;
+
+	for (i = 0; i < imemSize; i += 4)
+		if (cdn_apb_write(state, ADDR_IMEM + i,
+				  (u32) iMem[i] << 0 |
+				  (u32) iMem[i + 1] << 8 |
+				  (u32) iMem[i + 2] << 16 |
+				  (u32) iMem[i + 3] << 24))
+			return CDN_ERR;
+	for (i = 0; i < dmemSize; i += 4)
+		if (cdn_apb_write(state, ADDR_DMEM + i,
+				  (u32) dMem[i] << 0 |
+				  (u32) dMem[i + 1] << 8 |
+				  (u32) dMem[i + 2] << 16 |
+				  (u32) dMem[i + 3] << 24))
+			return CDN_ERR;
+
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_General_Test_Echo(state_struct *state, u32 val,
+					 CDN_BUS_TYPE bus_type)
+{
+	CDN_API_STATUS ret;
+	if (!state->running) {
+		if (!internal_apb_available(state))
+			return CDN_BSY;
+		state->bus_type = bus_type;
+		state->rxEnable = 1;
+		internal_tx_mkfullmsg(state, MB_MODULE_ID_GENERAL,
+				      GENERAL_TEST_ECHO, 1, 4, val);
+		return CDN_STARTED;
+	}
+	if (state->txEnable && !internal_mbox_tx_process(state).txend)
+		return CDN_BSY;
+	if (state->rxEnable && !internal_mbox_rx_process(state).rxend)
+		return CDN_BSY;
+	ret = internal_test_rx_head(state, MB_MODULE_ID_GENERAL,
+				    GENERAL_TEST_ECHO);
+	if (ret != CDN_OK) {
+		state->running = 0;
+		return ret;
+	}
+	state->running = 0;
+	if (val != internal_betoi(state->rxBuffer + INTERNAL_CMD_HEAD_SIZE, 4))
+		return CDN_ERR;
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_General_Test_Echo_blocking(state_struct *state, u32 val,
+						  CDN_BUS_TYPE bus_type)
+{
+	internal_block_function(&state->mutex, CDN_API_General_Test_Echo
+				(state, val, bus_type));
+}
+
+CDN_API_STATUS CDN_API_General_Test_Echo_Ext(state_struct *state,
+					     u8 const *msg, u8 *resp,
+					     u16 num_bytes,
+					     CDN_BUS_TYPE bus_type)
+{
+	CDN_API_STATUS ret;
+
+	if (!msg || !resp)
+		return CDN_ERR;
+
+	if ((num_bytes > GENERAL_TEST_ECHO_MAX_PAYLOAD)
+	    || (num_bytes < GENERAL_TEST_ECHO_MIN_PAYLOAD)) {
+		return CDN_ERR;
+	}
+
+	if (!state->running) {
+		if (!internal_apb_available(state))
+			return CDN_BSY;
+
+		state->bus_type = bus_type;
+		state->rxEnable = 1;
+
+		internal_tx_mkfullmsg(state, MB_MODULE_ID_GENERAL,
+				      GENERAL_TEST_ECHO, 1, -num_bytes, msg);
+
+		return CDN_STARTED;
+	}
+
+	if (state->txEnable && !internal_mbox_tx_process(state).txend)
+		return CDN_BSY;
+
+	if (state->rxEnable && !internal_mbox_rx_process(state).rxend)
+		return CDN_BSY;
+
+	ret =
+	    internal_test_rx_head(state, MB_MODULE_ID_GENERAL,
+				  GENERAL_TEST_ECHO);
+
+	if (ret != CDN_OK) {
+		state->running = 0;
+		return ret;
+	}
+
+	state->running = 0;
+
+	memcpy(resp, state->rxBuffer + INTERNAL_CMD_HEAD_SIZE, num_bytes);
+
+	if (memcmp(msg, resp, num_bytes) != 0)
+		return CDN_ERR;
+
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_General_Test_Echo_Ext_blocking(state_struct *state,
+						      u8 const *msg, u8 *resp,
+						      u16 num_bytes,
+						      CDN_BUS_TYPE bus_type)
+{
+	internal_block_function(&state->mutex, CDN_API_General_Test_Echo_Ext
+				       (state, msg, resp, num_bytes, bus_type));
+}
+
+CDN_API_STATUS CDN_API_General_getCurVersion(state_struct *state, u16 *ver,
+					     u16 *verlib)
+{
+	u32 vh, vl, vlh, vll;
+
+	if (cdn_apb_read(state, VER_L << 2, &vl))
+		return CDN_ERR;
+	if (cdn_apb_read(state, VER_H << 2, &vh))
+		return CDN_ERR;
+	if (cdn_apb_read(state, VER_LIB_L_ADDR << 2, &vll))
+		return CDN_ERR;
+	if (cdn_apb_read(state, VER_LIB_H_ADDR << 2, &vlh))
+		return CDN_ERR;
+	*ver = F_VER_MSB_RD(vh) << 8 | F_VER_LSB_RD(vl);
+	*verlib = F_SW_LIB_VER_H_RD(vlh) << 8 | F_SW_LIB_VER_L_RD(vll);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_Get_Event(state_struct *state, u32 *events)
+{
+	u32 evt[4] = { 0 };
+
+	if (!events)
+		return CDN_ERR;
+
+	if (cdn_apb_read(state, SW_EVENTS0 << 2, &evt[0])
+	    || cdn_apb_read(state, SW_EVENTS1 << 2, &evt[1])
+	    || cdn_apb_read(state, SW_EVENTS2 << 2, &evt[2])
+	    || cdn_apb_read(state, SW_EVENTS3 << 2, &evt[3])) {
+		printk(KERN_ERR "Failed to read events registers.\n");
+
+		return CDN_ERR;
+	}
+
+	*events = (evt[0] & 0xFF)
+	    | ((evt[1] & 0xFF) << 8)
+	    | ((evt[2] & 0xFF) << 16)
+	    | ((evt[3] & 0xFF) << 24);
+
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_Get_Debug_Reg_Val(state_struct *state, u16 *val)
+{
+	u32 dbg[2] = { 0 };
+
+	if (!val) {
+		printk(KERN_ERR "val pointer is NULL!\n");
+		return CDN_ERR;
+	}
+
+	if (cdn_apb_read(state, SW_DEBUG_L << 2, &dbg[0])
+	    || cdn_apb_read(state, SW_DEBUG_H << 2, &dbg[1])) {
+		printk(KERN_ERR "Failed to read debug registers.\n");
+
+		return CDN_ERR;
+	}
+
+	*val = (u16) ((dbg[0] & 0xFF) | ((dbg[1] & 0xFF) << 8));
+
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_CheckAlive(state_struct *state)
+{
+	u32 newalive;
+
+	if (cdn_apb_read(state, KEEP_ALIVE << 2, &newalive))
+		return CDN_ERR;
+	if (alive == newalive)
+		return CDN_BSY;
+	alive = newalive;
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_CheckAlive_blocking(state_struct *state)
+{
+	internal_block_function(&state->mutex, CDN_API_CheckAlive(state));
+}
+
+CDN_API_STATUS CDN_API_MainControl(state_struct *state, u8 mode, u8 *resp)
+{
+	if (!state->running) {
+		if (!internal_apb_available(state))
+			return CDN_BSY;
+		state->bus_type = CDN_BUS_TYPE_APB;
+		state->rxEnable = 1;
+		internal_tx_mkfullmsg(state, MB_MODULE_ID_GENERAL,
+				      GENERAL_MAIN_CONTROL, 1, 1, mode);
+		return CDN_STARTED;
+	}
+	internal_process_messages(state);
+	internal_opcode_ok_or_return(state, MB_MODULE_ID_GENERAL,
+				     GENERAL_MAIN_CONTROL_RESP);
+	internal_readmsg(state, 1, 1, resp);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_MainControl_blocking(state_struct *state, u8 mode,
+					    u8 *resp)
+{
+	internal_block_function(&state->mutex,
+				CDN_API_MainControl(state, mode, resp));
+}
+
+CDN_API_STATUS CDN_API_ApbConf(state_struct *state, u8 dpcd_bus_sel,
+			       u8 dpcd_bus_lock, u8 hdcp_bus_sel,
+			       u8 hdcp_bus_lock, u8 capb_bus_sel,
+			       u8 capb_bus_lock, u8 *dpcd_resp, u8 *hdcp_resp,
+			       u8 *capb_resp)
+{
+	u8 resp;
+	u8 set = 0;
+
+	if (!state->running) {
+		if (!internal_apb_available(state))
+			return CDN_BSY;
+
+		state->bus_type = CDN_BUS_TYPE_APB;
+		state->rxEnable = 1;
+
+		set |= (dpcd_bus_sel)
+		    ? (1 << GENERAL_BUS_SETTINGS_DPCD_BUS_BIT)
+		    : 0;
+		set |= (dpcd_bus_lock)
+		    ? (1 << GENERAL_BUS_SETTINGS_DPCD_BUS_LOCK_BIT)
+		    : 0;
+		set |= (hdcp_bus_sel)
+		    ? (1 << GENERAL_BUS_SETTINGS_HDCP_BUS_BIT)
+		    : 0;
+		set |= (hdcp_bus_lock)
+		    ? (1 << GENERAL_BUS_SETTINGS_HDCP_BUS_LOCK_BIT)
+		    : 0;
+		set |= (capb_bus_sel)
+		    ? (1 << GENERAL_BUS_SETTINGS_CAPB_OWNER_BIT)
+		    : 0;
+		set |= (capb_bus_lock)
+		    ? (1 << GENERAL_BUS_SETTINGS_CAPB_OWNER_LOCK_BIT)
+		    : 0;
+
+		internal_tx_mkfullmsg(state, MB_MODULE_ID_GENERAL,
+				      GENERAL_BUS_SETTINGS, 1, 1, set);
+
+		return CDN_STARTED;
+	}
+
+	internal_process_messages(state);
+	internal_opcode_ok_or_return(state, MB_MODULE_ID_GENERAL,
+				     GENERAL_BUS_SETTINGS_RESP);
+
+	/* Read one one-byte response */
+	internal_readmsg(state, 1, 1, &resp);
+
+	*dpcd_resp =
+	    (resp & (1 << GENERAL_BUS_SETTINGS_RESP_DPCD_BUS_BIT)) ? 1 : 0;
+	*hdcp_resp =
+	    (resp & (1 << GENERAL_BUS_SETTINGS_RESP_HDCP_BUS_BIT)) ? 1 : 0;
+	*capb_resp =
+	    (resp & (1 << GENERAL_BUS_SETTINGS_RESP_CAPB_OWNER_BIT)) ? 1 : 0;
+
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_ApbConf_blocking(state_struct *state, u8 dpcd_bus_sel,
+					u8 dpcd_bus_lock,
+					u8 hdcp_bus_sel,
+					u8 hdcp_bus_lock,
+					u8 capb_bus_sel,
+					u8 capb_bus_lock,
+					u8 *dpcd_resp,
+					u8 *hdcp_resp, u8 *capb_resp)
+{
+	internal_block_function(&state->mutex, CDN_API_ApbConf
+				(state, dpcd_bus_sel, dpcd_bus_lock,
+				 hdcp_bus_sel, hdcp_bus_lock, capb_bus_sel,
+				 capb_bus_lock, dpcd_resp, hdcp_resp,
+				 capb_resp));
+}
+
+CDN_API_STATUS CDN_API_SetClock(state_struct *state, u8 MHz)
+{
+	return cdn_apb_write(state, SW_CLK_H << 2, MHz);
+}
+
+CDN_API_STATUS CDN_API_General_Read_Register(state_struct *state, u32 addr,
+					     GENERAL_Read_Register_response *resp)
+{
+	CDN_API_STATUS ret;
+	if (!state->running) {
+		if (!internal_apb_available(state))
+			return CDN_BSY;
+		internal_tx_mkfullmsg(state, MB_MODULE_ID_GENERAL,
+				      GENERAL_READ_REGISTER, 1, 4, addr);
+		state->bus_type = CDN_BUS_TYPE_APB;
+		state->rxEnable = 1;
+		return CDN_STARTED;
+	}
+	internal_process_messages(state);
+	ret = internal_test_rx_head(state, MB_MODULE_ID_GENERAL,
+				    GENERAL_READ_REGISTER_RESP);
+	if (ret != CDN_OK)
+		return ret;
+	internal_readmsg(state, 2, 4, &resp->addr, 4, &resp->val);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_General_Read_Register_blocking(state_struct *state,
+						      u32 addr, GENERAL_Read_Register_response *resp)
+{
+	internal_block_function(&state->mutex, CDN_API_General_Read_Register
+				(state, addr, resp));
+}
+
+CDN_API_STATUS CDN_API_General_Write_Register(state_struct *state, u32 addr,
+					      u32 val)
+{
+	if (!state->running) {
+		if (!internal_apb_available(state))
+			return CDN_BSY;
+		internal_tx_mkfullmsg(state, MB_MODULE_ID_GENERAL,
+				      GENERAL_WRITE_REGISTER, 2, 4, addr, 4,
+				      val);
+		state->bus_type = CDN_BUS_TYPE_APB;
+		return CDN_STARTED;
+	}
+	internal_process_messages(state);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_General_Write_Register_blocking(state_struct *state,
+						       u32 addr, u32 val)
+{
+	internal_block_function(&state->mutex, CDN_API_General_Write_Register
+				(state, addr, val));
+}
+
+CDN_API_STATUS CDN_API_General_Write_Field(state_struct *state, u32 addr,
+					   u8 startBit, u8 bitsNo, u32 val)
+{
+	if (!state->running) {
+		if (!internal_apb_available(state))
+			return CDN_BSY;
+		internal_tx_mkfullmsg(state, MB_MODULE_ID_GENERAL,
+				      GENERAL_WRITE_FIELD, 4, 4, addr, 1,
+				      startBit, 1, bitsNo, 4, val);
+		state->bus_type = CDN_BUS_TYPE_APB;
+		return CDN_STARTED;
+	}
+	internal_process_messages(state);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_General_Write_Field_blocking(state_struct *state,
+						    u32 addr, u8 startBit,
+						    u8 bitsNo, u32 val)
+{
+	internal_block_function(&state->mutex, CDN_API_General_Write_Field
+				(state, addr, startBit, bitsNo, val));
+}
+
+CDN_API_STATUS CDN_API_General_Phy_Test_Access(state_struct *state, u8 *resp)
+{
+	CDN_API_STATUS ret;
+
+	*resp = 0;
+
+	if (!state->running) {
+		if (!internal_apb_available(state))
+			return CDN_BSY;
+
+		internal_tx_mkfullmsg(state, MB_MODULE_ID_GENERAL,
+				      GENERAL_TEST_ACCESS, 0);
+		state->bus_type = CDN_BUS_TYPE_APB;
+		state->rxEnable = 1;
+
+		return CDN_STARTED;
+	}
+
+	internal_process_messages(state);
+
+	ret =
+	    internal_test_rx_head(state, MB_MODULE_ID_GENERAL,
+				  GENERAL_TEST_ACCESS);
+
+	if (ret != CDN_OK)
+		return ret;
+
+	internal_readmsg(state, 1, 1, resp);
+
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_General_Phy_Test_Access_blocking(state_struct *state,
+							u8 *resp)
+{
+	internal_block_function(&state->mutex,
+				CDN_API_General_Phy_Test_Access(state, resp));
+}
+
+CDN_API_STATUS CDN_API_General_GetHpdState(state_struct *state, u8 *hpd_state)
+{
+	CDN_API_STATUS ret;
+	*hpd_state = 0;
+
+	if (!state->running) {
+		if (!internal_apb_available(state))
+			return CDN_BSY;
+
+		internal_tx_mkfullmsg(state, MB_MODULE_ID_GENERAL, GENERAL_GET_HPD_STATE, 0);
+		state->bus_type = CDN_BUS_TYPE_APB;
+		state->rxEnable = 1;
+		return CDN_STARTED;
+	}
+
+	internal_process_messages(state);
+	ret = internal_test_rx_head(state, MB_MODULE_ID_GENERAL,
+				    GENERAL_GET_HPD_STATE);
+	if (ret != CDN_OK)
+		return ret;
+
+	internal_readmsg(state, 1, 1, hpd_state);
+
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_General_GetHpdState_blocking(state_struct *state, u8 *hpd_state)
+{
+	internal_block_function(&state->mutex,
+				CDN_API_General_GetHpdState(state, hpd_state));
+}
diff --git a/drivers/mxc/hdp/API_General.h b/drivers/mxc/hdp/API_General.h
new file mode 100644
index 000000000000..15ec2358d312
--- /dev/null
+++ b/drivers/mxc/hdp/API_General.h
@@ -0,0 +1,228 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * API_General.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef API_GENERAL_H_
+#define API_GENERAL_H_
+
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/io.h>
+#include "util.h"
+
+#define GENERAL_TEST_ECHO_MAX_PAYLOAD 100
+#define GENERAL_TEST_ECHO_MIN_PAYLOAD 1
+
+/**
+ * GENERAL_Read_Register response struct
+ */
+typedef struct {
+	u32 addr;
+	u32 val;
+} GENERAL_Read_Register_response;
+
+/**
+ * \brief set up API, must be called before any other API call
+ */
+void CDN_API_Init(state_struct *state);
+
+/**
+ * \brief Loads firmware
+ *
+ * \param iMem - pointer to instruction memory
+ * \param imemSize - size of instruction memory buffer
+ * \param dMem - pointer to data memory
+ * \param dmemSize - size of data memory buffer
+ * \return 0 if success, 1 if apb error encountered, 2 if CPU isn't alive after loading firmware
+ *
+ * This function does not require initialisation by #CDN_API_Init
+ */
+
+CDN_API_STATUS CDN_API_LoadFirmware(state_struct *state, u8 *iMem,
+				    int imemSize, u8 *dMem, int dmemSize);
+
+/**
+ * \brief debug echo command for APB
+ * \param val - value to echo
+ * \return status
+ *
+ * will return #CDN_ERROR if reply message doesn't match request
+ */
+CDN_API_STATUS CDN_API_General_Test_Echo(state_struct *state, u32 val,
+					 CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief blocking version of #CDN_API_General_Test_Echo
+ */
+CDN_API_STATUS CDN_API_General_Test_Echo_blocking(state_struct *state, u32 val,
+						  CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief Extended Echo test for mailbox.
+ *
+ * This test will send msg buffer to firmware's mailbox and receive it back to
+ * the resp buffer. Received data will be check against data sent and status will
+ * be returned as well as received data.
+ *
+ * \param msg - Pointer to a buffer to send.
+ * \param resp - Pointer to buffer for receiving msg payload back.
+ * \param num_bytes - Number of bytes to send and receive.
+ * \param bus_type Bus type.
+ * \return status
+ *
+ * will return #CDN_ERROR if reply message doesn't match request or if
+ *  arguments are invalid.
+ */
+CDN_API_STATUS CDN_API_General_Test_Echo_Ext(state_struct *state,
+					     u8 const *msg, u8 *resp,
+					     u16 num_bytes,
+					     CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief blocking version of #CDN_API_General_Test_Echo_Ext
+ */
+CDN_API_STATUS CDN_API_General_Test_Echo_Ext_blocking(state_struct *state,
+						      u8 const *msg, u8 *resp,
+						      u16 num_bytes,
+						      CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief get current version
+ * \param [out] ver - fw version
+ * \param [out] libver - lib version
+ * \return status
+ *
+ * this function does not require #CDN_API_Init
+ */
+CDN_API_STATUS CDN_API_General_getCurVersion(state_struct *state, u16 *ver,
+					     u16 *verlib);
+
+/**
+ * \brief read event value
+ * \param [out] event - pointer to store 32-bit events value
+ * \return status
+ *
+ * this function does not require #CDN_API_Init
+ */
+CDN_API_STATUS CDN_API_Get_Event(state_struct *state, u32 *events);
+
+/**
+ * \brief read debug register value
+ * \param [out] val - pointer to store 16-bit debug reg value
+ * \return status
+ *
+ * this function does not require #CDN_API_Init
+ */
+CDN_API_STATUS CDN_API_Get_Debug_Reg_Val(state_struct *state, u16 *val);
+
+/**
+ * \brief check if KEEP_ALIVE register changed
+ * \return #CDN_BSY if KEEP_ALIVE not changed, #CDN_OK if changed and #CDN_ERR if error occurred while reading
+ */
+CDN_API_STATUS CDN_API_CheckAlive(state_struct *state);
+
+/**
+ * \breif blocking version of #CDN_API_CheckAlive
+ * blocks until KEEP_ALIVE register changes or error occurs while reading
+ */
+CDN_API_STATUS CDN_API_CheckAlive_blocking(state_struct *state);
+
+/**
+ * \brief set cpu to standby or active
+ * \param [in] state - 1 for active, 0 for standby
+ * \return status
+ */
+CDN_API_STATUS CDN_API_MainControl(state_struct *state, u8 mode, u8 *resp);
+
+/**
+ * \breif blocking version of #CDN_API_MainControl
+ */
+CDN_API_STATUS CDN_API_MainControl_blocking(state_struct *state, u8 mode,
+					    u8 *resp);
+
+/**
+ * \brief settings for APB
+ *
+ * Sends GENERAL_APB_CONF Command via regular Mailbox.
+ * @param dpcd_bus_sel Set DPCD to use selected bus (0 for APB or 1 for SAPB)
+ * @param dpcd_bus_lock Lock bus type. Aftern that bus type cannot be changed
+ * by using this function.
+ * @param hdcp_bus_sel Same meaning as for DPCD but for HDCP.
+ * @param hdcp_bus_lock Same meaning as for DPCD but for HDCP.
+ * @param capb_bus_sel Same meaning as for DPCD but for Cipher APB.
+ * @param capb_bus_lock Same meaning as for DPCD but for Cipher APB.
+ * @param dpcd_resp [out] Status of the operation.
+ * If set to zero then DPCD bus type was successfully changed.
+ * If not then error occurred, most likely due to locked DPCD bus.
+ * @param hdcp_resp [out] Same as for DPCD but for HDCP.
+ * @param capb_resp [out] Same as for DPCD but for Cipher APB.
+ *
+ * \return status
+ */
+CDN_API_STATUS CDN_API_ApbConf(state_struct *state, u8 dpcd_bus_sel,
+			       u8 dpcd_bus_lock, u8 hdcp_bus_sel,
+			       u8 hdcp_bus_lock, u8 capb_bus_sel,
+			       u8 capb_bus_lock, u8 *dpcd_resp, u8 *hdcp_resp,
+			       u8 *capb_resp);
+
+/**
+ * blocking version of #CDN_API_MainControl
+ */
+CDN_API_STATUS CDN_API_ApbConf_blocking(state_struct *state, u8 dpcd_bus_sel,
+					u8 dpcd_bus_lock,
+					u8 hdcp_bus_sel,
+					u8 hdcp_bus_lock,
+					u8 capb_bus_sel,
+					u8 capb_bus_lock,
+					u8 *dpcd_resp,
+					u8 *hdcp_resp, u8 *capb_resp);
+
+/**
+ * \brief set the  xtensa clk, write this api before turn on the cpu
+ */
+CDN_API_STATUS CDN_API_SetClock(state_struct *state, u8 MHz);
+
+CDN_API_STATUS CDN_API_General_Read_Register(state_struct *state, u32 addr,
+					     GENERAL_Read_Register_response *resp);
+CDN_API_STATUS CDN_API_General_Read_Register_blocking(state_struct *state,
+						      u32 addr, GENERAL_Read_Register_response *resp);
+CDN_API_STATUS CDN_API_General_Write_Register(state_struct *state, u32 addr,
+					      u32 val);
+CDN_API_STATUS CDN_API_General_Write_Register_blocking(state_struct *state,
+						       u32 addr, u32 val);
+CDN_API_STATUS CDN_API_General_Write_Field(state_struct *state, u32 addr,
+					   u8 startBit, u8 bitsNo, u32 val);
+CDN_API_STATUS CDN_API_General_Write_Field_blocking(state_struct *state,
+						    u32 addr, u8 startBit,
+						    u8 bitsNo, u32 val);
+CDN_API_STATUS CDN_API_General_Phy_Test_Access(state_struct *state, u8 *resp);
+CDN_API_STATUS CDN_API_General_Phy_Test_Access_blocking(state_struct *state,
+							u8 *resp);
+
+/**
+ * Read HPD state to check if plug is inserted or not.
+ * @param state [out] Pointer to variable where state will be stored.
+ *  Bit 0: 0 - plug not inserted, 1 - plug inserted.
+ *  Bits 1..7: reserved.
+ * @return status
+ */
+CDN_API_STATUS CDN_API_General_GetHpdState(state_struct *state, u8 *hpd_state);
+
+/**
+ * \breif blocking version of #CDN_API_General_GetHpdState
+ */
+CDN_API_STATUS CDN_API_General_GetHpdState_blocking(state_struct *state, u8 *hpd_state);
+
+#endif
diff --git a/drivers/mxc/hdp/API_HDCP.c b/drivers/mxc/hdp/API_HDCP.c
new file mode 100644
index 000000000000..f5364a2b671d
--- /dev/null
+++ b/drivers/mxc/hdp/API_HDCP.c
@@ -0,0 +1,429 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * API_HDCP.c
+ *
+ ******************************************************************************
+ */
+
+#include "API_HDCP.h"
+#include "util.h"
+#include "address.h"
+#include "opcodes.h"
+#include "hdcp2.h"
+
+CDN_API_STATUS CDN_API_HDCP_TX_CONFIGURATION(state_struct *state, u8 val,
+					     CDN_BUS_TYPE bus_type)
+{
+	if (!state->running) {
+		if (!internal_apb_available(state))
+			return CDN_BSY;
+		state->bus_type = bus_type;
+		internal_tx_mkfullmsg(state, MB_MODULE_ID_HDCP_TX,
+				      HDCP_TX_CONFIGURATION, 1, 1, val);
+		return CDN_STARTED;
+	}
+	if (state->txEnable && !internal_mbox_tx_process(state).txend)
+		return CDN_BSY;
+	state->running = 0;
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_HDCP_TX_CONFIGURATION_blocking(state_struct *state,
+						      u8 val,
+						      CDN_BUS_TYPE bus_type)
+{
+	internal_block_function(&state->mutex, CDN_API_HDCP_TX_CONFIGURATION
+				(state, val, bus_type));
+}
+
+CDN_API_STATUS
+CDN_API_HDCP2_TX_SET_PUBLIC_KEY_PARAMS(state_struct *state,
+				       S_HDCP_TRANS_PUBLIC_KEY_PARAMS *val,
+				       CDN_BUS_TYPE bus_type)
+{
+	if (!state->running) {
+		if (!internal_apb_available(state))
+			return CDN_BSY;
+		state->bus_type = bus_type;
+		internal_tx_mkfullmsg(state, MB_MODULE_ID_HDCP_TX,
+				      HDCP2_TX_SET_PUBLIC_KEY_PARAMS, 2,
+				      -sizeof(val->N), &val->N, -sizeof(val->E),
+				      &val->E);
+		return CDN_STARTED;
+	}
+	if (state->txEnable && !internal_mbox_tx_process(state).txend)
+		return CDN_BSY;
+	state->running = 0;
+	return CDN_OK;
+}
+
+CDN_API_STATUS
+CDN_API_HDCP2_TX_SET_PUBLIC_KEY_PARAMS_blocking(state_struct *state,
+							S_HDCP_TRANS_PUBLIC_KEY_PARAMS *val,
+							CDN_BUS_TYPE bus_type)
+{
+	internal_block_function(&state->mutex,
+				CDN_API_HDCP2_TX_SET_PUBLIC_KEY_PARAMS
+				(state, val, bus_type));
+}
+
+CDN_API_STATUS CDN_API_HDCP2_TX_SET_KM_KEY_PARAMS(state_struct *state,
+						  S_HDCP_TRANS_KM_KEY_PARAMS *val,
+						  CDN_BUS_TYPE bus_type)
+{
+	if (!state->running) {
+		if (!internal_apb_available(state))
+			return CDN_BSY;
+
+		state->bus_type = bus_type;
+		internal_tx_mkfullmsg(state, MB_MODULE_ID_HDCP_TX,
+				      HDCP2_TX_SET_KM_KEY_PARAMS, 1,
+				      -sizeof(val->KM_KEY), &val->KM_KEY);
+
+		return CDN_STARTED;
+	}
+
+	if (state->txEnable && !internal_mbox_tx_process(state).txend)
+		return CDN_BSY;
+
+	state->running = 0;
+
+	return CDN_OK;
+}
+
+CDN_API_STATUS
+CDN_API_HDCP2_TX_SET_KM_KEY_PARAMS_blocking(state_struct *state,
+					    S_HDCP_TRANS_KM_KEY_PARAMS *val,
+					    CDN_BUS_TYPE bus_type)
+{
+	internal_block_function(&state->mutex,
+				CDN_API_HDCP2_TX_SET_KM_KEY_PARAMS
+				(state, val, bus_type));
+}
+
+CDN_API_STATUS
+CDN_API_HDCP2_TX_SET_DEBUG_RANDOM_NUMBERS(state_struct *state,
+					  S_HDCP_TRANS_DEBUG_RANDOM_NUMBERS *val,
+					  CDN_BUS_TYPE bus_type)
+{
+	if (!state->running) {
+		if (!internal_apb_available(state))
+			return CDN_BSY;
+		state->bus_type = bus_type;
+		internal_tx_mkfullmsg(state, MB_MODULE_ID_HDCP_TX,
+				      HDCP2_TX_SET_DEBUG_RANDOM_NUMBERS, 5,
+				      -sizeof(val->KM), &val->KM,
+				      -sizeof(val->RN), &val->RN,
+				      -sizeof(val->KS), &val->KS,
+				      -sizeof(val->RIV), &val->RIV,
+				      -sizeof(val->RTX), &val->RTX);
+		return CDN_STARTED;
+	}
+	if (state->txEnable && !internal_mbox_tx_process(state).txend)
+		return CDN_BSY;
+	state->running = 0;
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_HDCP2_TX_SET_DEBUG_RANDOM_NUMBERS_blocking(
+				state_struct *state,
+				S_HDCP_TRANS_DEBUG_RANDOM_NUMBERS *val,
+				CDN_BUS_TYPE bus_type)
+{
+	internal_block_function(&state->mutex,
+				CDN_API_HDCP2_TX_SET_DEBUG_RANDOM_NUMBERS
+				(state, val, bus_type));
+}
+
+CDN_API_STATUS CDN_API_HDCP2_TX_RESPOND_KM(state_struct *state,
+					   S_HDCP_TRANS_PAIRING_DATA *val,
+					   CDN_BUS_TYPE bus_type)
+{
+	if (!state->running) {
+		if (!internal_apb_available(state))
+			return CDN_BSY;
+		state->bus_type = bus_type;
+		/* pairing info found in storage */
+		if (val != NULL)
+			internal_tx_mkfullmsg(state, MB_MODULE_ID_HDCP_TX,
+					      HDCP2_TX_RESPOND_KM, 4,
+					      -sizeof(val->Receiver_ID),
+					      &val->Receiver_ID,
+					      -sizeof(val->m), &val->m,
+					      -sizeof(val->KM), &val->KM,
+					      -sizeof(val->EKH), &val->EKH);
+		else
+			/* no pairing info found in storage */
+			internal_tx_mkfullmsg(state, MB_MODULE_ID_HDCP_TX,
+					      HDCP2_TX_RESPOND_KM, 0);
+		return CDN_STARTED;
+	}
+	if (state->txEnable && !internal_mbox_tx_process(state).txend)
+		return CDN_BSY;
+	state->running = 0;
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_HDCP2_TX_RESPOND_KM_blocking(state_struct *state,
+						    S_HDCP_TRANS_PAIRING_DATA *val,
+							CDN_BUS_TYPE bus_type)
+{
+	internal_block_function(&state->mutex, CDN_API_HDCP2_TX_RESPOND_KM
+				(state, val, bus_type));
+}
+
+CDN_API_STATUS
+CDN_API_HDCP1_TX_SEND_KEYS(state_struct *state,
+			   S_HDCP_TX_MAIL_BOX_CMD_HDCP1_TX_SEND_KEYS *val,
+			   CDN_BUS_TYPE bus_type)
+{
+	if (!state->running) {
+		if (!internal_apb_available(state))
+			return CDN_BSY;
+		state->bus_type = bus_type;
+		internal_tx_mkfullmsg(state, MB_MODULE_ID_HDCP_TX,
+				      HDCP1_TX_SEND_KEYS, 2, -sizeof(val->AKSV),
+				      &val->AKSV, -sizeof(val->KSV), &val->KSV);
+		return CDN_STARTED;
+	}
+	if (state->txEnable && !internal_mbox_tx_process(state).txend)
+		return CDN_BSY;
+	state->running = 0;
+	return CDN_OK;
+}
+
+CDN_API_STATUS
+CDN_API_HDCP1_TX_SEND_KEYS_blocking(state_struct *state,
+				    S_HDCP_TX_MAIL_BOX_CMD_HDCP1_TX_SEND_KEYS *val,
+					CDN_BUS_TYPE bus_type)
+{
+	internal_block_function(&state->mutex, CDN_API_HDCP1_TX_SEND_KEYS
+				(state, val, bus_type));
+}
+
+CDN_API_STATUS CDN_API_HDCP1_TX_SEND_RANDOM_AN(state_struct *state, u8 An[8],
+					       CDN_BUS_TYPE bus_type)
+{
+	if (!state->running) {
+		if (!internal_apb_available(state))
+			return CDN_BSY;
+		state->bus_type = bus_type;
+		internal_tx_mkfullmsg(state, MB_MODULE_ID_HDCP_TX,
+				      HDCP1_TX_SEND_RANDOM_AN, 1, -8, An);
+		return CDN_STARTED;
+	}
+	if (state->txEnable && !internal_mbox_tx_process(state).txend)
+		return CDN_BSY;
+	state->running = 0;
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_HDCP1_TX_SEND_RANDOM_AN_blocking(state_struct *state,
+							u8 An[8], CDN_BUS_TYPE bus_type)
+{
+	internal_block_function(&state->mutex, CDN_API_HDCP1_TX_SEND_RANDOM_AN
+				(state, An, bus_type));
+}
+
+CDN_API_STATUS CDN_API_HDCP_TX_STATUS_REQ(state_struct *state,
+					u8 *resp, CDN_BUS_TYPE bus_type)
+{
+	if (!state->running) {
+		if (!internal_apb_available(state))
+			return CDN_BSY;
+		state->bus_type = bus_type;
+		state->rxEnable = 1;
+		internal_tx_mkfullmsg(state, MB_MODULE_ID_HDCP_TX,
+				      HDCP_TX_STATUS_CHANGE, 0);
+		return CDN_STARTED;
+	}
+	internal_process_messages(state);
+	internal_opcode_match_or_return(state);
+	internal_readmsg(state, 1, -5, resp);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_HDCP_TX_STATUS_REQ_blocking(state_struct *state,
+						   u8 resp[5],
+						   CDN_BUS_TYPE bus_type)
+{
+	internal_block_function(&state->mutex, CDN_API_HDCP_TX_STATUS_REQ
+				(state, resp, bus_type));
+}
+
+CDN_API_STATUS CDN_API_HDCP2_TX_IS_KM_STORED_REQ(state_struct *state,
+						 u8 resp[5],
+						 CDN_BUS_TYPE bus_type)
+{
+	printk(KERN_DEBUG "_debug: 0\n");
+	if (!state->running) {
+		if (!internal_apb_available(state))
+			return CDN_BSY;
+		printk(KERN_DEBUG "_debug: 1\n");
+		state->bus_type = bus_type;
+		state->rxEnable = 1;
+		internal_tx_mkfullmsg(state, MB_MODULE_ID_HDCP_TX,
+				      HDCP2_TX_IS_KM_STORED, 0);
+		printk(KERN_DEBUG "_debug: 2\n");
+		return CDN_STARTED;
+	}
+	printk(KERN_DEBUG "_debug: 3\n");
+	internal_process_messages(state);
+	printk(KERN_DEBUG "_debug: 4\n");
+	internal_opcode_match_or_return(state);
+	printk(KERN_DEBUG "_debug: 5\n");
+	internal_readmsg(state, 1, -5, resp);
+	printk(KERN_DEBUG "_debug: 6\n");
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_HDCP2_TX_IS_KM_STORED_REQ_blocking(state_struct *state,
+							  u8 resp[5],
+							  CDN_BUS_TYPE bus_type)
+{
+	internal_block_function(&state->mutex, CDN_API_HDCP2_TX_IS_KM_STORED_REQ
+				(state, resp, bus_type));
+}
+
+CDN_API_STATUS CDN_API_HDCP2_TX_STORE_KM_REQ(state_struct *state,
+					     S_HDCP_TRANS_PAIRING_DATA *resp,
+					     CDN_BUS_TYPE bus_type)
+{
+	if (!state->running) {
+		if (!internal_apb_available(state))
+			return CDN_BSY;
+		state->bus_type = bus_type;
+		state->rxEnable = 1;
+		internal_tx_mkfullmsg(state, MB_MODULE_ID_HDCP_TX,
+				      HDCP2_TX_STORE_KM, 0);
+		return CDN_STARTED;
+	}
+	internal_process_messages(state);
+	internal_opcode_match_or_return(state);
+	internal_readmsg(state, 4,
+			 -sizeof(resp->Receiver_ID), &resp->Receiver_ID,
+			 -sizeof(resp->m), &resp->m,
+			 -sizeof(resp->KM), &resp->KM,
+			 -sizeof(resp->EKH), &resp->EKH);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_HDCP2_TX_STORE_KM_REQ_blocking(state_struct *state,
+						      S_HDCP_TRANS_PAIRING_DATA
+						      *resp,
+						      CDN_BUS_TYPE bus_type)
+{
+	internal_block_function(&state->mutex, CDN_API_HDCP2_TX_STORE_KM_REQ
+				(state, resp, bus_type));
+}
+
+CDN_API_STATUS CDN_API_HDCP_TX_IS_RECEIVER_ID_VALID_REQ(state_struct *state,
+							u8 *num, u8 *id,
+							CDN_BUS_TYPE bus_type)
+{
+	if (!state->running) {
+		if (!internal_apb_available(state))
+			return CDN_BSY;
+		state->bus_type = bus_type;
+		state->rxEnable = 1;
+		internal_tx_mkfullmsg(state, MB_MODULE_ID_HDCP_TX,
+				      HDCP_TX_IS_RECEIVER_ID_VALID, 0);
+		return CDN_STARTED;
+	}
+	internal_process_messages(state);
+	internal_opcode_match_or_return(state);
+	internal_readmsg(state, 1, 1, num);
+	internal_readmsg(state, 2, 1, NULL, -5 * *num, id);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_HDCP_TX_IS_RECEIVER_ID_VALID_REQ_blocking(
+								state_struct *state,
+								 u8 *num,
+								 u8 *id,
+								 CDN_BUS_TYPE
+								 bus_type)
+{
+	internal_block_function(&state->mutex,
+				CDN_API_HDCP_TX_IS_RECEIVER_ID_VALID_REQ
+				(state, num, id, bus_type));
+}
+
+CDN_API_STATUS CDN_API_HDCP_TX_RESPOND_RECEIVER_ID_VALID(
+							state_struct *state,
+							 u8 valid,
+							 CDN_BUS_TYPE bus_type)
+{
+	if (!state->running) {
+		if (!internal_apb_available(state))
+			return CDN_BSY;
+		state->bus_type = bus_type;
+		internal_tx_mkfullmsg(state, MB_MODULE_ID_HDCP_TX,
+				      HDCP_TX_RESPOND_RECEIVER_ID_VALID, 1, 1,
+				      valid);
+		return CDN_STARTED;
+	}
+	internal_process_messages(state);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_HDCP_TX_RESPOND_RECEIVER_ID_VALID_blocking(
+								state_struct *state,
+								u8 valid,
+								CDN_BUS_TYPE
+								bus_type)
+{
+	internal_block_function(&state->mutex,
+				CDN_API_HDCP_TX_RESPOND_RECEIVER_ID_VALID
+				(state, valid, bus_type));
+}
+
+CDN_API_STATUS CDN_API_HDCP_GENERAL_2_SET_LC(state_struct *state, u8 *lc,
+					     CDN_BUS_TYPE bus_type)
+{
+	internal_macro_command_tx(state, MB_MODULE_ID_HDCP_GENERAL,
+				  HDCP_GENERAL_SET_LC_128, bus_type, 1, -16, lc);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_HDCP_GENERAL_2_SET_LC_blocking(state_struct *state,
+						      u8 *lc,
+						      CDN_BUS_TYPE bus_type)
+{
+	internal_block_function(&state->mutex, CDN_API_HDCP_GENERAL_2_SET_LC
+				(state, lc, bus_type));
+}
+
+CDN_API_STATUS CDN_API_TEST_KEYS(state_struct *state, u8 test_type, u8 resp[1],
+				 CDN_BUS_TYPE bus_type)
+{
+	if (!state->running) {
+		if (!internal_apb_available(state))
+			return CDN_BSY;
+		state->bus_type = bus_type;
+		state->rxEnable = 1;
+		internal_tx_mkfullmsg(state, MB_MODULE_ID_HDCP_TX,
+				      HDCP_TX_TEST_KEYS, 1, 1, test_type);
+		return CDN_STARTED;
+	}
+	internal_process_messages(state);
+	internal_opcode_match_or_return(state);
+	internal_readmsg(state, 1, -1, resp);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_TEST_KEYS_blocking(state_struct *state, u8 test_type,
+					  u8 resp[1], CDN_BUS_TYPE bus_type)
+{
+	internal_block_function(&state->mutex, CDN_API_TEST_KEYS
+				(state, test_type, resp, bus_type));
+}
diff --git a/drivers/mxc/hdp/API_HDCP.h b/drivers/mxc/hdp/API_HDCP.h
new file mode 100644
index 000000000000..4a657c8aa3d4
--- /dev/null
+++ b/drivers/mxc/hdp/API_HDCP.h
@@ -0,0 +1,233 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * API_HDCP.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef _API_HDCP_H_
+#define _API_HDCP_H_
+
+/**
+ * \addtogroup HDCP_API
+ * \{
+ */
+
+#include "API_General.h"
+#include "hdcp_tran.h"
+
+/**
+ * \brief send HDCP_TX_CONFIGURATION command
+ * \return status
+ */
+CDN_API_STATUS CDN_API_HDCP_TX_CONFIGURATION(state_struct *state, u8 val,
+					     CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief blocking version of #CDN_API_HDCP_TX_CONFIGURATION
+ */
+CDN_API_STATUS CDN_API_HDCP_TX_CONFIGURATION_blocking(state_struct *state,
+						      u8 val,
+						      CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief send HDCP2_TX_SET_PUBLIC_KEY_PARAMS command
+ * \return status
+ */
+CDN_API_STATUS
+CDN_API_HDCP2_TX_SET_PUBLIC_KEY_PARAMS(state_struct *state,
+				       S_HDCP_TRANS_PUBLIC_KEY_PARAMS *val,
+				       CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief blocking version of #CDN_API_HDCP2_TX_SET_PUBLIC_KEY_PARAMS
+ */
+CDN_API_STATUS
+CDN_API_HDCP2_TX_SET_PUBLIC_KEY_PARAMS_blocking(state_struct *state,
+						S_HDCP_TRANS_PUBLIC_KEY_PARAMS *val,
+						CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief send HDCP2_TX_SET_KM_KEY_PARAMS command
+ * \return status
+ */
+CDN_API_STATUS CDN_API_HDCP2_TX_SET_KM_KEY_PARAMS(state_struct *state,
+						  S_HDCP_TRANS_KM_KEY_PARAMS *val,
+						  CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief blocking version of #CDN_API_HDCP2_TX_SET_KM_KEY_PARAMS
+ */
+CDN_API_STATUS
+CDN_API_HDCP2_TX_SET_KM_KEY_PARAMS_blocking(state_struct *state,
+					    S_HDCP_TRANS_KM_KEY_PARAMS *val,
+					    CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief send HDCP2_TX_SET_DEBUG_RANDOM_NUMBERS command
+ * \return status
+ */
+CDN_API_STATUS
+CDN_API_HDCP2_TX_SET_DEBUG_RANDOM_NUMBERS(state_struct *state,
+					  S_HDCP_TRANS_DEBUG_RANDOM_NUMBERS *val,
+					  CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief blocking version of #CDN_API_HDCP2_TX_SET_DEBUG_RANDOM_NUMBERS
+ */
+CDN_API_STATUS
+	CDN_API_HDCP2_TX_SET_DEBUG_RANDOM_NUMBERS_blocking
+	(state_struct *state, S_HDCP_TRANS_DEBUG_RANDOM_NUMBERS *val,
+	CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief send HDCP2_TX_RESPOND_KM command
+ * \param val - if NULL no arguments will be send
+ * \return status
+ */
+CDN_API_STATUS CDN_API_HDCP2_TX_RESPOND_KM(state_struct *state,
+					   S_HDCP_TRANS_PAIRING_DATA *val,
+					   CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief blocking version of #CDN_API_HDCP2_TX_RESPOND_KM
+ */
+CDN_API_STATUS CDN_API_HDCP2_TX_RESPOND_KM_blocking(state_struct *state,
+						    S_HDCP_TRANS_PAIRING_DATA *val,
+							CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief send HDCP1_TX_SEND_KEYS command
+ * \return status
+ */
+CDN_API_STATUS
+CDN_API_HDCP1_TX_SEND_KEYS(state_struct *state,
+			   S_HDCP_TX_MAIL_BOX_CMD_HDCP1_TX_SEND_KEYS *val,
+			   CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief blocking version of #CDN_API_HDCP1_TX_SEND_KEYS
+ */
+CDN_API_STATUS
+CDN_API_HDCP1_TX_SEND_KEYS_blocking(state_struct *state,
+				    S_HDCP_TX_MAIL_BOX_CMD_HDCP1_TX_SEND_KEYS *val,
+					CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief send HDCP1_TX_SEND_RANDOM_AN command
+ * \return status
+ */
+CDN_API_STATUS CDN_API_HDCP1_TX_SEND_RANDOM_AN(state_struct *state, u8 An[8],
+					       CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief blocking version of #CDN_API_HDCP1_TX_SEND_RANDOM_AN
+ */
+CDN_API_STATUS CDN_API_HDCP1_TX_SEND_RANDOM_AN_blocking(state_struct *state,
+							u8 An[8],
+							CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief send HDCP_TX_STATUS_REQ command
+ * \return status
+ */
+CDN_API_STATUS CDN_API_HDCP_TX_STATUS_REQ(state_struct *state, u8 resp[5],
+					  CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief blocking version of #CDN_API_HDCP_TX_STATUS_REQ
+ */
+CDN_API_STATUS CDN_API_HDCP_TX_STATUS_REQ_blocking(state_struct *state,
+						   u8 resp[5],
+						   CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief send HDCP2_TX_IS_KM_STORED_REQ command
+ * \return status
+ */
+CDN_API_STATUS CDN_API_HDCP2_TX_IS_KM_STORED_REQ(state_struct *state,
+						 u8 resp[5],
+						 CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief blocking version of #CDN_API_HDCP2_TX_IS_KM_STORED_REQ
+ */
+CDN_API_STATUS CDN_API_HDCP2_TX_IS_KM_STORED_REQ_blocking(state_struct *state,
+							  u8 resp[5],
+							  CDN_BUS_TYPE
+							  bus_type);
+
+/**
+ * \brief send HDCP2_TX_STORE_KM_REQ command
+ * \return status
+ */
+CDN_API_STATUS CDN_API_HDCP2_TX_STORE_KM_REQ(state_struct *state,
+					     S_HDCP_TRANS_PAIRING_DATA *resp,
+					     CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief blocking version of #CDN_API_HDCP2_TX_STORE_KM_REQ
+ */
+CDN_API_STATUS CDN_API_HDCP2_TX_STORE_KM_REQ_blocking(state_struct *state,
+						      S_HDCP_TRANS_PAIRING_DATA
+						      *resp,
+						      CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief send HDCP_TX_IS_RECEIVER_ID_VALID_REQ command
+ * \return status
+ */
+CDN_API_STATUS CDN_API_HDCP_TX_IS_RECEIVER_ID_VALID_REQ(state_struct *state,
+							u8 *num, u8 *id,
+							CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief blocking version of #CDN_API_HDCP_TX_IS_RECEIVER_ID_VALID_REQ
+ */
+CDN_API_STATUS CDN_API_HDCP_TX_IS_RECEIVER_ID_VALID_REQ_blocking(state_struct *state,
+								 u8 *num,
+								 u8 *id,
+								 CDN_BUS_TYPE
+								 bus_type);
+
+/**
+ * \brief send HDCP_TX_RESPOND_RECEIVER_ID_VALID command
+ * \return status
+ */
+CDN_API_STATUS CDN_API_HDCP_TX_RESPOND_RECEIVER_ID_VALID(state_struct *state,
+							 u8 valid,
+							 CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief blocking version of #CDN_API_HDCP_TX_RESPOND_RECEIVER_ID_VALID
+ */
+CDN_API_STATUS CDN_API_HDCP_TX_RESPOND_RECEIVER_ID_VALID_blocking(state_struct *state,
+								  u8 valid,
+								  CDN_BUS_TYPE
+								  bus_type);
+
+CDN_API_STATUS CDN_API_HDCP_GENERAL_2_SET_LC(state_struct *state, u8 *lc,
+					     CDN_BUS_TYPE bus_type);
+CDN_API_STATUS CDN_API_HDCP_GENERAL_2_SET_LC_blocking(state_struct *state,
+						      u8 *lc,
+						      CDN_BUS_TYPE bus_type);
+/* TODO DK: Implement */
+CDN_API_STATUS CDN_API_HDCP_SET_SEED(state_struct *state, u8 *seed,
+				     CDN_BUS_TYPE bus_type);
+CDN_API_STATUS CDN_API_HDCP_SET_SEED_blocking(state_struct *state, u8 *seed,
+					      CDN_BUS_TYPE bus_type);
+CDN_API_STATUS CDN_API_TEST_KEYS(state_struct *state, u8 test_type, u8 resp[1],
+				 CDN_BUS_TYPE bus_type);
+CDN_API_STATUS CDN_API_TEST_KEYS_blocking(state_struct *state, u8 test_type,
+					  u8 resp[1], CDN_BUS_TYPE bus_type);
+
+#endif
diff --git a/drivers/mxc/hdp/API_HDMITX.c b/drivers/mxc/hdp/API_HDMITX.c
new file mode 100644
index 000000000000..c346f06c459b
--- /dev/null
+++ b/drivers/mxc/hdp/API_HDMITX.c
@@ -0,0 +1,469 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * API_HDMITX.c
+ *
+ ******************************************************************************
+ */
+
+#include "API_HDMITX.h"
+#include "util.h"
+#include "opcodes.h"
+#include "mhl_hdtx_top.h"
+#include "source_phy.h"
+#include "address.h"
+#include "source_car.h"
+#include "source_vif.h"
+#include "general_handler.h"
+
+CDN_API_STATUS CDN_API_HDMITX_DDC_READ(state_struct *state,
+				       HDMITX_TRANS_DATA *data_in,
+				       HDMITX_TRANS_DATA *data_out)
+{
+	internal_macro_command_txrx(state, MB_MODULE_ID_HDMI_TX, HDMI_TX_READ,
+				    CDN_BUS_TYPE_APB, 3, 1, data_in->slave, 1,
+				    data_in->offset, 2, data_in->len);
+	internal_readmsg(state, 5, 1, &data_out->status, 1, &data_out->slave, 1,
+			 &data_out->offset, 2, &data_out->len, 0,
+			 &data_out->buff);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_HDMITX_DDC_READ_blocking(state_struct *state,
+						HDMITX_TRANS_DATA *data_in,
+						HDMITX_TRANS_DATA *data_out)
+{
+	internal_block_function(&state->mutex, CDN_API_HDMITX_DDC_READ
+				(state, data_in, data_out));
+}
+
+CDN_API_STATUS CDN_API_HDMITX_DDC_WRITE(state_struct *state,
+					HDMITX_TRANS_DATA *data_in,
+					HDMITX_TRANS_DATA *data_out)
+{
+	printk(KERN_INFO "foo: %x\n", data_in->buff[0]);
+	internal_macro_command_txrx(state, MB_MODULE_ID_HDMI_TX, HDMI_TX_WRITE,
+				    CDN_BUS_TYPE_APB, 4, 1, data_in->slave, 1,
+				    data_in->offset, 2, data_in->len,
+				    -data_in->len, data_in->buff);
+	internal_readmsg(state, 4, 1, &data_out->status, 1, &data_out->slave, 1,
+			 &data_out->offset, 2, &data_out->len);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_HDMITX_DDC_WRITE_blocking(state_struct *state,
+						 HDMITX_TRANS_DATA *data_in,
+						 HDMITX_TRANS_DATA *data_out)
+{
+	internal_block_function(&state->mutex, CDN_API_HDMITX_DDC_WRITE
+				(state, data_in, data_out));
+}
+
+CDN_API_STATUS CDN_API_HDMITX_DDC_UPDATE_READ(state_struct *state,
+					      HDMITX_TRANS_DATA *data_out)
+{
+	internal_macro_command_txrx(state, MB_MODULE_ID_HDMI_TX,
+				    HDMI_TX_UPDATE_READ, CDN_BUS_TYPE_APB, 0);
+	internal_readmsg(state, 2, 1, &data_out->status, 0, &data_out->buff);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_HDMITX_DDC_UPDATE_READ_blocking(state_struct *state,
+						       HDMITX_TRANS_DATA *
+						       data_out)
+{
+	internal_block_function(&state->mutex, CDN_API_HDMITX_DDC_UPDATE_READ
+				(state, data_out));
+}
+
+CDN_API_STATUS CDN_API_HDMITX_READ_EDID(state_struct *state, u8 block,
+					u8 segment,
+					HDMITX_TRANS_DATA *data_out)
+{
+	internal_macro_command_txrx(state, MB_MODULE_ID_HDMI_TX, HDMI_TX_EDID,
+				    CDN_BUS_TYPE_APB, 2, 1, block, 1, segment);
+	internal_readmsg(state, 5, 1, &data_out->status, 1, &data_out->slave, 1,
+			 &data_out->offset, 2, &data_out->len, 0,
+			 &data_out->buff);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_HDMITX_READ_EDID_blocking(state_struct *state, u8 block,
+						 u8 segment,
+						 HDMITX_TRANS_DATA *data_out)
+{
+	internal_block_function(&state->mutex, CDN_API_HDMITX_READ_EDID
+				(state, block, segment, data_out));
+}
+
+CDN_API_STATUS
+CDN_API_HDMITX_Set_Mode_blocking(state_struct *state,
+				 HDMI_TX_MAIL_HANDLER_PROTOCOL_TYPE protocol,
+				 u32 character_rate)
+{
+	CDN_API_STATUS ret;
+	GENERAL_Read_Register_response resp;
+	HDMITX_TRANS_DATA data_in;
+	HDMITX_TRANS_DATA data_out;
+	u8 buff = 1;
+
+	/* enable/disable  scrambler; */
+	if (protocol == HDMI_TX_MODE_HDMI_2_0) {
+		if (character_rate >= 340000)
+			buff = 3;	/* enable scrambling + TMDS_Bit_Clock_Ratio */
+		else
+			buff = 1;	/* enable scrambling */
+	} else {
+		buff = 0;	/* disable scrambling */
+	}
+
+	data_in.buff = &buff;
+	data_in.len = 1;
+	data_in.slave = 0x54;
+	data_in.offset = 0x20;	/* TMDS config */
+	if (protocol == HDMI_TX_MODE_HDMI_2_0)
+		ret =
+		    CDN_API_HDMITX_DDC_WRITE_blocking(state, &data_in,
+						      &data_out);
+	ret =
+	    CDN_API_General_Read_Register_blocking(state,
+						   ADDR_SOURCE_MHL_HD +
+						   (HDTX_CONTROLLER << 2),
+						   &resp);
+
+	/* remove data enable */
+	resp.val = resp.val & (~(F_DATA_EN(1)));
+	ret =
+	    CDN_API_General_Write_Register_blocking(state, ADDR_SOURCE_MHL_HD +
+						    (HDTX_CONTROLLER << 2),
+						    resp.val);
+	if (protocol == HDMI_TX_MODE_HDMI_2_0) {
+		if (character_rate >= 340000) {
+			ret =
+			    CDN_API_General_Write_Register_blocking
+			    (state,
+			     ADDR_SOURCE_MHL_HD + (HDTX_CLOCK_REG_0 << 2),
+			     F_DATA_REGISTER_VAL_0(0x00000));
+			ret =
+			    CDN_API_General_Write_Register_blocking(state,
+								    ADDR_SOURCE_MHL_HD
+								    +
+								    (HDTX_CLOCK_REG_1
+								     << 2),
+								    F_DATA_REGISTER_VAL_1
+								    (0xFFFFF));
+		}
+	}
+	/* set hdmi mode and preemble mode */
+	resp.val = resp.val & (~(F_HDMI_MODE(3)));
+	resp.val = resp.val & (~(F_HDMI2_PREAMBLE_EN(1)));
+
+	resp.val =
+	    (resp.val) | (F_HDMI_MODE(protocol)) | (F_HDMI2_PREAMBLE_EN(1));
+	ret =
+	    CDN_API_General_Write_Register_blocking(state, ADDR_SOURCE_MHL_HD +
+						    (HDTX_CONTROLLER << 2),
+						    resp.val);
+
+	/* data enable */
+	resp.val |= F_DATA_EN(1);
+	ret =
+	    CDN_API_General_Write_Register_blocking(state, ADDR_SOURCE_MHL_HD +
+						    (HDTX_CONTROLLER << 2),
+						    resp.val);
+	return ret;
+}
+
+CDN_API_STATUS CDN_API_HDMITX_Init_blocking(state_struct *state)
+{
+	CDN_API_STATUS ret;
+
+	ret =
+	    CDN_API_General_Write_Register_blocking(state, ADDR_SOURCD_PHY +
+						    (PHY_DATA_SEL << 2),
+						    F_SOURCE_PHY_MHDP_SEL(1));
+	ret =
+	    CDN_API_General_Write_Register_blocking(state, ADDR_SOURCE_MHL_HD +
+						    (HDTX_HPD << 2),
+						    F_HPD_VALID_WIDTH(4) |
+						    F_HPD_GLITCH_WIDTH(0));
+	ret =
+	    CDN_API_General_Write_Register_blocking(state, ADDR_SOURCE_MHL_HD +
+						    (HDTX_CONTROLLER << 2),
+						    F_HDMI_MODE(1) |
+						    F_AUTO_MODE(0) | F_GCP_EN(1)
+						    | F_DATA_EN(1) |
+						    F_CLEAR_AVMUTE(1) |
+						    F_HDMI2_PREAMBLE_EN(1) |
+						    F_HDMI2_CTRL_IL_MODE(1) |
+						    F_PIC_3D(0XF) |
+						    F_BCH_EN(1));
+	/* open CARS */
+	ret =
+	    CDN_API_General_Write_Register_blocking(state, ADDR_SOURCE_CAR +
+						    (SOURCE_PHY_CAR << 2), 0xF);
+	ret =
+	    CDN_API_General_Write_Register_blocking(state, ADDR_SOURCE_CAR +
+						    (SOURCE_HDTX_CAR << 2),
+						    0xFF);
+	ret =
+	    CDN_API_General_Write_Register_blocking(state, ADDR_SOURCE_CAR +
+						    (SOURCE_PKT_CAR << 2), 0xF);
+	ret =
+	    CDN_API_General_Write_Register_blocking(state, ADDR_SOURCE_CAR +
+						    (SOURCE_AIF_CAR << 2), 0xF);
+	ret =
+	    CDN_API_General_Write_Register_blocking(state, ADDR_SOURCE_CAR +
+						    (SOURCE_CIPHER_CAR << 2),
+						    0xF);
+	ret =
+	    CDN_API_General_Write_Register_blocking(state, ADDR_SOURCE_CAR +
+						    (SOURCE_CRYPTO_CAR << 2),
+						    0xF);
+	ret =
+	    CDN_API_General_Write_Register_blocking(state, ADDR_SOURCE_CAR +
+						    (SOURCE_CEC_CAR << 2), 3);
+
+	/* init vif */
+	ret =
+	    CDN_API_General_Write_Register_blocking(state, ADDR_SOURCE_VIF +
+						    (HSYNC2VSYNC_POL_CTRL << 2),
+						    F_HPOL(0) | F_VPOL(0));
+	return ret;
+}
+
+CDN_API_STATUS CDN_API_HDMITX_SetVic_blocking(state_struct *state,
+					      struct drm_display_mode *mode,
+					      int bpp,
+					      VIC_PXL_ENCODING_FORMAT format)
+{
+	CDN_API_STATUS ret;
+	GENERAL_Read_Register_response resp;
+	u32 vsync_lines = mode->vsync_end - mode->vsync_start;
+	u32 eof_lines = mode->vsync_start - mode->vdisplay;
+	u32 sof_lines = mode->vtotal - mode->vsync_end;
+	u32 hblank = mode->htotal - mode->hdisplay;
+	u32 hactive = mode->hdisplay;
+	u32 vblank = mode->vtotal - mode->vdisplay;
+	u32 vactive = mode->vdisplay;
+	u32 hfront = mode->hsync_start - mode->hdisplay;
+	u32 hback = mode->htotal - mode->hsync_end;
+	u32 vfront = eof_lines;
+	u32 hsync = hblank - hfront - hback;
+	u32 vsync = vsync_lines;
+	u32 vback = sof_lines;
+	u32 v_h_polarity = ((mode->flags & DRM_MODE_FLAG_NHSYNC) ? 0 : 1) +
+			   ((mode->flags & DRM_MODE_FLAG_NVSYNC) ? 0 : 2);
+
+	ret = CDN_API_General_Write_Register_blocking(state,
+						      ADDR_SOURCE_MHL_HD +
+						      (SCHEDULER_H_SIZE << 2),
+						      (hactive << 16) + hblank);
+	if (ret != CDN_OK)
+		return ret;
+
+	ret = CDN_API_General_Write_Register_blocking(state,
+						      ADDR_SOURCE_MHL_HD +
+						      (SCHEDULER_V_SIZE << 2),
+						      (vactive << 16) + vblank);
+	if (ret != CDN_OK)
+		return ret;
+
+	ret = CDN_API_General_Write_Register_blocking(state,
+						      ADDR_SOURCE_MHL_HD +
+						      (HDTX_SIGNAL_FRONT_WIDTH
+						       << 2),
+						      (vfront << 16) + hfront);
+	if (ret != CDN_OK)
+		return ret;
+
+	ret = CDN_API_General_Write_Register_blocking(state,
+						      ADDR_SOURCE_MHL_HD +
+						      (HDTX_SIGNAL_SYNC_WIDTH <<
+						       2),
+						      (vsync << 16) + hsync);
+	if (ret != CDN_OK)
+		return ret;
+
+	ret = CDN_API_General_Write_Register_blocking(state,
+						      ADDR_SOURCE_MHL_HD +
+						      (HDTX_SIGNAL_BACK_WIDTH <<
+						       2),
+						      (vback << 16) + hback);
+	if (ret != CDN_OK)
+		return ret;
+
+	ret = CDN_API_General_Write_Register_blocking(state,
+						      ADDR_SOURCE_VIF +
+						      (HSYNC2VSYNC_POL_CTRL <<
+						       2),
+						      v_h_polarity);
+	if (ret != CDN_OK)
+		return ret;
+
+	/* Reset Data Enable */
+	ret = CDN_API_General_Read_Register_blocking(state,
+						     ADDR_SOURCE_MHL_HD +
+						     (HDTX_CONTROLLER << 2),
+						     &resp);
+	if (ret != CDN_OK)
+		return ret;
+
+	/* reset data enable */
+	resp.val = resp.val & (~(F_DATA_EN(1)));
+	ret = CDN_API_General_Write_Register_blocking(state,
+						      ADDR_SOURCE_MHL_HD +
+						      (HDTX_CONTROLLER << 2),
+						      resp.val);
+	if (ret != CDN_OK)
+		return ret;
+
+	/* set bpp */
+	resp.val = resp.val & (~(F_VIF_DATA_WIDTH(3)));
+	switch (bpp) {
+	case 8:
+		resp.val = resp.val | (F_VIF_DATA_WIDTH(0));
+		break;
+
+	case 10:
+		resp.val = resp.val | (F_VIF_DATA_WIDTH(1));
+		break;
+
+	case 12:
+		resp.val = resp.val | (F_VIF_DATA_WIDTH(2));
+		break;
+
+	case 16:
+		resp.val = resp.val | (F_VIF_DATA_WIDTH(3));
+		break;
+	}
+
+	/* select color encoding */
+	resp.val = resp.val & (~(F_HDMI_ENCODING(3)));
+	switch (format) {
+	case PXL_RGB:
+
+		resp.val = resp.val | (F_HDMI_ENCODING(0));
+		break;
+
+	case YCBCR_4_4_4:
+		resp.val = resp.val | (F_HDMI_ENCODING(2));
+		break;
+
+	case YCBCR_4_2_2:
+		resp.val = resp.val | (F_HDMI_ENCODING(1));
+		break;
+
+	case YCBCR_4_2_0:
+		resp.val = resp.val | (F_HDMI_ENCODING(3));
+		break;
+	case Y_ONLY:
+		/* not exist in hdmi */
+		break;
+	}
+
+	ret = CDN_API_General_Write_Register_blocking(state,
+						      ADDR_SOURCE_MHL_HD +
+						      (HDTX_CONTROLLER << 2),
+						      resp.val);
+	if (ret != CDN_OK)
+		return ret;
+
+	/* set data enable */
+	resp.val = resp.val | (F_DATA_EN(1));
+	ret = CDN_API_General_Write_Register_blocking(state,
+						      ADDR_SOURCE_MHL_HD +
+						      (HDTX_CONTROLLER << 2),
+						      resp.val);
+	if (ret != CDN_OK)
+		return ret;
+
+	return ret;
+}
+
+CDN_API_STATUS CDN_API_HDMITX_ForceColorDepth_blocking(state_struct *state,
+						       u8 force, u8 val)
+{
+	u32 valToWrite = F_COLOR_DEPTH_VAL(val) | F_COLOR_DEPTH_FORCE(force);
+
+	return CDN_API_General_Write_Register_blocking(state,
+						       ADDR_SOURCE_MHL_HD +
+						       (GCP_FORCE_COLOR_DEPTH_CODING
+							<< 2), valToWrite);
+
+}
+
+CDN_API_STATUS CDN_API_HDMITX_ReadEvents(state_struct *state,
+					 uint32_t *events)
+{
+	CDN_API_STATUS ret;
+
+	if (!state->running) {
+		if (!internal_apb_available(state))
+			return CDN_BSY;
+
+		internal_tx_mkfullmsg(state, MB_MODULE_ID_HDMI_TX,
+				      HDMI_TX_EVENTS, 0);
+		state->rxEnable = 1;
+		state->bus_type = CDN_BUS_TYPE_APB;
+
+		return CDN_STARTED;
+	}
+
+	internal_process_messages(state);
+
+	ret =
+	    internal_test_rx_head(state, MB_MODULE_ID_HDMI_TX, HDMI_TX_EVENTS);
+
+	if (ret != CDN_OK)
+		return ret;
+
+	internal_readmsg(state, 1, 4, events);
+
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_HDMITX_ReadEvents_blocking(state_struct *state,
+						  uint32_t *events)
+{
+	internal_block_function(&state->mutex,
+				CDN_API_HDMITX_ReadEvents(state, events));
+}
+
+CDN_API_STATUS CDN_API_HDMITX_GetHpdStatus(state_struct *state, u8 *hpd_sts)
+{
+	CDN_API_STATUS ret;
+
+	if (!state->running) {
+		if (!internal_apb_available(state))
+			return CDN_BSY;
+		internal_tx_mkfullmsg(state, MB_MODULE_ID_HDMI_TX,
+				      HDMI_TX_HPD_STATUS, 0);
+		state->rxEnable = 1;
+		state->bus_type = CDN_BUS_TYPE_APB;
+		return CDN_STARTED;
+	}
+	internal_process_messages(state);
+	ret =
+	    internal_test_rx_head(state, MB_MODULE_ID_HDMI_TX,
+				  HDMI_TX_HPD_STATUS);
+	if (ret != CDN_OK)
+		return ret;
+	internal_readmsg(state, 1, 1, hpd_sts);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_HDMITX_GetHpdStatus_blocking(state_struct *state,
+						    u8 *hpd_sts)
+{
+	internal_block_function(&state->mutex,
+				CDN_API_HDMITX_GetHpdStatus(state, hpd_sts));
+}
diff --git a/drivers/mxc/hdp/API_HDMITX.h b/drivers/mxc/hdp/API_HDMITX.h
new file mode 100644
index 000000000000..c06c04bb5eca
--- /dev/null
+++ b/drivers/mxc/hdp/API_HDMITX.h
@@ -0,0 +1,135 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * API_HDMITX.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef _API_HDMITX_H_
+#define _API_HDMITX_H_
+
+#include "API_General.h"
+#include "hdmi.h"
+
+/**
+ * \addtogroup HDMI_TX_API
+ * \{
+ */
+
+# define HDMI_TX_EVENT_CODE_HPD_HIGH                  0x01
+# define HDMI_TX_EVENT_CODE_HPD_LOW                   0x02
+# define HDMI_TX_EVENT_CODE_HPD_STATE_LOW             0x00
+# define HDMI_TX_EVENT_CODE_HPD_STATE_HIGH            0x08
+typedef struct {
+    /** if used to return data, this pointer is set (instead of being a destination to copy data to */
+	u8 *buff;
+	HDMI_I2C_STATUS status;
+	u16 len;
+	u8 slave;
+	u8 offset;
+} HDMITX_TRANS_DATA;
+
+typedef enum {
+	HDMI_TX_MODE_DVI,
+	HDMI_TX_MODE_HDMI_1_4,
+	HDMI_TX_MODE_HDMI_2_0,
+} HDMI_TX_MAIL_HANDLER_PROTOCOL_TYPE;
+
+/**
+ * \brief I2C read transaction
+ * \param [in]  data_in  - fields used: len, slave, offset
+ * \param [out] data_out - fields used: all
+ * \returns status
+ */
+CDN_API_STATUS CDN_API_HDMITX_DDC_READ(state_struct *state,
+				       HDMITX_TRANS_DATA *data_in,
+				       HDMITX_TRANS_DATA *data_out);
+CDN_API_STATUS CDN_API_HDMITX_DDC_READ_blocking(state_struct *state,
+						HDMITX_TRANS_DATA *data_in,
+						HDMITX_TRANS_DATA *data_out);
+
+/**
+ * \brief I2C write transaction
+ * \param [in]  data_in  - fields used: len, slave, offset, buff
+ * \param [out] data_out - fields used: status, len, slave, offset
+ * \returns status
+ */
+CDN_API_STATUS CDN_API_HDMITX_DDC_WRITE(state_struct *state,
+					HDMITX_TRANS_DATA *data_in,
+					HDMITX_TRANS_DATA *data_out);
+CDN_API_STATUS CDN_API_HDMITX_DDC_WRITE_blocking(state_struct *state,
+						 HDMITX_TRANS_DATA *data_in,
+						 HDMITX_TRANS_DATA *data_out);
+
+/**
+ * \brief I2C update read
+ * \param [out] data_out - fields used: status, buff
+ * \returns status
+ */
+CDN_API_STATUS CDN_API_HDMITX_DDC_UPDATE_READ(state_struct *state,
+					      HDMITX_TRANS_DATA *data_out);
+CDN_API_STATUS CDN_API_HDMITX_DDC_UPDATE_READ_blocking(state_struct *state,
+						       HDMITX_TRANS_DATA *
+						       data_out);
+
+/**
+ * \brief I2C read edid
+ * \param [in]  block    - EDID block
+ * \pram  [in]  segment  - EDID segment
+ * \param [out] data_out - fields used: status, buff, slave (as block), offset (as segment), len
+ * \returns status
+ */
+CDN_API_STATUS CDN_API_HDMITX_READ_EDID(state_struct *state, u8 block,
+					u8 segment,
+					HDMITX_TRANS_DATA *data_out);
+CDN_API_STATUS CDN_API_HDMITX_READ_EDID_blocking(state_struct *state, u8 block,
+						 u8 segment,
+						 HDMITX_TRANS_DATA *data_out);
+
+/**
+ * \brief set hdmi protocol type (DVI,1.x,2.x) (send scrambler command over scdc and set bits in controller)
+ * \param [in]  protocol    - type
+ * \returns status
+ */
+CDN_API_STATUS
+CDN_API_HDMITX_Set_Mode_blocking(state_struct *state,
+				 HDMI_TX_MAIL_HANDLER_PROTOCOL_TYPE protocol,
+				 u32 character_rate);
+
+/**
+ * \brief init hdmi registers
+ * \returns status
+ */
+CDN_API_STATUS CDN_API_HDMITX_Init_blocking(state_struct *state);
+
+/**
+ * \brief change to vid id vicMode
+ * \returns status
+ */
+CDN_API_STATUS CDN_API_HDMITX_SetVic_blocking(state_struct *state,
+					      struct drm_display_mode *mode,
+					      int bpp,
+					      VIC_PXL_ENCODING_FORMAT format);
+
+/**
+ * \brief option to force color depth in the gcp or not force (HW mode)
+ * \returns status
+ */
+CDN_API_STATUS CDN_API_HDMITX_ForceColorDepth_blocking(state_struct *state,
+						       u8 force, u8 val);
+CDN_API_STATUS CDN_API_HDMITX_ReadEvents(state_struct *state, u32 *events);
+CDN_API_STATUS CDN_API_HDMITX_ReadEvents_blocking(state_struct *state,
+						  u32 *events);
+CDN_API_STATUS CDN_API_HDMITX_GetHpdStatus(state_struct *state, u8 *hpd_sts);
+CDN_API_STATUS CDN_API_HDMITX_GetHpdStatus_blocking(state_struct *state,
+						    u8 *hpd_sts);
+#endif
diff --git a/drivers/mxc/hdp/API_HDMI_Audio.c b/drivers/mxc/hdp/API_HDMI_Audio.c
new file mode 100644
index 000000000000..564467c1ceb2
--- /dev/null
+++ b/drivers/mxc/hdp/API_HDMI_Audio.c
@@ -0,0 +1,125 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * API_HDMI_Audio.c
+ *
+ ******************************************************************************
+ */
+
+#include "API_HDMI_Audio.h"
+#include "API_Infoframe.h"
+#include "source_aif_decoder.h"
+#include "source_aif_smpl2pckt.h"
+#include "dptx_stream.h"
+#include "address.h"
+#include "util.h"
+#include "aif_pckt2smp.h"
+#include "dptx_framer.h"
+#include "clock_meters.h"
+#include "source_car.h"
+#include "API_DPTX.h"
+#include "mhl_hdtx_top.h"
+
+CDN_API_STATUS CDN_API_HDMI_AudioSetInfoFrame(state_struct *state,
+					      AUDIO_MUTE_MODE mode,
+					      AUDIO_TYPE audioType,
+					      int numOfChannels,
+					      AUDIO_FREQ freq, int lanes,
+					      int ncts)
+{
+	u32 packet_type = 0x84;
+	u32 packet_version = 0x1;
+	u32 packet_len = 0xA;
+	u32 packet_HB0 = packet_type;
+	u32 packet_HB1 = packet_version;
+	u32 packet_HB2 = packet_len;
+	u32 packet_PB0 = 0;
+	u32 packet_PB1 = numOfChannels - 1;
+	u32 packet_PB2 = 0;
+	u32 packet_PB3 = 0;
+	u32 packet_PB4 = 0;
+	u32 packet_PB5 = 0;
+	u32 packet_PB6 = 0;
+	u32 packet_PB7 = 0;
+	u32 packet_PB8 = 0;
+	u32 packet_PB9 = 0;
+	u32 packet_PB10 = 0;
+	u32 packet_PB11 = 0;
+	u32 packet_PB12 = 0;
+	u32 packet_PB13 = 0;
+	u32 packet_PB14 = 0;
+	u32 packet_PB15 = 0;
+	u32 packet_PB16 = 0;
+	u32 packet_PB17 = 0;
+	u32 packet_PB18 = 0;
+	u32 packet_PB19 = 0;
+	u32 packet_PB20 = 0;
+	u32 packet_PB21 = 0;
+	u32 packet_PB22 = 0;
+	u32 packet_PB23 = 0;
+	u32 packet_PB24 = 0;
+	u32 packet_PB25 = 0;
+	u32 packet_PB26 = 0;
+	u32 packet_PB27 = 0;
+	u32 PB1_13_chksum = 0;
+	u32 packet_chksum = 0;
+	u8 packet[32];
+
+	if (numOfChannels == 2)
+		packet_PB4 = 0;
+	else if (numOfChannels == 8)
+		packet_PB4 = 0x13;
+
+	PB1_13_chksum =
+	    (packet_HB0 + packet_HB1 + packet_HB2 + packet_PB1 + packet_PB2 +
+	     packet_PB3 + packet_PB4 + packet_PB5 + packet_PB6 + packet_PB7 +
+	     packet_PB8 + packet_PB9 + packet_PB10);
+	packet_chksum =
+	    256 - (PB1_13_chksum - 256 * ((u32) PB1_13_chksum / 256));
+	packet_PB0 = packet_chksum;
+
+	packet[0] = 0;
+	packet[1] = packet_HB0;
+	packet[2] = packet_HB1;
+	packet[3] = packet_HB2;
+	packet[4] = packet_PB0;
+	packet[5] = packet_PB1;
+	packet[6] = packet_PB2;
+	packet[7] = packet_PB3;
+	packet[8] = packet_PB4;
+	packet[9] = packet_PB5;
+	packet[10] = packet_PB6;
+	packet[11] = packet_PB7;
+	packet[12] = packet_PB8;
+	packet[13] = packet_PB9;
+	packet[14] = packet_PB10;
+	packet[15] = packet_PB11;
+	packet[16] = packet_PB12;
+	packet[17] = packet_PB13;
+	packet[18] = packet_PB14;
+	packet[19] = packet_PB15;
+	packet[20] = packet_PB16;
+	packet[21] = packet_PB17;
+	packet[22] = packet_PB18;
+	packet[23] = packet_PB19;
+	packet[24] = packet_PB20;
+	packet[25] = packet_PB21;
+	packet[26] = packet_PB22;
+	packet[27] = packet_PB23;
+	packet[28] = packet_PB24;
+	packet[29] = packet_PB25;
+	packet[30] = packet_PB26;
+	packet[31] = packet_PB27;
+
+	CDN_API_InfoframeSet(state, 1, 28, (u32 *) &packet[0], packet_type);
+
+	return CDN_OK;
+}
diff --git a/drivers/mxc/hdp/API_HDMI_Audio.h b/drivers/mxc/hdp/API_HDMI_Audio.h
new file mode 100644
index 000000000000..1f26d5778fb8
--- /dev/null
+++ b/drivers/mxc/hdp/API_HDMI_Audio.h
@@ -0,0 +1,39 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * API_HDMI_Audio.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef API_HDMI_Audio_H_
+#define API_HDMI_Audio_H_
+
+#include "API_General.h"
+#include "API_Audio.h"
+
+/**
+ * \addtogroup HDMI_TX_API
+ * \{
+ */
+
+ /**
+ * \brief send audio info frame according to parameters
+ * \returns status
+ */
+CDN_API_STATUS CDN_API_HDMI_AudioSetInfoFrame(state_struct *state,
+					      AUDIO_MUTE_MODE mode,
+					      AUDIO_TYPE audioType,
+					      int numOfChannels,
+					      AUDIO_FREQ freq, int lanes,
+					      int ncts);
+
+#endif
diff --git a/drivers/mxc/hdp/API_Infoframe.c b/drivers/mxc/hdp/API_Infoframe.c
new file mode 100644
index 000000000000..08e5fdd6481a
--- /dev/null
+++ b/drivers/mxc/hdp/API_Infoframe.c
@@ -0,0 +1,116 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * API_Infoframe.c
+ *
+ ******************************************************************************
+ */
+
+#include "API_Infoframe.h"
+#include "address.h"
+#include "source_pif.h"
+#include "util.h"
+
+#define BANK_OFFSET 0x0
+
+static CDN_API_STATUS infoframeSet(state_struct *state, u8 entry_id,
+				   u8 packet_len,
+				   u32 *packet, u8 packet_type, u8 active_idle)
+{
+	u32 idx;
+	u32 activeIdleBit = (active_idle == 0) ? 0 : 0x20000;
+
+	/* invalidate entry */
+	if (cdn_apb_write
+	    (state,
+	     BANK_OFFSET | ADDR_SOURCE_PIF | (SOURCE_PIF_PKT_ALLOC_REG << 2),
+	     activeIdleBit | F_PKT_ALLOC_ADDRESS(entry_id)))
+		return CDN_ERR;
+	if (cdn_apb_write
+	    (state,
+	     BANK_OFFSET | ADDR_SOURCE_PIF | (SOURCE_PIF_PKT_ALLOC_WR_EN << 2),
+	     F_PKT_ALLOC_WR_EN(1)))
+		return CDN_ERR;
+
+	/* flush fifo 1 */
+	if (cdn_apb_write
+	    (state,
+	     BANK_OFFSET | ADDR_SOURCE_PIF | (SOURCE_PIF_FIFO1_FLUSH << 2),
+	     F_FIFO1_FLUSH(1)))
+		return CDN_ERR;
+
+	/* write packet into memory */
+	for (idx = 0; idx < packet_len; idx++)
+		if (cdn_apb_write
+		    (state,
+		     BANK_OFFSET | ADDR_SOURCE_PIF | (SOURCE_PIF_DATA_WR << 2),
+		     F_DATA_WR(packet[idx])))
+			return CDN_ERR;
+
+	/* write entry id */
+	if (cdn_apb_write
+	    (state, BANK_OFFSET | ADDR_SOURCE_PIF | (SOURCE_PIF_WR_ADDR << 2),
+	     F_WR_ADDR(entry_id)))
+		return CDN_ERR;
+
+	/* write request */
+	if (cdn_apb_write
+	    (state, BANK_OFFSET | ADDR_SOURCE_PIF | (SOURCE_PIF_WR_REQ << 2),
+	     F_HOST_WR(1)))
+		return CDN_ERR;
+
+	/* update entry */
+	if (cdn_apb_write
+	    (state,
+	     BANK_OFFSET | ADDR_SOURCE_PIF | (SOURCE_PIF_PKT_ALLOC_REG << 2),
+	     activeIdleBit | F_TYPE_VALID(1) | F_PACKET_TYPE(packet_type) |
+	     F_PKT_ALLOC_ADDRESS(entry_id)))
+		return CDN_ERR;
+	if (cdn_apb_write
+	    (state,
+	     BANK_OFFSET | ADDR_SOURCE_PIF | (SOURCE_PIF_PKT_ALLOC_WR_EN << 2),
+	     F_PKT_ALLOC_WR_EN(1)))
+		return CDN_ERR;
+
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_InfoframeSet(state_struct *state, u8 entry_id,
+				    u8 packet_len, u32 *packet, u8 packet_type)
+{
+	return infoframeSet(state, entry_id, packet_len, packet, packet_type,
+			    1);
+}
+
+CDN_API_STATUS CDN_API_InfoframeSetNoActiveIdle(state_struct *state,
+						u8 entry_id, u8 packet_len,
+						u32 *packet, u8 packet_type)
+{
+	return infoframeSet(state, entry_id, packet_len, packet, packet_type,
+			    0);
+}
+
+CDN_API_STATUS CDN_API_InfoframeRemove(state_struct *state, u8 entry_id)
+{
+	/* invalidate entry */
+	if (cdn_apb_write
+	    (state,
+	     BANK_OFFSET | ADDR_SOURCE_PIF | (SOURCE_PIF_PKT_ALLOC_REG << 2),
+	     0x20000 | F_PKT_ALLOC_ADDRESS(entry_id)))
+		return CDN_ERR;
+	if (cdn_apb_write
+	    (state,
+	     BANK_OFFSET | ADDR_SOURCE_PIF | (SOURCE_PIF_PKT_ALLOC_WR_EN << 2),
+	     F_PKT_ALLOC_WR_EN(1)))
+		return CDN_ERR;
+
+	return CDN_OK;
+}
diff --git a/drivers/mxc/hdp/API_Infoframe.h b/drivers/mxc/hdp/API_Infoframe.h
new file mode 100644
index 000000000000..796b879df34b
--- /dev/null
+++ b/drivers/mxc/hdp/API_Infoframe.h
@@ -0,0 +1,33 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * API_Infoframe.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef API_INFOFRAME_H
+#define API_INFOFRAME_H
+
+#include "API_General.h"
+/**
+ * \addtogroup INFO_FRAME_API
+ * \{
+ */
+CDN_API_STATUS CDN_API_InfoframeSet(state_struct *state, u8 entry_id,
+				    u8 packet_len, u32 *packet,
+				    u8 packet_type);
+CDN_API_STATUS CDN_API_InfoframeSetNoActiveIdle(state_struct *state,
+						u8 entry_id, u8 packet_len,
+						u32 *packet, u8 packet_type);
+CDN_API_STATUS CDN_API_InfoframeRemove(state_struct *state, u8 entry_id);
+
+#endif
diff --git a/drivers/mxc/hdp/Kconfig b/drivers/mxc/hdp/Kconfig
new file mode 100644
index 000000000000..b26ef11c52e6
--- /dev/null
+++ b/drivers/mxc/hdp/Kconfig
@@ -0,0 +1,2 @@
+config MX8_HDP
+	tristate "IMX8 HDP API"
diff --git a/drivers/mxc/hdp/Makefile b/drivers/mxc/hdp/Makefile
new file mode 100644
index 000000000000..235b845c1b8c
--- /dev/null
+++ b/drivers/mxc/hdp/Makefile
@@ -0,0 +1,11 @@
+obj-$(CONFIG_MX8_HDP) += \
+	API_Audio.o \
+	API_AVI.o \
+	API_AFE.o \
+	API_General.o \
+	API_HDCP.o \
+	API_HDMITX.o \
+	API_HDMI_Audio.o \
+	API_Infoframe.o \
+	API_DPTX.o \
+	util.o
diff --git a/drivers/mxc/hdp/address.h b/drivers/mxc/hdp/address.h
new file mode 100644
index 000000000000..26a1218beb98
--- /dev/null
+++ b/drivers/mxc/hdp/address.h
@@ -0,0 +1,78 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * address.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef ADDRESS_H_
+#define ADDRESS_H_
+
+#define ADDR_IMEM 0x10000
+#define ADDR_DMEM 0x20000
+#define ADDR_CIPHER 0x60000
+#define BASE_CIPHER 0x600
+#define ADDR_APB_CFG 0x00000
+#define BASE_APB_CFG 0x000
+#define ADDR_SOURCE_AIF_DECODER 0x30000
+#define BASE_SOURCE_AIF_DECODER 0x300
+#define ADDR_SOURCE_AIF_SMPL2PCKT 0x30080
+#define BASE_SOURCE_AIF_SMPL2PCKT 0x300
+#define ADDR_AIF_ENCODER 0x30000
+#define BASE_AIF_ENCODER 0x300
+#define ADDR_SOURCE_PIF 0x30800
+#define BASE_SOURCE_PIF 0x308
+#define ADDR_SINK_PIF 0x30800
+#define BASE_SINK_PIF 0x308
+#define ADDR_APB_CFG 0x00000
+#define BASE_APB_CFG 0x000
+#define ADDR_SOURCE_CSC 0x40000
+#define BASE_SOURCE_CSC 0x400
+#define ADDR_UCPU_CFG 0x00000
+#define BASE_UCPU_CFG 0x000
+#define ADDR_SOURCE_CAR 0x00900
+#define BASE_SOURCE_CAR 0x009
+#define ADDR_SINK_CAR 0x00900
+#define BASE_SINK_CAR 0x009
+#define ADDR_CLOCK_METERS 0x00A00
+#define BASE_CLOCK_METERS 0x00A
+#define ADDR_SOURCE_VIF 0x00b00
+#define BASE_SOURCE_VIF 0x00b
+#define ADDR_SINK_MHL_HD 0x01000
+#define ADDR_SINK_VIDEO_HD 0x01800
+#define BASE_SINK_MHL_HD 0x010
+#define ADDR_SINK_CORE 0x07800
+#define BASE_SINK_CORE 0x078
+#define ADDR_DPTX_PHY 0x02000
+#define BASE_DPTX_PHY 0x020
+#define ADDR_DPTX_HPD 0x02100
+#define BASE_DPTX_HPD 0x021
+#define ADDR_DPTX_FRAMER 0x02200
+#define BASE_DPTX_FRAMER 0x022
+#define ADDR_DPTX_STREAM 0x02200
+#define BASE_DPTX_STREAM 0x022
+#define ADDR_DPTX_GLBL 0x02300
+#define BASE_DPTX_GLBL 0x023
+#define ADDR_DPTX_HDCP 0x02400
+#define BASE_DPTX_HDCP 0x024
+#define ADDR_DP_AUX 0x02800
+#define BASE_DP_AUX 0x028
+#define ADDR_CRYPTO 0x05800
+#define BASE_CRYPTO 0x058
+#define ADDR_CIPHER 0x60000
+#define BASE_CIPHER 0x600
+#define ADDR_SOURCE_MHL_HD 0x01000
+
+#define ADDR_AFE  (0x20000 * 4)
+#define ADDR_SOURCD_PHY  (0x800)
+
+#endif
diff --git a/drivers/mxc/hdp/aif_pckt2smp.h b/drivers/mxc/hdp/aif_pckt2smp.h
new file mode 100644
index 000000000000..924c3ad5473b
--- /dev/null
+++ b/drivers/mxc/hdp/aif_pckt2smp.h
@@ -0,0 +1,138 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * This file was auto-generated. Do not edit it manually.
+ *
+ ******************************************************************************
+ *
+ * aif_pckt2smp.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef AIF_PCKT2SMP_H_
+#define AIF_PCKT2SMP_H_
+
+/* register PKT2SMPL_CNTL */
+#define PKT2SMPL_CNTL 0
+#define F_SW_RST(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SW_RST_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_PKT2SMPL_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_PKT2SMPL_EN_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_NUM_OF_I2S_PORTS(x) (((x) & ((1 << 2) - 1)) << 2)
+#define F_NUM_OF_I2S_PORTS_RD(x) (((x) & (((1 << 2) - 1) << 2)) >> 2)
+#define F_AIF_ERR_MASK(x) (((x) & ((1 << 1) - 1)) << 4)
+#define F_AIF_ERR_MASK_RD(x) (((x) & (((1 << 1) - 1) << 4)) >> 4)
+#define F_AIF_OVERFLOW_MASK(x) (((x) & ((1 << 1) - 1)) << 5)
+#define F_AIF_OVERFLOW_MASK_RD(x) (((x) & (((1 << 1) - 1) << 5)) >> 5)
+#define F_AIF_UNDERFLOW_MASK(x) (((x) & ((1 << 1) - 1)) << 6)
+#define F_AIF_UNDERFLOW_MASK_RD(x) (((x) & (((1 << 1) - 1) << 6)) >> 6)
+#define F_CFG_FORCE_SP(x) (((x) & ((1 << 1) - 1)) << 7)
+#define F_CFG_FORCE_SP_RD(x) (((x) & (((1 << 1) - 1) << 7)) >> 7)
+
+/* register ACR_CFG */
+#define ACR_CFG 1
+#define F_ACR_STOP_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_ACR_STOP_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_ACR_FIFO_STATUS_DIS(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_ACR_FIFO_STATUS_DIS_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_ACR_DIS_USE_NEDGE(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_ACR_DIS_USE_NEDGE_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+#define F_ACR_MASTER_CLK_FX_MODE(x) (((x) & ((1 << 2) - 1)) << 3)
+#define F_ACR_MASTER_CLK_FX_MODE_RD(x) (((x) & (((1 << 2) - 1) << 3)) >> 3)
+#define F_ACR_SW_RESET(x) (((x) & ((1 << 1) - 1)) << 5)
+#define F_ACR_SW_RESET_RD(x) (((x) & (((1 << 1) - 1) << 5)) >> 5)
+
+/* register SPDIF_CFG */
+#define SPDIF_CFG 2
+#define F_SPDIF_SELECTED(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SPDIF_SELECTED_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+/* register AUDIO_FIFO_PTR_CFG0 */
+#define AUDIO_FIFO_PTR_CFG0 3
+#define F_AUDIO_FIFO_PTR_EMPTY_LOW(x) (((x) & ((1 << 9) - 1)) << 0)
+#define F_AUDIO_FIFO_PTR_EMPTY_LOW_RD(x) (((x) & (((1 << 9) - 1) << 0)) >> 0)
+#define F_AUDIO_FIFO_PTR_EMPTY_HIGH(x) (((x) & ((1 << 9) - 1)) << 9)
+#define F_AUDIO_FIFO_PTR_EMPTY_HIGH_RD(x) (((x) & (((1 << 9) - 1) << 9)) >> 9)
+#define F_AUDIO_FIFO_PTR_LOW_LOW(x) (((x) & ((1 << 9) - 1)) << 18)
+#define F_AUDIO_FIFO_PTR_LOW_LOW_RD(x) (((x) & (((1 << 9) - 1) << 18)) >> 18)
+
+/* register AUDIO_FIFO_PTR_CFG1 */
+#define AUDIO_FIFO_PTR_CFG1 4
+#define F_AUDIO_FIFO_PTR_LOW_HIGH(x) (((x) & ((1 << 9) - 1)) << 0)
+#define F_AUDIO_FIFO_PTR_LOW_HIGH_RD(x) (((x) & (((1 << 9) - 1) << 0)) >> 0)
+#define F_AUDIO_FIFO_PTR_BELOW_LOW(x) (((x) & ((1 << 9) - 1)) << 9)
+#define F_AUDIO_FIFO_PTR_BELOW_LOW_RD(x) (((x) & (((1 << 9) - 1) << 9)) >> 9)
+#define F_AUDIO_FIFO_PTR_BELOW_HIGH(x) (((x) & ((1 << 9) - 1)) << 18)
+#define F_AUDIO_FIFO_PTR_BELOW_HIGH_RD(x) (((x) & (((1 << 9) - 1) << 18)) >> 18)
+
+/* register AUDIO_FIFO_PTR_CFG2 */
+#define AUDIO_FIFO_PTR_CFG2 5
+#define F_AUDIO_FIFO_PTR_NOMINAL_LOW(x) (((x) & ((1 << 9) - 1)) << 0)
+#define F_AUDIO_FIFO_PTR_NOMINAL_LOW_RD(x) (((x) & (((1 << 9) - 1) << 0)) >> 0)
+#define F_AUDIO_FIFO_PTR_NOMINAL_HIGH(x) (((x) & ((1 << 9) - 1)) << 9)
+#define F_AUDIO_FIFO_PTR_NOMINAL_HIGH_RD(x) (((x) & (((1 << 9) - 1) << 9)) >> 9)
+#define F_AUDIO_FIFO_PTR_ABOVE_LOW(x) (((x) & ((1 << 9) - 1)) << 18)
+#define F_AUDIO_FIFO_PTR_ABOVE_LOW_RD(x) (((x) & (((1 << 9) - 1) << 18)) >> 18)
+
+/* register AUDIO_FIFO_PTR_CFG3 */
+#define AUDIO_FIFO_PTR_CFG3 6
+#define F_AUDIO_FIFO_PTR_ABOVE_HIGH(x) (((x) & ((1 << 9) - 1)) << 0)
+#define F_AUDIO_FIFO_PTR_ABOVE_HIGH_RD(x) (((x) & (((1 << 9) - 1) << 0)) >> 0)
+#define F_AUDIO_FIFO_PTR_HIGH_LOW(x) (((x) & ((1 << 9) - 1)) << 9)
+#define F_AUDIO_FIFO_PTR_HIGH_LOW_RD(x) (((x) & (((1 << 9) - 1) << 9)) >> 9)
+#define F_AUDIO_FIFO_PTR_HIGH_HIGH(x) (((x) & ((1 << 9) - 1)) << 18)
+#define F_AUDIO_FIFO_PTR_HIGH_HIGH_RD(x) (((x) & (((1 << 9) - 1) << 18)) >> 18)
+
+/* register AUDIO_FIFO_PTR_CFG4 */
+#define AUDIO_FIFO_PTR_CFG4 7
+#define F_AUDIO_FIFO_PTR_FULL_LOW(x) (((x) & ((1 << 9) - 1)) << 0)
+#define F_AUDIO_FIFO_PTR_FULL_LOW_RD(x) (((x) & (((1 << 9) - 1) << 0)) >> 0)
+#define F_AUDIO_FIFO_PTR_FULL_HIGH(x) (((x) & ((1 << 9) - 1)) << 9)
+#define F_AUDIO_FIFO_PTR_FULL_HIGH_RD(x) (((x) & (((1 << 9) - 1) << 9)) >> 9)
+
+/* register AUDIO_FIFO_PTR_CFG5 */
+#define AUDIO_FIFO_PTR_CFG5 8
+#define F_AUDIO_FIFO_PTR_IDLE_LOW(x) (((x) & ((1 << 9) - 1)) << 0)
+#define F_AUDIO_FIFO_PTR_IDLE_LOW_RD(x) (((x) & (((1 << 9) - 1) << 0)) >> 0)
+#define F_AUDIO_FIFO_PTR_IDLE_HIGH(x) (((x) & ((1 << 9) - 1)) << 9)
+#define F_AUDIO_FIFO_PTR_IDLE_HIGH_RD(x) (((x) & (((1 << 9) - 1) << 9)) >> 9)
+
+/* register AIF_INT_STTS */
+#define AIF_INT_STTS 9
+#define F_AIF_ERR_STATUS(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_AIF_ERR_STATUS_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_AIF_OVERFLOW_STATUS(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_AIF_OVERFLOW_STATUS_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_AIF_UNDERFLOW_STATUS(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_AIF_UNDERFLOW_STATUS_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+
+/* register AIF_ACR_N_ST */
+#define AIF_ACR_N_ST 10
+#define F_ACR_N(x) (((x) & ((1 << 20) - 1)) << 0)
+#define F_ACR_N_RD(x) (((x) & (((1 << 20) - 1) << 0)) >> 0)
+
+/* register AIF_ACR_CTS_ST */
+#define AIF_ACR_CTS_ST 11
+#define F_ACR_CTS(x) (((x) & ((1 << 20) - 1)) << 0)
+#define F_ACR_CTS_RD(x) (((x) & (((1 << 20) - 1) << 0)) >> 0)
+
+/* register AIF_ACR_N_OFST_CFG */
+#define AIF_ACR_N_OFST_CFG 12
+#define F_ACR_N_OFFSET(x) (((x) & ((1 << 24) - 1)) << 0)
+#define F_ACR_N_OFFSET_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+
+/* register AIF_ACR_CTS_OFST_CFG */
+#define AIF_ACR_CTS_OFST_CFG 13
+#define F_ACR_CTS_OFFSET(x) (((x) & ((1 << 24) - 1)) << 0)
+#define F_ACR_CTS_OFFSET_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+
+#endif
diff --git a/drivers/mxc/hdp/all.h b/drivers/mxc/hdp/all.h
new file mode 100644
index 000000000000..c790d8fea347
--- /dev/null
+++ b/drivers/mxc/hdp/all.h
@@ -0,0 +1,31 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * all.h
+ *
+ ******************************************************************************
+ */
+#include "address.h"
+#include "apb_cfg.h"
+#include "API_AVI.h"
+#include "API_AFE.h"
+#include "API_DPTX.h"
+#include "API_General.h"
+#include "API_Infoframe.h"
+#include "API_Audio.h"
+#include "API_HDCP.h"
+#include "API_HDMITX.h"
+#include "API_HDMI_Audio.h"
+#include "dptx_framer.h"
+#include "source_car.h"
+#include "source_phy.h"
+#include "source_vif.h"
+#include "util.h"
diff --git a/drivers/mxc/hdp/apb_cfg.h b/drivers/mxc/hdp/apb_cfg.h
new file mode 100644
index 000000000000..a4c52f257927
--- /dev/null
+++ b/drivers/mxc/hdp/apb_cfg.h
@@ -0,0 +1,155 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * This file was auto-generated. Do not edit it manually.
+ *
+ ******************************************************************************
+ *
+ * apb_cfg.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef APB_CFG_H_
+#define APB_CFG_H_
+
+/* register APB_CTRL */
+#define APB_CTRL 0
+#define F_APB_XT_RESET(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_APB_XT_RESET_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_APB_DRAM_PATH(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_APB_DRAM_PATH_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_APB_IRAM_PATH(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_APB_IRAM_PATH_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+
+/* register XT_INT_CTRL */
+#define XT_INT_CTRL 1
+#define F_XT_INT_POLARITY(x) (((x) & ((1 << 2) - 1)) << 0)
+#define F_XT_INT_POLARITY_RD(x) (((x) & (((1 << 2) - 1) << 0)) >> 0)
+
+/* register MAILBOX_FULL_ADDR */
+#define MAILBOX_FULL_ADDR 2
+#define F_MAILBOX_FULL(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_MAILBOX_FULL_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+/* register MAILBOX_EMPTY_ADDR */
+#define MAILBOX_EMPTY_ADDR 3
+#define F_MAILBOX_EMPTY(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_MAILBOX_EMPTY_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+/* register MAILBOX0_WR_DATA */
+#define MAILBOX0_WR_DATA 4
+#define F_MAILBOX0_WR_DATA(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_MAILBOX0_WR_DATA_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+
+/* register MAILBOX0_RD_DATA */
+#define MAILBOX0_RD_DATA 5
+#define F_MAILBOX0_RD_DATA(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_MAILBOX0_RD_DATA_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+
+/* register KEEP_ALIVE */
+#define KEEP_ALIVE 6
+#define F_KEEP_ALIVE_CNT(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_KEEP_ALIVE_CNT_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+
+/* register VER_L */
+#define VER_L 7
+#define F_VER_LSB(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_VER_LSB_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+
+/* register VER_H */
+#define VER_H 8
+#define F_VER_MSB(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_VER_MSB_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+
+/* register VER_LIB_L_ADDR */
+#define VER_LIB_L_ADDR 9
+#define F_SW_LIB_VER_L(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_SW_LIB_VER_L_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+
+/* register VER_LIB_H_ADDR */
+#define VER_LIB_H_ADDR 10
+#define F_SW_LIB_VER_H(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_SW_LIB_VER_H_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+
+/* register SW_DEBUG_L */
+#define SW_DEBUG_L 11
+#define F_SW_DEBUG_7_0(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_SW_DEBUG_7_0_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+
+/* register SW_DEBUG_H */
+#define SW_DEBUG_H 12
+#define F_SW_DEBUG_15_8(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_SW_DEBUG_15_8_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+
+/* register MAILBOX_INT_MASK */
+#define MAILBOX_INT_MASK 13
+#define F_MAILBOX_INT_MASK(x) (((x) & ((1 << 2) - 1)) << 0)
+#define F_MAILBOX_INT_MASK_RD(x) (((x) & (((1 << 2) - 1) << 0)) >> 0)
+
+/* register MAILBOX_INT_STATUS */
+#define MAILBOX_INT_STATUS 14
+#define F_MAILBOX_INT_STATUS(x) (((x) & ((1 << 2) - 1)) << 0)
+#define F_MAILBOX_INT_STATUS_RD(x) (((x) & (((1 << 2) - 1) << 0)) >> 0)
+
+/* register SW_CLK_L */
+#define SW_CLK_L 15
+#define F_SW_CLOCK_VAL_L(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_SW_CLOCK_VAL_L_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+
+/* register SW_CLK_H */
+#define SW_CLK_H 16
+#define F_SW_CLOCK_VAL_H(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_SW_CLOCK_VAL_H_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+
+/* register SW_EVENTS0 */
+#define SW_EVENTS0 17
+#define F_SW_EVENTS7_0(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_SW_EVENTS7_0_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+
+/* register SW_EVENTS1 */
+#define SW_EVENTS1 18
+#define F_SW_EVENTS15_8(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_SW_EVENTS15_8_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+
+/* register SW_EVENTS2 */
+#define SW_EVENTS2 19
+#define F_SW_EVENTS23_16(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_SW_EVENTS23_16_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+
+/* register SW_EVENTS3 */
+#define SW_EVENTS3 20
+#define F_SW_EVENTS31_24(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_SW_EVENTS31_24_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+
+/* register XT_OCD_CTRL */
+#define XT_OCD_CTRL 24
+#define F_XT_DRESET(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_XT_DRESET_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_XT_OCDHALTONRESET(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_XT_OCDHALTONRESET_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+
+/* register XT_OCD_CTRL_RO */
+#define XT_OCD_CTRL_RO 25
+#define F_XT_XOCDMODE(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_XT_XOCDMODE_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+/* register APB_INT_MASK */
+#define APB_INT_MASK 27
+#define F_APB_INTR_MASK(x) (((x) & ((1 << 3) - 1)) << 0)
+#define F_APB_INTR_MASK_RD(x) (((x) & (((1 << 3) - 1) << 0)) >> 0)
+
+/* register APB_STATUS_MASK */
+#define APB_STATUS_MASK 28
+#define F_APB_INTR_STATUS(x) (((x) & ((1 << 3) - 1)) << 0)
+#define F_APB_INTR_STATUS_RD(x) (((x) & (((1 << 3) - 1) << 0)) >> 0)
+
+#endif
diff --git a/drivers/mxc/hdp/clock_meters.h b/drivers/mxc/hdp/clock_meters.h
new file mode 100644
index 000000000000..75ac960f4f41
--- /dev/null
+++ b/drivers/mxc/hdp/clock_meters.h
@@ -0,0 +1,127 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * This file was auto-generated. Do not edit it manually.
+ *
+ ******************************************************************************
+ *
+ * clock_meters.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef CLOCK_METERS_H_
+#define CLOCK_METERS_H_
+
+/* register CM_CTRL */
+#define CM_CTRL 0
+#define F_NMVID_SEL_EXTERNAL(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_NMVID_SEL_EXTERNAL_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_SPDIF_SEL_EXTERNAL(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_SPDIF_SEL_EXTERNAL_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_I2S_SEL_EXTERNAL(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_I2S_SEL_EXTERNAL_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+#define F_SEL_AUD_LANE_REF(x) (((x) & ((1 << 1) - 1)) << 3)
+#define F_SEL_AUD_LANE_REF_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+#define F_I2S_MULT(x) (((x) & ((1 << 3) - 1)) << 4)
+#define F_I2S_MULT_RD(x) (((x) & (((1 << 3) - 1) << 4)) >> 4)
+
+/* register CM_I2S_CTRL */
+#define CM_I2S_CTRL 1
+#define F_I2S_REF_CYC(x) (((x) & ((1 << 24) - 1)) << 0)
+#define F_I2S_REF_CYC_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+#define F_I2S_MEAS_TOLERANCE(x) (((x) & ((1 << 4) - 1)) << 24)
+#define F_I2S_MEAS_TOLERANCE_RD(x) (((x) & (((1 << 4) - 1) << 24)) >> 24)
+
+/* register CM_SPDIF_CTRL */
+#define CM_SPDIF_CTRL 2
+#define F_SPDIF_REF_CYC(x) (((x) & ((1 << 24) - 1)) << 0)
+#define F_SPDIF_REF_CYC_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+#define F_SPDIF_MEAS_TOLERANCE(x) (((x) & ((1 << 4) - 1)) << 24)
+#define F_SPDIF_MEAS_TOLERANCE_RD(x) (((x) & (((1 << 4) - 1) << 24)) >> 24)
+
+/* register CM_VID_CTRL */
+#define CM_VID_CTRL 3
+#define F_NMVID_REF_CYC(x) (((x) & ((1 << 24) - 1)) << 0)
+#define F_NMVID_REF_CYC_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+#define F_NMVID_MEAS_TOLERANCE(x) (((x) & ((1 << 4) - 1)) << 24)
+#define F_NMVID_MEAS_TOLERANCE_RD(x) (((x) & (((1 << 4) - 1) << 24)) >> 24)
+
+/* register CM_LANE_CTRL */
+#define CM_LANE_CTRL 4
+#define F_LANE_REF_CYC(x) (((x) & ((1 << 24) - 1)) << 0)
+#define F_LANE_REF_CYC_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+
+/* register I2S_NM_STABLE */
+#define I2S_NM_STABLE 5
+#define F_I2S_MNAUD_STABLE(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_I2S_MNAUD_STABLE_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+/* register I2S_NCTS_STABLE */
+#define I2S_NCTS_STABLE 6
+#define F_I2S_NCTS_STABLE(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_I2S_NCTS_STABLE_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+/* register SPDIF_NM_STABLE */
+#define SPDIF_NM_STABLE 7
+#define F_SPDIF_MNAUD_STABLE(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SPDIF_MNAUD_STABLE_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+/* register SPDIF_NCTS_STABLE */
+#define SPDIF_NCTS_STABLE 8
+#define F_SPDIF_NCTS_STABLE(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SPDIF_NCTS_STABLE_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+/* register NMVID_MEAS_STABLE */
+#define NMVID_MEAS_STABLE 9
+#define F_ST_NMVID_MEAS_STABLE(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_ST_NMVID_MEAS_STABLE_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+/* register CM_VID_MEAS */
+#define CM_VID_MEAS 10
+#define F_NMVID_MEAS_CYC(x) (((x) & ((1 << 24) - 1)) << 0)
+#define F_NMVID_MEAS_CYC_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+#define F_NMVID_MEAS_VALID_INDC(x) (((x) & ((1 << 1) - 1)) << 24)
+#define F_NMVID_MEAS_VALID_INDC_RD(x) (((x) & (((1 << 1) - 1) << 24)) >> 24)
+
+/* register CM_AUD_MEAS */
+#define CM_AUD_MEAS 11
+#define F_NMAUD_MEAS_CYC(x) (((x) & ((1 << 24) - 1)) << 0)
+#define F_NMAUD_MEAS_CYC_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+#define F_NMAUD_MEAS_VALID_INDC(x) (((x) & ((1 << 1) - 1)) << 24)
+#define F_NMAUD_MEAS_VALID_INDC_RD(x) (((x) & (((1 << 1) - 1) << 24)) >> 24)
+
+/* register I2S_MEAS */
+#define I2S_MEAS 16
+#define F_I2_MEAS(x) (((x) & ((1 << 24) - 1)) << 0)
+#define F_I2_MEAS_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+
+/* register I2S_DP_MEAS */
+#define I2S_DP_MEAS 17
+#define F_I2_DP_MEAS(x) (((x) & ((1 << 24) - 1)) << 0)
+#define F_I2_DP_MEAS_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+
+/* register SPDIF_DP_MEAS */
+#define SPDIF_DP_MEAS 32
+#define F_SPDIF_DP_MEAS(x) (((x) & ((1 << 24) - 1)) << 0)
+#define F_SPDIF_DP_MEAS_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+
+/* register SPDIF_MEAS */
+#define SPDIF_MEAS 33
+#define F_SPDIF_MEAS(x) (((x) & ((1 << 24) - 1)) << 0)
+#define F_SPDIF_MEAS_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+
+/* register NMVID_MEAS */
+#define NMVID_MEAS 48
+#define F_NMVID_MEAS(x) (((x) & ((1 << 24) - 1)) << 0)
+#define F_NMVID_MEAS_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+
+#endif //CLOCK_METERS
diff --git a/drivers/mxc/hdp/dptx_framer.h b/drivers/mxc/hdp/dptx_framer.h
new file mode 100644
index 000000000000..eaa8d28c0441
--- /dev/null
+++ b/drivers/mxc/hdp/dptx_framer.h
@@ -0,0 +1,342 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * This file was auto-generated. Do not edit it manually.
+ *
+ ******************************************************************************
+ *
+ * dptx_framer.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef DPTX_FRAMER_H_
+#define DPTX_FRAMER_H_
+
+/* register DP_FRAMER_GLOBAL_CONFIG */
+#define DP_FRAMER_GLOBAL_CONFIG 0
+#define F_NUM_LANES(x) (((x) & ((1 << 2) - 1)) << 0)
+#define F_NUM_LANES_RD(x) (((x) & (((1 << 2) - 1) << 0)) >> 0)
+#define F_MST_SST(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_MST_SST_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+#define F_GLOBAL_EN(x) (((x) & ((1 << 1) - 1)) << 3)
+#define F_GLOBAL_EN_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+#define F_RG_EN(x) (((x) & ((1 << 1) - 1)) << 4)
+#define F_RG_EN_RD(x) (((x) & (((1 << 1) - 1) << 4)) >> 4)
+#define F_NO_VIDEO(x) (((x) & ((1 << 1) - 1)) << 5)
+#define F_NO_VIDEO_RD(x) (((x) & (((1 << 1) - 1) << 5)) >> 5)
+#define F_ENC_RST_DIS(x) (((x) & ((1 << 1) - 1)) << 6)
+#define F_ENC_RST_DIS_RD(x) (((x) & (((1 << 1) - 1) << 6)) >> 6)
+#define F_WR_VHSYNC_FALL(x) (((x) & ((1 << 1) - 1)) << 7)
+#define F_WR_VHSYNC_FALL_RD(x) (((x) & (((1 << 1) - 1) << 7)) >> 7)
+
+/* register DP_SW_RESET */
+#define DP_SW_RESET 1
+#define F_SW_RST(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SW_RST_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+/* register DP_FRAMER_TU */
+#define DP_FRAMER_TU 2
+#define F_TU_VALID_SYMBOLS(x) (((x) & ((1 << 6) - 1)) << 0)
+#define F_TU_VALID_SYMBOLS_RD(x) (((x) & (((1 << 6) - 1) << 0)) >> 0)
+#define F_TU_SIZE(x) (((x) & ((1 << 7) - 1)) << 8)
+#define F_TU_SIZE_RD(x) (((x) & (((1 << 7) - 1) << 8)) >> 8)
+#define F_TU_CNT_RST_EN(x) (((x) & ((1 << 1) - 1)) << 15)
+#define F_TU_CNT_RST_EN_RD(x) (((x) & (((1 << 1) - 1) << 15)) >> 15)
+#define F_BS_SR_REPLACE_POSITION(x) (((x) & ((1 << 9) - 1)) << 16)
+#define F_BS_SR_REPLACE_POSITION_RD(x) (((x) & (((1 << 9) - 1) << 16)) >> 16)
+
+/* register DP_FRAMER_PXL_REPR */
+#define DP_FRAMER_PXL_REPR 3
+#define F_COLOR_DEPTH(x) (((x) & ((1 << 5) - 1)) << 0)
+#define F_COLOR_DEPTH_RD(x) (((x) & (((1 << 5) - 1) << 0)) >> 0)
+#define F_PXL_ENC_FORMAT(x) (((x) & ((1 << 5) - 1)) << 8)
+#define F_PXL_ENC_FORMAT_RD(x) (((x) & (((1 << 5) - 1) << 8)) >> 8)
+
+/* register DP_FRAMER_SP */
+#define DP_FRAMER_SP 4
+#define F_VSP(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_VSP_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_HSP(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_HSP_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_INTERLACE_EN(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_INTERLACE_EN_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+#define F_FRAMER_3D_EN(x) (((x) & ((1 << 1) - 1)) << 3)
+#define F_FRAMER_3D_EN_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+#define F_STACKED_3D_EN(x) (((x) & ((1 << 1) - 1)) << 4)
+#define F_STACKED_3D_EN_RD(x) (((x) & (((1 << 1) - 1) << 4)) >> 4)
+
+/* register AUDIO_PACK_CONTROL */
+#define AUDIO_PACK_CONTROL 5
+#define F_MST_SDP_ID(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_MST_SDP_ID_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+#define F_AUDIO_PACK_EN(x) (((x) & ((1 << 1) - 1)) << 8)
+#define F_AUDIO_PACK_EN_RD(x) (((x) & (((1 << 1) - 1) << 8)) >> 8)
+#define F_MONO(x) (((x) & ((1 << 1) - 1)) << 9)
+#define F_MONO_RD(x) (((x) & (((1 << 1) - 1) << 9)) >> 9)
+
+/* register DP_VC_TABLE_0 */
+#define DP_VC_TABLE_0 6
+#define F_VC_TABLE_0(x) (((x) & ((1 << 6) - 1)) << 0)
+#define F_VC_TABLE_0_RD(x) (((x) & (((1 << 6) - 1) << 0)) >> 0)
+#define F_VC_TABLE_1(x) (((x) & ((1 << 6) - 1)) << 8)
+#define F_VC_TABLE_1_RD(x) (((x) & (((1 << 6) - 1) << 8)) >> 8)
+#define F_VC_TABLE_2(x) (((x) & ((1 << 6) - 1)) << 16)
+#define F_VC_TABLE_2_RD(x) (((x) & (((1 << 6) - 1) << 16)) >> 16)
+#define F_VC_TABLE_3(x) (((x) & ((1 << 6) - 1)) << 24)
+#define F_VC_TABLE_3_RD(x) (((x) & (((1 << 6) - 1) << 24)) >> 24)
+
+/* register DP_VC_TABLE_1 */
+#define DP_VC_TABLE_1 7
+#define F_VC_TABLE_4(x) (((x) & ((1 << 6) - 1)) << 0)
+#define F_VC_TABLE_4_RD(x) (((x) & (((1 << 6) - 1) << 0)) >> 0)
+#define F_VC_TABLE_5(x) (((x) & ((1 << 6) - 1)) << 8)
+#define F_VC_TABLE_5_RD(x) (((x) & (((1 << 6) - 1) << 8)) >> 8)
+#define F_VC_TABLE_6(x) (((x) & ((1 << 6) - 1)) << 16)
+#define F_VC_TABLE_6_RD(x) (((x) & (((1 << 6) - 1) << 16)) >> 16)
+#define F_VC_TABLE_7(x) (((x) & ((1 << 6) - 1)) << 24)
+#define F_VC_TABLE_7_RD(x) (((x) & (((1 << 6) - 1) << 24)) >> 24)
+
+/* register DP_VC_TABLE_2 */
+#define DP_VC_TABLE_2 8
+#define F_VC_TABLE_8(x) (((x) & ((1 << 6) - 1)) << 0)
+#define F_VC_TABLE_8_RD(x) (((x) & (((1 << 6) - 1) << 0)) >> 0)
+#define F_VC_TABLE_9(x) (((x) & ((1 << 6) - 1)) << 8)
+#define F_VC_TABLE_9_RD(x) (((x) & (((1 << 6) - 1) << 8)) >> 8)
+#define F_VC_TABLE_10(x) (((x) & ((1 << 6) - 1)) << 16)
+#define F_VC_TABLE_10_RD(x) (((x) & (((1 << 6) - 1) << 16)) >> 16)
+#define F_VC_TABLE_11(x) (((x) & ((1 << 6) - 1)) << 24)
+#define F_VC_TABLE_11_RD(x) (((x) & (((1 << 6) - 1) << 24)) >> 24)
+
+/* register DP_VC_TABLE_3 */
+#define DP_VC_TABLE_3 9
+#define F_VC_TABLE_12(x) (((x) & ((1 << 6) - 1)) << 0)
+#define F_VC_TABLE_12_RD(x) (((x) & (((1 << 6) - 1) << 0)) >> 0)
+#define F_VC_TABLE_13(x) (((x) & ((1 << 6) - 1)) << 8)
+#define F_VC_TABLE_13_RD(x) (((x) & (((1 << 6) - 1) << 8)) >> 8)
+#define F_VC_TABLE_14(x) (((x) & ((1 << 6) - 1)) << 16)
+#define F_VC_TABLE_14_RD(x) (((x) & (((1 << 6) - 1) << 16)) >> 16)
+#define F_VC_TABLE_15(x) (((x) & ((1 << 6) - 1)) << 24)
+#define F_VC_TABLE_15_RD(x) (((x) & (((1 << 6) - 1) << 24)) >> 24)
+
+/* register DP_VC_TABLE_4 */
+#define DP_VC_TABLE_4 10
+#define F_VC_TABLE_16(x) (((x) & ((1 << 6) - 1)) << 0)
+#define F_VC_TABLE_16_RD(x) (((x) & (((1 << 6) - 1) << 0)) >> 0)
+#define F_VC_TABLE_17(x) (((x) & ((1 << 6) - 1)) << 8)
+#define F_VC_TABLE_17_RD(x) (((x) & (((1 << 6) - 1) << 8)) >> 8)
+#define F_VC_TABLE_18(x) (((x) & ((1 << 6) - 1)) << 16)
+#define F_VC_TABLE_18_RD(x) (((x) & (((1 << 6) - 1) << 16)) >> 16)
+#define F_VC_TABLE_19(x) (((x) & ((1 << 6) - 1)) << 24)
+#define F_VC_TABLE_19_RD(x) (((x) & (((1 << 6) - 1) << 24)) >> 24)
+
+/* register DP_VC_TABLE_5 */
+#define DP_VC_TABLE_5 11
+#define F_VC_TABLE_20(x) (((x) & ((1 << 6) - 1)) << 0)
+#define F_VC_TABLE_20_RD(x) (((x) & (((1 << 6) - 1) << 0)) >> 0)
+#define F_VC_TABLE_21(x) (((x) & ((1 << 6) - 1)) << 8)
+#define F_VC_TABLE_21_RD(x) (((x) & (((1 << 6) - 1) << 8)) >> 8)
+#define F_VC_TABLE_22(x) (((x) & ((1 << 6) - 1)) << 16)
+#define F_VC_TABLE_22_RD(x) (((x) & (((1 << 6) - 1) << 16)) >> 16)
+#define F_VC_TABLE_23(x) (((x) & ((1 << 6) - 1)) << 24)
+#define F_VC_TABLE_23_RD(x) (((x) & (((1 << 6) - 1) << 24)) >> 24)
+
+/* register DP_VC_TABLE_6 */
+#define DP_VC_TABLE_6 12
+#define F_VC_TABLE_24(x) (((x) & ((1 << 6) - 1)) << 0)
+#define F_VC_TABLE_24_RD(x) (((x) & (((1 << 6) - 1) << 0)) >> 0)
+#define F_VC_TABLE_25(x) (((x) & ((1 << 6) - 1)) << 8)
+#define F_VC_TABLE_25_RD(x) (((x) & (((1 << 6) - 1) << 8)) >> 8)
+#define F_VC_TABLE_26(x) (((x) & ((1 << 6) - 1)) << 16)
+#define F_VC_TABLE_26_RD(x) (((x) & (((1 << 6) - 1) << 16)) >> 16)
+#define F_VC_TABLE_27(x) (((x) & ((1 << 6) - 1)) << 24)
+#define F_VC_TABLE_27_RD(x) (((x) & (((1 << 6) - 1) << 24)) >> 24)
+
+/* register DP_VC_TABLE_7 */
+#define DP_VC_TABLE_7 13
+#define F_VC_TABLE_28(x) (((x) & ((1 << 6) - 1)) << 0)
+#define F_VC_TABLE_28_RD(x) (((x) & (((1 << 6) - 1) << 0)) >> 0)
+#define F_VC_TABLE_29(x) (((x) & ((1 << 6) - 1)) << 8)
+#define F_VC_TABLE_29_RD(x) (((x) & (((1 << 6) - 1) << 8)) >> 8)
+#define F_VC_TABLE_30(x) (((x) & ((1 << 6) - 1)) << 16)
+#define F_VC_TABLE_30_RD(x) (((x) & (((1 << 6) - 1) << 16)) >> 16)
+#define F_VC_TABLE_31(x) (((x) & ((1 << 6) - 1)) << 24)
+#define F_VC_TABLE_31_RD(x) (((x) & (((1 << 6) - 1) << 24)) >> 24)
+
+/* register DP_VC_TABLE_8 */
+#define DP_VC_TABLE_8 14
+#define F_VC_TABLE_32(x) (((x) & ((1 << 6) - 1)) << 0)
+#define F_VC_TABLE_32_RD(x) (((x) & (((1 << 6) - 1) << 0)) >> 0)
+#define F_VC_TABLE_33(x) (((x) & ((1 << 6) - 1)) << 8)
+#define F_VC_TABLE_33_RD(x) (((x) & (((1 << 6) - 1) << 8)) >> 8)
+#define F_VC_TABLE_34(x) (((x) & ((1 << 6) - 1)) << 16)
+#define F_VC_TABLE_34_RD(x) (((x) & (((1 << 6) - 1) << 16)) >> 16)
+#define F_VC_TABLE_35(x) (((x) & ((1 << 6) - 1)) << 24)
+#define F_VC_TABLE_35_RD(x) (((x) & (((1 << 6) - 1) << 24)) >> 24)
+
+/* register DP_VC_TABLE_9 */
+#define DP_VC_TABLE_9 15
+#define F_VC_TABLE_36(x) (((x) & ((1 << 1) - 1)) << 5)
+#define F_VC_TABLE_36_RD(x) (((x) & (((1 << 1) - 1) << 5)) >> 5)
+#define F_VC_TABLE_37(x) (((x) & ((1 << 6) - 1)) << 8)
+#define F_VC_TABLE_37_RD(x) (((x) & (((1 << 6) - 1) << 8)) >> 8)
+#define F_VC_TABLE_38(x) (((x) & ((1 << 6) - 1)) << 16)
+#define F_VC_TABLE_38_RD(x) (((x) & (((1 << 6) - 1) << 16)) >> 16)
+#define F_VC_TABLE_39(x) (((x) & ((1 << 6) - 1)) << 24)
+#define F_VC_TABLE_39_RD(x) (((x) & (((1 << 6) - 1) << 24)) >> 24)
+
+/* register DP_VC_TABLE_10 */
+#define DP_VC_TABLE_10 16
+#define F_VC_TABLE_40(x) (((x) & ((1 << 6) - 1)) << 0)
+#define F_VC_TABLE_40_RD(x) (((x) & (((1 << 6) - 1) << 0)) >> 0)
+#define F_VC_TABLE_41(x) (((x) & ((1 << 6) - 1)) << 8)
+#define F_VC_TABLE_41_RD(x) (((x) & (((1 << 6) - 1) << 8)) >> 8)
+#define F_VC_TABLE_42(x) (((x) & ((1 << 6) - 1)) << 16)
+#define F_VC_TABLE_42_RD(x) (((x) & (((1 << 6) - 1) << 16)) >> 16)
+#define F_VC_TABLE_43(x) (((x) & ((1 << 6) - 1)) << 24)
+#define F_VC_TABLE_43_RD(x) (((x) & (((1 << 6) - 1) << 24)) >> 24)
+
+/* register DP_VC_TABLE_11 */
+#define DP_VC_TABLE_11 17
+#define F_VC_TABLE_44(x) (((x) & ((1 << 6) - 1)) << 0)
+#define F_VC_TABLE_44_RD(x) (((x) & (((1 << 6) - 1) << 0)) >> 0)
+#define F_VC_TABLE_45(x) (((x) & ((1 << 6) - 1)) << 8)
+#define F_VC_TABLE_45_RD(x) (((x) & (((1 << 6) - 1) << 8)) >> 8)
+#define F_VC_TABLE_46(x) (((x) & ((1 << 6) - 1)) << 16)
+#define F_VC_TABLE_46_RD(x) (((x) & (((1 << 6) - 1) << 16)) >> 16)
+#define F_VC_TABLE_47(x) (((x) & ((1 << 6) - 1)) << 24)
+#define F_VC_TABLE_47_RD(x) (((x) & (((1 << 6) - 1) << 24)) >> 24)
+
+/* register DP_VC_TABLE_12 */
+#define DP_VC_TABLE_12 18
+#define F_VC_TABLE_48(x) (((x) & ((1 << 6) - 1)) << 0)
+#define F_VC_TABLE_48_RD(x) (((x) & (((1 << 6) - 1) << 0)) >> 0)
+#define F_VC_TABLE_49(x) (((x) & ((1 << 6) - 1)) << 8)
+#define F_VC_TABLE_49_RD(x) (((x) & (((1 << 6) - 1) << 8)) >> 8)
+#define F_VC_TABLE_50(x) (((x) & ((1 << 6) - 1)) << 16)
+#define F_VC_TABLE_50_RD(x) (((x) & (((1 << 6) - 1) << 16)) >> 16)
+#define F_VC_TABLE_51(x) (((x) & ((1 << 6) - 1)) << 24)
+#define F_VC_TABLE_51_RD(x) (((x) & (((1 << 6) - 1) << 24)) >> 24)
+
+/* register DP_VC_TABLE_13 */
+#define DP_VC_TABLE_13 19
+#define F_VC_TABLE_52(x) (((x) & ((1 << 6) - 1)) << 0)
+#define F_VC_TABLE_52_RD(x) (((x) & (((1 << 6) - 1) << 0)) >> 0)
+#define F_VC_TABLE_53(x) (((x) & ((1 << 6) - 1)) << 8)
+#define F_VC_TABLE_53_RD(x) (((x) & (((1 << 6) - 1) << 8)) >> 8)
+#define F_VC_TABLE_54(x) (((x) & ((1 << 6) - 1)) << 16)
+#define F_VC_TABLE_54_RD(x) (((x) & (((1 << 6) - 1) << 16)) >> 16)
+#define F_VC_TABLE_55(x) (((x) & ((1 << 6) - 1)) << 24)
+#define F_VC_TABLE_55_RD(x) (((x) & (((1 << 6) - 1) << 24)) >> 24)
+
+/* register DP_VC_TABLE_14 */
+#define DP_VC_TABLE_14 20
+#define F_VC_TABLE_56(x) (((x) & ((1 << 6) - 1)) << 0)
+#define F_VC_TABLE_56_RD(x) (((x) & (((1 << 6) - 1) << 0)) >> 0)
+#define F_VC_TABLE_57(x) (((x) & ((1 << 6) - 1)) << 8)
+#define F_VC_TABLE_57_RD(x) (((x) & (((1 << 6) - 1) << 8)) >> 8)
+#define F_VC_TABLE_58(x) (((x) & ((1 << 6) - 1)) << 16)
+#define F_VC_TABLE_58_RD(x) (((x) & (((1 << 6) - 1) << 16)) >> 16)
+#define F_VC_TABLE_59(x) (((x) & ((1 << 6) - 1)) << 24)
+#define F_VC_TABLE_59_RD(x) (((x) & (((1 << 6) - 1) << 24)) >> 24)
+
+/* register LINE_THRESH */
+#define LINE_THRESH 21
+#define F_CFG_ACTIVE_LINE_TRESH(x) (((x) & ((1 << 6) - 1)) << 0)
+#define F_CFG_ACTIVE_LINE_TRESH_RD(x) (((x) & (((1 << 6) - 1) << 0)) >> 0)
+#define F_VC_TABLE_61(x) (((x) & ((1 << 6) - 1)) << 8)
+#define F_VC_TABLE_61_RD(x) (((x) & (((1 << 6) - 1) << 8)) >> 8)
+#define F_VC_TABLE_62(x) (((x) & ((1 << 6) - 1)) << 16)
+#define F_VC_TABLE_62_RD(x) (((x) & (((1 << 6) - 1) << 16)) >> 16)
+#define F_VC_TABLE_63(x) (((x) & ((1 << 6) - 1)) << 24)
+#define F_VC_TABLE_63_RD(x) (((x) & (((1 << 6) - 1) << 24)) >> 24)
+
+/* register DP_VB_ID */
+#define DP_VB_ID 22
+#define F_VB_ID(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_VB_ID_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+
+/* register DP_MTPH_LVP_CONTROL */
+#define DP_MTPH_LVP_CONTROL 23
+#define F_MTPH_LVP_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_MTPH_LVP_EN_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+/* register DP_MTPH_SYMBOL_VALUES */
+#define DP_MTPH_SYMBOL_VALUES 24
+#define F_MPTH_LVP_SYM(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_MPTH_LVP_SYM_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+#define F_MTPH_ECF_SYM(x) (((x) & ((1 << 8) - 1)) << 8)
+#define F_MTPH_ECF_SYM_RD(x) (((x) & (((1 << 8) - 1) << 8)) >> 8)
+#define F_MTPH_MTPH_SYM(x) (((x) & ((1 << 8) - 1)) << 16)
+#define F_MTPH_MTPH_SYM_RD(x) (((x) & (((1 << 8) - 1) << 16)) >> 16)
+
+/* register DP_MTPH_ECF_CONTROL */
+#define DP_MTPH_ECF_CONTROL 25
+#define F_MPTH_ECF_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_MPTH_ECF_EN_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_MTPH_ACT_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_MTPH_ACT_EN_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+
+/* register DP_FIELDSEQ_3D */
+#define DP_FIELDSEQ_3D 26
+#define F_FIELD_SEQ_START(x) (((x) & ((1 << 16) - 1)) << 0)
+#define F_FIELD_SEQ_START_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+#define F_FIELD_SEQ_END(x) (((x) & ((1 << 16) - 1)) << 16)
+#define F_FIELD_SEQ_END_RD(x) (((x) & (((1 << 16) - 1) << 16)) >> 16)
+
+/* register DP_MTPH_STATUS */
+#define DP_MTPH_STATUS 27
+#define F_MTP_ACT_CNT_CTRL_CURR_STATE(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_MTP_ACT_CNT_CTRL_CURR_STATE_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+#define F_MTP_ECF_CNT_CTRL_CURR_STATE(x) (((x) & ((1 << 8) - 1)) << 8)
+#define F_MTP_ECF_CNT_CTRL_CURR_STATE_RD(x) (((x) & (((1 << 8) - 1) << 8)) >> 8)
+#define F_MTPH_ACT_STATUS(x) (((x) & ((1 << 1) - 1)) << 16)
+#define F_MTPH_ACT_STATUS_RD(x) (((x) & (((1 << 1) - 1) << 16)) >> 16)
+#define F_MTPH_ECF_STATUS(x) (((x) & ((1 << 1) - 1)) << 17)
+#define F_MTPH_ECF_STATUS_RD(x) (((x) & (((1 << 1) - 1) << 17)) >> 17)
+#define F_MTPH_LVP_STATUS(x) (((x) & ((1 << 1) - 1)) << 18)
+#define F_MTPH_LVP_STATUS_RD(x) (((x) & (((1 << 1) - 1) << 18)) >> 18)
+
+/* register DP_INTERRUPT_SOURCE */
+#define DP_INTERRUPT_SOURCE 28
+#define F_PSLVERR(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_PSLVERR_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_MTPH_ACT_EN_CLEAR(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_MTPH_ACT_EN_CLEAR_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_MTPH_LVP_EN_CLEAR(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_MTPH_LVP_EN_CLEAR_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+#define F_MTPH_ECF_EN_CLEAR(x) (((x) & ((1 << 1) - 1)) << 3)
+#define F_MTPH_ECF_EN_CLEAR_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+
+/* register DP_INTERRUPT_MASK */
+#define DP_INTERRUPT_MASK 29
+#define F_PSLVERR_MASK(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_PSLVERR_MASK_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_MTPH_ACT_EN_CLEAR_MASK(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_MTPH_ACT_EN_CLEAR_MASK_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_MTPH_LVP_EN_CLEAR_MASK(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_MTPH_LVP_EN_CLEAR_MASK_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+#define F_MTPH_ECF_EN_CLEAR_MASK(x) (((x) & ((1 << 1) - 1)) << 3)
+#define F_MTPH_ECF_EN_CLEAR_MASK_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+
+/* register DP_FRONT_BACK_PORCH */
+#define DP_FRONT_BACK_PORCH 30
+#define F_BACK_PORCH(x) (((x) & ((1 << 16) - 1)) << 0)
+#define F_BACK_PORCH_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+#define F_FRONT_PORCH(x) (((x) & ((1 << 16) - 1)) << 16)
+#define F_FRONT_PORCH_RD(x) (((x) & (((1 << 16) - 1) << 16)) >> 16)
+
+/* register DP_BYTE_COUNT */
+#define DP_BYTE_COUNT 31
+#define F_BYTE_COUNT(x) (((x) & ((1 << 16) - 1)) << 0)
+#define F_BYTE_COUNT_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+
+#endif //DPTX_FRAMER
diff --git a/drivers/mxc/hdp/dptx_stream.h b/drivers/mxc/hdp/dptx_stream.h
new file mode 100644
index 000000000000..ea5402354a55
--- /dev/null
+++ b/drivers/mxc/hdp/dptx_stream.h
@@ -0,0 +1,178 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * This file was auto-generated. Do not edit it manually.
+ *
+ ******************************************************************************
+ *
+ * dptx_stream.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef DPTX_STREAM_H_
+#define DPTX_STREAM_H_
+
+/* register MSA_HORIZONTAL_0 */
+#define MSA_HORIZONTAL_0 32
+#define F_PCK_STUFF_HTOTAL(x) (((x) & ((1 << 16) - 1)) << 0)
+#define F_PCK_STUFF_HTOTAL_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+#define F_PCK_STUFF_HSTART(x) (((x) & ((1 << 16) - 1)) << 16)
+#define F_PCK_STUFF_HSTART_RD(x) (((x) & (((1 << 16) - 1) << 16)) >> 16)
+
+/* register MSA_HORIZONTAL_1 */
+#define MSA_HORIZONTAL_1 33
+#define F_PCK_STUFF_HSYNCWIDTH(x) (((x) & ((1 << 15) - 1)) << 0)
+#define F_PCK_STUFF_HSYNCWIDTH_RD(x) (((x) & (((1 << 15) - 1) << 0)) >> 0)
+#define F_PCK_STUFF_HSYNCPOLARITY(x) (((x) & ((1 << 1) - 1)) << 15)
+#define F_PCK_STUFF_HSYNCPOLARITY_RD(x) (((x) & (((1 << 1) - 1) << 15)) >> 15)
+#define F_PCK_STUFF_HWIDTH(x) (((x) & ((1 << 16) - 1)) << 16)
+#define F_PCK_STUFF_HWIDTH_RD(x) (((x) & (((1 << 16) - 1) << 16)) >> 16)
+
+/* register MSA_VERTICAL_0 */
+#define MSA_VERTICAL_0 34
+#define F_PCK_STUFF_VTOTAL(x) (((x) & ((1 << 16) - 1)) << 0)
+#define F_PCK_STUFF_VTOTAL_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+#define F_PCK_STUFF_VSTART(x) (((x) & ((1 << 16) - 1)) << 16)
+#define F_PCK_STUFF_VSTART_RD(x) (((x) & (((1 << 16) - 1) << 16)) >> 16)
+
+/* register MSA_VERTICAL_1 */
+#define MSA_VERTICAL_1 35
+#define F_PCK_STUFF_VSYNCWIDTH(x) (((x) & ((1 << 15) - 1)) << 0)
+#define F_PCK_STUFF_VSYNCWIDTH_RD(x) (((x) & (((1 << 15) - 1) << 0)) >> 0)
+#define F_PCK_STUFF_VSYNCPOLARITY(x) (((x) & ((1 << 1) - 1)) << 15)
+#define F_PCK_STUFF_VSYNCPOLARITY_RD(x) (((x) & (((1 << 1) - 1) << 15)) >> 15)
+#define F_PCK_STUFF_VHEIGHT(x) (((x) & ((1 << 16) - 1)) << 16)
+#define F_PCK_STUFF_VHEIGHT_RD(x) (((x) & (((1 << 16) - 1) << 16)) >> 16)
+
+/* register MSA_MISC */
+#define MSA_MISC 36
+#define F_MSA_MISC0(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_MSA_MISC0_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+#define F_MSA_MISC1(x) (((x) & ((1 << 8) - 1)) << 8)
+#define F_MSA_MISC1_RD(x) (((x) & (((1 << 8) - 1) << 8)) >> 8)
+#define F_MSA_MISC1_INV(x) (((x) & ((1 << 1) - 1)) << 16)
+#define F_MSA_MISC1_INV_RD(x) (((x) & (((1 << 1) - 1) << 16)) >> 16)
+#define F_MSA_IN_MID_INTERLACE_EN(x) (((x) & ((1 << 1) - 1)) << 17)
+#define F_MSA_IN_MID_INTERLACE_EN_RD(x) (((x) & (((1 << 1) - 1) << 17)) >> 17)
+
+/* register STREAM_CONFIG */
+#define STREAM_CONFIG 37
+#define F_STREAM_NUM(x) (((x) & ((1 << 6) - 1)) << 0)
+#define F_STREAM_NUM_RD(x) (((x) & (((1 << 6) - 1) << 0)) >> 0)
+
+/* register AUDIO_PACK_STATUS */
+#define AUDIO_PACK_STATUS 38
+#define F_AP_FIFO_EMPTY(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_AP_FIFO_EMPTY_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_AP_FIFO_FULL(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_AP_FIFO_FULL_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_AP_AIF_FSM_CURR_ST(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_AP_AIF_FSM_CURR_ST_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+#define F_AP_SDP_TRANSFER_FSM_CURR_ST(x) (((x) & ((1 << 3) - 1)) << 3)
+#define F_AP_SDP_TRANSFER_FSM_CURR_ST_RD(x) (((x) & (((1 << 3) - 1) << 3)) >> 3)
+#define F_AP_FIFO_RD_FSM_CURR_ST(x) (((x) & ((1 << 2) - 1)) << 6)
+#define F_AP_FIFO_RD_FSM_CURR_ST_RD(x) (((x) & (((1 << 2) - 1) << 6)) >> 6)
+#define F_AP_FIFO_WR_FSM_CURR_ST(x) (((x) & ((1 << 2) - 1)) << 8)
+#define F_AP_FIFO_WR_FSM_CURR_ST_RD(x) (((x) & (((1 << 2) - 1) << 8)) >> 8)
+#define F_AP_PARITY_FSM_CURRENT_STATE(x) (((x) & ((1 << 3) - 1)) << 10)
+#define F_AP_PARITY_FSM_CURRENT_STATE_RD(x) (((x) & (((1 << 3) - 1) << 10)) >> 10)
+#define F_AUDIO_TS_VERSION(x) (((x) & ((1 << 6) - 1)) << 16)
+#define F_AUDIO_TS_VERSION_RD(x) (((x) & (((1 << 6) - 1) << 16)) >> 16)
+
+/* register VIF_STATUS */
+#define VIF_STATUS 39
+#define F_VIF_FIFO_EMPTY(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_VIF_FIFO_EMPTY_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_VIF_FIFO_FULL(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_VIF_FIFO_FULL_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_VIF_WR_CTRL_STATE(x) (((x) & ((1 << 6) - 1)) << 2)
+#define F_VIF_WR_CTRL_STATE_RD(x) (((x) & (((1 << 6) - 1) << 2)) >> 2)
+#define F_VIF_RD_CTRL_STATE(x) (((x) & ((1 << 20) - 1)) << 8)
+#define F_VIF_RD_CTRL_STATE_RD(x) (((x) & (((1 << 20) - 1) << 8)) >> 8)
+
+/* register PCK_STUFF_STATUS_0 */
+#define PCK_STUFF_STATUS_0 40
+#define F_NO_VIDEO_GEN_STATE(x) (((x) & ((1 << 5) - 1)) << 0)
+#define F_NO_VIDEO_GEN_STATE_RD(x) (((x) & (((1 << 5) - 1) << 0)) >> 0)
+#define F_SST_VIDEO_GEN_STATE(x) (((x) & ((1 << 7) - 1)) << 8)
+#define F_SST_VIDEO_GEN_STATE_RD(x) (((x) & (((1 << 7) - 1) << 8)) >> 8)
+#define F_MST_VIDEO_GEN_STATE(x) (((x) & ((1 << 6) - 1)) << 16)
+#define F_MST_VIDEO_GEN_STATE_RD(x) (((x) & (((1 << 6) - 1) << 16)) >> 16)
+#define F_MSA_GEN_STATE(x) (((x) & ((1 << 7) - 1)) << 24)
+#define F_MSA_GEN_STATE_RD(x) (((x) & (((1 << 7) - 1) << 24)) >> 24)
+
+/* register PCK_STUFF_STATUS_1 */
+#define PCK_STUFF_STATUS_1 41
+#define F_SST_SS_GEN_STATE(x) (((x) & ((1 << 6) - 1)) << 0)
+#define F_SST_SS_GEN_STATE_RD(x) (((x) & (((1 << 6) - 1) << 0)) >> 0)
+#define F_MST_SS_GEN_STATE(x) (((x) & ((1 << 6) - 1)) << 8)
+#define F_MST_SS_GEN_STATE_RD(x) (((x) & (((1 << 6) - 1) << 8)) >> 8)
+
+/* register INFO_PACK_STATUS */
+#define INFO_PACK_STATUS 42
+#define F_INFO_PACK_FIFO_FULL(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_INFO_PACK_FIFO_FULL_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_INFO_PACK_FIFO_EMPTY(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_INFO_PACK_FIFO_EMPTY_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_IP_PARITY_FSM_CURRENT_STATE(x) (((x) & ((1 << 3) - 1)) << 2)
+#define F_IP_PARITY_FSM_CURRENT_STATE_RD(x) (((x) & (((1 << 3) - 1) << 2)) >> 2)
+#define F_IP_FIFO_WR_FSM_CURRENT_STATE(x) (((x) & ((1 << 3) - 1)) << 5)
+#define F_IP_FIFO_WR_FSM_CURRENT_STATE_RD(x) (((x) & (((1 << 3) - 1) << 5)) >> 5)
+#define F_IP_FIFO_RD_FSM_CURRENT_STATE(x) (((x) & ((1 << 4) - 1)) << 8)
+#define F_IP_FIFO_RD_FSM_CURRENT_STATE_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+#define F_IP_SEND_DATA_FSM_CURRENT_STATE(x) (((x) & ((1 << 4) - 1)) << 12)
+#define F_IP_SEND_DATA_FSM_CURRENT_STATE_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+#define F_IN_VBID(x) (((x) & ((1 << 8) - 1)) << 24)
+#define F_IN_VBID_RD(x) (((x) & (((1 << 8) - 1) << 24)) >> 24)
+
+/* register RATE_GOVERNOR_STATUS */
+#define RATE_GOVERNOR_STATUS 43
+#define F_RATE_GOVERNOR_FSM_STATE(x) (((x) & ((1 << 3) - 1)) << 0)
+#define F_RATE_GOVERNOR_FSM_STATE_RD(x) (((x) & (((1 << 3) - 1) << 0)) >> 0)
+#define F_CFG_TU_VS_DIFF(x) (((x) & ((1 << 2) - 1)) << 8)
+#define F_CFG_TU_VS_DIFF_RD(x) (((x) & (((1 << 2) - 1) << 8)) >> 8)
+#define F_CFG_HSYNC_DELAY(x) (((x) & ((1 << 8) - 1)) << 16)
+#define F_CFG_HSYNC_DELAY_RD(x) (((x) & (((1 << 8) - 1) << 16)) >> 16)
+#define F_CFG_EN_HSYNC_DELAY(x) (((x) & ((1 << 1) - 1)) << 24)
+#define F_CFG_EN_HSYNC_DELAY_RD(x) (((x) & (((1 << 1) - 1) << 24)) >> 24)
+
+/* register DP_HORIZONTAL */
+#define DP_HORIZONTAL 44
+#define F_HSYNCWIDTH(x) (((x) & ((1 << 15) - 1)) << 0)
+#define F_HSYNCWIDTH_RD(x) (((x) & (((1 << 15) - 1) << 0)) >> 0)
+#define F_HWIDTH(x) (((x) & ((1 << 16) - 1)) << 16)
+#define F_HWIDTH_RD(x) (((x) & (((1 << 16) - 1) << 16)) >> 16)
+
+/* register DP_VERTICAL_0 */
+#define DP_VERTICAL_0 45
+#define F_VHEIGHT(x) (((x) & ((1 << 16) - 1)) << 0)
+#define F_VHEIGHT_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+#define F_VSTART(x) (((x) & ((1 << 16) - 1)) << 16)
+#define F_VSTART_RD(x) (((x) & (((1 << 16) - 1) << 16)) >> 16)
+
+/* register DP_VERTICAL_1 */
+#define DP_VERTICAL_1 46
+#define F_VTOTAL(x) (((x) & ((1 << 16) - 1)) << 0)
+#define F_VTOTAL_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+#define F_VTOTAL_EVEN(x) (((x) & ((1 << 1) - 1)) << 16)
+#define F_VTOTAL_EVEN_RD(x) (((x) & (((1 << 1) - 1) << 16)) >> 16)
+
+/* register DP_BLOCK_SDP */
+#define DP_BLOCK_SDP 47
+#define F_BLOCK_SDP_BS(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_BLOCK_SDP_BS_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+#define F_BLOCK_SDP_BE(x) (((x) & ((1 << 8) - 1)) << 8)
+#define F_BLOCK_SDP_BE_RD(x) (((x) & (((1 << 8) - 1) << 8)) >> 8)
+#define F_NO_VIDEO_BLOCK_SDP(x) (((x) & ((1 << 12) - 1)) << 16)
+#define F_NO_VIDEO_BLOCK_SDP_RD(x) (((x) & (((1 << 12) - 1) << 16)) >> 16)
+
+#endif //DPTX_STREAM
diff --git a/drivers/mxc/hdp/general_handler.h b/drivers/mxc/hdp/general_handler.h
new file mode 100644
index 000000000000..d6eb2b9844c3
--- /dev/null
+++ b/drivers/mxc/hdp/general_handler.h
@@ -0,0 +1,136 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * This file was auto-generated. Do not edit it manually.
+ *
+ ******************************************************************************
+ *
+ * general_handler.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef GENERAL_HANDLER_H
+#define GENERAL_HANDLER_H
+
+/**
+ *  \file
+ *  \brief general handler, checks available messages, receives it from mailbox, handles requests and sends response to the host
+ */
+#define DP_TX_MAIL_HANDLER_REQUEST_BUFFER_LEN 256
+
+/**
+ *  \brief opcode defines host->controller
+ */
+#define GENERAL_MAIN_CONTROL            0x01
+#define GENERAL_TEST_ECHO               0x02
+#define GENERAL_BUS_SETTINGS            0x03
+#define GENERAL_TEST_ACCESS             0x04
+
+#define GENERAL_WRITE_REGISTER          0x05
+#define GENERAL_WRITE_FIELD             0x06
+#define GENERAL_READ_REGISTER           0x07
+#define GENERAL_GET_HPD_STATE           0x11
+
+#define GENERAL_TEST_TRNG_SIMPLE        0xF0
+
+#define GENERAL_MAIN_CONTROL_SET_ACTIVE_BIT         0
+#define GENERAL_MAIN_CONTROL_SET_ALT_CIPHER_ADDR    1
+#define GENERAL_MAIN_CONTROL_SET_FAST_HDCP_DELAYS   2
+
+#define GENERAL_BUS_SETTINGS_DPCD_BUS_BIT           0
+#define GENERAL_BUS_SETTINGS_DPCD_BUS_LOCK_BIT      1
+#define GENERAL_BUS_SETTINGS_HDCP_BUS_BIT           2
+#define GENERAL_BUS_SETTINGS_HDCP_BUS_LOCK_BIT      3
+#define GENERAL_BUS_SETTINGS_CAPB_OWNER_BIT         4
+#define GENERAL_BUS_SETTINGS_CAPB_OWNER_LOCK_BIT    5
+
+/**
+ *  \brief opcode defines controller->host
+ */
+
+#define GENERAL_MAIN_CONTROL_RESP        0x01
+#define GENERAL_TEST_ECHO_RESP           0x02
+#define GENERAL_BUS_SETTINGS_RESP        0x03
+
+#define GENERAL_READ_REGISTER_RESP       0x07
+
+#define GENERAL_BUS_SETTINGS_RESP_DPCD_BUS_BIT      0
+#define GENERAL_BUS_SETTINGS_RESP_HDCP_BUS_BIT      1
+#define GENERAL_BUS_SETTINGS_RESP_CAPB_OWNER_BIT    2
+
+#define GENERAL_BUS_SETTINGS_RESP_SUCCESS           0
+#define GENERAL_BUS_SETTINGS_RESP_LOCK_ERROR        1
+
+typedef struct {
+	unsigned char dpcd_locked;
+	unsigned char hdcp_locked;
+	unsigned char capb_locked;
+	unsigned char active_mode;
+} S_GENERAL_HANDLER_DATA;
+
+/**
+ *  \brief event id sent to the host
+ */
+typedef enum {
+	EVENT_ID_DPTX_HPD = 0,
+	EVENT_ID_HDMI_TX_HPD = 0,
+	EVENT_ID_HDMI_RX_5V = 0,
+
+	EVENT_ID_DPTX_TRAINING = 1,
+	EVENT_ID_HDMI_RX_SCDC_CHANGE = 1,
+
+	EVENT_ID_RESERVE0 = 2,
+	EVENT_ID_RESERVE1 = 3,
+
+	EVENT_ID_HDCPTX_STATUS = 4,
+	EVENT_ID_HDCPRX_STATUS = 4,
+
+	EVENT_ID_HDCPTX_IS_KM_STORED = 5,
+	EVENT_ID_HDCPTX_STORE_KM = 6,
+	EVENT_ID_HDCPTX_IS_RECEIVER_ID_VALID = 7,
+	EVENT_ID_HDMITX_READ_REQUEST = 8,
+} EVENT_ID;
+
+/**
+ * \brief convert bank id and register number to address and write to ptr
+ */
+
+#define select_reg_old(bank, reg_no, ptr) \
+{ \
+	ptr = 0; \
+	if ((bank == 0x22) || (bank == 0x20) || (bank == 0x0b) || (bank == 0x09) || (bank == 0x0A)) \
+		ptr = (u32 *)(bank << 8 | reg_no); \
+}
+
+#define select_reg(bank, reg_no, ptr) \
+do { \
+	ptr = (u32 *)(bank << 8 | reg_no); \
+} while (0)
+
+#define select_reg4(pmsb, p2, p3, plsb, ptr) \
+do { \
+	ptr = (u32 *)((pmsb << 24) | (p2 << 16) | (p3 << 8) | (plsb << 0)); \
+} while (0)
+
+#define EVENTS_DPTX_CNT 2
+#define EVENTS_HDCPTX_CNT 4
+
+void general_handler_set_active_mode(void);
+void general_handler_set_standby_mode(void);
+
+/**
+ *  \brief request sending en event to the host
+ *  \param [in] eventId
+ *  \param [in] eventCode
+ */
+
+#endif /* GENERAL_HANDLER_H */
diff --git a/drivers/mxc/hdp/hdcp.h b/drivers/mxc/hdp/hdcp.h
new file mode 100644
index 000000000000..3c7365b5c583
--- /dev/null
+++ b/drivers/mxc/hdp/hdcp.h
@@ -0,0 +1,22 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * hdcp.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef HDCP_H
+#define HDCP_H
+# include "mailBox.h"
+
+#define RX_TX_HDCP_TRANS_MAX_BUFFER 640
+#endif //HDCP_H
diff --git a/drivers/mxc/hdp/hdcp2.h b/drivers/mxc/hdp/hdcp2.h
new file mode 100644
index 000000000000..4675da7ffc3f
--- /dev/null
+++ b/drivers/mxc/hdp/hdcp2.h
@@ -0,0 +1,261 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * This file was auto-generated. Do not edit it manually.
+ *
+ ******************************************************************************
+ *
+ * hdcp2.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef HDCP2_H
+#define HDCP2_H
+#include "mailBox.h"
+/*
+ * HDCP 2 registers
+ * and general use function for HDCP2 (transmitter and receiver)
+ * Author - yehonatan levin - cadence
+ */
+/**
+ *  \file
+ *  \brief HDCP 2 registers
+ * and general use function for HDCP2 (trasmiter and receiver)
+ */
+
+/* HDCP2 register list */
+
+#ifdef DP_TX
+#define HDCP2_RTX                       0x69000
+#define HDCP2_TX_CAPS                   0x69008
+#define HDCP2_CERT_RX                   0x6900B
+#define HDCP2_RRX                       0x69215
+#define HDCP2_RX_CAPS                   0x6921D
+#define HDCP2_EKPUB_KM                  0x69220
+#define HDCP2_EKH_KM_WR                 0x692A0
+#define HDCP2_M                         0x692B0
+#define HDCP2_H_TAG                     0x692C0
+#define HDCP2_EKH_KM_RD                 0x692E0
+#define HDCP2_RN                        0x692F0
+#define HDCP2_L_TAG                     0x692F8
+#define HDCP2_EDKEY_KS                  0x69318
+#define HDCP2_RIV                       0x69328
+#define HDCP2_RX_INFO                   0x69330
+#define HDCP2_SEQ_NUM_V                 0x69332
+#define HDCP2_V_TAG                     0x69335
+#define HDCP2_RECEIVER_ID_LIST          0x69345
+#define HDCP2_V                         0x693E0
+#define HDCP2_SEQ_NUM_M                 0x693F0
+#define HDCP2_K                         0x693F3
+#define HDCP2_STREAM_ID_TYPE            0x693F5
+#define HDCP2_M_TAG                     0x69473
+#define HDCP2_RXSTATUS                  0x69493
+#define HDCP2_RSVD                      0x69494
+#define HDCP2_DBG                       0x69518
+
+#else /* HDMI */
+#define HDCP2_HDCP14        0x0
+#define HDCP2_RSVD1         0x44
+#define HDCP2_HDCP2_VERSION 0x50
+#define HDCP2_RSVD2         0x51
+#define HDCP2_WRITE_MESSAGE 0x60
+#define HDCP2_RSVD3         0x61
+#define HDCP2_RXSTATUS      0x70
+#define HDCP2_RSVD4         0x72
+#define HDCP2_READ_MESSAGE  0x80
+#define HDCP2_RSVD5         0x81
+#define HDCP2_DBG           0xC0
+#endif
+
+/* HDCP2 commands */
+#define HDCP2_CMD_AKE_INIT                          2
+#define HDCP2_CMD_AKE_SEND_CERT                     3
+#define HDCP2_CMD_AKE_NO_STORED_KM                  4
+#define HDCP2_CMD_AKE_STORED_KM                     5
+#define HDCP2_CMD_AKE_SEND_H_PRIME                  7
+#define HDCP2_CMD_AKE_SEND_PAIRING_INFO             8
+#define HDCP2_CMD_LC_INIT                           9
+#define HDCP2_CMD_LC_SEND_L_PRIME                   10
+#define HDCP2_SKE_SEND_EKS                          11
+#define HDCP2_REPEATER_AUTH_SEND_RECEIVER_ID_LIST   12
+#define HDCP2_REPEATER_AUTH_SEND_ACK                15
+#define HDCP2_REPEATER_AUTH_STREAM_MANAGE           16
+#define HDCP2_REPEATER_AUTH_STREAM_READY            17
+
+/* values */
+#define HDCP2_VAL_HDCP2_VERSION_SUPPORTED 2
+
+#define LC_128_LEN 16
+extern u8 pHdcpLc128[LC_128_LEN];
+
+typedef enum {
+	HDCP2_NOT_FINISHED = 0x11,
+	HDCP2_FINISHED
+} HDCP_2_REC_RES;
+
+/* command structs */
+/* AKE INIT */
+typedef struct {
+	u8 version;
+	u8 transmitter_capability_mask[2];
+} S_HDCP2_TXCAPS;
+
+typedef struct {
+	u8 rtx[8];
+	S_HDCP2_TXCAPS txcaps;
+} S_HDCP2_CMD_AKE_INIT;
+
+/* AKE_SEND_CERT */
+
+typedef struct {
+	u8 cert_rx[522];
+	u8 r_rx[8];
+	u8 rxcaps[3];
+} S_HDCP2_CMD_AKE_SEND_CERT;
+
+/* AKE_NO_STORED_KM */
+
+typedef struct {
+	u8 ekpub_km[128];
+} S_HDCP2_CMD_AKE_NO_STORED_KM;
+
+/* AKE_STORED_KM */
+
+typedef struct {
+	u8 ekh_km[16];
+	u8 m[16];
+} S_HDCP2_CMD_AKE_STORED_KM;
+
+/* AKE_SEND_H_PRIME */
+
+typedef struct {
+	u8 h[32];
+} S_HDCP2_CMD_AKE_SEND_H_PRIME;
+
+/* AKE_SEND_PAIRING_INFO */
+
+typedef struct {
+	u8 Ekh_Km[16];
+} S_HDCP2_CMD_AKE_SEND_PAIRING_INFO;
+
+/* LC_Init */
+
+typedef struct {
+	u8 rn[8];
+} S_HDCP2_CMD_LC_Init;
+
+/* LC_Send_L_Prime */
+
+typedef struct {
+	u8 l[32];
+} S_HDCP2_CMD_LC_Send_L_Prime;
+
+/* LC_Send_Eks */
+
+typedef struct {
+	u8 Edkey_Ks[16];
+	u8 Riv[8];
+} S_HDCP2_CMD_SKE_Send_Eks;
+
+/* REPEATER_AUTH_SEND_RECEIVER_ID_LIST */
+
+typedef struct {
+	u8 RxInfo[2];
+	u8 seq_num_V[3];
+	u8 V[16];		/* max device count * 5 */
+} S_HDCP2_CMD_REPEATER_AUTH_SEND_RECEIVER_ID_LIST;
+
+/* HDCP2_RxInfo bits */
+typedef struct {
+	u16 HDCP1_DEVICE_DOWNSTREAM:1;
+	u16 HDCP2_0_REPEATER_DOWNSTREAM:1;
+	u16 MAX_CASCADE_EXCEEDED:1;
+	u16 MAX_DEVS_EXCEEDED:1;
+	u16 DEVICE_COUNT:5;
+	u16 DEPTH:3;
+} S_HDCP2_RX_INFO_BITS;
+
+typedef union {
+	S_HDCP2_RX_INFO_BITS bits;
+	u16 value16Bit;
+} U_HDCP2_RX_INFO;
+
+/* REPEATER_AUTH_SEND_ACK */
+
+typedef struct {
+	u8 v[16];
+} S_HDCP2_CMD_REPEATER_AUTH_SEND_ACK;
+
+/* REPEATER_AUTH_STREAM_MANAGE */
+
+typedef struct {
+	u8 seq_num_m[3];
+	u8 k[2];
+	u8 streamId_Type[2];	/* should be k*2 by spec??? */
+} S_HDCP2_CMD_REPEATER_AUTH_STREAM_MANAGE;
+
+/* REPEATER_AUTH_STREAM_READY */
+
+typedef struct {
+	u8 m[32];
+} S_HDCP2_CMD_REPEATER_AUTH_STREAM_READY;
+
+/* HDCP2_RXSTATUS bits */
+#ifdef DP_TX
+typedef struct {
+
+	u8 READY:1;
+	u8 H_AVAILABLE:1;
+	u8 PAIRING_AVAILABLE:1;
+	u8 REAUTH_REQ:1;
+	u8 LINK_INTEGRITY_FAILURE:1;
+	u8 RSVD:3;
+} S_HDCP2_RX_STATUS_BITS;
+#else
+typedef struct {
+	u16 Message_Size:10;
+	u16 READY:1;
+	u16 REAUTH_REQ:1;
+	u16 RSVD:4;
+} S_HDCP2_RX_STATUS_BITS;
+
+#endif
+
+typedef union {
+	S_HDCP2_RX_STATUS_BITS bits;
+	u16 value16Bit;
+} U_HDCP2_RX_STATUS;
+
+/* HDCP ports mail box messages */
+typedef enum {
+	HDCP_GENERAL_SET_LC_128 = 0,
+	HDCP_SET_SEED,
+} HDCP_GENERAL_MSG;
+
+/**
+ *  \brief get command length for specific command
+ *
+ *  \param [in] offset offset of the command
+ *  \return Return_Description
+ *
+ */
+u32 hdcp2_commandLen(u32 offset);
+/**
+ *  \brief message length for specific message
+ *
+ *  \param [in] msg the message
+ *  \return the size of this message
+ *
+ */
+u32 hdcp2_MsgcommandLen(u8 msg);
+
+#endif
diff --git a/drivers/mxc/hdp/hdcp_tran.h b/drivers/mxc/hdp/hdcp_tran.h
new file mode 100644
index 000000000000..09d391b56ae6
--- /dev/null
+++ b/drivers/mxc/hdp/hdcp_tran.h
@@ -0,0 +1,226 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * hdcp_tran.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef HDCP_TRAN_H
+#define HDCP_TRAN_H
+
+#include "hdcp.h"
+
+/**
+ *  \file
+ *  \brief general HDCP2 transmitter function and data structures
+ */
+
+/* supported HDCP TX ports */
+typedef enum {
+	HDCP_TX_PORT_0,
+	HDCP_TX_PORT_1,
+	HDCP_TX_PORT_2,
+	HDCP_TX_PORT_3,
+	HDCP_TX_NUM_OF_PORTS,
+} HDCP_TX_PORT;
+
+/* HDCP TX ports working mode (HDCP 2.2 or 1.4) */
+typedef enum {
+	HDCP_TX_2,		/* lock only with HDCP2 */
+	HDCP_TX_1,		/* lock only with HDCP1 */
+	HDCP_TX_BOTH,		/* lock on HDCP2 or 1 depend on other side */
+} HDCP_TX_MODE;
+
+/* HDCP TX ports stream type (relevant if receiver is repeater) */
+typedef enum {
+	HDCP_CONTENT_TYPE_0,	/* May be transmitted by The HDCP Repeater to all HDCP Devices. */
+	HDCP_CONTENT_TYPE_1,	/* Must not be transmitted by the HDCP Repeater to HDCP 1.x-compliant Devices and HDCP 2.0-compliant Repeaters */
+} HDCP_TX_CONTENT_STREAM_TYPE;
+
+/* HDCP TX ports stream packet status */
+typedef enum {
+	HDCP_CONTENT_NEED_TO_SEND,
+	HDCP_CONTENT_SENT_AND_WAIT_FOR_RESPOND,
+	HDCP_CONTENT_SENT_AND_FAILED,
+	HDCP_CONTENT_SUCCESS,
+} HDCP_TX_CONTENT_STREAM_STATUS;
+
+/* HDCP TX ports working mode (HDCP 2.2 or 1.4) */
+typedef enum {
+	HDCP_TX_NOT_ACTIVE,
+	HDCP_TX_NOT_CONFIGURED,
+	HDCP_TX_START,
+	HDCP_TX_WAIT_FOR_RX_TYPE,
+	HDCP_TX_ACTION
+} HDCP_TX_STATE;
+
+typedef union {
+	struct {
+		HDCP_TX_MODE port_supported_modes:2;
+		HDCP_TX_MODE port_cur_mode:2;
+		HDCP_TX_STATE port_state:4;
+		HDCP_TX_CONTENT_STREAM_TYPE contentType:1;
+		HDCP_TX_CONTENT_STREAM_STATUS content_status:2;
+		u8 statusWasUpdated:1;
+		u8 errorWasUpdated:1;
+		u8 ENABLE_1_1_FEATURES:1;
+		u8 ENABLE_1_1_FEATURES_onCurrentConnection:1;
+		u8 hdmi_mode:1;
+		u8 irq:1;
+	} fields;
+	u32 bits;
+} U_HDCP_TRANS_PORT_DATA_STATUS;
+
+/* struct holding data needed to the HDCP transmitter */
+#define TX_PORT_STATUS_EXTRA_DATA 3
+typedef struct {
+
+	U_HDCP_TRANS_PORT_DATA_STATUS status;
+	u16 port_status;
+	u8 port_status_extraData[TX_PORT_STATUS_EXTRA_DATA];
+	u32 seq_num_M;		/* for sending content stream manage */
+	u32 seq_num_V;
+	u8 rxTxBuffer[RX_TX_HDCP_TRANS_MAX_BUFFER];
+
+	u8 recieverIdListCommand[(128 * 5) + 4];
+	u32 recieverIdListSize;
+	MB_TYPE mailBoxType;
+
+} S_HDCP_TRANS_PORT_DATA;
+
+typedef struct {
+	S_HDCP_TRANS_PORT_DATA port[HDCP_TX_NUM_OF_PORTS];
+} S_HDCP_TRANS_DATA;
+
+/* HDCP TX ports working mode (HDCP 2.2 or 1.4) */
+
+/**
+ *
+ *  \brief transmitter supported API (via mail box)
+ */
+typedef enum {
+	HDCP_TX_CONFIGURATION,			/*!< use this command to set HDCP transmitter type and wake it up (or stop ), 1 byte with following bits :  Bit (0-1)= 0 - support only HDCP 2, 1 - support only HDCP 1, 2 - support both HDCP, Bit 2 - active (to activate port set to 1), to stop port set to 0 */
+	HDCP2_TX_SET_PUBLIC_KEY_PARAMS,		/*!< use it to set public key for the HDCP2.x transmitter(HDCP2.x), Modulus n - 384 bytes,  E - 3 bytes */
+	HDCP2_TX_SET_DEBUG_RANDOM_NUMBERS,	/*!< use this command to enforce  the random parameters (for debug only!), instead of the random data generated by the embedded RNG.Use this command after HDCP_TX_SET_PUBLIC_KEY_PARAMS command. Relevant to (HDCP2.x), data is : KM 16 bytes,RN 8 bytes,KS 16 bytes,RIV 8 bytes,RTX 8 bytes */
+	HDCP2_TX_RESPOND_KM,			/*!< If km is stored, return all parameters, else there is no extra data(HDCP2.x), data is : Receiver ID (5 bytes),m (16 bytes),Km (16 bytes),Ekh(Km)(16 bytes) */
+	HDCP1_TX_SEND_KEYS,			/*!< send keys needed for HDCP 1, data is :  AKSV (5 bytes), ksv (7*40 = 280 bytes) */
+	HDCP1_TX_SEND_RANDOM_AN,		/*!< set AN, use it for debug purpose, if not use, it will be random number, data is (8 bytes) */
+	HDCP_TX_STATUS_CHANGE,			/*!< Will be called in port status change event by cadence HDCP IP, Status for the port:Bit 0 - AUTHENTICATED (1 - link is authenticated), Bit 1 - receiver is REPEATER (1 for repeater, 0 not),Bit 2 - 0 for HDCP1, 1 for HDCP2,     */
+	HDCP2_TX_IS_KM_STORED,			/*!< controller check if KM is stored by host(HDCP2.x), data is : Receiver ID (5 bytes) */
+	HDCP2_TX_STORE_KM,			/*!< controller ask host to store KM, host may store it on non-volatile memory for faster authentication(HDCP2.x), data is : Receiver ID (5 bytes),m (16 bytes),Km(16 bytes),Ekh(Km),(16 bytes) */
+	HDCP_TX_IS_RECEIVER_ID_VALID,		/*!< controller check if receivers ID are not in revocation list, input is->first byte for number of receivers, then list of receivers (5 bytes each) */
+	HDCP_TX_RESPOND_RECEIVER_ID_VALID,	/*!< If receivers ID are valid return 1, otherwise return 0, same for HDCP1,HDCP2 */
+	HDCP_TX_TEST_KEYS,			/*!< compare HDCP keys with facsimile key */
+	HDCP2_TX_SET_KM_KEY_PARAMS,		/*!< This Command is used to load customer defined Key for km-key encryption into the HDCP2.x transmitter controller. */
+} HDCP_TRNAS_MAIL_BOX_MSG;
+
+/* HDCP_TX_CONFIGURATION */
+
+/* bits 0-1 HDCP_TX_MODE */
+#define HDCP_TX_CONFIGURATION_MODE_OFFSET                       0
+#define HDCP_TX_CONFIGURATION_MODE_LEN                          2
+#define HDCP_TX_CONFIGURATION_RUN                               2
+#define HDCP_TX_CONFIGURATION_RPTR_CONTENT_STREAM_MNGR_OFFSET   3
+#define HDCP_TX_CONFIGURATION_RPTR                              4
+#define HDCP_TX_ENABLE_1_1_FEATURES                             5
+#define HDCP_TX_SECOND_LINK                                     6
+#define HDCP_TX_HDMI_MODE                                       7
+
+#define HDCP_TX_CONFIGURATION_ENABLE_KM_KEY_MASK (1 << 4)
+
+/* HDCP_TX_STATUS_CHANGE bits */
+#define HDCP_STATUS_AUTHENTICATED           0
+#define HDCP_STATUS_REPEATER                1
+#define HDCP_STATUS_HDCP2                   2
+#define HDCP_STATUS_STRAM_MANAGE_SUCCESS    4
+#define HDCP_STATUS_ERROR_TYPE              5
+#define HDCP_STATUS_1_1_FEATURES            9
+
+/**
+ * \brief different error types for HDCP_TX_STATUS_CHANGE
+ */
+typedef enum {
+	HDCP_TRAN_ERR_No_error,
+	HDCP_TRAN_ERR_HPD_is_down,
+	HDCP_TRAN_ERR_SRM_failure,
+	HDCP_TRAN_ERR_signature_verification,
+	HDCP_TRAN_ERR_h_tag_diff_h,
+	HDCP_TRAN_ERR_v_tag_diff_v,
+	HDCP_TRAN_ERR_locality_check,
+	HDCP_TRAN_ERR_Ddc,
+	HDCP_TRAN_ERR_REAUTH_REQ,
+	HDCP_TRAN_ERR_topology,
+	HDCP_TRAN_ERR_HDCP_RSVD1,
+	HDCP_TRAN_ERR_HDMI_capability,
+	HDCP_TRAN_ERR_RI,
+	HDCP_TRAN_ERR_watchDog_expired,
+} HDCP_TRNAS_ERR_TYPE;
+
+/* HDCP2_TX_SET_PUBLIC_KEY_PARAMS */
+#define DLP_MODULUS_N 384
+#define DLP_E 3
+typedef struct {
+	u8 N[DLP_MODULUS_N];
+	u8 E[DLP_E];
+} S_HDCP_TRANS_PUBLIC_KEY_PARAMS;
+
+/* HDCP2_TX_SET_KM_KEY_PARAMS */
+#define DLP_KM_KEY 16
+typedef struct {
+	u8 KM_KEY[DLP_KM_KEY];
+} S_HDCP_TRANS_KM_KEY_PARAMS;
+
+/* HDCP2_TX_SET_DEBUG_RANDOM_NUMBERS */
+#define DEBUG_RANDOM_NUMBERS_KM_LEN 16
+#define DEBUG_RANDOM_NUMBERS_RN_LEN 8
+#define DEBUG_RANDOM_NUMBERS_KS_LEN 16
+#define DEBUG_RANDOM_NUMBERS_RIV_LEN 8
+#define DEBUG_RANDOM_NUMBERS_RTX_LEN 8
+
+typedef struct {
+	u8 KM[DEBUG_RANDOM_NUMBERS_KM_LEN];
+	u8 RN[DEBUG_RANDOM_NUMBERS_RN_LEN];
+	u8 KS[DEBUG_RANDOM_NUMBERS_KS_LEN];
+	u8 RIV[DEBUG_RANDOM_NUMBERS_RIV_LEN];
+	u8 RTX[DEBUG_RANDOM_NUMBERS_RTX_LEN];
+} S_HDCP_TRANS_DEBUG_RANDOM_NUMBERS;
+
+#define HDCP_PAIRING_M_LEN 16
+#define HDCP_PAIRING_M_EKH 16
+#define HDCP_PAIRING_R_ID 5
+
+typedef struct {
+	u8 Receiver_ID[HDCP_PAIRING_R_ID];
+	u8 m[HDCP_PAIRING_M_LEN];
+	u8 KM[DEBUG_RANDOM_NUMBERS_KM_LEN];
+	u8 EKH[HDCP_PAIRING_M_EKH];
+} S_HDCP_TRANS_PAIRING_DATA;
+
+typedef struct {
+	u8 Receiver_ID[HDCP_PAIRING_R_ID];
+} S_HDCP_TRANS_REVOCATION_LIST;
+
+/* HDCP1_TX_SEND_KEYS */
+#define AKSV_SIZE (5)
+#define HDCPT1_KSV_SIZE (7 * 40)
+
+typedef struct {
+	u8 AKSV[AKSV_SIZE];
+	u8 KSV[HDCPT1_KSV_SIZE];
+} S_HDCP_TX_MAIL_BOX_CMD_HDCP1_TX_SEND_KEYS;
+
+#define AN_SIZE (8)
+
+/* HDCP2_TX_SESSION_KEY */
+#define HDCP_SESSION_KEY_LEN 16
+
+#endif //HDCP_TRAN_H
diff --git a/drivers/mxc/hdp/hdmi.h b/drivers/mxc/hdp/hdmi.h
new file mode 100644
index 000000000000..90d686b22b00
--- /dev/null
+++ b/drivers/mxc/hdp/hdmi.h
@@ -0,0 +1,92 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * hdmi.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef _HDMI__
+#define _HDMI__
+/* ONLY ENUMS AND #DEFINES IN THIS FILE *
+ * THIS FILE WILL BE USED IN HOST'S API */
+
+#define EDID_SLAVE_ADDRESS                  0x50
+#define EDID_SEGMENT_SLAVE_ADDRESS          0x30
+#define SCDC_SLAVE_ADDRESS                  0x54
+
+typedef enum {
+	HDMI_TX_READ,
+	HDMI_TX_WRITE,
+	HDMI_TX_UPDATE_READ,
+	HDMI_TX_EDID,
+	HDMI_TX_EVENTS,
+	HDMI_TX_HPD_STATUS,
+	HDMI_TX_DEBUG_ECHO = 0xAA,
+	HDMI_TX_TEST = 0xBB,
+	HDMI_TX_EDID_INTERNAL = 0xF0,
+} HDMI_TX_OPCODE;
+
+typedef enum {
+	HDMI_I2C_ACK,
+	HDMI_I2C_NACK,
+	HDMI_I2C_TO,
+	HDMI_I2C_ARB_LOST,
+	HDMI_I2C_RRTO,
+	HDMI_I2C_RRT,
+    /** when i2c hardware didn't respond after some time */
+	HDMI_I2C_HW_TO,
+	HDMI_I2C_ERR		//unspecified error
+} HDMI_I2C_STATUS;
+
+typedef enum {
+	HDMI_RX_SET_EDID,
+	HDMI_RX_SCDC_SET,
+	HDMI_RX_SCDC_GET,
+	HDMI_RX_READ_EVENTS,
+	HDMI_RX_SET_HPD,
+
+	HDMI_RX_DEBUG_ECHO = 0xAA,
+	HDMI_RX_TEST = 0xBB,
+} HDMI_RX_OPCODE;
+
+typedef enum {
+	HDMI_SCDC_SINK_VER,
+	HDMI_SCDC_SOURCE_VER,
+} HDMI_SCDC_FIELD;
+
+typedef struct {
+	u8 sink_ver;
+	u8 manufacturer_oui_1;
+	u8 manufacturer_oui_2;
+	u8 manufacturer_oui_3;
+	u8 devId[8];
+	u8 hardware_major_rev;
+	u8 hardware_minor_rev;
+	u8 software_major_rev;
+	u8 software_minor_rev;
+	u8 manufacturerSpecific[34];
+} S_HDMI_SCDC_SET_MSG;
+
+typedef struct {
+	u8 source_ver;
+	u8 TMDS_Config;
+	u8 config_0;
+	u8 manufacturerSpecific[34];
+} S_HDMI_SCDC_GET_MSG;
+
+/* hpd events location */
+#define HDMI_RX_EVENT_5V_HIGH            0
+#define HDMI_RX_EVENT_5V_LOW             1
+#define HDMI_TX_EVENT_reserved           2
+#define HDMI_RX_EVENT_5V_VAL             3
+
+#endif
diff --git a/drivers/mxc/hdp/mailBox.h b/drivers/mxc/hdp/mailBox.h
new file mode 100644
index 000000000000..e25aac04e26a
--- /dev/null
+++ b/drivers/mxc/hdp/mailBox.h
@@ -0,0 +1,86 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * mailBox.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef MAIL_BOX_H
+#define MAIL_BOX_H
+
+#define MAIL_BOX_MAX_SIZE 600
+#define MAIL_BOX_MAX_TX_SIZE 160
+
+ /**
+ * \file mailBox.h
+ * \brief Implementation mail box communication channel between IP and external host
+ */
+
+#define MB_MODULE_ID_DP_TX          0x01
+#define MB_MODULE_ID_DP_RX          0x02
+#define MB_MODULE_ID_HDMI_TX        0x03
+#define MB_MODULE_ID_HDMI_RX        0x04
+#define MB_MODULE_ID_MHL_TX         0x05
+#define MB_MODULE_ID_MHL_RX         0x06
+#define MB_MODULE_ID_HDCP_TX        0x07
+#define MB_MODULE_ID_HDCP_RX        0x08
+#define MB_MODULE_ID_HDCP_GENERAL   0x09
+#define MB_MODULE_ID_GENERAL        0x0A
+
+typedef enum {
+	MB_TYPE_REGULAR,
+	MB_TYPE_SECURE,
+	MB_TYPE_COUNT,
+} MB_TYPE;
+
+typedef enum {
+	MB_SUCCESS,
+	MB_BUSY,
+	MB_NO_MEMORY
+} MB_RET;
+
+typedef enum {
+	MB_TO_HOST,
+	MB_TO_CONTROLLER,
+} MB_IDX;
+
+typedef enum {
+	MB_STATE_EMPTY,
+	MB_STATE_WAIT_MODULE_ID,
+	MB_STATE_WAIT_SIZE_MSB,
+	MB_STATE_WAIT_SIZE_LSB,
+	MB_STATE_READ_DATA,
+	MB_STATE_MSG_READY,
+} MB_RX_STATE;
+
+#define MB_OPCODE_ID 0
+#define MB_MODULE_ID 1
+#define MB_SIZE_MSB_ID 2
+#define MB_SIZE_LSB_ID 3
+#define MB_DATA_ID 4
+
+typedef struct {
+	MB_RX_STATE rxState;
+	u32 rx_data_idx;
+	u32 rx_final_msgSize;
+	u8 rxBuff[MAIL_BOX_MAX_SIZE];
+	u8 txBuff[MAIL_BOX_MAX_TX_SIZE];
+	u32 txTotal;
+	u32 txCur;
+} S_MAIL_BOX_PORT_DATA;
+
+typedef struct {
+	S_MAIL_BOX_PORT_DATA portData;
+	u8 portsTxBusy;		//bit for each port (0-7)
+} S_MAIL_BOX_DATA;
+
+#endif //MAIL_BOX_H
diff --git a/drivers/mxc/hdp/mhl_hdtx_top.h b/drivers/mxc/hdp/mhl_hdtx_top.h
new file mode 100644
index 000000000000..00a56cff96b8
--- /dev/null
+++ b/drivers/mxc/hdp/mhl_hdtx_top.h
@@ -0,0 +1,190 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * This file was auto-generated. Do not edit it manually.
+ *
+ ******************************************************************************
+ *
+ * mhl_hdtx_top.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef MHL_HDTX_TOP_H_
+#define MHL_HDTX_TOP_H_
+
+/* register SCHEDULER_H_SIZE */
+#define SCHEDULER_H_SIZE 0
+#define F_H_BLANK_SIZE(x) (((x) & ((1 << 16) - 1)) << 0)
+#define F_H_BLANK_SIZE_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+#define F_H_ACTIVE_SIZE(x) (((x) & ((1 << 16) - 1)) << 16)
+#define F_H_ACTIVE_SIZE_RD(x) (((x) & (((1 << 16) - 1) << 16)) >> 16)
+
+/* register SCHEDULER_V_SIZE */
+#define SCHEDULER_V_SIZE 1
+#define F_V_BLANK_SIZE(x) (((x) & ((1 << 16) - 1)) << 0)
+#define F_V_BLANK_SIZE_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+#define F_V_ACTIVE_SIZE(x) (((x) & ((1 << 16) - 1)) << 16)
+#define F_V_ACTIVE_SIZE_RD(x) (((x) & (((1 << 16) - 1) << 16)) >> 16)
+
+/* register SCHEDULER_KEEP_OUT */
+#define SCHEDULER_KEEP_OUT 2
+#define F_HKEEP_OUT(x) (((x) & ((1 << 9) - 1)) << 0)
+#define F_HKEEP_OUT_RD(x) (((x) & (((1 << 9) - 1) << 0)) >> 0)
+#define F_VKEEP_OUT_START(x) (((x) & ((1 << 11) - 1)) << 9)
+#define F_VKEEP_OUT_START_RD(x) (((x) & (((1 << 11) - 1) << 9)) >> 9)
+#define F_VKEEP_OUT_ZONE(x) (((x) & ((1 << 8) - 1)) << 20)
+#define F_VKEEP_OUT_ZONE_RD(x) (((x) & (((1 << 8) - 1) << 20)) >> 20)
+
+/* register HDTX_SIGNAL_FRONT_WIDTH */
+#define HDTX_SIGNAL_FRONT_WIDTH 3
+#define F_HFRONT(x) (((x) & ((1 << 16) - 1)) << 0)
+#define F_HFRONT_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+#define F_VFRONT(x) (((x) & ((1 << 16) - 1)) << 16)
+#define F_VFRONT_RD(x) (((x) & (((1 << 16) - 1) << 16)) >> 16)
+
+/* register HDTX_SIGNAL_SYNC_WIDTH */
+#define HDTX_SIGNAL_SYNC_WIDTH 4
+#define F_HSYNC(x) (((x) & ((1 << 16) - 1)) << 0)
+#define F_HSYNC_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+#define F_VSYNC(x) (((x) & ((1 << 16) - 1)) << 16)
+#define F_VSYNC_RD(x) (((x) & (((1 << 16) - 1) << 16)) >> 16)
+
+/* register HDTX_SIGNAL_BACK_WIDTH */
+#define HDTX_SIGNAL_BACK_WIDTH 5
+#define F_HBACK(x) (((x) & ((1 << 16) - 1)) << 0)
+#define F_HBACK_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+#define F_VBACK(x) (((x) & ((1 << 16) - 1)) << 16)
+#define F_VBACK_RD(x) (((x) & (((1 << 16) - 1) << 16)) >> 16)
+
+/* register HDTX_CONTROLLER */
+#define HDTX_CONTROLLER 6
+#define F_HDMI_MODE(x) (((x) & ((1 << 2) - 1)) << 0)
+#define F_HDMI_MODE_RD(x) (((x) & (((1 << 2) - 1) << 0)) >> 0)
+#define F_VIF_DATA_WIDTH(x) (((x) & ((1 << 2) - 1)) << 2)
+#define F_VIF_DATA_WIDTH_RD(x) (((x) & (((1 << 2) - 1) << 2)) >> 2)
+#define F_AUTO_MODE(x) (((x) & ((1 << 1) - 1)) << 4)
+#define F_AUTO_MODE_RD(x) (((x) & (((1 << 1) - 1) << 4)) >> 4)
+#define F_IL_PROG(x) (((x) & ((1 << 2) - 1)) << 5)
+#define F_IL_PROG_RD(x) (((x) & (((1 << 2) - 1) << 5)) >> 5)
+#define F_PIC_3D(x) (((x) & ((1 << 4) - 1)) << 7)
+#define F_PIC_3D_RD(x) (((x) & (((1 << 4) - 1) << 7)) >> 7)
+#define F_BCH_EN(x) (((x) & ((1 << 1) - 1)) << 11)
+#define F_BCH_EN_RD(x) (((x) & (((1 << 1) - 1) << 11)) >> 11)
+#define F_GCP_EN(x) (((x) & ((1 << 1) - 1)) << 12)
+#define F_GCP_EN_RD(x) (((x) & (((1 << 1) - 1) << 12)) >> 12)
+#define F_SET_AVMUTE(x) (((x) & ((1 << 1) - 1)) << 13)
+#define F_SET_AVMUTE_RD(x) (((x) & (((1 << 1) - 1) << 13)) >> 13)
+#define F_CLEAR_AVMUTE(x) (((x) & ((1 << 1) - 1)) << 14)
+#define F_CLEAR_AVMUTE_RD(x) (((x) & (((1 << 1) - 1) << 14)) >> 14)
+#define F_DATA_EN(x) (((x) & ((1 << 1) - 1)) << 15)
+#define F_DATA_EN_RD(x) (((x) & (((1 << 1) - 1) << 15)) >> 15)
+#define F_HDMI_ENCODING(x) (((x) & ((1 << 2) - 1)) << 16)
+#define F_HDMI_ENCODING_RD(x) (((x) & (((1 << 2) - 1) << 16)) >> 16)
+#define F_HDMI2_PREAMBLE_EN(x) (((x) & ((1 << 1) - 1)) << 18)
+#define F_HDMI2_PREAMBLE_EN_RD(x) (((x) & (((1 << 1) - 1) << 18)) >> 18)
+#define F_HDMI2_CTRL_IL_MODE(x) (((x) & ((1 << 1) - 1)) << 19)
+#define F_HDMI2_CTRL_IL_MODE_RD(x) (((x) & (((1 << 1) - 1) << 19)) >> 19)
+
+/* register HDTX_HDCP */
+#define HDTX_HDCP 7
+#define F_HDTX_HDCP_SELECT(x) (((x) & ((1 << 2) - 1)) << 0)
+#define F_HDTX_HDCP_SELECT_RD(x) (((x) & (((1 << 2) - 1) << 0)) >> 0)
+#define F_ENC_BIT(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_ENC_BIT_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+#define F_HDCP_ENABLE_1P1_FEATURES(x) (((x) & ((1 << 1) - 1)) << 3)
+#define F_HDCP_ENABLE_1P1_FEATURES_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+#define F_HDCP_DELAY_FIFO_SW_RST(x) (((x) & ((1 << 1) - 1)) << 4)
+#define F_HDCP_DELAY_FIFO_SW_RST_RD(x) (((x) & (((1 << 1) - 1) << 4)) >> 4)
+#define F_HDCP_DELAY_FIFO_SW_START(x) (((x) & ((1 << 1) - 1)) << 5)
+#define F_HDCP_DELAY_FIFO_SW_START_RD(x) (((x) & (((1 << 1) - 1) << 5)) >> 5)
+#define F_HDCP_DOUBLE_FIFO_SW_RST(x) (((x) & ((1 << 1) - 1)) << 6)
+#define F_HDCP_DOUBLE_FIFO_SW_RST_RD(x) (((x) & (((1 << 1) - 1) << 6)) >> 6)
+#define F_HDCP_SINGLE_FIFO_SW_RST(x) (((x) & ((1 << 1) - 1)) << 7)
+#define F_HDCP_SINGLE_FIFO_SW_RST_RD(x) (((x) & (((1 << 1) - 1) << 7)) >> 7)
+#define F_HDCP_DELAY_FIFO_AFULL_THR(x) (((x) & ((1 << 4) - 1)) << 8)
+#define F_HDCP_DELAY_FIFO_AFULL_THR_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+#define F_HDCP_CTRL_SW_RST(x) (((x) & ((1 << 1) - 1)) << 12)
+#define F_HDCP_CTRL_SW_RST_RD(x) (((x) & (((1 << 1) - 1) << 12)) >> 12)
+#define F_HDCP_CTRL_IL_MODE(x) (((x) & ((1 << 1) - 1)) << 13)
+#define F_HDCP_CTRL_IL_MODE_RD(x) (((x) & (((1 << 1) - 1) << 13)) >> 13)
+
+/* register HDTX_HPD */
+#define HDTX_HPD 8
+#define F_HPD_VALID_WIDTH(x) (((x) & ((1 << 12) - 1)) << 0)
+#define F_HPD_VALID_WIDTH_RD(x) (((x) & (((1 << 12) - 1) << 0)) >> 0)
+#define F_HPD_GLITCH_WIDTH(x) (((x) & ((1 << 8) - 1)) << 12)
+#define F_HPD_GLITCH_WIDTH_RD(x) (((x) & (((1 << 8) - 1) << 12)) >> 12)
+
+/* register HDTX_CLOCK_REG_0 */
+#define HDTX_CLOCK_REG_0 9
+#define F_DATA_REGISTER_VAL_0(x) (((x) & ((1 << 20) - 1)) << 0)
+#define F_DATA_REGISTER_VAL_0_RD(x) (((x) & (((1 << 20) - 1) << 0)) >> 0)
+
+/* register HDTX_CLOCK_REG_1 */
+#define HDTX_CLOCK_REG_1 10
+#define F_DATA_REGISTER_VAL_1(x) (((x) & ((1 << 20) - 1)) << 0)
+#define F_DATA_REGISTER_VAL_1_RD(x) (((x) & (((1 << 20) - 1) << 0)) >> 0)
+
+/* register HPD_PLUG_IN */
+#define HPD_PLUG_IN 11
+#define F_FILTER_HPD(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_FILTER_HPD_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+/* register HDCP_IN */
+#define HDCP_IN 12
+#define F_HDCP_ESS_STATE(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_HDCP_ESS_STATE_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_HDCP_DOUBLE_FIFO_WFULL(x) (((x) & ((1 << 1) - 1)) << 4)
+#define F_HDCP_DOUBLE_FIFO_WFULL_RD(x) (((x) & (((1 << 1) - 1) << 4)) >> 4)
+#define F_HDCP_DOUBLE_FIFO_REMPTY(x) (((x) & ((1 << 1) - 1)) << 5)
+#define F_HDCP_DOUBLE_FIFO_REMPTY_RD(x) (((x) & (((1 << 1) - 1) << 5)) >> 5)
+#define F_HDCP_DOUBLE_FIFO_OVERRUN(x) (((x) & ((1 << 1) - 1)) << 6)
+#define F_HDCP_DOUBLE_FIFO_OVERRUN_RD(x) (((x) & (((1 << 1) - 1) << 6)) >> 6)
+#define F_HDCP_DOUBLE_FIFO_UNDERRUN(x) (((x) & ((1 << 1) - 1)) << 7)
+#define F_HDCP_DOUBLE_FIFO_UNDERRUN_RD(x) (((x) & (((1 << 1) - 1) << 7)) >> 7)
+#define F_HDCP_DELAY_FIFO_EMPTY(x) (((x) & ((1 << 1) - 1)) << 8)
+#define F_HDCP_DELAY_FIFO_EMPTY_RD(x) (((x) & (((1 << 1) - 1) << 8)) >> 8)
+#define F_HDCP_DELAY_FIFO_FULL(x) (((x) & ((1 << 1) - 1)) << 9)
+#define F_HDCP_DELAY_FIFO_FULL_RD(x) (((x) & (((1 << 1) - 1) << 9)) >> 9)
+#define F_HDCP_SINGLE_FIFO_WFULL(x) (((x) & ((1 << 2) - 1)) << 10)
+#define F_HDCP_SINGLE_FIFO_WFULL_RD(x) (((x) & (((1 << 2) - 1) << 10)) >> 10)
+#define F_HDCP_SINGLE_FIFO_REMPTY(x) (((x) & ((1 << 2) - 1)) << 12)
+#define F_HDCP_SINGLE_FIFO_REMPTY_RD(x) (((x) & (((1 << 2) - 1) << 12)) >> 12)
+#define F_HDCP_SINGLE_FIFO_OVERRUN(x) (((x) & ((1 << 2) - 1)) << 14)
+#define F_HDCP_SINGLE_FIFO_OVERRUN_RD(x) (((x) & (((1 << 2) - 1) << 14)) >> 14)
+#define F_HDCP_SINGLE_FIFO_UNDERRUN(x) (((x) & ((1 << 2) - 1)) << 16)
+#define F_HDCP_SINGLE_FIFO_UNDERRUN_RD(x) (((x) & (((1 << 2) - 1) << 16)) >> 16)
+
+/* register GCP_FORCE_COLOR_DEPTH_CODING */
+#define GCP_FORCE_COLOR_DEPTH_CODING 13
+#define F_COLOR_DEPTH_VAL(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_COLOR_DEPTH_VAL_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_COLOR_DEPTH_FORCE(x) (((x) & ((1 << 1) - 1)) << 4)
+#define F_COLOR_DEPTH_FORCE_RD(x) (((x) & (((1 << 1) - 1) << 4)) >> 4)
+#define F_DEFAULT_PHASE_VAL(x) (((x) & ((1 << 1) - 1)) << 5)
+#define F_DEFAULT_PHASE_VAL_RD(x) (((x) & (((1 << 1) - 1) << 5)) >> 5)
+
+/* register SSCP_POSITIONING */
+#define SSCP_POSITIONING 14
+#define F_SSCP_ROW_VAL(x) (((x) & ((1 << 16) - 1)) << 0)
+#define F_SSCP_ROW_VAL_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+#define F_SSCP_COL_VAL(x) (((x) & ((1 << 16) - 1)) << 16)
+#define F_SSCP_COL_VAL_RD(x) (((x) & (((1 << 16) - 1) << 16)) >> 16)
+
+/* register HDCP_WIN_OF_OPP_POSITION */
+#define HDCP_WIN_OF_OPP_POSITION 15
+#define F_HDCP_WIN_OF_OPP_START(x) (((x) & ((1 << 10) - 1)) << 0)
+#define F_HDCP_WIN_OF_OPP_START_RD(x) (((x) & (((1 << 10) - 1) << 0)) >> 0)
+#define F_HDCP_WIN_OF_OPP_SIZE(x) (((x) & ((1 << 6) - 1)) << 10)
+#define F_HDCP_WIN_OF_OPP_SIZE_RD(x) (((x) & (((1 << 6) - 1) << 10)) >> 10)
+
+#endif //MHL_HDTX_TOP
diff --git a/drivers/mxc/hdp/opcodes.h b/drivers/mxc/hdp/opcodes.h
new file mode 100644
index 000000000000..8980b76d946b
--- /dev/null
+++ b/drivers/mxc/hdp/opcodes.h
@@ -0,0 +1,86 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * This file was auto-generated. Do not edit it manually.
+ *
+ ******************************************************************************
+ *
+ * opcodes.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef OPCODES_H_
+#define OPCODES_H_
+
+#define DP_TX_MAIL_HANDLER_H
+#define DP_TX_MAIL_HANDLER_REQUEST_BUFFER_LEN 256
+#define DPTX_SET_POWER_MNG              0x00
+#define DPTX_SET_HOST_CAPABILITIES      0x01
+#define DPTX_GET_EDID                   0x02
+#define DPTX_READ_DPCD                  0x03
+#define DPTX_WRITE_DPCD                 0x04
+#define DPTX_ENABLE_EVENT               0x05
+#define DPTX_WRITE_REGISTER             0x06
+#define DPTX_READ_REGISTER              0x07
+#define DPTX_WRITE_FIELD                0x08
+#define DPTX_TRAINING_CONTROL           0x09
+#define DPTX_READ_EVENT                 0x0A
+#define DPTX_READ_LINK_STAT                0x0B
+#define DPTX_SET_VIDEO                    0x0C
+#define DPTX_SET_AUDIO                    0x0D
+#define DPTX_GET_LAST_AUX_STAUS            0x0E
+#define DPTX_SET_LINK_BREAK_POINT        0x0F
+#define DPTX_FORCE_LANES                0x10
+#define DPTX_HPD_STATE                             0x11
+#define DPTX_EDP_RATE_TRAINING		0x12
+#define DPTX_DBG_SET                               0xF0
+#define DP_TX_OPCODE_READ_I2C_REQUEST              0xA5
+#define DP_TX_OPCODE_WRITE_I2C_REQUEST             0xA6
+#define DP_TX_OPCODE_MESSAGE_FILTER                0xA7
+#define DPTX_EDID_RESP                             0x02
+#define DPTX_DPCD_READ_RESP                        0x03
+#define DPTX_DPCD_WRITE_RESP                       0x04
+#define DPTX_READ_EVENT_RESP                       0x0A
+#define DPTX_READ_REGISTER_RESP                    0x07
+#define DP_TX_OPCODE_MESSAGE                       0x10
+#define DP_TX_OPCODE_READ_I2C_RESPONSE             0x50
+#define DP_TX_OPCODE_WRITE_I2C_RESPONSE            0x60
+#define DP_TX_OPCODE_LOOPBACK_TEST                 0xFE
+#define DP_TX_OPCODE_BIT_TEST                      0xFF
+#define DP_TX_EVENT_ENABLE_HPD_BIT                 0x00
+#define DP_TX_EVENT_ENABLE_TRAINING_BIT            0x01
+#define DP_TX_EVENT_CODE_HPD_HIGH                  0x01
+#define DP_TX_EVENT_CODE_HPD_LOW                   0x02
+#define DP_TX_EVENT_CODE_HPD_PULSE                 0x04
+#define DP_TX_EVENT_CODE_HPD_STATE_HIGH            0x08
+#define DP_TX_EVENT_CODE_HPD_STATE_LOW             0x00
+#define DP_TX_EVENT_CODE_TRAINING_FULL_STARTED     0x01
+#define DP_TX_EVENT_CODE_TRAINING_FAST_STARTED     0x02
+#define DP_TX_EVENT_CODE_TRAINING_FINISHED_CR      0x04
+#define DP_TX_EVENT_CODE_TRAINING_FINISHED_EQ      0x08
+#define DP_TX_EVENT_CODE_TRAINING_FINISHED_FAST    0x10
+#define DP_TX_EVENT_CODE_TRAINING_FAILED_CR        0x20
+#define DP_TX_EVENT_CODE_TRAINING_FAILED_EQ        0x40
+#define DP_TX_EVENT_CODE_TRAINING_FAILED_FAST      0x80
+#define MB_MODULE_ID_DP_TX                         0x01
+#define MB_MODULE_ID_DP_RX                         0x02
+#define MB_MODULE_ID_HDMI_TX                       0x03
+#define MB_MODULE_ID_HDMI_RX                       0x04
+#define MB_MODULE_ID_MHL_TX                        0x05
+#define MB_MODULE_ID_MHL_RX                        0x06
+#define MB_MODULE_ID_HDCP_TX                       0x07
+#define MB_MODULE_ID_HDCP_RX                       0x08
+#define MB_MODULE_ID_HDCP_GENERAL                  0x09
+#define MB_MODULE_ID_GENERAL                       0x0A
+#define MB_MODULE_ID                               1
+
+#endif
diff --git a/drivers/mxc/hdp/sink_aif_encoder.h b/drivers/mxc/hdp/sink_aif_encoder.h
new file mode 100644
index 000000000000..c75a1033ebd3
--- /dev/null
+++ b/drivers/mxc/hdp/sink_aif_encoder.h
@@ -0,0 +1,367 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright 2018 NXP
+ *
+ ******************************************************************************
+ *
+ * This file was auto-generated. Do not edit it manually.
+ *
+ ******************************************************************************
+ *
+ * sink_aif_encoder.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef SINK_AIF_ENCODER_H_
+#define SINK_AIF_ENCODER_H_
+
+/* register AUDIO_SINK_CNTL */
+#define AUDIO_SINK_CNTL 0
+#define F_SINK_SW_RST(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SINK_SW_RST_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_I2S_ENC_START(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_I2S_ENC_START_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+
+/* register AUDIO_SINK_STTS */
+#define AUDIO_SINK_STTS 1
+#define F_CH_INDX_ERR(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_CH_INDX_ERR_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+/* register AUDIO_SINK_CNFG */
+#define AUDIO_SINK_CNFG 2
+#define F_ENC_LOW_INDEX_MSB(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_ENC_LOW_INDEX_MSB_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_SINK_AUDIO_CH_NUM(x) (((x) & ((1 << 5) - 1)) << 1)
+#define F_SINK_AUDIO_CH_NUM_RD(x) (((x) & (((1 << 5) - 1) << 1)) >> 1)
+#define F_ENC_SAMPLE_JUST(x) (((x) & ((1 << 2) - 1)) << 6)
+#define F_ENC_SAMPLE_JUST_RD(x) (((x) & (((1 << 2) - 1) << 6)) >> 6)
+#define F_ENC_SMPL_WIDTH(x) (((x) & ((1 << 2) - 1)) << 8)
+#define F_ENC_SMPL_WIDTH_RD(x) (((x) & (((1 << 2) - 1) << 8)) >> 8)
+#define F_I2S_ENC_WL_SIZE(x) (((x) & ((1 << 2) - 1)) << 10)
+#define F_I2S_ENC_WL_SIZE_RD(x) (((x) & (((1 << 2) - 1) << 10)) >> 10)
+#define F_CNTL_SMPL_ONLY_EN(x) (((x) & ((1 << 1) - 1)) << 12)
+#define F_CNTL_SMPL_ONLY_EN_RD(x) (((x) & (((1 << 1) - 1) << 12)) >> 12)
+#define F_SINK_AIF_TYPE_SMPL(x) (((x) & ((1 << 4) - 1)) << 13)
+#define F_SINK_AIF_TYPE_SMPL_RD(x) (((x) & (((1 << 4) - 1) << 13)) >> 13)
+#define F_CNTL_TYPE_OVRD(x) (((x) & ((1 << 4) - 1)) << 17)
+#define F_CNTL_TYPE_OVRD_RD(x) (((x) & (((1 << 4) - 1) << 17)) >> 17)
+#define F_CNTL_TYPE_OVRD_EN(x) (((x) & ((1 << 1) - 1)) << 21)
+#define F_CNTL_TYPE_OVRD_EN_RD(x) (((x) & (((1 << 1) - 1) << 21)) >> 21)
+#define F_I2S_ENC_PORT_EN(x) (((x) & ((1 << 4) - 1)) << 22)
+#define F_I2S_ENC_PORT_EN_RD(x) (((x) & (((1 << 4) - 1) << 22)) >> 22)
+#define F_WS_POLARITY(x) (((x) & ((1 << 1) - 1)) << 26)
+#define F_WS_POLARITY_RD(x) (((x) & (((1 << 1) - 1) << 26)) >> 26)
+
+/* register FIFO_CNTL_ADDR */
+#define FIFO_CNTL_ADDR 3
+#define F_CFG_FIFO_SW_RST(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_CFG_FIFO_SW_RST_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_CFG_INDEX_SYNC_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_CFG_INDEX_SYNC_EN_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_CFG_FIFO_DIR(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_CFG_FIFO_DIR_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+#define F_CFG_DIS_PORT3(x) (((x) & ((1 << 1) - 1)) << 3)
+#define F_CFG_DIS_PORT3_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+
+/* register FIFO_STTS_ADDR */
+#define FIFO_STTS_ADDR 4
+#define F_ST_WFULL_REG(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_ST_WFULL_REG_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_ST_REMPTY_REG(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_ST_REMPTY_REG_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_ST_OVERRUN_REG(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_ST_OVERRUN_REG_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+#define F_ST_UNDERRUN_REG(x) (((x) & ((1 << 1) - 1)) << 3)
+#define F_ST_UNDERRUN_REG_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+
+/* register SINK_COM_CH_STTS_BITS */
+#define SINK_COM_CH_STTS_BITS 5
+#define F_BYTE0(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_BYTE0_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+#define F_CATEGORY_CODE(x) (((x) & ((1 << 8) - 1)) << 8)
+#define F_CATEGORY_CODE_RD(x) (((x) & (((1 << 8) - 1) << 8)) >> 8)
+#define F_SAMPLING_FREQ(x) (((x) & ((1 << 4) - 1)) << 16)
+#define F_SAMPLING_FREQ_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+#define F_CLOCK_ACCURACY(x) (((x) & ((1 << 4) - 1)) << 20)
+#define F_CLOCK_ACCURACY_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+#define F_ORIGINAL_SAMP_FREQ(x) (((x) & ((1 << 4) - 1)) << 24)
+#define F_ORIGINAL_SAMP_FREQ_RD(x) (((x) & (((1 << 4) - 1) << 24)) >> 24)
+
+/* register SINK_STTS_BIT_CH01 */
+#define SINK_STTS_BIT_CH01 6
+#define F_SOURCE_NUM_CH0(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_SOURCE_NUM_CH0_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_CHANNEL_NUM_CH0(x) (((x) & ((1 << 4) - 1)) << 4)
+#define F_CHANNEL_NUM_CH0_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+#define F_WORD_LENGTH_CH0(x) (((x) & ((1 << 4) - 1)) << 8)
+#define F_WORD_LENGTH_CH0_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+#define F_SOURCE_NUM_CH1(x) (((x) & ((1 << 4) - 1)) << 12)
+#define F_SOURCE_NUM_CH1_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+#define F_CHANNEL_NUM_CH1(x) (((x) & ((1 << 4) - 1)) << 16)
+#define F_CHANNEL_NUM_CH1_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+#define F_WORD_LENGTH_CH1(x) (((x) & ((1 << 4) - 1)) << 20)
+#define F_WORD_LENGTH_CH1_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+
+/* register SINK_STTS_BIT_CH23 */
+#define SINK_STTS_BIT_CH23 7
+#define F_SOURCE_NUM_CH2(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_SOURCE_NUM_CH2_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_CHANNEL_NUM_CH2(x) (((x) & ((1 << 4) - 1)) << 4)
+#define F_CHANNEL_NUM_CH2_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+#define F_WORD_LENGTH_CH2(x) (((x) & ((1 << 4) - 1)) << 8)
+#define F_WORD_LENGTH_CH2_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+#define F_SOURCE_NUM_CH3(x) (((x) & ((1 << 4) - 1)) << 12)
+#define F_SOURCE_NUM_CH3_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+#define F_CHANNEL_NUM_CH3(x) (((x) & ((1 << 4) - 1)) << 16)
+#define F_CHANNEL_NUM_CH3_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+#define F_WORD_LENGTH_CH3(x) (((x) & ((1 << 4) - 1)) << 20)
+#define F_WORD_LENGTH_CH3_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+
+/* register SINK_STTS_BIT_CH45 */
+#define SINK_STTS_BIT_CH45 8
+#define F_SOURCE_NUM_CH4(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_SOURCE_NUM_CH4_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_CHANNEL_NUM_CH4(x) (((x) & ((1 << 4) - 1)) << 4)
+#define F_CHANNEL_NUM_CH4_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+#define F_WORD_LENGTH_CH4(x) (((x) & ((1 << 4) - 1)) << 8)
+#define F_WORD_LENGTH_CH4_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+#define F_SOURCE_NUM_CH5(x) (((x) & ((1 << 4) - 1)) << 12)
+#define F_SOURCE_NUM_CH5_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+#define F_CHANNEL_NUM_CH5(x) (((x) & ((1 << 4) - 1)) << 16)
+#define F_CHANNEL_NUM_CH5_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+#define F_WORD_LENGTH_CH5(x) (((x) & ((1 << 4) - 1)) << 20)
+#define F_WORD_LENGTH_CH5_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+
+/* register SINK_STTS_BIT_CH67 */
+#define SINK_STTS_BIT_CH67 9
+#define F_SOURCE_NUM_CH6(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_SOURCE_NUM_CH6_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_CHANNEL_NUM_CH6(x) (((x) & ((1 << 4) - 1)) << 4)
+#define F_CHANNEL_NUM_CH6_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+#define F_WORD_LENGTH_CH6(x) (((x) & ((1 << 4) - 1)) << 8)
+#define F_WORD_LENGTH_CH6_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+#define F_SOURCE_NUM_CH7(x) (((x) & ((1 << 4) - 1)) << 12)
+#define F_SOURCE_NUM_CH7_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+#define F_CHANNEL_NUM_CH7(x) (((x) & ((1 << 4) - 1)) << 16)
+#define F_CHANNEL_NUM_CH7_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+#define F_WORD_LENGTH_CH7(x) (((x) & ((1 << 4) - 1)) << 20)
+#define F_WORD_LENGTH_CH7_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+
+/* register SINK_STTS_BIT_CH89 */
+#define SINK_STTS_BIT_CH89 10
+#define F_SOURCE_NUM_CH8(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_SOURCE_NUM_CH8_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_CHANNEL_NUM_CH8(x) (((x) & ((1 << 4) - 1)) << 4)
+#define F_CHANNEL_NUM_CH8_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+#define F_WORD_LENGTH_CH8(x) (((x) & ((1 << 4) - 1)) << 8)
+#define F_WORD_LENGTH_CH8_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+#define F_SOURCE_NUM_CH9(x) (((x) & ((1 << 4) - 1)) << 12)
+#define F_SOURCE_NUM_CH9_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+#define F_CHANNEL_NUM_CH9(x) (((x) & ((1 << 4) - 1)) << 16)
+#define F_CHANNEL_NUM_CH9_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+#define F_WORD_LENGTH_CH9(x) (((x) & ((1 << 4) - 1)) << 20)
+#define F_WORD_LENGTH_CH9_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+
+/* register SINK_STTS_BIT_CH1011 */
+#define SINK_STTS_BIT_CH1011 11
+#define F_SOURCE_NUM_CH10(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_SOURCE_NUM_CH10_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_CHANNEL_NUM_CH10(x) (((x) & ((1 << 4) - 1)) << 4)
+#define F_CHANNEL_NUM_CH10_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+#define F_WORD_LENGTH_CH10(x) (((x) & ((1 << 4) - 1)) << 8)
+#define F_WORD_LENGTH_CH10_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+#define F_SOURCE_NUM_CH11(x) (((x) & ((1 << 4) - 1)) << 12)
+#define F_SOURCE_NUM_CH11_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+#define F_CHANNEL_NUM_CH11(x) (((x) & ((1 << 4) - 1)) << 16)
+#define F_CHANNEL_NUM_CH11_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+#define F_WORD_LENGTH_CH11(x) (((x) & ((1 << 4) - 1)) << 20)
+#define F_WORD_LENGTH_CH11_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+
+/* register SINK_STTS_BIT_CH1213 */
+#define SINK_STTS_BIT_CH1213 12
+#define F_SOURCE_NUM_CH12(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_SOURCE_NUM_CH12_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_CHANNEL_NUM_CH12(x) (((x) & ((1 << 4) - 1)) << 4)
+#define F_CHANNEL_NUM_CH12_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+#define F_WORD_LENGTH_CH12(x) (((x) & ((1 << 4) - 1)) << 8)
+#define F_WORD_LENGTH_CH12_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+#define F_SOURCE_NUM_CH13(x) (((x) & ((1 << 4) - 1)) << 12)
+#define F_SOURCE_NUM_CH13_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+#define F_CHANNEL_NUM_CH13(x) (((x) & ((1 << 4) - 1)) << 16)
+#define F_CHANNEL_NUM_CH13_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+#define F_WORD_LENGTH_CH13(x) (((x) & ((1 << 4) - 1)) << 20)
+#define F_WORD_LENGTH_CH13_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+
+/* register SINK_STTS_BIT_CH1415 */
+#define SINK_STTS_BIT_CH1415 13
+#define F_SOURCE_NUM_CH14(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_SOURCE_NUM_CH14_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_CHANNEL_NUM_CH14(x) (((x) & ((1 << 4) - 1)) << 4)
+#define F_CHANNEL_NUM_CH14_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+#define F_WORD_LENGTH_CH14(x) (((x) & ((1 << 4) - 1)) << 8)
+#define F_WORD_LENGTH_CH14_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+#define F_SOURCE_NUM_CH15(x) (((x) & ((1 << 4) - 1)) << 12)
+#define F_SOURCE_NUM_CH15_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+#define F_CHANNEL_NUM_CH15(x) (((x) & ((1 << 4) - 1)) << 16)
+#define F_CHANNEL_NUM_CH15_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+#define F_WORD_LENGTH_CH15(x) (((x) & ((1 << 4) - 1)) << 20)
+#define F_WORD_LENGTH_CH15_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+
+/* register SINK_STTS_BIT_CH1617 */
+#define SINK_STTS_BIT_CH1617 14
+#define F_SOURCE_NUM_CH16(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_SOURCE_NUM_CH16_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_CHANNEL_NUM_CH16(x) (((x) & ((1 << 4) - 1)) << 4)
+#define F_CHANNEL_NUM_CH16_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+#define F_WORD_LENGTH_CH16(x) (((x) & ((1 << 4) - 1)) << 8)
+#define F_WORD_LENGTH_CH16_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+#define F_SOURCE_NUM_CH17(x) (((x) & ((1 << 4) - 1)) << 12)
+#define F_SOURCE_NUM_CH17_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+#define F_CHANNEL_NUM_CH17(x) (((x) & ((1 << 4) - 1)) << 16)
+#define F_CHANNEL_NUM_CH17_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+#define F_WORD_LENGTH_CH17(x) (((x) & ((1 << 4) - 1)) << 20)
+#define F_WORD_LENGTH_CH17_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+
+/* register SINK_STTS_BIT_CH1819 */
+#define SINK_STTS_BIT_CH1819 15
+#define F_SOURCE_NUM_CH18(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_SOURCE_NUM_CH18_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_CHANNEL_NUM_CH18(x) (((x) & ((1 << 4) - 1)) << 4)
+#define F_CHANNEL_NUM_CH18_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+#define F_WORD_LENGTH_CH18(x) (((x) & ((1 << 4) - 1)) << 8)
+#define F_WORD_LENGTH_CH18_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+#define F_SOURCE_NUM_CH19(x) (((x) & ((1 << 4) - 1)) << 12)
+#define F_SOURCE_NUM_CH19_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+#define F_CHANNEL_NUM_CH19(x) (((x) & ((1 << 4) - 1)) << 16)
+#define F_CHANNEL_NUM_CH19_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+#define F_WORD_LENGTH_CH19(x) (((x) & ((1 << 4) - 1)) << 20)
+#define F_WORD_LENGTH_CH19_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+
+/* register SINK_STTS_BIT_CH2021 */
+#define SINK_STTS_BIT_CH2021 16
+#define F_SOURCE_NUM_CH20(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_SOURCE_NUM_CH20_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_CHANNEL_NUM_CH20(x) (((x) & ((1 << 4) - 1)) << 4)
+#define F_CHANNEL_NUM_CH20_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+#define F_WORD_LENGTH_CH20(x) (((x) & ((1 << 4) - 1)) << 8)
+#define F_WORD_LENGTH_CH20_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+#define F_SOURCE_NUM_CH21(x) (((x) & ((1 << 4) - 1)) << 12)
+#define F_SOURCE_NUM_CH21_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+#define F_CHANNEL_NUM_CH21(x) (((x) & ((1 << 4) - 1)) << 16)
+#define F_CHANNEL_NUM_CH21_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+#define F_WORD_LENGTH_CH21(x) (((x) & ((1 << 4) - 1)) << 20)
+#define F_WORD_LENGTH_CH21_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+
+/* register SINK_STTS_BIT_CH2223 */
+#define SINK_STTS_BIT_CH2223 17
+#define F_SOURCE_NUM_CH22(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_SOURCE_NUM_CH22_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_CHANNEL_NUM_CH22(x) (((x) & ((1 << 4) - 1)) << 4)
+#define F_CHANNEL_NUM_CH22_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+#define F_WORD_LENGTH_CH22(x) (((x) & ((1 << 4) - 1)) << 8)
+#define F_WORD_LENGTH_CH22_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+#define F_SOURCE_NUM_CH23(x) (((x) & ((1 << 4) - 1)) << 12)
+#define F_SOURCE_NUM_CH23_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+#define F_CHANNEL_NUM_CH23(x) (((x) & ((1 << 4) - 1)) << 16)
+#define F_CHANNEL_NUM_CH23_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+#define F_WORD_LENGTH_CH23(x) (((x) & ((1 << 4) - 1)) << 20)
+#define F_WORD_LENGTH_CH23_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+
+/* register SINK_STTS_BIT_CH2425 */
+#define SINK_STTS_BIT_CH2425 18
+#define F_SOURCE_NUM_CH24(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_SOURCE_NUM_CH24_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_CHANNEL_NUM_CH24(x) (((x) & ((1 << 4) - 1)) << 4)
+#define F_CHANNEL_NUM_CH24_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+#define F_WORD_LENGTH_CH24(x) (((x) & ((1 << 4) - 1)) << 8)
+#define F_WORD_LENGTH_CH24_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+#define F_SOURCE_NUM_CH25(x) (((x) & ((1 << 4) - 1)) << 12)
+#define F_SOURCE_NUM_CH25_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+#define F_CHANNEL_NUM_CH25(x) (((x) & ((1 << 4) - 1)) << 16)
+#define F_CHANNEL_NUM_CH25_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+#define F_WORD_LENGTH_CH25(x) (((x) & ((1 << 4) - 1)) << 20)
+#define F_WORD_LENGTH_CH25_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+
+/* register SINK_STTS_BIT_CH2627 */
+#define SINK_STTS_BIT_CH2627 19
+#define F_SOURCE_NUM_CH26(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_SOURCE_NUM_CH26_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_CHANNEL_NUM_CH26(x) (((x) & ((1 << 4) - 1)) << 4)
+#define F_CHANNEL_NUM_CH26_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+#define F_WORD_LENGTH_CH26(x) (((x) & ((1 << 4) - 1)) << 8)
+#define F_WORD_LENGTH_CH26_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+#define F_SOURCE_NUM_CH27(x) (((x) & ((1 << 4) - 1)) << 12)
+#define F_SOURCE_NUM_CH27_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+#define F_CHANNEL_NUM_CH27(x) (((x) & ((1 << 4) - 1)) << 16)
+#define F_CHANNEL_NUM_CH27_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+#define F_WORD_LENGTH_CH27(x) (((x) & ((1 << 4) - 1)) << 20)
+#define F_WORD_LENGTH_CH27_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+
+/* register SINK_STTS_BIT_CH2829 */
+#define SINK_STTS_BIT_CH2829 20
+#define F_SOURCE_NUM_CH28(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_SOURCE_NUM_CH28_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_CHANNEL_NUM_CH28(x) (((x) & ((1 << 4) - 1)) << 4)
+#define F_CHANNEL_NUM_CH28_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+#define F_WORD_LENGTH_CH28(x) (((x) & ((1 << 4) - 1)) << 8)
+#define F_WORD_LENGTH_CH28_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+#define F_SOURCE_NUM_CH29(x) (((x) & ((1 << 4) - 1)) << 12)
+#define F_SOURCE_NUM_CH29_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+#define F_CHANNEL_NUM_CH29(x) (((x) & ((1 << 4) - 1)) << 16)
+#define F_CHANNEL_NUM_CH29_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+#define F_WORD_LENGTH_CH29(x) (((x) & ((1 << 4) - 1)) << 20)
+#define F_WORD_LENGTH_CH29_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+
+/* register SINK_STTS_BIT_CH3031 */
+#define SINK_STTS_BIT_CH3031 21
+#define F_SOURCE_NUM_CH30(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_SOURCE_NUM_CH30_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_CHANNEL_NUM_CH30(x) (((x) & ((1 << 4) - 1)) << 4)
+#define F_CHANNEL_NUM_CH30_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+#define F_WORD_LENGTH_CH30(x) (((x) & ((1 << 4) - 1)) << 8)
+#define F_WORD_LENGTH_CH30_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+#define F_SOURCE_NUM_CH31(x) (((x) & ((1 << 4) - 1)) << 12)
+#define F_SOURCE_NUM_CH31_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+#define F_CHANNEL_NUM_CH31(x) (((x) & ((1 << 4) - 1)) << 16)
+#define F_CHANNEL_NUM_CH31_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+#define F_WORD_LENGTH_CH31(x) (((x) & ((1 << 4) - 1)) << 20)
+#define F_WORD_LENGTH_CH31_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+
+#endif /* SINK_AIF_ENCODER */
+
diff --git a/drivers/mxc/hdp/sink_car.h b/drivers/mxc/hdp/sink_car.h
new file mode 100644
index 000000000000..a38001c15b02
--- /dev/null
+++ b/drivers/mxc/hdp/sink_car.h
@@ -0,0 +1,168 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright 2018 NXP
+ *
+ ******************************************************************************
+ *
+ * This file was auto-generated. Do not edit it manually.
+ *
+ ******************************************************************************
+ *
+ * sink_car.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef SINK_CAR_H_
+#define SINK_CAR_H_
+
+/* register SINK_MHL_HD_CAR */
+#define SINK_MHL_HD_CAR 0
+#define F_SINK_MHL_HD_VIF_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SINK_MHL_HD_VIF_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_SINK_MHL_HD_VIF_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_SINK_MHL_HD_VIF_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_SINK_MHL_HD_SYS_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_SINK_MHL_HD_SYS_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+#define F_SINK_MHL_HD_SYS_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 3)
+#define F_SINK_MHL_HD_SYS_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+#define F_SINK_MHL_HD_PHY_DATA_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 4)
+#define F_SINK_MHL_HD_PHY_DATA_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 4)) >> 4)
+#define F_SINK_MHL_HD_PHY_DATA_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 5)
+#define F_SINK_MHL_HD_PHY_DATA_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 5)) >> 5)
+
+/* register SINK_CEC_CAR */
+#define SINK_CEC_CAR 1
+#define F_SINK_CEC_SYS_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SINK_CEC_SYS_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_SINK_CEC_SYS_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_SINK_CEC_SYS_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+
+/* register SINK_SCDC_CAR */
+#define SINK_SCDC_CAR 2
+#define F_SINK_SCDC_SYS_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SINK_SCDC_SYS_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_SINK_SCDC_SYS_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_SINK_SCDC_SYS_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_SINK_SCDC_RSTN_EN(x) (((x) & ((1 << 8) - 1)) << 8)
+#define F_SINK_SCDC_RSTN_EN_RD(x) (((x) & (((1 << 8) - 1) << 8)) >> 8)
+#define F_SINK_SCDC_CLK_EN(x) (((x) & ((1 << 8) - 1)) << 16)
+#define F_SINK_SCDC_CLK_EN_RD(x) (((x) & (((1 << 8) - 1) << 16)) >> 16)
+
+/* register SINK_PKT_CAR */
+#define SINK_PKT_CAR 3
+#define F_SINK_PKT_SYS_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SINK_PKT_SYS_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_SINK_PKT_SYS_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_SINK_PKT_SYS_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_SINK_PKT_DATA_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_SINK_PKT_DATA_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+#define F_SINK_PKT_DATA_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 3)
+#define F_SINK_PKT_DATA_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+
+/* register SINK_AIF_CAR */
+#define SINK_AIF_CAR 4
+#define F_SINK_AIF_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SINK_AIF_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_SINK_AIF_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_SINK_AIF_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_SINK_AIF_SYS_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_SINK_AIF_SYS_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+#define F_SINK_AIF_SYS_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 3)
+#define F_SINK_AIF_SYS_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+#define F_SINK_ACR_CHAR_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 4)
+#define F_SINK_ACR_CHAR_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 4)) >> 4)
+#define F_SINK_ACR_CHAR_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 5)
+#define F_SINK_ACR_CHAR_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 5)) >> 5)
+
+/* register SINK_CIPHER_CAR */
+#define SINK_CIPHER_CAR 5
+#define F_SINK_CIPHER_CHAR_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SINK_CIPHER_CHAR_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_SINK_CIPHER_CHAR_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_SINK_CIPHER_CHAR_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_SINK_CIPHER_SYS_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_SINK_CIPHER_SYS_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+#define F_SINK_CIPHER_SYS_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 3)
+#define F_SINK_CIPHER_SYS_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+
+/* register SINK_CRYPTO_CAR */
+#define SINK_CRYPTO_CAR 6
+#define F_SINK_CRYPTO_SYS_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SINK_CRYPTO_SYS_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_SINK_CRYPTO_SYS_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_SINK_CRYPTO_SYS_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+
+/* register SINK_VIF_CAR */
+#define SINK_VIF_CAR 7
+#define F_SINK_VIF_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SINK_VIF_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_SINK_VIF_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_SINK_VIF_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+
+/* register SINK_AUDIO_CAR */
+#define SINK_AUDIO_CAR 8
+#define F_SINK_ACR_REF_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SINK_ACR_REF_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_SINK_ACR_REF_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_SINK_ACR_REF_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_SINK_SPDIF_MCLK_EN(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_SINK_SPDIF_MCLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+#define F_SINK_SPDIF_MCLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 3)
+#define F_SINK_SPDIF_MCLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+#define F_SINK_I2S_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 4)
+#define F_SINK_I2S_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 4)) >> 4)
+#define F_SINK_I2S_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 5)
+#define F_SINK_I2S_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 5)) >> 5)
+
+/* register SINK_PHY_CAR */
+#define SINK_PHY_CAR 9
+#define F_SINK_XT_PCLK_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SINK_XT_PCLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_SINK_XT_PRESETN_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_SINK_XT_PRESETN_EN_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+
+/* register SINK_DEBUG_CAR */
+#define SINK_DEBUG_CAR 10
+#define F_SINK_CLOCK_METER_SYS_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SINK_CLOCK_METER_SYS_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_SINK_CLOCK_METER_SYS_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_SINK_CLOCK_METER_SYS_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+
+#endif /* SINK_CAR */
+
diff --git a/drivers/mxc/hdp/sink_clk_meters.h b/drivers/mxc/hdp/sink_clk_meters.h
new file mode 100644
index 000000000000..c238b9785583
--- /dev/null
+++ b/drivers/mxc/hdp/sink_clk_meters.h
@@ -0,0 +1,241 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright 2018 NXP
+ *
+ ******************************************************************************
+ *
+ * This file was auto-generated. Do not edit it manually.
+ *
+ ******************************************************************************
+ *
+ * sink_clk_meters.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef SINK_CLK_METERS_H_
+#define SINK_CLK_METERS_H_
+
+/* register CLK_METER_REF_CFG */
+#define CLK_METER_REF_CFG 0
+#define F_REF_CYCLES_SINK_REF_CLK(x) (((x) & ((1 << 24) - 1)) << 0)
+#define F_REF_CYCLES_SINK_REF_CLK_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+#define F_MEAS_TOLERANCE_SINK_REF_CLK(x) (((x) & ((1 << 4) - 1)) << 24)
+#define F_MEAS_TOLERANCE_SINK_REF_CLK_RD(x) (((x) & (((1 << 4) - 1) << 24)) >> 24)
+
+/* register CLK_METER_PHY_CHAR_CFG */
+#define CLK_METER_PHY_CHAR_CFG 1
+#define F_REF_CYCLES_SINK_PHY_CHAR_CLK(x) (((x) & ((1 << 24) - 1)) << 0)
+#define F_REF_CYCLES_SINK_PHY_CHAR_CLK_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+#define F_MEAS_TOLERANCE_SINK_PHY_CHAR_CLK(x) (((x) & ((1 << 4) - 1)) << 24)
+#define F_MEAS_TOLERANCE_SINK_PHY_CHAR_CLK_RD(x) (((x) & (((1 << 4) - 1) << 24)) >> 24)
+
+/* register CLK_METER_PHY_DATA_CFG */
+#define CLK_METER_PHY_DATA_CFG 2
+#define F_REF_CYCLES_SINK_PHY_DATA_CLK(x) (((x) & ((1 << 24) - 1)) << 0)
+#define F_REF_CYCLES_SINK_PHY_DATA_CLK_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+#define F_MEAS_TOLERANCE_SINK_PHY_DATA_CLK(x) (((x) & ((1 << 4) - 1)) << 24)
+#define F_MEAS_TOLERANCE_SINK_PHY_DATA_CLK_RD(x) (((x) & (((1 << 4) - 1) << 24)) >> 24)
+
+/* register CLK_METER_PHY_PIXEL_CFG */
+#define CLK_METER_PHY_PIXEL_CFG 3
+#define F_REF_CYCLES_SINK_PHY_PIXEL_CLK(x) (((x) & ((1 << 24) - 1)) << 0)
+#define F_REF_CYCLES_SINK_PHY_PIXEL_CLK_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+#define F_MEAS_TOLERANCE_SINK_PHY_PIXEL_CLK(x) (((x) & ((1 << 4) - 1)) << 24)
+#define F_MEAS_TOLERANCE_SINK_PHY_PIXEL_CLK_RD(x) (((x) & (((1 << 4) - 1) << 24)) >> 24)
+
+/* register CLK_METER_SPDIF_CFG */
+#define CLK_METER_SPDIF_CFG 4
+#define F_REF_CYCLES_SINK_SPDIF_MCLK(x) (((x) & ((1 << 24) - 1)) << 0)
+#define F_REF_CYCLES_SINK_SPDIF_MCLK_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+#define F_MEAS_TOLERANCE_SINK_SPDIF_MCLK(x) (((x) & ((1 << 4) - 1)) << 24)
+#define F_MEAS_TOLERANCE_SINK_SPDIF_MCLK_RD(x) (((x) & (((1 << 4) - 1) << 24)) >> 24)
+
+/* register CLK_METER_I2S_CFG */
+#define CLK_METER_I2S_CFG 5
+#define F_REF_CYCLES_SINK_I2S_CLK(x) (((x) & ((1 << 24) - 1)) << 0)
+#define F_REF_CYCLES_SINK_I2S_CLK_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+#define F_MEAS_TOLERANCE_SINK_I2S_CLK(x) (((x) & ((1 << 4) - 1)) << 24)
+#define F_MEAS_TOLERANCE_SINK_I2S_CLK_RD(x) (((x) & (((1 << 4) - 1) << 24)) >> 24)
+
+/* register CLK_METER_PCLK_CFG */
+#define CLK_METER_PCLK_CFG 6
+#define F_REF_CYCLES_SINK_PCLK(x) (((x) & ((1 << 24) - 1)) << 0)
+#define F_REF_CYCLES_SINK_PCLK_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+#define F_MEAS_TOLERANCE_SINK_PCLK(x) (((x) & ((1 << 4) - 1)) << 24)
+#define F_MEAS_TOLERANCE_SINK_PCLK_RD(x) (((x) & (((1 << 4) - 1) << 24)) >> 24)
+
+/* register CLK_METER_SCLK_CFG */
+#define CLK_METER_SCLK_CFG 7
+#define F_REF_CYCLES_SINK_SCLK(x) (((x) & ((1 << 24) - 1)) << 0)
+#define F_REF_CYCLES_SINK_SCLK_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+#define F_MEAS_TOLERANCE_SINK_SCLK(x) (((x) & ((1 << 4) - 1)) << 24)
+#define F_MEAS_TOLERANCE_SINK_SCLK_RD(x) (((x) & (((1 << 4) - 1) << 24)) >> 24)
+
+/* register CLK_METER_CCLK_CFG */
+#define CLK_METER_CCLK_CFG 8
+#define F_REF_CYCLES_SINK_CCLK(x) (((x) & ((1 << 24) - 1)) << 0)
+#define F_REF_CYCLES_SINK_CCLK_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+#define F_MEAS_TOLERANCE_SINK_CCLK(x) (((x) & ((1 << 4) - 1)) << 24)
+#define F_MEAS_TOLERANCE_SINK_CCLK_RD(x) (((x) & (((1 << 4) - 1) << 24)) >> 24)
+
+/* register CLK_METER_TRNG_CFG */
+#define CLK_METER_TRNG_CFG 9
+#define F_REF_CYCLES_SINK_TRNG_CLK(x) (((x) & ((1 << 24) - 1)) << 0)
+#define F_REF_CYCLES_SINK_TRNG_CLK_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+#define F_MEAS_TOLERANCE_SINK_TRNG_CLK(x) (((x) & ((1 << 4) - 1)) << 24)
+#define F_MEAS_TOLERANCE_SINK_TRNG_CLK_RD(x) (((x) & (((1 << 4) - 1) << 24)) >> 24)
+
+/* register CLK_METER_REF_ST */
+#define CLK_METER_REF_ST 10
+#define F_MEAS_CYCLES_SINK_REF_CLK(x) (((x) & ((1 << 24) - 1)) << 0)
+#define F_MEAS_CYCLES_SINK_REF_CLK_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+#define F_MEAS_STABLE_SINK_REF_CLK(x) (((x) & ((1 << 1) - 1)) << 24)
+#define F_MEAS_STABLE_SINK_REF_CLK_RD(x) (((x) & (((1 << 1) - 1) << 24)) >> 24)
+
+/* register CLK_METER_PHY_CHAR_ST */
+#define CLK_METER_PHY_CHAR_ST 11
+#define F_MEAS_CYCLES_SINK_PHY_CHAR_CLK(x) (((x) & ((1 << 24) - 1)) << 0)
+#define F_MEAS_CYCLES_SINK_PHY_CHAR_CLK_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+#define F_MEAS_STABLE_SINK_PHY_CHAR_CLK(x) (((x) & ((1 << 1) - 1)) << 24)
+#define F_MEAS_STABLE_SINK_PHY_CHAR_CLK_RD(x) (((x) & (((1 << 1) - 1) << 24)) >> 24)
+
+/* register CLK_METER_PHY_DATA_ST */
+#define CLK_METER_PHY_DATA_ST 12
+#define F_MEAS_CYCLES_SINK_PHY_DATA_CLK(x) (((x) & ((1 << 24) - 1)) << 0)
+#define F_MEAS_CYCLES_SINK_PHY_DATA_CLK_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+#define F_MEAS_STABLE_SINK_PHY_DATA_CLK(x) (((x) & ((1 << 1) - 1)) << 24)
+#define F_MEAS_STABLE_SINK_PHY_DATA_CLK_RD(x) (((x) & (((1 << 1) - 1) << 24)) >> 24)
+
+/* register CLK_METER_PHY_PIXEL_ST */
+#define CLK_METER_PHY_PIXEL_ST 13
+#define F_MEAS_CYCLES_SINK_PHY_PIXEL_CLK(x) (((x) & ((1 << 24) - 1)) << 0)
+#define F_MEAS_CYCLES_SINK_PHY_PIXEL_CLK_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+#define F_MEAS_STABLE_SINK_PHY_PIXEL_CLK(x) (((x) & ((1 << 1) - 1)) << 24)
+#define F_MEAS_STABLE_SINK_PHY_PIXEL_CLK_RD(x) (((x) & (((1 << 1) - 1) << 24)) >> 24)
+
+/* register CLK_METER_SPDIF_ST */
+#define CLK_METER_SPDIF_ST 14
+#define F_MEAS_CYCLES_SINK_SPDIF_MCLK(x) (((x) & ((1 << 24) - 1)) << 0)
+#define F_MEAS_CYCLES_SINK_SPDIF_MCLK_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+#define F_MEAS_STABLE_SINK_SPDIF_MCLK(x) (((x) & ((1 << 1) - 1)) << 24)
+#define F_MEAS_STABLE_SINK_SPDIF_MCLK_RD(x) (((x) & (((1 << 1) - 1) << 24)) >> 24)
+
+/* register CLK_METER_I2S_ST */
+#define CLK_METER_I2S_ST 15
+#define F_MEAS_CYCLES_SINK_I2S_CLK(x) (((x) & ((1 << 24) - 1)) << 0)
+#define F_MEAS_CYCLES_SINK_I2S_CLK_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+#define F_MEAS_STABLE_SINK_I2S_CLK(x) (((x) & ((1 << 1) - 1)) << 24)
+#define F_MEAS_STABLE_SINK_I2S_CLK_RD(x) (((x) & (((1 << 1) - 1) << 24)) >> 24)
+
+/* register CLK_METER_PCLK_ST */
+#define CLK_METER_PCLK_ST 16
+#define F_MEAS_CYCLES_SINK_PCLK(x) (((x) & ((1 << 24) - 1)) << 0)
+#define F_MEAS_CYCLES_SINK_PCLK_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+#define F_MEAS_STABLE_SINK_PCLK(x) (((x) & ((1 << 1) - 1)) << 24)
+#define F_MEAS_STABLE_SINK_PCLK_RD(x) (((x) & (((1 << 1) - 1) << 24)) >> 24)
+
+/* register CLK_METER_SCLK_ST */
+#define CLK_METER_SCLK_ST 17
+#define F_MEAS_CYCLES_SINK_SCLK(x) (((x) & ((1 << 24) - 1)) << 0)
+#define F_MEAS_CYCLES_SINK_SCLK_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+#define F_MEAS_STABLE_SINK_SCLK(x) (((x) & ((1 << 1) - 1)) << 24)
+#define F_MEAS_STABLE_SINK_SCLK_RD(x) (((x) & (((1 << 1) - 1) << 24)) >> 24)
+
+/* register CLK_METER_CCLK_ST */
+#define CLK_METER_CCLK_ST 18
+#define F_MEAS_CYCLES_SINK_CCLK(x) (((x) & ((1 << 24) - 1)) << 0)
+#define F_MEAS_CYCLES_SINK_CCLK_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+#define F_MEAS_STABLE_SINK_CCLK(x) (((x) & ((1 << 1) - 1)) << 24)
+#define F_MEAS_STABLE_SINK_CCLK_RD(x) (((x) & (((1 << 1) - 1) << 24)) >> 24)
+
+/* register CLK_METER_TRNG_ST */
+#define CLK_METER_TRNG_ST 19
+#define F_MEAS_CYCLES_SINK_TRNG_CLK(x) (((x) & ((1 << 24) - 1)) << 0)
+#define F_MEAS_CYCLES_SINK_TRNG_CLK_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+#define F_MEAS_STABLE_SINK_TRNG_CLK(x) (((x) & ((1 << 1) - 1)) << 24)
+#define F_MEAS_STABLE_SINK_TRNG_CLK_RD(x) (((x) & (((1 << 1) - 1) << 24)) >> 24)
+
+/* register CLK_METER_INT_MASK */
+#define CLK_METER_INT_MASK 20
+#define F_MEAS_MASK_SINK_REF_CLK(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_MEAS_MASK_SINK_REF_CLK_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_MEAS_MASK_SINK_PHY_CHAR_CLK(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_MEAS_MASK_SINK_PHY_CHAR_CLK_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_MEAS_MASK_SINK_PHY_DATA_CLK(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_MEAS_MASK_SINK_PHY_DATA_CLK_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+#define F_MEAS_MASK_SINK_PHY_PIXEL_CLK(x) (((x) & ((1 << 1) - 1)) << 3)
+#define F_MEAS_MASK_SINK_PHY_PIXEL_CLK_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+#define F_MEAS_MASK_SINK_SPDIF_MCLK(x) (((x) & ((1 << 1) - 1)) << 4)
+#define F_MEAS_MASK_SINK_SPDIF_MCLK_RD(x) (((x) & (((1 << 1) - 1) << 4)) >> 4)
+#define F_MEAS_MASK_SINK_I2S_CLK(x) (((x) & ((1 << 1) - 1)) << 5)
+#define F_MEAS_MASK_SINK_I2S_CLK_RD(x) (((x) & (((1 << 1) - 1) << 5)) >> 5)
+#define F_MEAS_MASK_SINK_PCLK(x) (((x) & ((1 << 1) - 1)) << 6)
+#define F_MEAS_MASK_SINK_PCLK_RD(x) (((x) & (((1 << 1) - 1) << 6)) >> 6)
+#define F_MEAS_MASK_SINK_SCLK(x) (((x) & ((1 << 1) - 1)) << 7)
+#define F_MEAS_MASK_SINK_SCLK_RD(x) (((x) & (((1 << 1) - 1) << 7)) >> 7)
+#define F_MEAS_MASK_SINK_CCLK(x) (((x) & ((1 << 1) - 1)) << 8)
+#define F_MEAS_MASK_SINK_CCLK_RD(x) (((x) & (((1 << 1) - 1) << 8)) >> 8)
+#define F_MEAS_MASK_SINK_TRNG_CLK(x) (((x) & ((1 << 1) - 1)) << 9)
+#define F_MEAS_MASK_SINK_TRNG_CLK_RD(x) (((x) & (((1 << 1) - 1) << 9)) >> 9)
+
+/* register CLK_METER_INT_ST */
+#define CLK_METER_INT_ST 21
+#define F_MEAS_STATUS_SINK_REF_CLK(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_MEAS_STATUS_SINK_REF_CLK_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_MEAS_STATUS_SINK_PHY_CHAR_CLK(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_MEAS_STATUS_SINK_PHY_CHAR_CLK_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_MEAS_STATUS_SINK_PHY_DATA_CLK(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_MEAS_STATUS_SINK_PHY_DATA_CLK_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+#define F_MEAS_STATUS_SINK_PHY_PIXEL_CLK(x) (((x) & ((1 << 1) - 1)) << 3)
+#define F_MEAS_STATUS_SINK_PHY_PIXEL_CLK_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+#define F_MEAS_STATUS_SINK_SPDIF_MCLK(x) (((x) & ((1 << 1) - 1)) << 4)
+#define F_MEAS_STATUS_SINK_SPDIF_MCLK_RD(x) (((x) & (((1 << 1) - 1) << 4)) >> 4)
+#define F_MEAS_STATUS_SINK_I2S_CLK(x) (((x) & ((1 << 1) - 1)) << 5)
+#define F_MEAS_STATUS_SINK_I2S_CLK_RD(x) (((x) & (((1 << 1) - 1) << 5)) >> 5)
+#define F_MEAS_STATUS_SINK_PCLK(x) (((x) & ((1 << 1) - 1)) << 6)
+#define F_MEAS_STATUS_SINK_PCLK_RD(x) (((x) & (((1 << 1) - 1) << 6)) >> 6)
+#define F_MEAS_STATUS_SINK_SCLK(x) (((x) & ((1 << 1) - 1)) << 7)
+#define F_MEAS_STATUS_SINK_SCLK_RD(x) (((x) & (((1 << 1) - 1) << 7)) >> 7)
+#define F_MEAS_STATUS_SINK_CCLK(x) (((x) & ((1 << 1) - 1)) << 8)
+#define F_MEAS_STATUS_SINK_CCLK_RD(x) (((x) & (((1 << 1) - 1) << 8)) >> 8)
+#define F_MEAS_STATUS_SINK_TRNG_CLK(x) (((x) & ((1 << 1) - 1)) << 9)
+#define F_MEAS_STATUS_SINK_TRNG_CLK_RD(x) (((x) & (((1 << 1) - 1) << 9)) >> 9)
+
+#endif /* SINK_CLK_METERS */
+
diff --git a/drivers/mxc/hdp/sink_core.h b/drivers/mxc/hdp/sink_core.h
new file mode 100644
index 000000000000..ba63ca2af41a
--- /dev/null
+++ b/drivers/mxc/hdp/sink_core.h
@@ -0,0 +1,117 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright 2018 NXP
+ *
+ ******************************************************************************
+ *
+ * This file was auto-generated. Do not edit it manually.
+ *
+ ******************************************************************************
+ *
+ * sink_core.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef SINK_CORE_H_
+#define SINK_CORE_H_
+
+/* register SCDC_INT_MSK */
+#define SCDC_INT_MSK 0
+#define F_SCDC_INT_MASK(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_SCDC_INT_MASK_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+
+/* register SCDC_INT_STS */
+#define SCDC_INT_STS 1
+#define F_SCDC_INT_STATUS(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_SCDC_INT_STATUS_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+
+/* register PHY_IF_LANE0_CFG */
+#define PHY_IF_LANE0_CFG 2
+#define F_SINK_PHY_DATA0_DATA_REVERSE(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SINK_PHY_DATA0_DATA_REVERSE_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_SINK_PHY_DATA0_CHAR_REVERSE(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_SINK_PHY_DATA0_CHAR_REVERSE_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_SINK_PHY_CHAR0_SWAP(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_SINK_PHY_CHAR0_SWAP_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+#define F_SINK_PHY_LANE0(x) (((x) & ((1 << 2) - 1)) << 3)
+#define F_SINK_PHY_LANE0_RD(x) (((x) & (((1 << 2) - 1) << 3)) >> 3)
+
+/* register PHY_IF_LANE1_CFG */
+#define PHY_IF_LANE1_CFG 3
+#define F_SINK_PHY_DATA1_DATA_REVERSE(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SINK_PHY_DATA1_DATA_REVERSE_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_SINK_PHY_DATA1_CHAR_REVERSE(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_SINK_PHY_DATA1_CHAR_REVERSE_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_SINK_PHY_CHAR1_SWAP(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_SINK_PHY_CHAR1_SWAP_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+#define F_SINK_PHY_LANE1(x) (((x) & ((1 << 2) - 1)) << 3)
+#define F_SINK_PHY_LANE1_RD(x) (((x) & (((1 << 2) - 1) << 3)) >> 3)
+
+/* register PHY_IF_LANE2_CFG */
+#define PHY_IF_LANE2_CFG 4
+#define F_SINK_PHY_DATA2_DATA_REVERSE(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SINK_PHY_DATA2_DATA_REVERSE_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_SINK_PHY_DATA2_CHAR_REVERSE(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_SINK_PHY_DATA2_CHAR_REVERSE_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_SINK_PHY_CHAR2_SWAP(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_SINK_PHY_CHAR2_SWAP_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+#define F_SINK_PHY_LANE2(x) (((x) & ((1 << 2) - 1)) << 3)
+#define F_SINK_PHY_LANE2_RD(x) (((x) & (((1 << 2) - 1) << 3)) >> 3)
+
+/* register TOP_ST */
+#define TOP_ST 5
+#define F_SINK_5V(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SINK_5V_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+/* register TOP_CFG */
+#define TOP_CFG 6
+#define F_SINK_HPD(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SINK_HPD_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+/* register SCDC_FILTER_CFG */
+#define SCDC_FILTER_CFG 7
+#define F_SCDC_FILTER_BYPASS(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SCDC_FILTER_BYPASS_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_SCDC_FILTER_VALID_WIDTH(x) (((x) & ((1 << 12) - 1)) << 1)
+#define F_SCDC_FILTER_VALID_WIDTH_RD(x) (((x) & (((1 << 12) - 1) << 1)) >> 1)
+#define F_SCDC_FILTER_GLITCH_WIDTH(x) (((x) & ((1 << 8) - 1)) << 13)
+#define F_SCDC_FILTER_GLITCH_WIDTH_RD(x) (((x) & (((1 << 8) - 1) << 13)) >> 13)
+
+#endif /* SINK_CORE */
+
diff --git a/drivers/mxc/hdp/sink_mhl_hd.h b/drivers/mxc/hdp/sink_mhl_hd.h
new file mode 100644
index 000000000000..be03200e9d96
--- /dev/null
+++ b/drivers/mxc/hdp/sink_mhl_hd.h
@@ -0,0 +1,418 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright 2018 NXP
+ *
+ ******************************************************************************
+ *
+ * This file was auto-generated. Do not edit it manually.
+ *
+ ******************************************************************************
+ *
+ * sink_mhl_hd.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef SINK_MHL_HD_H_
+#define SINK_MHL_HD_H_
+
+/* register TMDS_ALIGN_CTRL */
+#define TMDS_ALIGN_CTRL 0
+#define F_CHAR_MATCH_CNT_THR(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_CHAR_MATCH_CNT_THR_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_CHAR_HAM_DIS_TOL(x) (((x) & ((1 << 4) - 1)) << 4)
+#define F_CHAR_HAM_DIS_TOL_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+#define F_LOCK_ALIGN(x) (((x) & ((1 << 1) - 1)) << 8)
+#define F_LOCK_ALIGN_RD(x) (((x) & (((1 << 1) - 1) << 8)) >> 8)
+#define F_ALIGN_WD_THR(x) (((x) & ((1 << 3) - 1)) << 9)
+#define F_ALIGN_WD_THR_RD(x) (((x) & (((1 << 3) - 1) << 9)) >> 9)
+#define F_ALIGN_ANY_CHAR(x) (((x) & ((1 << 1) - 1)) << 12)
+#define F_ALIGN_ANY_CHAR_RD(x) (((x) & (((1 << 1) - 1) << 12)) >> 12)
+
+/* register TMDS_DEC_CTRL */
+#define TMDS_DEC_CTRL 1
+#define F_DECODER_ERR_CORR_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_DECODER_ERR_CORR_EN_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_TMDS_DECODER_SW_RST(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_TMDS_DECODER_SW_RST_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_TMDS_FORCE_HDMI_MODE(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_TMDS_FORCE_HDMI_MODE_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+#define F_TMDS_SW_HDMI_MODE(x) (((x) & ((1 << 1) - 1)) << 3)
+#define F_TMDS_SW_HDMI_MODE_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+
+/* register TMDS_DEC_ST */
+#define TMDS_DEC_ST 2
+#define F_DEFRAMER_HDMI_MODE(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_DEFRAMER_HDMI_MODE_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_CHAR_HAM_ERR(x) (((x) & ((1 << 3) - 1)) << 2)
+#define F_CHAR_HAM_ERR_RD(x) (((x) & (((1 << 3) - 1) << 2)) >> 2)
+#define F_CHAR_ALIGNED(x) (((x) & ((1 << 3) - 1)) << 5)
+#define F_CHAR_ALIGNED_RD(x) (((x) & (((1 << 3) - 1) << 5)) >> 5)
+#define F_CTRL_ALIGN_ERR(x) (((x) & ((1 << 1) - 1)) << 8)
+#define F_CTRL_ALIGN_ERR_RD(x) (((x) & (((1 << 1) - 1) << 8)) >> 8)
+#define F_CTRL_ALIGNED(x) (((x) & ((1 << 1) - 1)) << 9)
+#define F_CTRL_ALIGNED_RD(x) (((x) & (((1 << 1) - 1) << 9)) >> 9)
+#define F_TMDS_CHAR_CH0_WIN(x) (((x) & ((1 << 4) - 1)) << 10)
+#define F_TMDS_CHAR_CH0_WIN_RD(x) (((x) & (((1 << 4) - 1) << 10)) >> 10)
+#define F_TMDS_CHAR_CH1_WIN(x) (((x) & ((1 << 4) - 1)) << 14)
+#define F_TMDS_CHAR_CH1_WIN_RD(x) (((x) & (((1 << 4) - 1) << 14)) >> 14)
+#define F_TMDS_CHAR_CH2_WIN(x) (((x) & ((1 << 4) - 1)) << 18)
+#define F_TMDS_CHAR_CH2_WIN_RD(x) (((x) & (((1 << 4) - 1) << 18)) >> 18)
+
+/* register TMDS_CH0_ERR_CNT */
+#define TMDS_CH0_ERR_CNT 3
+#define F_DEFRAMER_CH0_ERROR_CNT(x) (((x) & ((1 << 16) - 1)) << 0)
+#define F_DEFRAMER_CH0_ERROR_CNT_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+
+/* register TMDS_CH1_ERR_CNT */
+#define TMDS_CH1_ERR_CNT 4
+#define F_DEFRAMER_CH1_ERROR_CNT(x) (((x) & ((1 << 16) - 1)) << 0)
+#define F_DEFRAMER_CH1_ERROR_CNT_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+
+/* register TMDS_CH2_ERR_CNT */
+#define TMDS_CH2_ERR_CNT 5
+#define F_DEFRAMER_CH2_ERROR_CNT(x) (((x) & ((1 << 16) - 1)) << 0)
+#define F_DEFRAMER_CH2_ERROR_CNT_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+
+/* register HDCP_FIFO_STAT */
+#define HDCP_FIFO_STAT 6
+#define F_HDCP_DOUBLE_FIFO_REMPTY(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_HDCP_DOUBLE_FIFO_REMPTY_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_HDCP_DOUBLE_FIFO_WFULL(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_HDCP_DOUBLE_FIFO_WFULL_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_HDCP_DOUBLE_FIFO_UNDERRUN(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_HDCP_DOUBLE_FIFO_UNDERRUN_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+#define F_HDCP_DOUBLE_FIFO_OVERRUN(x) (((x) & ((1 << 1) - 1)) << 3)
+#define F_HDCP_DOUBLE_FIFO_OVERRUN_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+#define F_HDCP22_DATA_FIFO_UNDERRUN(x) (((x) & ((1 << 1) - 1)) << 4)
+#define F_HDCP22_DATA_FIFO_UNDERRUN_RD(x) (((x) & (((1 << 1) - 1) << 4)) >> 4)
+#define F_HDCP22_DATA_FIFO_OVERRUN(x) (((x) & ((1 << 1) - 1)) << 5)
+#define F_HDCP22_DATA_FIFO_OVERRUN_RD(x) (((x) & (((1 << 1) - 1) << 5)) >> 5)
+#define F_HDCP22_DATA_FIFO_REMPTY(x) (((x) & ((1 << 1) - 1)) << 6)
+#define F_HDCP22_DATA_FIFO_REMPTY_RD(x) (((x) & (((1 << 1) - 1) << 6)) >> 6)
+#define F_HDCP22_DATA_FIFO_WFULL(x) (((x) & ((1 << 1) - 1)) << 7)
+#define F_HDCP22_DATA_FIFO_WFULL_RD(x) (((x) & (((1 << 1) - 1) << 7)) >> 7)
+#define F_HDCP_DELAY_FIFO_EMPTY(x) (((x) & ((1 << 1) - 1)) << 8)
+#define F_HDCP_DELAY_FIFO_EMPTY_RD(x) (((x) & (((1 << 1) - 1) << 8)) >> 8)
+#define F_HDCP_DELAY_FIFO_FULL(x) (((x) & ((1 << 1) - 1)) << 9)
+#define F_HDCP_DELAY_FIFO_FULL_RD(x) (((x) & (((1 << 1) - 1) << 9)) >> 9)
+#define F_HDCP14_DATA_FIFO_UNDERRUN(x) (((x) & ((1 << 2) - 1)) << 10)
+#define F_HDCP14_DATA_FIFO_UNDERRUN_RD(x) (((x) & (((1 << 2) - 1) << 10)) >> 10)
+#define F_HDCP14_DATA_FIFO_OVERRUN(x) (((x) & ((1 << 2) - 1)) << 12)
+#define F_HDCP14_DATA_FIFO_OVERRUN_RD(x) (((x) & (((1 << 2) - 1) << 12)) >> 12)
+#define F_HDCP14_DATA_FIFO_REMPTY(x) (((x) & ((1 << 2) - 1)) << 14)
+#define F_HDCP14_DATA_FIFO_REMPTY_RD(x) (((x) & (((1 << 2) - 1) << 14)) >> 14)
+#define F_HDCP14_DATA_FIFO_WFULL(x) (((x) & ((1 << 2) - 1)) << 16)
+#define F_HDCP14_DATA_FIFO_WFULL_RD(x) (((x) & (((1 << 2) - 1) << 16)) >> 16)
+
+/* register HDCP_DELAY_FIFO_CTRL */
+#define HDCP_DELAY_FIFO_CTRL 7
+#define F_HDCP_DELAY_FIFO_AFULL_THR(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_HDCP_DELAY_FIFO_AFULL_THR_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_HDCP_DELAY_FIFO_SW_RST(x) (((x) & ((1 << 1) - 1)) << 4)
+#define F_HDCP_DELAY_FIFO_SW_RST_RD(x) (((x) & (((1 << 1) - 1) << 4)) >> 4)
+#define F_HDCP_DOUBLE_FIFO_SW_RST(x) (((x) & ((1 << 1) - 1)) << 5)
+#define F_HDCP_DOUBLE_FIFO_SW_RST_RD(x) (((x) & (((1 << 1) - 1) << 5)) >> 5)
+#define F_HDCP14_DATA_FIFO_SW_RST(x) (((x) & ((1 << 1) - 1)) << 6)
+#define F_HDCP14_DATA_FIFO_SW_RST_RD(x) (((x) & (((1 << 1) - 1) << 6)) >> 6)
+#define F_HDCP_CTRL_SW_RST(x) (((x) & ((1 << 1) - 1)) << 7)
+#define F_HDCP_CTRL_SW_RST_RD(x) (((x) & (((1 << 1) - 1) << 7)) >> 7)
+
+/* register HDCP_CTRL */
+#define HDCP_CTRL 8
+#define F_HDCP_ENABLE_1P1_FEATURES(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_HDCP_ENABLE_1P1_FEATURES_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_HDCP_SELECT(x) (((x) & ((1 << 2) - 1)) << 1)
+#define F_HDCP_SELECT_RD(x) (((x) & (((1 << 2) - 1) << 1)) >> 1)
+#define F_FORCE_VSYNC_POLARITY(x) (((x) & ((1 << 1) - 1)) << 3)
+#define F_FORCE_VSYNC_POLARITY_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+#define F_FORCE_HSYNC_POLARITY(x) (((x) & ((1 << 1) - 1)) << 4)
+#define F_FORCE_HSYNC_POLARITY_RD(x) (((x) & (((1 << 1) - 1) << 4)) >> 4)
+#define F_SW_VSYNC_POLARITY(x) (((x) & ((1 << 1) - 1)) << 5)
+#define F_SW_VSYNC_POLARITY_RD(x) (((x) & (((1 << 1) - 1) << 5)) >> 5)
+#define F_SW_HSYNC_POLARITY(x) (((x) & ((1 << 1) - 1)) << 6)
+#define F_SW_HSYNC_POLARITY_RD(x) (((x) & (((1 << 1) - 1) << 6)) >> 6)
+
+/* register HDCP_STAT */
+#define HDCP_STAT 9
+#define F_HDCP_ESS_STATE(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_HDCP_ESS_STATE_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_SINK_HD_CIPHER_HSYNC_POLARITY(x) (((x) & ((1 << 1) - 1)) << 4)
+#define F_SINK_HD_CIPHER_HSYNC_POLARITY_RD(x) (((x) & (((1 << 1) - 1) << 4)) >> 4)
+#define F_SINK_HD_CIPHER_VSYNC_POLARITY(x) (((x) & ((1 << 1) - 1)) << 5)
+#define F_SINK_HD_CIPHER_VSYNC_POLARITY_RD(x) (((x) & (((1 << 1) - 1) << 5)) >> 5)
+
+/* register PKT_CTRL */
+#define PKT_CTRL 10
+#define F_SINK_AVMUTE_SET(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SINK_AVMUTE_SET_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_SINK_AVMUTE_CLR(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_SINK_AVMUTE_CLR_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_ERR_CORR_EN(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_ERR_CORR_EN_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+
+/* register PKT_STAT_0 */
+#define PKT_STAT_0 11
+#define F_SINK_AVMUTE(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SINK_AVMUTE_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_SINK_ACR_CTS(x) (((x) & ((1 << 20) - 1)) << 1)
+#define F_SINK_ACR_CTS_RD(x) (((x) & (((1 << 20) - 1) << 1)) >> 1)
+#define F_PKT_DEC_GCP_CD(x) (((x) & ((1 << 4) - 1)) << 21)
+#define F_PKT_DEC_GCP_CD_RD(x) (((x) & (((1 << 4) - 1) << 21)) >> 21)
+#define F_PKT_DEC_GCP_PP(x) (((x) & ((1 << 4) - 1)) << 25)
+#define F_PKT_DEC_GCP_PP_RD(x) (((x) & (((1 << 4) - 1) << 25)) >> 25)
+
+/* register PKT_STAT_1 */
+#define PKT_STAT_1 12
+#define F_SINK_ACR_N(x) (((x) & ((1 << 20) - 1)) << 0)
+#define F_SINK_ACR_N_RD(x) (((x) & (((1 << 20) - 1) << 0)) >> 0)
+
+/* register PKT_ERR_CNT_HEADER */
+#define PKT_ERR_CNT_HEADER 13
+#define F_PKT_HEADER_ERR_CNT(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_PKT_HEADER_ERR_CNT_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+#define F_PKT_HEADER_CORR_ERR_CNT(x) (((x) & ((1 << 8) - 1)) << 8)
+#define F_PKT_HEADER_CORR_ERR_CNT_RD(x) (((x) & (((1 << 8) - 1) << 8)) >> 8)
+
+/* register PKT_ERR_CNT_01 */
+#define PKT_ERR_CNT_01 14
+#define F_PKT_SUBPKT0_ERR_CNT(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_PKT_SUBPKT0_ERR_CNT_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+#define F_PKT_SUBPKT0_CORR_ERR_CNT(x) (((x) & ((1 << 8) - 1)) << 8)
+#define F_PKT_SUBPKT0_CORR_ERR_CNT_RD(x) (((x) & (((1 << 8) - 1) << 8)) >> 8)
+#define F_PKT_SUBPKT1_ERR_CNT(x) (((x) & ((1 << 8) - 1)) << 16)
+#define F_PKT_SUBPKT1_ERR_CNT_RD(x) (((x) & (((1 << 8) - 1) << 16)) >> 16)
+#define F_PKT_SUBPKT1_CORR_ERR_CNT(x) (((x) & ((1 << 8) - 1)) << 24)
+#define F_PKT_SUBPKT1_CORR_ERR_CNT_RD(x) (((x) & (((1 << 8) - 1) << 24)) >> 24)
+
+/* register PKT_ERR_CNT_23 */
+#define PKT_ERR_CNT_23 15
+#define F_PKT_SUBPKT2_ERR_CNT(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_PKT_SUBPKT2_ERR_CNT_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+#define F_PKT_SUBPKT2_CORR_ERR_CNT(x) (((x) & ((1 << 8) - 1)) << 8)
+#define F_PKT_SUBPKT2_CORR_ERR_CNT_RD(x) (((x) & (((1 << 8) - 1) << 8)) >> 8)
+#define F_PKT_SUBPKT3_ERR_CNT(x) (((x) & ((1 << 8) - 1)) << 16)
+#define F_PKT_SUBPKT3_ERR_CNT_RD(x) (((x) & (((1 << 8) - 1) << 16)) >> 16)
+#define F_PKT_SUBPKT3_CORR_ERR_CNT(x) (((x) & ((1 << 8) - 1)) << 24)
+#define F_PKT_SUBPKT3_CORR_ERR_CNT_RD(x) (((x) & (((1 << 8) - 1) << 24)) >> 24)
+
+/* register TMDS_SCR_CTRL */
+#define TMDS_SCR_CTRL 16
+#define F_SCRAMBLER_MODE(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SCRAMBLER_MODE_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_SCRAMBLER_SW_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_SCRAMBLER_SW_EN_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_SCRAMBLER_CTRL_SW_RST(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_SCRAMBLER_CTRL_SW_RST_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+
+/* register TMDS_SCR_CNT_INT_CTRL */
+#define TMDS_SCR_CNT_INT_CTRL 17
+#define F_SCRAMBLER_SSCP_LINE_DET_THR(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_SCRAMBLER_SSCP_LINE_DET_THR_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+#define F_SCRAMBLER_CTRL_LINE_DET_THR(x) (((x) & ((1 << 24) - 1)) << 8)
+#define F_SCRAMBLER_CTRL_LINE_DET_THR_RD(x) (((x) & (((1 << 24) - 1) << 8)) >> 8)
+
+/* register TMDS_SCR_VALID_CTRL */
+#define TMDS_SCR_VALID_CTRL 18
+#define F_SCRAMBLER_SSCP_LINE_VALID_THR(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_SCRAMBLER_SSCP_LINE_VALID_THR_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+#define F_SCRAMBLER_CTRL_LINE_VALID_THR(x) (((x) & ((1 << 24) - 1)) << 8)
+#define F_SCRAMBLER_CTRL_LINE_VALID_THR_RD(x) (((x) & (((1 << 24) - 1) << 8)) >> 8)
+
+/* register TMDS_SCR_CNT_INT_ST */
+#define TMDS_SCR_CNT_INT_ST 19
+#define F_SCRAMBLER_SSCP_LINE_CNT(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_SCRAMBLER_SSCP_LINE_CNT_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+#define F_SCRAMBLER_CTRL_LINE_CNT(x) (((x) & ((1 << 24) - 1)) << 8)
+#define F_SCRAMBLER_CTRL_LINE_CNT_RD(x) (((x) & (((1 << 24) - 1) << 8)) >> 8)
+
+/* register TMDS_MHL_HD_INT_MASK */
+#define TMDS_MHL_HD_INT_MASK 20
+#define F_TMDS_MHL_HD_MASK(x) (((x) & ((1 << 9) - 1)) << 0)
+#define F_TMDS_MHL_HD_MASK_RD(x) (((x) & (((1 << 9) - 1) << 0)) >> 0)
+
+/* register TMDS_MHL_HD_INT_STAT */
+#define TMDS_MHL_HD_INT_STAT 21
+#define F_TMDS_MHL_HD_STATUS(x) (((x) & ((1 << 9) - 1)) << 0)
+#define F_TMDS_MHL_HD_STATUS_RD(x) (((x) & (((1 << 9) - 1) << 0)) >> 0)
+
+/* register TMDS_STAT_CNT0_CTRL */
+#define TMDS_STAT_CNT0_CTRL 22
+#define F_STATUS_CNT0_INC_SEL(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_STATUS_CNT0_INC_SEL_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_STATUS_CNT0_DEC_SEL(x) (((x) & ((1 << 4) - 1)) << 4)
+#define F_STATUS_CNT0_DEC_SEL_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+#define F_STATUS_CNT0_CLR_SEL(x) (((x) & ((1 << 4) - 1)) << 8)
+#define F_STATUS_CNT0_CLR_SEL_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+#define F_STATUS_CNT0_START_SEL(x) (((x) & ((1 << 4) - 1)) << 12)
+#define F_STATUS_CNT0_START_SEL_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+#define F_STATUS_CNT0_STOP_SEL(x) (((x) & ((1 << 4) - 1)) << 16)
+#define F_STATUS_CNT0_STOP_SEL_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+
+/* register TMDS_STAT_CNT0_THR */
+#define TMDS_STAT_CNT0_THR 23
+#define F_STATUS_CNT0_THR(x) (((x) & ((1 << 32) - 1)) << 0)
+#define F_STATUS_CNT0_THR_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register TMDS_STAT_CNT0_VAL */
+#define TMDS_STAT_CNT0_VAL 24
+#define F_STATUS_CNT0_VAL(x) (((x) & ((1 << 32) - 1)) << 0)
+#define F_STATUS_CNT0_VAL_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register TMDS_STAT_CNT1_CTRL */
+#define TMDS_STAT_CNT1_CTRL 25
+#define F_STATUS_CNT1_INC_SEL(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_STATUS_CNT1_INC_SEL_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_STATUS_CNT1_DEC_SEL(x) (((x) & ((1 << 4) - 1)) << 4)
+#define F_STATUS_CNT1_DEC_SEL_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+#define F_STATUS_CNT1_CLR_SEL(x) (((x) & ((1 << 4) - 1)) << 8)
+#define F_STATUS_CNT1_CLR_SEL_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+#define F_STATUS_CNT1_START_SEL(x) (((x) & ((1 << 4) - 1)) << 12)
+#define F_STATUS_CNT1_START_SEL_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+#define F_STATUS_CNT1_STOP_SEL(x) (((x) & ((1 << 4) - 1)) << 16)
+#define F_STATUS_CNT1_STOP_SEL_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+
+/* register TMDS_STAT_CNT1_THR */
+#define TMDS_STAT_CNT1_THR 26
+#define F_STATUS_CNT1_THR(x) (((x) & ((1 << 32) - 1)) << 0)
+#define F_STATUS_CNT1_THR_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register TMDS_STAT_CNT1_VAL */
+#define TMDS_STAT_CNT1_VAL 27
+#define F_STATUS_CNT1_VAL(x) (((x) & ((1 << 32) - 1)) << 0)
+#define F_STATUS_CNT1_VAL_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register TMDS_STAT_CNT2_CTRL */
+#define TMDS_STAT_CNT2_CTRL 28
+#define F_STATUS_CNT2_INC_SEL(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_STATUS_CNT2_INC_SEL_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_STATUS_CNT2_DEC_SEL(x) (((x) & ((1 << 4) - 1)) << 4)
+#define F_STATUS_CNT2_DEC_SEL_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+#define F_STATUS_CNT2_CLR_SEL(x) (((x) & ((1 << 4) - 1)) << 8)
+#define F_STATUS_CNT2_CLR_SEL_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+#define F_STATUS_CNT2_START_SEL(x) (((x) & ((1 << 4) - 1)) << 12)
+#define F_STATUS_CNT2_START_SEL_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+#define F_STATUS_CNT2_STOP_SEL(x) (((x) & ((1 << 4) - 1)) << 16)
+#define F_STATUS_CNT2_STOP_SEL_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+
+/* register TMDS_STAT_CNT2_THR */
+#define TMDS_STAT_CNT2_THR 29
+#define F_STATUS_CNT2_THR(x) (((x) & ((1 << 32) - 1)) << 0)
+#define F_STATUS_CNT2_THR_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register TMDS_STAT_CNT2_VAL */
+#define TMDS_STAT_CNT2_VAL 30
+#define F_STATUS_CNT2_VAL(x) (((x) & ((1 << 32) - 1)) << 0)
+#define F_STATUS_CNT2_VAL_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register TMDS_STAT_CNT3_CTRL */
+#define TMDS_STAT_CNT3_CTRL 31
+#define F_STATUS_CNT3_INC_SEL(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_STATUS_CNT3_INC_SEL_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_STATUS_CNT3_DEC_SEL(x) (((x) & ((1 << 4) - 1)) << 4)
+#define F_STATUS_CNT3_DEC_SEL_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+#define F_STATUS_CNT3_CLR_SEL(x) (((x) & ((1 << 4) - 1)) << 8)
+#define F_STATUS_CNT3_CLR_SEL_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+#define F_STATUS_CNT3_START_SEL(x) (((x) & ((1 << 4) - 1)) << 12)
+#define F_STATUS_CNT3_START_SEL_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+#define F_STATUS_CNT3_STOP_SEL(x) (((x) & ((1 << 4) - 1)) << 16)
+#define F_STATUS_CNT3_STOP_SEL_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+
+/* register TMDS_STAT_CNT3_THR */
+#define TMDS_STAT_CNT3_THR 32
+#define F_STATUS_CNT3_THR(x) (((x) & ((1 << 32) - 1)) << 0)
+#define F_STATUS_CNT3_THR_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register TMDS_STAT_CNT3_VAL */
+#define TMDS_STAT_CNT3_VAL 33
+#define F_STATUS_CNT3_VAL(x) (((x) & ((1 << 32) - 1)) << 0)
+#define F_STATUS_CNT3_VAL_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register TMDS_POLARITY_STAT */
+#define TMDS_POLARITY_STAT 34
+#define F_TMDS_HSYNC_POLARITY(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_TMDS_HSYNC_POLARITY_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_TMDS_VSYNC_POLARITY(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_TMDS_VSYNC_POLARITY_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+
+/* register TMDS_MHL_HD_ERR_INT_MASK */
+#define TMDS_MHL_HD_ERR_INT_MASK 35
+#define F_TMDS_MHL_HD_ERR_MASK(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_TMDS_MHL_HD_ERR_MASK_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+
+/* register TMDS_MHL_HD_ERR_INT_STAT */
+#define TMDS_MHL_HD_ERR_INT_STAT 36
+#define F_TMDS_MHL_HD_ERR_STATUS(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_TMDS_MHL_HD_ERR_STATUS_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+
+/* register MHL_HD_INT_MASK */
+#define MHL_HD_INT_MASK 37
+#define F_MHL_HD_INT_MASK(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_MHL_HD_INT_MASK_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+
+/* register MHL_HD_INT_STAT */
+#define MHL_HD_INT_STAT 38
+#define F_MHL_HD_INT_STATUS(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_MHL_HD_INT_STATUS_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+
+/* register PKT_ACR_CTS_CTRL */
+#define PKT_ACR_CTS_CTRL 39
+#define F_SW_FORCE_ACR_CTS(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SW_FORCE_ACR_CTS_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_PKT_DEC_ACR_CTS(x) (((x) & ((1 << 20) - 1)) << 1)
+#define F_PKT_DEC_ACR_CTS_RD(x) (((x) & (((1 << 20) - 1) << 1)) >> 1)
+
+/* register PKT_ACR_N_CTRL */
+#define PKT_ACR_N_CTRL 40
+#define F_SW_FORCE_ACR_N(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SW_FORCE_ACR_N_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_PKT_DEC_ACR_N(x) (((x) & ((1 << 20) - 1)) << 1)
+#define F_PKT_DEC_ACR_N_RD(x) (((x) & (((1 << 20) - 1) << 1)) >> 1)
+
+/* register PKT_AVI_DATA_LOW */
+#define PKT_AVI_DATA_LOW 41
+#define F_PKT_DEC_AVI_DATA_LOW(x) (((x) & ((1 << 32) - 1)) << 0)
+#define F_PKT_DEC_AVI_DATA_LOW_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register PKT_AVI_DATA_HIGH */
+#define PKT_AVI_DATA_HIGH 42
+#define F_PKT_DEC_AVI_DATA_HIGH(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_PKT_DEC_AVI_DATA_HIGH_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+
+#endif /* SINK_MHL_HD */
+
diff --git a/drivers/mxc/hdp/sink_pif.h b/drivers/mxc/hdp/sink_pif.h
new file mode 100644
index 000000000000..bd0944fbb27f
--- /dev/null
+++ b/drivers/mxc/hdp/sink_pif.h
@@ -0,0 +1,160 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright 2018 NXP
+ *
+ ******************************************************************************
+ *
+ * This file was auto-generated. Do not edit it manually.
+ *
+ ******************************************************************************
+ *
+ * sink_pif.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef SINK_PIF_H_
+#define SINK_PIF_H_
+
+/* register PKT_INFO_TYPE_CFG1 */
+#define PKT_INFO_TYPE_CFG1 0
+#define F_INFO_TYPE1(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_INFO_TYPE1_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+#define F_INFO_TYPE2(x) (((x) & ((1 << 8) - 1)) << 8)
+#define F_INFO_TYPE2_RD(x) (((x) & (((1 << 8) - 1) << 8)) >> 8)
+#define F_INFO_TYPE3(x) (((x) & ((1 << 8) - 1)) << 16)
+#define F_INFO_TYPE3_RD(x) (((x) & (((1 << 8) - 1) << 16)) >> 16)
+#define F_INFO_TYPE4(x) (((x) & ((1 << 8) - 1)) << 24)
+#define F_INFO_TYPE4_RD(x) (((x) & (((1 << 8) - 1) << 24)) >> 24)
+
+/* register PKT_INFO_TYPE_CFG2 */
+#define PKT_INFO_TYPE_CFG2 1
+#define F_INFO_TYPE5(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_INFO_TYPE5_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+#define F_INFO_TYPE6(x) (((x) & ((1 << 8) - 1)) << 8)
+#define F_INFO_TYPE6_RD(x) (((x) & (((1 << 8) - 1) << 8)) >> 8)
+#define F_INFO_TYPE7(x) (((x) & ((1 << 8) - 1)) << 16)
+#define F_INFO_TYPE7_RD(x) (((x) & (((1 << 8) - 1) << 16)) >> 16)
+#define F_INFO_TYPE8(x) (((x) & ((1 << 8) - 1)) << 24)
+#define F_INFO_TYPE8_RD(x) (((x) & (((1 << 8) - 1) << 24)) >> 24)
+
+/* register PKT_INFO_TYPE_CFG3 */
+#define PKT_INFO_TYPE_CFG3 2
+#define F_INFO_TYPE9(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_INFO_TYPE9_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+#define F_INFO_TYPE10(x) (((x) & ((1 << 8) - 1)) << 8)
+#define F_INFO_TYPE10_RD(x) (((x) & (((1 << 8) - 1) << 8)) >> 8)
+#define F_INFO_TYPE11(x) (((x) & ((1 << 8) - 1)) << 16)
+#define F_INFO_TYPE11_RD(x) (((x) & (((1 << 8) - 1) << 16)) >> 16)
+#define F_INFO_TYPE12(x) (((x) & ((1 << 8) - 1)) << 24)
+#define F_INFO_TYPE12_RD(x) (((x) & (((1 << 8) - 1) << 24)) >> 24)
+
+/* register PKT_INFO_TYPE_CFG4 */
+#define PKT_INFO_TYPE_CFG4 3
+#define F_INFO_TYPE13(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_INFO_TYPE13_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+#define F_INFO_TYPE14(x) (((x) & ((1 << 8) - 1)) << 8)
+#define F_INFO_TYPE14_RD(x) (((x) & (((1 << 8) - 1) << 8)) >> 8)
+#define F_INFO_TYPE15(x) (((x) & ((1 << 8) - 1)) << 16)
+#define F_INFO_TYPE15_RD(x) (((x) & (((1 << 8) - 1) << 16)) >> 16)
+#define F_INFO_TYPE16(x) (((x) & ((1 << 8) - 1)) << 24)
+#define F_INFO_TYPE16_RD(x) (((x) & (((1 << 8) - 1) << 24)) >> 24)
+
+/* register PKT_INFO_CTRL */
+#define PKT_INFO_CTRL 4
+#define F_PACKET_RDN_WR(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_PACKET_RDN_WR_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_PACKET_NUM(x) (((x) & ((1 << 4) - 1)) << 1)
+#define F_PACKET_NUM_RD(x) (((x) & (((1 << 4) - 1) << 1)) >> 1)
+
+/* register PKT_INFO_HEADER */
+#define PKT_INFO_HEADER 7
+#define F_PKT_MEMORY_HEADER(x) (((x) & ((1 << 32) - 1)) << 0)
+#define F_PKT_MEMORY_HEADER_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register PKT_INFO_DATA1 */
+#define PKT_INFO_DATA1 8
+#define F_PKT_MEMORY_DATA1(x) (((x) & ((1 << 32) - 1)) << 0)
+#define F_PKT_MEMORY_DATA1_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register PKT_INFO_DATA2 */
+#define PKT_INFO_DATA2 9
+#define F_PKT_MEMORY_DATA2(x) (((x) & ((1 << 32) - 1)) << 0)
+#define F_PKT_MEMORY_DATA2_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register PKT_INFO_DATA3 */
+#define PKT_INFO_DATA3 10
+#define F_PKT_MEMORY_DATA3(x) (((x) & ((1 << 32) - 1)) << 0)
+#define F_PKT_MEMORY_DATA3_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register PKT_INFO_DATA4 */
+#define PKT_INFO_DATA4 11
+#define F_PKT_MEMORY_DATA4(x) (((x) & ((1 << 32) - 1)) << 0)
+#define F_PKT_MEMORY_DATA4_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register PKT_INFO_DATA5 */
+#define PKT_INFO_DATA5 12
+#define F_PKT_MEMORY_DATA5(x) (((x) & ((1 << 32) - 1)) << 0)
+#define F_PKT_MEMORY_DATA5_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register PKT_INFO_DATA6 */
+#define PKT_INFO_DATA6 13
+#define F_PKT_MEMORY_DATA6(x) (((x) & ((1 << 32) - 1)) << 0)
+#define F_PKT_MEMORY_DATA6_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register PKT_INFO_DATA7 */
+#define PKT_INFO_DATA7 14
+#define F_PKT_MEMORY_DATA7(x) (((x) & ((1 << 32) - 1)) << 0)
+#define F_PKT_MEMORY_DATA7_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register PKT_INT_STATUS */
+#define PKT_INT_STATUS 15
+#define F_PKT_RDY_STATUS(x) (((x) & ((1 << 17) - 1)) << 0)
+#define F_PKT_RDY_STATUS_RD(x) (((x) & (((1 << 17) - 1) << 0)) >> 0)
+
+/* register PKT_INT_MASK */
+#define PKT_INT_MASK 16
+#define F_PKT_RDY_MASK(x) (((x) & ((1 << 17) - 1)) << 0)
+#define F_PKT_RDY_MASK_RD(x) (((x) & (((1 << 17) - 1) << 0)) >> 0)
+
+/* register PKT_TRANS_CTRL */
+#define PKT_TRANS_CTRL 17
+#define F_PKT_TRANS_MASK_ERR(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_PKT_TRANS_MASK_ERR_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+#endif /* SINK_PIF */
diff --git a/drivers/mxc/hdp/sink_vif.h b/drivers/mxc/hdp/sink_vif.h
new file mode 100644
index 000000000000..cce0080a81e3
--- /dev/null
+++ b/drivers/mxc/hdp/sink_vif.h
@@ -0,0 +1,285 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright 2018 NXP
+ *
+ ******************************************************************************
+ *
+ * This file was auto-generated. Do not edit it manually.
+ *
+ ******************************************************************************
+ *
+ * sink_vif.h
+ *
+ ******************************************************************************
+ */
+#ifndef SINK_VIF_H_
+#define SINK_VIF_H_
+
+/* register VIDEO_UNPACK_CFG */
+#define VIDEO_UNPACK_CFG 0
+#define F_SW_CD_PHASE(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_SW_CD_PHASE_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_FORCE_SW_CD(x) (((x) & ((1 << 1) - 1)) << 4)
+#define F_FORCE_SW_CD_RD(x) (((x) & (((1 << 1) - 1) << 4)) >> 4)
+#define F_SW_CD_COLOR_DEPTH(x) (((x) & ((1 << 4) - 1)) << 5)
+#define F_SW_CD_COLOR_DEPTH_RD(x) (((x) & (((1 << 4) - 1) << 5)) >> 5)
+#define F_FORCE_SW_PHASE(x) (((x) & ((1 << 1) - 1)) << 9)
+#define F_FORCE_SW_PHASE_RD(x) (((x) & (((1 << 1) - 1) << 9)) >> 9)
+#define F_VIDEO_PIXEL_ENCODING(x) (((x) & ((1 << 2) - 1)) << 10)
+#define F_VIDEO_PIXEL_ENCODING_RD(x) (((x) & (((1 << 2) - 1) << 10)) >> 10)
+
+/* register VIDEO_UNPACK_CTRL */
+#define VIDEO_UNPACK_CTRL 1
+#define F_SW_CD_FSM_CLR(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SW_CD_FSM_CLR_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_CD_ENABLE(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_CD_ENABLE_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_CD_FIFO_AEMPTY_TH(x) (((x) & ((1 << 5) - 1)) << 2)
+#define F_CD_FIFO_AEMPTY_TH_RD(x) (((x) & (((1 << 5) - 1) << 2)) >> 2)
+#define F_FSM_ERROR_ENABLE(x) (((x) & ((1 << 1) - 1)) << 7)
+#define F_FSM_ERROR_ENABLE_RD(x) (((x) & (((1 << 1) - 1) << 7)) >> 7)
+
+/* register VIDEO_UNPACK_STAT */
+#define VIDEO_UNPACK_STAT 2
+#define F_CD_FIFO_OVERRUN(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_CD_FIFO_OVERRUN_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_CD_FIFO_UNDERRUN(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_CD_FIFO_UNDERRUN_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_CD_PHASE(x) (((x) & ((1 << 4) - 1)) << 2)
+#define F_CD_PHASE_RD(x) (((x) & (((1 << 4) - 1) << 2)) >> 2)
+#define F_CD_COLOR_DEPTH(x) (((x) & ((1 << 4) - 1)) << 6)
+#define F_CD_COLOR_DEPTH_RD(x) (((x) & (((1 << 4) - 1) << 6)) >> 6)
+#define F_CD_LAST_PHASE(x) (((x) & ((1 << 4) - 1)) << 10)
+#define F_CD_LAST_PHASE_RD(x) (((x) & (((1 << 4) - 1) << 10)) >> 10)
+#define F_CD_FIFO_EMPTY(x) (((x) & ((1 << 1) - 1)) << 14)
+#define F_CD_FIFO_EMPTY_RD(x) (((x) & (((1 << 1) - 1) << 14)) >> 14)
+#define F_CD_FIFO_FULL(x) (((x) & ((1 << 1) - 1)) << 15)
+#define F_CD_FIFO_FULL_RD(x) (((x) & (((1 << 1) - 1) << 15)) >> 15)
+#define F_CD_STATE(x) (((x) & ((1 << 5) - 1)) << 16)
+#define F_CD_STATE_RD(x) (((x) & (((1 << 5) - 1) << 16)) >> 16)
+
+/* register VANLYZ_CTRL */
+#define VANLYZ_CTRL 4
+#define F_VANLYZ_START(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_VANLYZ_START_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_VANLYZ_RESET(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_VANLYZ_RESET_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_VANLYZ_FRAMES_CHECK_EN(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_VANLYZ_FRAMES_CHECK_EN_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+#define F_VANLYZ_FORMAT_FINDER_EN(x) (((x) & ((1 << 1) - 1)) << 3)
+#define F_VANLYZ_FORMAT_FINDER_EN_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+
+/* register VANLYZ_FRAMES_TO_CHECK */
+#define VANLYZ_FRAMES_TO_CHECK 5
+#define F_VANLYZ_FRAMES_TO_CHECK(x) (((x) & ((1 << 32) - 1)) << 0)
+#define F_VANLYZ_FRAMES_TO_CHECK_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register VANLYZ_CFG_0 */
+#define VANLYZ_CFG_0 6
+#define F_VANLYZ_HSYNC_POLARITY(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_VANLYZ_HSYNC_POLARITY_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_VANLYZ_VSYNC_POLARITY(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_VANLYZ_VSYNC_POLARITY_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_VANLYZ_BITWIDTH(x) (((x) & ((1 << 2) - 1)) << 2)
+#define F_VANLYZ_BITWIDTH_RD(x) (((x) & (((1 << 2) - 1) << 2)) >> 2)
+
+/* register VANLYZ_CFG_1 */
+#define VANLYZ_CFG_1 7
+#define F_VANLYZ_FRONT_PORCH(x) (((x) & ((1 << 16) - 1)) << 0)
+#define F_VANLYZ_FRONT_PORCH_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+#define F_VANLYZ_BACK_PORCH(x) (((x) & ((1 << 16) - 1)) << 16)
+#define F_VANLYZ_BACK_PORCH_RD(x) (((x) & (((1 << 16) - 1) << 16)) >> 16)
+
+/* register VANLYZ_CFG_2 */
+#define VANLYZ_CFG_2 8
+#define F_VANLYZ_ACTIVE_SLOT(x) (((x) & ((1 << 16) - 1)) << 0)
+#define F_VANLYZ_ACTIVE_SLOT_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+#define F_VANLYZ_FRAME_LINES(x) (((x) & ((1 << 16) - 1)) << 16)
+#define F_VANLYZ_FRAME_LINES_RD(x) (((x) & (((1 << 16) - 1) << 16)) >> 16)
+
+/* register VANLYZ_CFG_3 */
+#define VANLYZ_CFG_3 9
+#define F_VANLYZ_LINE_WIDTH(x) (((x) & ((1 << 16) - 1)) << 0)
+#define F_VANLYZ_LINE_WIDTH_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+
+/* register VANLYZ_CFG_4 */
+#define VANLYZ_CFG_4 10
+#define F_VANLYZ_NUM_CLK_CYC(x) (((x) & ((1 << 24) - 1)) << 0)
+#define F_VANLYZ_NUM_CLK_CYC_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+#define F_VANLYZ_VSYNC_LINES(x) (((x) & ((1 << 8) - 1)) << 24)
+#define F_VANLYZ_VSYNC_LINES_RD(x) (((x) & (((1 << 8) - 1) << 24)) >> 24)
+
+/* register VANLYZ_CFG_5 */
+#define VANLYZ_CFG_5 11
+#define F_VANLYZ_3D_MODE(x) (((x) & ((1 << 3) - 1)) << 0)
+#define F_VANLYZ_3D_MODE_RD(x) (((x) & (((1 << 3) - 1) << 0)) >> 0)
+#define F_VANLYZ_EOF_LINES(x) (((x) & ((1 << 8) - 1)) << 3)
+#define F_VANLYZ_EOF_LINES_RD(x) (((x) & (((1 << 8) - 1) << 3)) >> 3)
+#define F_VANLYZ_SOF_LINES(x) (((x) & ((1 << 8) - 1)) << 11)
+#define F_VANLYZ_SOF_LINES_RD(x) (((x) & (((1 << 8) - 1) << 11)) >> 11)
+
+/* register VANLYZ_CLK_METER_REF_CYC */
+#define VANLYZ_CLK_METER_REF_CYC 12
+#define F_VANLYZ_CLK_METER_REF_CYC(x) (((x) & ((1 << 24) - 1)) << 0)
+#define F_VANLYZ_CLK_METER_REF_CYC_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+
+/* register VANLYZ_CLK_METER_MEAS_TOLRNCE */
+#define VANLYZ_CLK_METER_MEAS_TOLRNCE 13
+#define F_VANLYZ_CLK_METER_MEAS_TOLRNCE(x) (((x) & ((1 << 16) - 1)) << 0)
+#define F_VANLYZ_CLK_METER_MEAS_TOLRNCE_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+
+/* register VANLYZ_FORMAT_NUM */
+#define VANLYZ_FORMAT_NUM 14
+#define F_VANLYZ_FORMAT1_NUM(x) (((x) & ((1 << 6) - 1)) << 0)
+#define F_VANLYZ_FORMAT1_NUM_RD(x) (((x) & (((1 << 6) - 1) << 0)) >> 0)
+#define F_VANLYZ_FORMAT2_NUM(x) (((x) & ((1 << 6) - 1)) << 8)
+#define F_VANLYZ_FORMAT2_NUM_RD(x) (((x) & (((1 << 6) - 1) << 8)) >> 8)
+
+/* register VANLYZ_FAILURES */
+#define VANLYZ_FAILURES 15
+#define F_VANLYZ_FAILURES(x) (((x) & ((1 << 16) - 1)) << 0)
+#define F_VANLYZ_FAILURES_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+
+/* register VANLYZ_ST_0 */
+#define VANLYZ_ST_0 16
+#define F_VANLYZ_STATUS_HP(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_VANLYZ_STATUS_HP_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_VANLYZ_STATUS_VP(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_VANLYZ_STATUS_VP_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+
+/* register VANLYZ_ST_1 */
+#define VANLYZ_ST_1 17
+#define F_VANLYZ_STATUS_FRAME_LINES(x) (((x) & ((1 << 16) - 1)) << 0)
+#define F_VANLYZ_STATUS_FRAME_LINES_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+#define F_VANLYZ_STATUS_FP(x) (((x) & ((1 << 16) - 1)) << 16)
+#define F_VANLYZ_STATUS_FP_RD(x) (((x) & (((1 << 16) - 1) << 16)) >> 16)
+
+/* register VANLYZ_ST_2 */
+#define VANLYZ_ST_2 18
+#define F_VANLYZ_STATUS_BP(x) (((x) & ((1 << 16) - 1)) << 0)
+#define F_VANLYZ_STATUS_BP_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+#define F_VANLYZ_STATUS_AS(x) (((x) & ((1 << 16) - 1)) << 16)
+#define F_VANLYZ_STATUS_AS_RD(x) (((x) & (((1 << 16) - 1) << 16)) >> 16)
+
+/* register VANLYZ_STATUS_3 */
+#define VANLYZ_STATUS_3 19
+#define F_VANLYZ_STATUS_LINE_WIDTH(x) (((x) & ((1 << 16) - 1)) << 0)
+#define F_VANLYZ_STATUS_LINE_WIDTH_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+
+/* register VANLYZ_STATUS_4 */
+#define VANLYZ_STATUS_4 20
+#define F_VANLYZ_STATUS_VSYNC_LINES(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_VANLYZ_STATUS_VSYNC_LINES_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+#define F_VANLYZ_STATUS_EOF_LINES(x) (((x) & ((1 << 8) - 1)) << 8)
+#define F_VANLYZ_STATUS_EOF_LINES_RD(x) (((x) & (((1 << 8) - 1) << 8)) >> 8)
+#define F_VANLYZ_STATUS_SOF_LINES(x) (((x) & ((1 << 8) - 1)) << 16)
+#define F_VANLYZ_STATUS_SOF_LINES_RD(x) (((x) & (((1 << 8) - 1) << 16)) >> 16)
+
+/* register VANLYZ_STATUS_5 */
+#define VANLYZ_STATUS_5 21
+#define F_VANLYZ_FORMAT_FINDER_ADD(x) (((x) & ((1 << 6) - 1)) << 0)
+#define F_VANLYZ_FORMAT_FINDER_ADD_RD(x) (((x) & (((1 << 6) - 1) << 0)) >> 0)
+#define F_VANLYZ_FORMAT_FINDER_ACTIVE(x) (((x) & ((1 << 1) - 1)) << 6)
+#define F_VANLYZ_FORMAT_FINDER_ACTIVE_RD(x) (((x) & (((1 << 1) - 1) << 6)) >> 6)
+#define F_VANLYZ_CNT_LINES(x) (((x) & ((1 << 18) - 1)) << 7)
+#define F_VANLYZ_CNT_LINES_RD(x) (((x) & (((1 << 18) - 1) << 7)) >> 7)
+
+/* register VANLYZ_STATUS_6 */
+#define VANLYZ_STATUS_6 22
+#define F_VANLYZ_CNT_VIDEO(x) (((x) & ((1 << 18) - 1)) << 0)
+#define F_VANLYZ_CNT_VIDEO_RD(x) (((x) & (((1 << 18) - 1) << 0)) >> 0)
+
+/* register VANLYZ_STATUS_7 */
+#define VANLYZ_STATUS_7 23
+#define F_VANLYZ_VIDEO_SIZE(x) (((x) & ((1 << 18) - 1)) << 0)
+#define F_VANLYZ_VIDEO_SIZE_RD(x) (((x) & (((1 << 18) - 1) << 0)) >> 0)
+
+/* register VANLYZ_PIC_CFG_0 */
+#define VANLYZ_PIC_CFG_0 24
+#define F_VANLYZ_PIC_R(x) (((x) & ((1 << 16) - 1)) << 0)
+#define F_VANLYZ_PIC_R_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+#define F_VANLYZ_PIC_G(x) (((x) & ((1 << 16) - 1)) << 16)
+#define F_VANLYZ_PIC_G_RD(x) (((x) & (((1 << 16) - 1) << 16)) >> 16)
+
+/* register VANLYZ_PIC_CFG_1 */
+#define VANLYZ_PIC_CFG_1 25
+#define F_VANLYZ_PIC_B(x) (((x) & ((1 << 16) - 1)) << 0)
+#define F_VANLYZ_PIC_B_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+
+/* register VIF_MHL_HD_ERR_INT_MASK */
+#define VIF_MHL_HD_ERR_INT_MASK 26
+#define F_VIF_MHL_HD_ERR_MASK(x) (((x) & ((1 << 20) - 1)) << 0)
+#define F_VIF_MHL_HD_ERR_MASK_RD(x) (((x) & (((1 << 20) - 1) << 0)) >> 0)
+
+/* register VIF_MHL_HD_ERR_INT_STAT */
+#define VIF_MHL_HD_ERR_INT_STAT 27
+#define F_VIF_MHL_HD_ERR_STATUS(x) (((x) & ((1 << 20) - 1)) << 0)
+#define F_VIF_MHL_HD_ERR_STATUS_RD(x) (((x) & (((1 << 20) - 1) << 0)) >> 0)
+
+/* register VIF_IP_DETECT_CTRL */
+#define VIF_IP_DETECT_CTRL 28
+#define F_READ_DTCT_ERR(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_READ_DTCT_ERR_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_IP_DTCT_WIN(x) (((x) & ((1 << 12) - 1)) << 1)
+#define F_IP_DTCT_WIN_RD(x) (((x) & (((1 << 12) - 1) << 1)) >> 1)
+#define F_IP_DTCT_EN(x) (((x) & ((1 << 1) - 1)) << 13)
+#define F_IP_DTCT_EN_RD(x) (((x) & (((1 << 1) - 1) << 13)) >> 13)
+
+/* register VIF_IP_DETECT_ST1 */
+#define VIF_IP_DETECT_ST1 29
+#define F_IP_DTCT_HSYNC2VSYNC_F1(x) (((x) & ((1 << 16) - 1)) << 0)
+#define F_IP_DTCT_HSYNC2VSYNC_F1_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+#define F_IP_DTCT_HSYNC2VSYNC_F2(x) (((x) & ((1 << 16) - 1)) << 16)
+#define F_IP_DTCT_HSYNC2VSYNC_F2_RD(x) (((x) & (((1 << 16) - 1) << 16)) >> 16)
+
+/* register VIF_IP_DETECT_ST2 */
+#define VIF_IP_DETECT_ST2 30
+#define F_IP_STATE(x) (((x) & ((1 << 2) - 1)) << 0)
+#define F_IP_STATE_RD(x) (((x) & (((1 << 2) - 1) << 0)) >> 0)
+#define F_IP_DTCT_ERR(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_IP_DTCT_ERR_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+#define F_IP_DTCT_HJITTER(x) (((x) & ((1 << 1) - 1)) << 3)
+#define F_IP_DTCT_HJITTER_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+#define F_IP_DTCT_VJITTER(x) (((x) & ((1 << 1) - 1)) << 4)
+#define F_IP_DTCT_VJITTER_RD(x) (((x) & (((1 << 1) - 1) << 4)) >> 4)
+#define F_IP_DTCT_IP(x) (((x) & ((1 << 1) - 1)) << 5)
+#define F_IP_DTCT_IP_RD(x) (((x) & (((1 << 1) - 1) << 5)) >> 5)
+#define F_IP_DTCT_FIELD(x) (((x) & ((1 << 1) - 1)) << 6)
+#define F_IP_DTCT_FIELD_RD(x) (((x) & (((1 << 1) - 1) << 6)) >> 6)
+
+#endif /* SINK_VIF */
diff --git a/drivers/mxc/hdp/source_aif_decoder.h b/drivers/mxc/hdp/source_aif_decoder.h
new file mode 100644
index 000000000000..f6c1636cf5c4
--- /dev/null
+++ b/drivers/mxc/hdp/source_aif_decoder.h
@@ -0,0 +1,422 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * This file was auto-generated. Do not edit it manually.
+ *
+ ******************************************************************************
+ *
+ * source_aif_decoder.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef SOURCE_AIF_DECODER_H_
+#define SOURCE_AIF_DECODER_H_
+
+/* register AUDIO_SRC_CNTL */
+#define AUDIO_SRC_CNTL 0
+#define F_SW_RST(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SW_RST_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_I2S_DEC_START(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_I2S_DEC_START_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_I2S_BLOCK_START_FORCE(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_I2S_BLOCK_START_FORCE_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+#define F_SPDIF_TS_EN(x) (((x) & ((1 << 1) - 1)) << 3)
+#define F_SPDIF_TS_EN_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+#define F_I2S_TS_EN(x) (((x) & ((1 << 1) - 1)) << 4)
+#define F_I2S_TS_EN_RD(x) (((x) & (((1 << 1) - 1) << 4)) >> 4)
+#define F_VALID_BITS_FORCE(x) (((x) & ((1 << 1) - 1)) << 5)
+#define F_VALID_BITS_FORCE_RD(x) (((x) & (((1 << 1) - 1) << 5)) >> 5)
+#define F_VALID_ALL(x) (((x) & ((1 << 1) - 1)) << 6)
+#define F_VALID_ALL_RD(x) (((x) & (((1 << 1) - 1) << 6)) >> 6)
+
+/* register AUDIO_SRC_CNFG */
+#define AUDIO_SRC_CNFG 1
+#define F_LOW_INDEX_MSB(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_LOW_INDEX_MSB_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_WS_POLARITY(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_WS_POLARITY_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_AUDIO_CH_NUM(x) (((x) & ((1 << 5) - 1)) << 2)
+#define F_AUDIO_CH_NUM_RD(x) (((x) & (((1 << 5) - 1) << 2)) >> 2)
+#define F_AUDIO_SAMPLE_JUST(x) (((x) & ((1 << 2) - 1)) << 7)
+#define F_AUDIO_SAMPLE_JUST_RD(x) (((x) & (((1 << 2) - 1) << 7)) >> 7)
+#define F_AUDIO_SAMPLE_WIDTH(x) (((x) & ((1 << 2) - 1)) << 9)
+#define F_AUDIO_SAMPLE_WIDTH_RD(x) (((x) & (((1 << 2) - 1) << 9)) >> 9)
+#define F_TRANS_SMPL_WIDTH(x) (((x) & ((1 << 2) - 1)) << 11)
+#define F_TRANS_SMPL_WIDTH_RD(x) (((x) & (((1 << 2) - 1) << 11)) >> 11)
+#define F_AUDIO_CHANNEL_TYPE(x) (((x) & ((1 << 4) - 1)) << 13)
+#define F_AUDIO_CHANNEL_TYPE_RD(x) (((x) & (((1 << 4) - 1) << 13)) >> 13)
+#define F_I2S_DEC_PORT_EN(x) (((x) & ((1 << 4) - 1)) << 17)
+#define F_I2S_DEC_PORT_EN_RD(x) (((x) & (((1 << 4) - 1) << 17)) >> 17)
+
+/* register COM_CH_STTS_BITS */
+#define COM_CH_STTS_BITS 2
+#define F_BYTE0(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_BYTE0_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+#define F_CATEGORY_CODE(x) (((x) & ((1 << 8) - 1)) << 8)
+#define F_CATEGORY_CODE_RD(x) (((x) & (((1 << 8) - 1) << 8)) >> 8)
+#define F_SAMPLING_FREQ(x) (((x) & ((1 << 4) - 1)) << 16)
+#define F_SAMPLING_FREQ_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+#define F_CLOCK_ACCURACY(x) (((x) & ((1 << 4) - 1)) << 20)
+#define F_CLOCK_ACCURACY_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+#define F_ORIGINAL_SAMP_FREQ(x) (((x) & ((1 << 4) - 1)) << 24)
+#define F_ORIGINAL_SAMP_FREQ_RD(x) (((x) & (((1 << 4) - 1) << 24)) >> 24)
+
+/* register STTS_BIT_CH01 */
+#define STTS_BIT_CH01 3
+#define F_SOURCE_NUM_CH0(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_SOURCE_NUM_CH0_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_CHANNEL_NUM_CH0(x) (((x) & ((1 << 4) - 1)) << 4)
+#define F_CHANNEL_NUM_CH0_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+#define F_WORD_LENGTH_CH0(x) (((x) & ((1 << 4) - 1)) << 8)
+#define F_WORD_LENGTH_CH0_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+#define F_SOURCE_NUM_CH1(x) (((x) & ((1 << 4) - 1)) << 12)
+#define F_SOURCE_NUM_CH1_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+#define F_CHANNEL_NUM_CH1(x) (((x) & ((1 << 4) - 1)) << 16)
+#define F_CHANNEL_NUM_CH1_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+#define F_WORD_LENGTH_CH1(x) (((x) & ((1 << 4) - 1)) << 20)
+#define F_WORD_LENGTH_CH1_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+#define F_VALID_BITS1_0(x) (((x) & ((1 << 2) - 1)) << 24)
+#define F_VALID_BITS1_0_RD(x) (((x) & (((1 << 2) - 1) << 24)) >> 24)
+
+/* register STTS_BIT_CH23 */
+#define STTS_BIT_CH23 4
+#define F_SOURCE_NUM_CH2(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_SOURCE_NUM_CH2_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_CHANNEL_NUM_CH2(x) (((x) & ((1 << 4) - 1)) << 4)
+#define F_CHANNEL_NUM_CH2_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+#define F_WORD_LENGTH_CH2(x) (((x) & ((1 << 4) - 1)) << 8)
+#define F_WORD_LENGTH_CH2_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+#define F_SOURCE_NUM_CH3(x) (((x) & ((1 << 4) - 1)) << 12)
+#define F_SOURCE_NUM_CH3_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+#define F_CHANNEL_NUM_CH3(x) (((x) & ((1 << 4) - 1)) << 16)
+#define F_CHANNEL_NUM_CH3_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+#define F_WORD_LENGTH_CH3(x) (((x) & ((1 << 4) - 1)) << 20)
+#define F_WORD_LENGTH_CH3_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+#define F_VALID_BITS3_2(x) (((x) & ((1 << 2) - 1)) << 24)
+#define F_VALID_BITS3_2_RD(x) (((x) & (((1 << 2) - 1) << 24)) >> 24)
+
+/* register STTS_BIT_CH45 */
+#define STTS_BIT_CH45 5
+#define F_SOURCE_NUM_CH4(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_SOURCE_NUM_CH4_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_CHANNEL_NUM_CH4(x) (((x) & ((1 << 4) - 1)) << 4)
+#define F_CHANNEL_NUM_CH4_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+#define F_WORD_LENGTH_CH4(x) (((x) & ((1 << 4) - 1)) << 8)
+#define F_WORD_LENGTH_CH4_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+#define F_SOURCE_NUM_CH5(x) (((x) & ((1 << 4) - 1)) << 12)
+#define F_SOURCE_NUM_CH5_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+#define F_CHANNEL_NUM_CH5(x) (((x) & ((1 << 4) - 1)) << 16)
+#define F_CHANNEL_NUM_CH5_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+#define F_WORD_LENGTH_CH5(x) (((x) & ((1 << 4) - 1)) << 20)
+#define F_WORD_LENGTH_CH5_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+#define F_VALID_BITS5_4(x) (((x) & ((1 << 2) - 1)) << 24)
+#define F_VALID_BITS5_4_RD(x) (((x) & (((1 << 2) - 1) << 24)) >> 24)
+
+/* register STTS_BIT_CH67 */
+#define STTS_BIT_CH67 6
+#define F_SOURCE_NUM_CH6(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_SOURCE_NUM_CH6_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_CHANNEL_NUM_CH6(x) (((x) & ((1 << 4) - 1)) << 4)
+#define F_CHANNEL_NUM_CH6_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+#define F_WORD_LENGTH_CH6(x) (((x) & ((1 << 4) - 1)) << 8)
+#define F_WORD_LENGTH_CH6_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+#define F_SOURCE_NUM_CH7(x) (((x) & ((1 << 4) - 1)) << 12)
+#define F_SOURCE_NUM_CH7_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+#define F_CHANNEL_NUM_CH7(x) (((x) & ((1 << 4) - 1)) << 16)
+#define F_CHANNEL_NUM_CH7_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+#define F_WORD_LENGTH_CH7(x) (((x) & ((1 << 4) - 1)) << 20)
+#define F_WORD_LENGTH_CH7_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+#define F_VALID_BITS7_6(x) (((x) & ((1 << 2) - 1)) << 24)
+#define F_VALID_BITS7_6_RD(x) (((x) & (((1 << 2) - 1) << 24)) >> 24)
+
+/* register STTS_BIT_CH89 */
+#define STTS_BIT_CH89 7
+#define F_SOURCE_NUM_CH8(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_SOURCE_NUM_CH8_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_CHANNEL_NUM_CH8(x) (((x) & ((1 << 4) - 1)) << 4)
+#define F_CHANNEL_NUM_CH8_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+#define F_WORD_LENGTH_CH8(x) (((x) & ((1 << 4) - 1)) << 8)
+#define F_WORD_LENGTH_CH8_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+#define F_SOURCE_NUM_CH9(x) (((x) & ((1 << 4) - 1)) << 12)
+#define F_SOURCE_NUM_CH9_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+#define F_CHANNEL_NUM_CH9(x) (((x) & ((1 << 4) - 1)) << 16)
+#define F_CHANNEL_NUM_CH9_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+#define F_WORD_LENGTH_CH9(x) (((x) & ((1 << 4) - 1)) << 20)
+#define F_WORD_LENGTH_CH9_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+#define F_VALID_BITS9_8(x) (((x) & ((1 << 2) - 1)) << 24)
+#define F_VALID_BITS9_8_RD(x) (((x) & (((1 << 2) - 1) << 24)) >> 24)
+
+/* register STTS_BIT_CH1011 */
+#define STTS_BIT_CH1011 8
+#define F_SOURCE_NUM_CH10(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_SOURCE_NUM_CH10_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_CHANNEL_NUM_CH10(x) (((x) & ((1 << 4) - 1)) << 4)
+#define F_CHANNEL_NUM_CH10_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+#define F_WORD_LENGTH_CH10(x) (((x) & ((1 << 4) - 1)) << 8)
+#define F_WORD_LENGTH_CH10_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+#define F_SOURCE_NUM_CH11(x) (((x) & ((1 << 4) - 1)) << 12)
+#define F_SOURCE_NUM_CH11_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+#define F_CHANNEL_NUM_CH11(x) (((x) & ((1 << 4) - 1)) << 16)
+#define F_CHANNEL_NUM_CH11_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+#define F_WORD_LENGTH_CH11(x) (((x) & ((1 << 4) - 1)) << 20)
+#define F_WORD_LENGTH_CH11_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+#define F_VALID_BITS11_10(x) (((x) & ((1 << 2) - 1)) << 24)
+#define F_VALID_BITS11_10_RD(x) (((x) & (((1 << 2) - 1) << 24)) >> 24)
+
+/* register STTS_BIT_CH1213 */
+#define STTS_BIT_CH1213 9
+#define F_SOURCE_NUM_CH12(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_SOURCE_NUM_CH12_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_CHANNEL_NUM_CH12(x) (((x) & ((1 << 4) - 1)) << 4)
+#define F_CHANNEL_NUM_CH12_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+#define F_WORD_LENGTH_CH12(x) (((x) & ((1 << 4) - 1)) << 8)
+#define F_WORD_LENGTH_CH12_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+#define F_SOURCE_NUM_CH13(x) (((x) & ((1 << 4) - 1)) << 12)
+#define F_SOURCE_NUM_CH13_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+#define F_CHANNEL_NUM_CH13(x) (((x) & ((1 << 4) - 1)) << 16)
+#define F_CHANNEL_NUM_CH13_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+#define F_WORD_LENGTH_CH13(x) (((x) & ((1 << 4) - 1)) << 20)
+#define F_WORD_LENGTH_CH13_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+#define F_VALID_BITS13_12(x) (((x) & ((1 << 2) - 1)) << 24)
+#define F_VALID_BITS13_12_RD(x) (((x) & (((1 << 2) - 1) << 24)) >> 24)
+
+/* register STTS_BIT_CH1415 */
+#define STTS_BIT_CH1415 10
+#define F_SOURCE_NUM_CH14(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_SOURCE_NUM_CH14_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_CHANNEL_NUM_CH14(x) (((x) & ((1 << 4) - 1)) << 4)
+#define F_CHANNEL_NUM_CH14_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+#define F_WORD_LENGTH_CH14(x) (((x) & ((1 << 4) - 1)) << 8)
+#define F_WORD_LENGTH_CH14_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+#define F_SOURCE_NUM_CH15(x) (((x) & ((1 << 4) - 1)) << 12)
+#define F_SOURCE_NUM_CH15_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+#define F_CHANNEL_NUM_CH15(x) (((x) & ((1 << 4) - 1)) << 16)
+#define F_CHANNEL_NUM_CH15_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+#define F_WORD_LENGTH_CH15(x) (((x) & ((1 << 4) - 1)) << 20)
+#define F_WORD_LENGTH_CH15_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+#define F_VALID_BITS15_14(x) (((x) & ((1 << 2) - 1)) << 24)
+#define F_VALID_BITS15_14_RD(x) (((x) & (((1 << 2) - 1) << 24)) >> 24)
+
+/* register STTS_BIT_CH1617 */
+#define STTS_BIT_CH1617 11
+#define F_SOURCE_NUM_CH16(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_SOURCE_NUM_CH16_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_CHANNEL_NUM_CH16(x) (((x) & ((1 << 4) - 1)) << 4)
+#define F_CHANNEL_NUM_CH16_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+#define F_WORD_LENGTH_CH16(x) (((x) & ((1 << 4) - 1)) << 8)
+#define F_WORD_LENGTH_CH16_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+#define F_SOURCE_NUM_CH17(x) (((x) & ((1 << 4) - 1)) << 12)
+#define F_SOURCE_NUM_CH17_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+#define F_CHANNEL_NUM_CH17(x) (((x) & ((1 << 4) - 1)) << 16)
+#define F_CHANNEL_NUM_CH17_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+#define F_WORD_LENGTH_CH17(x) (((x) & ((1 << 4) - 1)) << 20)
+#define F_WORD_LENGTH_CH17_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+#define F_VALID_BITS17_16(x) (((x) & ((1 << 2) - 1)) << 24)
+#define F_VALID_BITS17_16_RD(x) (((x) & (((1 << 2) - 1) << 24)) >> 24)
+
+/* register STTS_BIT_CH1819 */
+#define STTS_BIT_CH1819 12
+#define F_SOURCE_NUM_CH18(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_SOURCE_NUM_CH18_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_CHANNEL_NUM_CH18(x) (((x) & ((1 << 4) - 1)) << 4)
+#define F_CHANNEL_NUM_CH18_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+#define F_WORD_LENGTH_CH18(x) (((x) & ((1 << 4) - 1)) << 8)
+#define F_WORD_LENGTH_CH18_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+#define F_SOURCE_NUM_CH19(x) (((x) & ((1 << 4) - 1)) << 12)
+#define F_SOURCE_NUM_CH19_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+#define F_CHANNEL_NUM_CH19(x) (((x) & ((1 << 4) - 1)) << 16)
+#define F_CHANNEL_NUM_CH19_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+#define F_WORD_LENGTH_CH19(x) (((x) & ((1 << 4) - 1)) << 20)
+#define F_WORD_LENGTH_CH19_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+#define F_VALID_BITS19_18(x) (((x) & ((1 << 2) - 1)) << 24)
+#define F_VALID_BITS19_18_RD(x) (((x) & (((1 << 2) - 1) << 24)) >> 24)
+
+/* register STTS_BIT_CH2021 */
+#define STTS_BIT_CH2021 13
+#define F_SOURCE_NUM_CH20(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_SOURCE_NUM_CH20_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_CHANNEL_NUM_CH20(x) (((x) & ((1 << 4) - 1)) << 4)
+#define F_CHANNEL_NUM_CH20_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+#define F_WORD_LENGTH_CH20(x) (((x) & ((1 << 4) - 1)) << 8)
+#define F_WORD_LENGTH_CH20_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+#define F_SOURCE_NUM_CH21(x) (((x) & ((1 << 4) - 1)) << 12)
+#define F_SOURCE_NUM_CH21_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+#define F_CHANNEL_NUM_CH21(x) (((x) & ((1 << 4) - 1)) << 16)
+#define F_CHANNEL_NUM_CH21_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+#define F_WORD_LENGTH_CH21(x) (((x) & ((1 << 4) - 1)) << 20)
+#define F_WORD_LENGTH_CH21_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+#define F_VALID_BITS21_20(x) (((x) & ((1 << 2) - 1)) << 24)
+#define F_VALID_BITS21_20_RD(x) (((x) & (((1 << 2) - 1) << 24)) >> 24)
+
+/* register STTS_BIT_CH2223 */
+#define STTS_BIT_CH2223 14
+#define F_SOURCE_NUM_CH22(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_SOURCE_NUM_CH22_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_CHANNEL_NUM_CH22(x) (((x) & ((1 << 4) - 1)) << 4)
+#define F_CHANNEL_NUM_CH22_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+#define F_WORD_LENGTH_CH22(x) (((x) & ((1 << 4) - 1)) << 8)
+#define F_WORD_LENGTH_CH22_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+#define F_SOURCE_NUM_CH23(x) (((x) & ((1 << 4) - 1)) << 12)
+#define F_SOURCE_NUM_CH23_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+#define F_CHANNEL_NUM_CH23(x) (((x) & ((1 << 4) - 1)) << 16)
+#define F_CHANNEL_NUM_CH23_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+#define F_WORD_LENGTH_CH23(x) (((x) & ((1 << 4) - 1)) << 20)
+#define F_WORD_LENGTH_CH23_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+#define F_VALID_BITS23_22(x) (((x) & ((1 << 2) - 1)) << 24)
+#define F_VALID_BITS23_22_RD(x) (((x) & (((1 << 2) - 1) << 24)) >> 24)
+
+/* register STTS_BIT_CH2425 */
+#define STTS_BIT_CH2425 15
+#define F_SOURCE_NUM_CH24(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_SOURCE_NUM_CH24_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_CHANNEL_NUM_CH24(x) (((x) & ((1 << 4) - 1)) << 4)
+#define F_CHANNEL_NUM_CH24_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+#define F_WORD_LENGTH_CH24(x) (((x) & ((1 << 4) - 1)) << 8)
+#define F_WORD_LENGTH_CH24_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+#define F_SOURCE_NUM_CH25(x) (((x) & ((1 << 4) - 1)) << 12)
+#define F_SOURCE_NUM_CH25_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+#define F_CHANNEL_NUM_CH25(x) (((x) & ((1 << 4) - 1)) << 16)
+#define F_CHANNEL_NUM_CH25_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+#define F_WORD_LENGTH_CH25(x) (((x) & ((1 << 4) - 1)) << 20)
+#define F_WORD_LENGTH_CH25_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+#define F_VALID_BITS25_24(x) (((x) & ((1 << 2) - 1)) << 24)
+#define F_VALID_BITS25_24_RD(x) (((x) & (((1 << 2) - 1) << 24)) >> 24)
+
+/* register STTS_BIT_CH2627 */
+#define STTS_BIT_CH2627 16
+#define F_SOURCE_NUM_CH26(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_SOURCE_NUM_CH26_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_CHANNEL_NUM_CH26(x) (((x) & ((1 << 4) - 1)) << 4)
+#define F_CHANNEL_NUM_CH26_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+#define F_WORD_LENGTH_CH26(x) (((x) & ((1 << 4) - 1)) << 8)
+#define F_WORD_LENGTH_CH26_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+#define F_SOURCE_NUM_CH27(x) (((x) & ((1 << 4) - 1)) << 12)
+#define F_SOURCE_NUM_CH27_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+#define F_CHANNEL_NUM_CH27(x) (((x) & ((1 << 4) - 1)) << 16)
+#define F_CHANNEL_NUM_CH27_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+#define F_WORD_LENGTH_CH27(x) (((x) & ((1 << 4) - 1)) << 20)
+#define F_WORD_LENGTH_CH27_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+#define F_VALID_BITS27_26(x) (((x) & ((1 << 2) - 1)) << 24)
+#define F_VALID_BITS27_26_RD(x) (((x) & (((1 << 2) - 1) << 24)) >> 24)
+
+/* register STTS_BIT_CH2829 */
+#define STTS_BIT_CH2829 17
+#define F_SOURCE_NUM_CH28(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_SOURCE_NUM_CH28_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_CHANNEL_NUM_CH28(x) (((x) & ((1 << 4) - 1)) << 4)
+#define F_CHANNEL_NUM_CH28_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+#define F_WORD_LENGTH_CH28(x) (((x) & ((1 << 4) - 1)) << 8)
+#define F_WORD_LENGTH_CH28_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+#define F_SOURCE_NUM_CH29(x) (((x) & ((1 << 4) - 1)) << 12)
+#define F_SOURCE_NUM_CH29_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+#define F_CHANNEL_NUM_CH29(x) (((x) & ((1 << 4) - 1)) << 16)
+#define F_CHANNEL_NUM_CH29_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+#define F_WORD_LENGTH_CH29(x) (((x) & ((1 << 4) - 1)) << 20)
+#define F_WORD_LENGTH_CH29_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+#define F_VALID_BITS29_28(x) (((x) & ((1 << 2) - 1)) << 24)
+#define F_VALID_BITS29_28_RD(x) (((x) & (((1 << 2) - 1) << 24)) >> 24)
+
+/* register STTS_BIT_CH3031 */
+#define STTS_BIT_CH3031 18
+#define F_SOURCE_NUM_CH30(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_SOURCE_NUM_CH30_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_CHANNEL_NUM_CH30(x) (((x) & ((1 << 4) - 1)) << 4)
+#define F_CHANNEL_NUM_CH30_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+#define F_WORD_LENGTH_CH30(x) (((x) & ((1 << 4) - 1)) << 8)
+#define F_WORD_LENGTH_CH30_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+#define F_SOURCE_NUM_CH31(x) (((x) & ((1 << 4) - 1)) << 12)
+#define F_SOURCE_NUM_CH31_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+#define F_CHANNEL_NUM_CH31(x) (((x) & ((1 << 4) - 1)) << 16)
+#define F_CHANNEL_NUM_CH31_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+#define F_WORD_LENGTH_CH31(x) (((x) & ((1 << 4) - 1)) << 20)
+#define F_WORD_LENGTH_CH31_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+#define F_VALID_BITS31_30(x) (((x) & ((1 << 2) - 1)) << 24)
+#define F_VALID_BITS31_30_RD(x) (((x) & (((1 << 2) - 1) << 24)) >> 24)
+
+/* register SPDIF_CTRL_ADDR */
+#define SPDIF_CTRL_ADDR 19
+#define F_SPDIF_JITTER_AVG_WIN(x) (((x) & ((1 << 3) - 1)) << 0)
+#define F_SPDIF_JITTER_AVG_WIN_RD(x) (((x) & (((1 << 3) - 1) << 0)) >> 0)
+#define F_SPDIF_JITTER_THRSH(x) (((x) & ((1 << 8) - 1)) << 3)
+#define F_SPDIF_JITTER_THRSH_RD(x) (((x) & (((1 << 8) - 1) << 3)) >> 3)
+#define F_SPDIF_FIFO_MID_RANGE(x) (((x) & ((1 << 8) - 1)) << 11)
+#define F_SPDIF_FIFO_MID_RANGE_RD(x) (((x) & (((1 << 8) - 1) << 11)) >> 11)
+#define F_SPDIF_JITTER_BYPASS(x) (((x) & ((1 << 1) - 1)) << 19)
+#define F_SPDIF_JITTER_BYPASS_RD(x) (((x) & (((1 << 1) - 1) << 19)) >> 19)
+#define F_SPDIF_AVG_SEL(x) (((x) & ((1 << 1) - 1)) << 20)
+#define F_SPDIF_AVG_SEL_RD(x) (((x) & (((1 << 1) - 1) << 20)) >> 20)
+#define F_SPDIF_ENABLE(x) (((x) & ((1 << 1) - 1)) << 21)
+#define F_SPDIF_ENABLE_RD(x) (((x) & (((1 << 1) - 1) << 21)) >> 21)
+#define F_SPDIF_JITTER_STATUS(x) (((x) & ((1 << 4) - 1)) << 22)
+#define F_SPDIF_JITTER_STATUS_RD(x) (((x) & (((1 << 4) - 1) << 22)) >> 22)
+
+/* register SPDIF_CH1_CS_3100_ADDR */
+#define SPDIF_CH1_CS_3100_ADDR 20
+#define F_SPDIF_CH1_ST_STTS_BITS3100(x) (((x) & ((1 << 32) - 1)) << 0)
+#define F_SPDIF_CH1_ST_STTS_BITS3100_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register SPDIF_CH1_CS_6332_ADDR */
+#define SPDIF_CH1_CS_6332_ADDR 21
+#define F_SPDIF_CH1_ST_STTS_BITS6332(x) (((x) & ((1 << 32) - 1)) << 0)
+#define F_SPDIF_CH1_ST_STTS_BITS6332_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register SPDIF_CH1_CS_9564_ADDR */
+#define SPDIF_CH1_CS_9564_ADDR 22
+#define F_SPDIF_CH1_ST_STTS_BITS9564(x) (((x) & ((1 << 32) - 1)) << 0)
+#define F_SPDIF_CH1_ST_STTS_BITS9564_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register SPDIF_CH1_CS_12796_ADDR */
+#define SPDIF_CH1_CS_12796_ADDR 23
+#define F_SPDIF_CH1_ST_STTS_BITS12796(x) (((x) & ((1 << 32) - 1)) << 0)
+#define F_SPDIF_CH1_ST_STTS_BITS12796_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register SPDIF_CH1_CS_159128_ADDR */
+#define SPDIF_CH1_CS_159128_ADDR 24
+#define F_SPDIF_CH1_ST_STTS_BITS159128(x) (((x) & ((1 << 32) - 1)) << 0)
+#define F_SPDIF_CH1_ST_STTS_BITS159128_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register SPDIF_CH1_CS_191160_ADDR */
+#define SPDIF_CH1_CS_191160_ADDR 25
+#define F_SPDIF_CH1_ST_STTS_BITS191160(x) (((x) & ((1 << 32) - 1)) << 0)
+#define F_SPDIF_CH1_ST_STTS_BITS191160_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register SPDIF_CH2_CS_3100_ADDR */
+#define SPDIF_CH2_CS_3100_ADDR 26
+#define F_SPDIF_CH2_ST_STTS_BITS3100(x) (((x) & ((1 << 32) - 1)) << 0)
+#define F_SPDIF_CH2_ST_STTS_BITS3100_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register SPDIF_CH2_CS_6332_ADDR */
+#define SPDIF_CH2_CS_6332_ADDR 27
+#define F_SPDIF_CH2_ST_STTS_BITS6332(x) (((x) & ((1 << 32) - 1)) << 0)
+#define F_SPDIF_CH2_ST_STTS_BITS6332_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register SPDIF_CH2_CS_9564_ADDR */
+#define SPDIF_CH2_CS_9564_ADDR 28
+#define F_SPDIF_CH2_ST_STTS_BITS9564(x) (((x) & ((1 << 32) - 1)) << 0)
+#define F_SPDIF_CH2_ST_STTS_BITS9564_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register SPDIF_CH2_CS_12796_ADDR */
+#define SPDIF_CH2_CS_12796_ADDR 29
+#define F_SPDIF_CH2_ST_STTS_BITS12796(x) (((x) & ((1 << 32) - 1)) << 0)
+#define F_SPDIF_CH2_ST_STTS_BITS12796_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register SPDIF_CH2_CS_159128_ADDR */
+#define SPDIF_CH2_CS_159128_ADDR 30
+#define F_SPDIF_CH2_ST_STTS_BITS159128(x) (((x) & ((1 << 32) - 1)) << 0)
+#define F_SPDIF_CH2_ST_STTS_BITS159128_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register SPDIF_CH2_CS_191160_ADDR */
+#define SPDIF_CH2_CS_191160_ADDR 31
+#define F_SPDIF_CH2_ST_STTS_BITS191160(x) (((x) & ((1 << 32) - 1)) << 0)
+#define F_SPDIF_CH2_ST_STTS_BITS191160_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+#endif //SOURCE_AIF_DECODER
diff --git a/drivers/mxc/hdp/source_aif_smpl2pckt.h b/drivers/mxc/hdp/source_aif_smpl2pckt.h
new file mode 100644
index 000000000000..e7e78aef8992
--- /dev/null
+++ b/drivers/mxc/hdp/source_aif_smpl2pckt.h
@@ -0,0 +1,83 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * This file was auto-generated. Do not edit it manually.
+ *
+ ******************************************************************************
+ *
+ * source_aif_smpl2pckt.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef SOURCE_AIF_SMPL2PCKT_H_
+#define SOURCE_AIF_SMPL2PCKT_H_
+
+/* register SMPL2PKT_CNTL */
+#define SMPL2PKT_CNTL 0
+#define F_SW_RST(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SW_RST_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_SMPL2PKT_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_SMPL2PKT_EN_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+
+/* register SMPL2PKT_CNFG */
+#define SMPL2PKT_CNFG 1
+#define F_MAX_NUM_CH(x) (((x) & ((1 << 5) - 1)) << 0)
+#define F_MAX_NUM_CH_RD(x) (((x) & (((1 << 5) - 1) << 0)) >> 0)
+#define F_NUM_OF_I2S_PORTS_S(x) (((x) & ((1 << 2) - 1)) << 5)
+#define F_NUM_OF_I2S_PORTS_RD_S(x) (((x) & (((1 << 2) - 1) << 5)) >> 5)
+#define F_AUDIO_TYPE(x) (((x) & ((1 << 4) - 1)) << 7)
+#define F_AUDIO_TYPE_RD(x) (((x) & (((1 << 4) - 1) << 7)) >> 7)
+#define F_CFG_SUB_PCKT_NUM(x) (((x) & ((1 << 3) - 1)) << 11)
+#define F_CFG_SUB_PCKT_NUM_RD(x) (((x) & (((1 << 3) - 1) << 11)) >> 11)
+#define F_CFG_BLOCK_LPCM_FIRST_PKT(x) (((x) & ((1 << 1) - 1)) << 14)
+#define F_CFG_BLOCK_LPCM_FIRST_PKT_RD(x) (((x) & (((1 << 1) - 1) << 14)) >> 14)
+#define F_CFG_EN_AUTO_SUB_PCKT_NUM(x) (((x) & ((1 << 1) - 1)) << 15)
+#define F_CFG_EN_AUTO_SUB_PCKT_NUM_RD(x) (((x) & (((1 << 1) - 1) << 15)) >> 15)
+#define F_CFG_SAMPLE_PRESENT(x) (((x) & ((1 << 4) - 1)) << 16)
+#define F_CFG_SAMPLE_PRESENT_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+#define F_CFG_SAMPLE_PRESENT_FORCE(x) (((x) & ((1 << 1) - 1)) << 20)
+#define F_CFG_SAMPLE_PRESENT_FORCE_RD(x) (((x) & (((1 << 1) - 1) << 20)) >> 20)
+
+/* register FIFO_CNTL */
+#define FIFO_CNTL 2
+#define F_FIFO_SW_RST(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_FIFO_SW_RST_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_SYNC_WR_TO_CH_ZERO(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_SYNC_WR_TO_CH_ZERO_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_FIFO_DIR(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_FIFO_DIR_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+#define F_FIFO_EMPTY_CALC(x) (((x) & ((1 << 1) - 1)) << 3)
+#define F_FIFO_EMPTY_CALC_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+#define F_CFG_DIS_PORT3(x) (((x) & ((1 << 1) - 1)) << 4)
+#define F_CFG_DIS_PORT3_RD(x) (((x) & (((1 << 1) - 1) << 4)) >> 4)
+
+/* register FIFO_STTS */
+#define FIFO_STTS 3
+#define F_WFULL(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_WFULL_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_REMPTY(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_REMPTY_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_OVERRUN(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_OVERRUN_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+#define F_UNDERRUN(x) (((x) & ((1 << 1) - 1)) << 3)
+#define F_UNDERRUN_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+
+/* register SUB_PCKT_THRSH */
+#define SUB_PCKT_THRSH 4
+#define F_CFG_MEM_FIFO_THRSH1(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_CFG_MEM_FIFO_THRSH1_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+#define F_CFG_MEM_FIFO_THRSH2(x) (((x) & ((1 << 8) - 1)) << 8)
+#define F_CFG_MEM_FIFO_THRSH2_RD(x) (((x) & (((1 << 8) - 1) << 8)) >> 8)
+#define F_CFG_MEM_FIFO_THRSH3(x) (((x) & ((1 << 8) - 1)) << 16)
+#define F_CFG_MEM_FIFO_THRSH3_RD(x) (((x) & (((1 << 8) - 1) << 16)) >> 16)
+
+#endif //SOURCE_AIF_SMPL2PCKT
diff --git a/drivers/mxc/hdp/source_car.h b/drivers/mxc/hdp/source_car.h
new file mode 100644
index 000000000000..7f61a2ab6555
--- /dev/null
+++ b/drivers/mxc/hdp/source_car.h
@@ -0,0 +1,143 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * This file was auto-generated. Do not edit it manually.
+ *
+ ******************************************************************************
+ *
+ * source_car.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef SOURCE_CAR_H_
+#define SOURCE_CAR_H_
+
+/* register SOURCE_HDTX_CAR */
+#define SOURCE_HDTX_CAR 0
+#define F_HDTX_PIXEL_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_HDTX_PIXEL_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_HDTX_PIXEL_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_HDTX_PIXEL_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_HDTX_SYS_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_HDTX_SYS_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+#define F_HDTX_SYS_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 3)
+#define F_HDTX_SYS_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+#define F_HDTX_PHY_DATA_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 4)
+#define F_HDTX_PHY_DATA_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 4)) >> 4)
+#define F_HDTX_PHY_DATA_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 5)
+#define F_HDTX_PHY_DATA_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 5)) >> 5)
+#define F_HDTX_PHY_CHAR_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 6)
+#define F_HDTX_PHY_CHAR_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 6)) >> 6)
+#define F_HDTX_PHY_CHAR_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 7)
+#define F_HDTX_PHY_CHAR_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 7)) >> 7)
+
+/* register SOURCE_DPTX_CAR */
+#define SOURCE_DPTX_CAR 1
+#define F_CFG_DPTX_VIF_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_CFG_DPTX_VIF_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_CFG_DPTX_VIF_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_CFG_DPTX_VIF_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_DPTX_SYS_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_DPTX_SYS_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+#define F_DPTX_SYS_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 3)
+#define F_DPTX_SYS_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+#define F_SOURCE_AUX_SYS_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 4)
+#define F_SOURCE_AUX_SYS_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 4)) >> 4)
+#define F_SOURCE_AUX_SYS_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 5)
+#define F_SOURCE_AUX_SYS_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 5)) >> 5)
+#define F_DPTX_PHY_CHAR_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 6)
+#define F_DPTX_PHY_CHAR_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 6)) >> 6)
+#define F_DPTX_PHY_CHAR_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 7)
+#define F_DPTX_PHY_CHAR_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 7)) >> 7)
+#define F_DPTX_PHY_DATA_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 8)
+#define F_DPTX_PHY_DATA_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 8)) >> 8)
+#define F_DPTX_PHY_DATA_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 9)
+#define F_DPTX_PHY_DATA_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 9)) >> 9)
+#define F_DPTX_FRMR_DATA_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 10)
+#define F_DPTX_FRMR_DATA_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 10)) >> 10)
+#define F_DPTX_FRMR_DATA_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 11)
+#define F_DPTX_FRMR_DATA_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 11)) >> 11)
+
+/* register SOURCE_PHY_CAR */
+#define SOURCE_PHY_CAR 2
+#define F_SOURCE_PHY_DATA_OUT_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SOURCE_PHY_DATA_OUT_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_SOURCE_PHY_DATA_OUT_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_SOURCE_PHY_DATA_OUT_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_SOURCE_PHY_CHAR_OUT_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_SOURCE_PHY_CHAR_OUT_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+#define F_SOURCE_PHY_CHAR_OUT_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 3)
+#define F_SOURCE_PHY_CHAR_OUT_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+
+/* register SOURCE_CEC_CAR */
+#define SOURCE_CEC_CAR 3
+#define F_SOURCE_CEC_SYS_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SOURCE_CEC_SYS_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_SOURCE_CEC_SYS_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_SOURCE_CEC_SYS_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+
+/* register SOURCE_CBUS_CAR */
+#define SOURCE_CBUS_CAR 4
+#define F_SOURCE_CBUS_SYS_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SOURCE_CBUS_SYS_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_SOURCE_CBUS_SYS_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_SOURCE_CBUS_SYS_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+
+/* register SOURCE_PKT_CAR */
+#define SOURCE_PKT_CAR 6
+#define F_SOURCE_PKT_DATA_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SOURCE_PKT_DATA_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_SOURCE_PKT_DATA_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_SOURCE_PKT_DATA_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_SOURCE_PKT_SYS_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_SOURCE_PKT_SYS_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+#define F_SOURCE_PKT_SYS_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 3)
+#define F_SOURCE_PKT_SYS_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+
+/* register SOURCE_AIF_CAR */
+#define SOURCE_AIF_CAR 7
+#define F_SOURCE_AIF_PKT_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SOURCE_AIF_PKT_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_SOURCE_AIF_PKT_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_SOURCE_AIF_PKT_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_SOURCE_AIF_SYS_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_SOURCE_AIF_SYS_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+#define F_SOURCE_AIF_SYS_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 3)
+#define F_SOURCE_AIF_SYS_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+#define F_SPDIF_CDR_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 4)
+#define F_SPDIF_CDR_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 4)) >> 4)
+#define F_SPDIF_CDR_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 5)
+#define F_SPDIF_CDR_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 5)) >> 5)
+#define F_SPDIF_MCLK_EN(x) (((x) & ((1 << 1) - 1)) << 6)
+#define F_SPDIF_MCLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 6)) >> 6)
+#define F_SPDIF_MCLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 7)
+#define F_SPDIF_MCLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 7)) >> 7)
+
+/* register SOURCE_CIPHER_CAR */
+#define SOURCE_CIPHER_CAR 8
+#define F_SOURCE_CIPHER_CHAR_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SOURCE_CIPHER_CHAR_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_SOURCE_CIPHER_CHAR_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_SOURCE_CIPHER_CHAR_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_SOURCE_CIPHER_SYS_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_SOURCE_CIPHER_SYS_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+#define F_SOURCE_CIPHER_SYSTEM_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 3)
+#define F_SOURCE_CIPHER_SYSTEM_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+
+/* register SOURCE_CRYPTO_CAR */
+#define SOURCE_CRYPTO_CAR 9
+#define F_SOURCE_CRYPTO_SYS_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SOURCE_CRYPTO_SYS_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_SOURCE_CRYPTO_SYS_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_SOURCE_CRYPTO_SYS_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+
+#endif //SOURCE_CAR
diff --git a/drivers/mxc/hdp/source_phy.h b/drivers/mxc/hdp/source_phy.h
new file mode 100644
index 000000000000..12ed255fe286
--- /dev/null
+++ b/drivers/mxc/hdp/source_phy.h
@@ -0,0 +1,150 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * This file was auto-generated. Do not edit it manually.
+ *
+ ******************************************************************************
+ *
+ * source_phy.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef SOURCE_PHY_H_
+#define SOURCE_PHY_H_
+
+/* register SHIFT_PATTERN_IN_3_0 */
+#define SHIFT_PATTERN_IN_3_0 0
+#define F_SOURCE_PHY_SHIFT_PATTERN0(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_SOURCE_PHY_SHIFT_PATTERN0_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+#define F_SOURCE_PHY_SHIFT_PATTERN1(x) (((x) & ((1 << 8) - 1)) << 8)
+#define F_SOURCE_PHY_SHIFT_PATTERN1_RD(x) (((x) & (((1 << 8) - 1) << 8)) >> 8)
+#define F_SOURCE_PHY_SHIFT_PATTERN2(x) (((x) & ((1 << 8) - 1)) << 16)
+#define F_SOURCE_PHY_SHIFT_PATTERN2_RD(x) (((x) & (((1 << 8) - 1) << 16)) >> 16)
+#define F_SOURCE_PHY_SHIFT_PATTERN3(x) (((x) & ((1 << 8) - 1)) << 24)
+#define F_SOURCE_PHY_SHIFT_PATTERN3_RD(x) (((x) & (((1 << 8) - 1) << 24)) >> 24)
+
+/* register SHIFT_PATTERN_IN_4_7 */
+#define SHIFT_PATTERN_IN_4_7 1
+#define F_SOURCE_PHY_SHIFT_PATTERN4(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_SOURCE_PHY_SHIFT_PATTERN4_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+#define F_SOURCE_PHY_SHIFT_PATTERN5(x) (((x) & ((1 << 8) - 1)) << 8)
+#define F_SOURCE_PHY_SHIFT_PATTERN5_RD(x) (((x) & (((1 << 8) - 1) << 8)) >> 8)
+#define F_SOURCE_PHY_SHIFT_PATTERN6(x) (((x) & ((1 << 8) - 1)) << 16)
+#define F_SOURCE_PHY_SHIFT_PATTERN6_RD(x) (((x) & (((1 << 8) - 1) << 16)) >> 16)
+#define F_SOURCE_PHY_SHIFT_PATTERN7(x) (((x) & ((1 << 8) - 1)) << 24)
+#define F_SOURCE_PHY_SHIFT_PATTERN7_RD(x) (((x) & (((1 << 8) - 1) << 24)) >> 24)
+
+/* register SHIFT_PATTERN_IN9_8 */
+#define SHIFT_PATTERN_IN9_8 2
+#define F_SOURCE_PHY_SHIFT_PATTERN8(x) (((x) & ((1 << 8) - 1)) << 0)
+#define F_SOURCE_PHY_SHIFT_PATTERN8_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+#define F_SOURCE_PHY_SHIFT_PATTERN9(x) (((x) & ((1 << 8) - 1)) << 8)
+#define F_SOURCE_PHY_SHIFT_PATTERN9_RD(x) (((x) & (((1 << 8) - 1) << 8)) >> 8)
+#define F_SOURCE_PHY_SHIFT_LOAD(x) (((x) & ((1 << 1) - 1)) << 16)
+#define F_SOURCE_PHY_SHIFT_LOAD_RD(x) (((x) & (((1 << 1) - 1) << 16)) >> 16)
+#define F_SOURCE_PHY_SHIFT_EN(x) (((x) & ((1 << 1) - 1)) << 17)
+#define F_SOURCE_PHY_SHIFT_EN_RD(x) (((x) & (((1 << 1) - 1) << 17)) >> 17)
+#define F_SOURCE_PHY_SHIFT_REPETITION(x) (((x) & ((1 << 3) - 1)) << 18)
+#define F_SOURCE_PHY_SHIFT_REPETITION_RD(x) (((x) & (((1 << 3) - 1) << 18)) >> 18)
+
+/* register PRBS_CNTRL */
+#define PRBS_CNTRL 3
+#define F_SOURCE_PHY_PRBS0_MODE(x) (((x) & ((1 << 2) - 1)) << 0)
+#define F_SOURCE_PHY_PRBS0_MODE_RD(x) (((x) & (((1 << 2) - 1) << 0)) >> 0)
+#define F_SOURCE_PHY_PRBS0_OUT_MODE(x) (((x) & ((1 << 2) - 1)) << 2)
+#define F_SOURCE_PHY_PRBS0_OUT_MODE_RD(x) (((x) & (((1 << 2) - 1) << 2)) >> 2)
+#define F_SOURCE_PHY_PRBS1_MODE(x) (((x) & ((1 << 2) - 1)) << 4)
+#define F_SOURCE_PHY_PRBS1_MODE_RD(x) (((x) & (((1 << 2) - 1) << 4)) >> 4)
+#define F_SOURCE_PHY_PRBS1_OUT_MODE(x) (((x) & ((1 << 2) - 1)) << 6)
+#define F_SOURCE_PHY_PRBS1_OUT_MODE_RD(x) (((x) & (((1 << 2) - 1) << 6)) >> 6)
+#define F_SOURCE_PHY_PRBS2_MODE(x) (((x) & ((1 << 2) - 1)) << 8)
+#define F_SOURCE_PHY_PRBS2_MODE_RD(x) (((x) & (((1 << 2) - 1) << 8)) >> 8)
+#define F_SOURCE_PHY_PRBS2_OUT_MODE(x) (((x) & ((1 << 2) - 1)) << 10)
+#define F_SOURCE_PHY_PRBS2_OUT_MODE_RD(x) (((x) & (((1 << 2) - 1) << 10)) >> 10)
+#define F_SOURCE_PHY_PRBS3_MODE(x) (((x) & ((1 << 2) - 1)) << 12)
+#define F_SOURCE_PHY_PRBS3_MODE_RD(x) (((x) & (((1 << 2) - 1) << 12)) >> 12)
+#define F_SOURCE_PHY_PRBS3_OUT_MODE(x) (((x) & ((1 << 2) - 1)) << 14)
+#define F_SOURCE_PHY_PRBS3_OUT_MODE_RD(x) (((x) & (((1 << 2) - 1) << 14)) >> 14)
+
+/* register PRBS_ERR_INSERTION */
+#define PRBS_ERR_INSERTION 4
+#define F_ADD_ERROR0(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_ADD_ERROR0_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_NUMBER_OF_ERRORS0(x) (((x) & ((1 << 5) - 1)) << 1)
+#define F_NUMBER_OF_ERRORS0_RD(x) (((x) & (((1 << 5) - 1) << 1)) >> 1)
+#define F_ADD_ERROR1(x) (((x) & ((1 << 1) - 1)) << 6)
+#define F_ADD_ERROR1_RD(x) (((x) & (((1 << 1) - 1) << 6)) >> 6)
+#define F_NUMBER_OF_ERRORS1(x) (((x) & ((1 << 5) - 1)) << 7)
+#define F_NUMBER_OF_ERRORS1_RD(x) (((x) & (((1 << 5) - 1) << 7)) >> 7)
+#define F_ADD_ERROR2(x) (((x) & ((1 << 1) - 1)) << 12)
+#define F_ADD_ERROR2_RD(x) (((x) & (((1 << 1) - 1) << 12)) >> 12)
+#define F_NUMBER_OF_ERRORS2(x) (((x) & ((1 << 5) - 1)) << 13)
+#define F_NUMBER_OF_ERRORS2_RD(x) (((x) & (((1 << 5) - 1) << 13)) >> 13)
+#define F_ADD_ERROR3(x) (((x) & ((1 << 1) - 1)) << 18)
+#define F_ADD_ERROR3_RD(x) (((x) & (((1 << 1) - 1) << 18)) >> 18)
+#define F_NUMBER_OF_ERRORS3(x) (((x) & ((1 << 5) - 1)) << 19)
+#define F_NUMBER_OF_ERRORS3_RD(x) (((x) & (((1 << 5) - 1) << 19)) >> 19)
+
+/* register LANES_CONFIG */
+#define LANES_CONFIG 5
+#define F_SOURCE_PHY_LANE0_SWAP(x) (((x) & ((1 << 2) - 1)) << 0)
+#define F_SOURCE_PHY_LANE0_SWAP_RD(x) (((x) & (((1 << 2) - 1) << 0)) >> 0)
+#define F_SOURCE_PHY_LANE1_SWAP(x) (((x) & ((1 << 2) - 1)) << 2)
+#define F_SOURCE_PHY_LANE1_SWAP_RD(x) (((x) & (((1 << 2) - 1) << 2)) >> 2)
+#define F_SOURCE_PHY_LANE2_SWAP(x) (((x) & ((1 << 2) - 1)) << 4)
+#define F_SOURCE_PHY_LANE2_SWAP_RD(x) (((x) & (((1 << 2) - 1) << 4)) >> 4)
+#define F_SOURCE_PHY_LANE3_SWAP(x) (((x) & ((1 << 2) - 1)) << 6)
+#define F_SOURCE_PHY_LANE3_SWAP_RD(x) (((x) & (((1 << 2) - 1) << 6)) >> 6)
+#define F_SOURCE_PHY_LANE0_LSB_MSB(x) (((x) & ((1 << 1) - 1)) << 8)
+#define F_SOURCE_PHY_LANE0_LSB_MSB_RD(x) (((x) & (((1 << 1) - 1) << 8)) >> 8)
+#define F_SOURCE_PHY_LANE1_LSB_MSB(x) (((x) & ((1 << 1) - 1)) << 9)
+#define F_SOURCE_PHY_LANE1_LSB_MSB_RD(x) (((x) & (((1 << 1) - 1) << 9)) >> 9)
+#define F_SOURCE_PHY_LANE2_LSB_MSB(x) (((x) & ((1 << 1) - 1)) << 10)
+#define F_SOURCE_PHY_LANE2_LSB_MSB_RD(x) (((x) & (((1 << 1) - 1) << 10)) >> 10)
+#define F_SOURCE_PHY_LANE3_LSB_MSB(x) (((x) & ((1 << 1) - 1)) << 11)
+#define F_SOURCE_PHY_LANE3_LSB_MSB_RD(x) (((x) & (((1 << 1) - 1) << 11)) >> 11)
+#define F_SOURCE_PHY_AUX_SPARE(x) (((x) & ((1 << 4) - 1)) << 12)
+#define F_SOURCE_PHY_AUX_SPARE_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+#define F_SOURCE_PHY_LANE0_POLARITY(x) (((x) & ((1 << 1) - 1)) << 16)
+#define F_SOURCE_PHY_LANE0_POLARITY_RD(x) (((x) & (((1 << 1) - 1) << 16)) >> 16)
+#define F_SOURCE_PHY_LANE1_POLARITY(x) (((x) & ((1 << 1) - 1)) << 17)
+#define F_SOURCE_PHY_LANE1_POLARITY_RD(x) (((x) & (((1 << 1) - 1) << 17)) >> 17)
+#define F_SOURCE_PHY_LANE2_POLARITY(x) (((x) & ((1 << 1) - 1)) << 18)
+#define F_SOURCE_PHY_LANE2_POLARITY_RD(x) (((x) & (((1 << 1) - 1) << 18)) >> 18)
+#define F_SOURCE_PHY_LANE3_POLARITY(x) (((x) & ((1 << 1) - 1)) << 19)
+#define F_SOURCE_PHY_LANE3_POLARITY_RD(x) (((x) & (((1 << 1) - 1) << 19)) >> 19)
+#define F_SOURCE_PHY_DATA_DEL_EN(x) (((x) & ((1 << 1) - 1)) << 20)
+#define F_SOURCE_PHY_DATA_DEL_EN_RD(x) (((x) & (((1 << 1) - 1) << 20)) >> 20)
+#define F_SOURCE_PHY_COMB_BYPASS(x) (((x) & ((1 << 1) - 1)) << 21)
+#define F_SOURCE_PHY_COMB_BYPASS_RD(x) (((x) & (((1 << 1) - 1) << 21)) >> 21)
+#define F_SOURCE_PHY_20_10(x) (((x) & ((1 << 1) - 1)) << 22)
+#define F_SOURCE_PHY_20_10_RD(x) (((x) & (((1 << 1) - 1) << 22)) >> 22)
+
+/* register PHY_DATA_SEL */
+#define PHY_DATA_SEL 6
+#define F_SOURCE_PHY_DATA_SEL(x) (((x) & ((1 << 3) - 1)) << 0)
+#define F_SOURCE_PHY_DATA_SEL_RD(x) (((x) & (((1 << 3) - 1) << 0)) >> 0)
+#define F_SOURCE_PHY_MHDP_SEL(x) (((x) & ((1 << 2) - 1)) << 3)
+#define F_SOURCE_PHY_MHDP_SEL_RD(x) (((x) & (((1 << 2) - 1) << 3)) >> 3)
+
+/* register LANES_DEL_VAL */
+#define LANES_DEL_VAL 7
+#define F_SOURCE_PHY_LANE0_DEL_VAL(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_SOURCE_PHY_LANE0_DEL_VAL_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_SOURCE_PHY_LANE1_DEL_VAL(x) (((x) & ((1 << 4) - 1)) << 4)
+#define F_SOURCE_PHY_LANE1_DEL_VAL_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+#define F_SOURCE_PHY_LANE2_DEL_VAL(x) (((x) & ((1 << 4) - 1)) << 8)
+#define F_SOURCE_PHY_LANE2_DEL_VAL_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+#define F_SOURCE_PHY_LANE3_DEL_VAL(x) (((x) & ((1 << 4) - 1)) << 12)
+#define F_SOURCE_PHY_LANE3_DEL_VAL_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+
+#endif //SOURCE_PHY
diff --git a/drivers/mxc/hdp/source_pif.h b/drivers/mxc/hdp/source_pif.h
new file mode 100644
index 000000000000..e22890413b6f
--- /dev/null
+++ b/drivers/mxc/hdp/source_pif.h
@@ -0,0 +1,140 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * This file was auto-generated. Do not edit it manually.
+ *
+ ******************************************************************************
+ *
+ * source_pif.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef SOURCE_PIF_H_
+#define SOURCE_PIF_H_
+
+/* register SOURCE_PIF_WR_ADDR */
+#define SOURCE_PIF_WR_ADDR 0
+#define F_WR_ADDR(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_WR_ADDR_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+
+/* register SOURCE_PIF_WR_REQ */
+#define SOURCE_PIF_WR_REQ 1
+#define F_HOST_WR(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_HOST_WR_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+/* register SOURCE_PIF_RD_ADDR */
+#define SOURCE_PIF_RD_ADDR 2
+#define F_RD_ADDR(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_RD_ADDR_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+
+/* register SOURCE_PIF_RD_REQ */
+#define SOURCE_PIF_RD_REQ 3
+#define F_HOST_RD(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_HOST_RD_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+/* register SOURCE_PIF_DATA_WR */
+#define SOURCE_PIF_DATA_WR 4
+#define F_DATA_WR(x) (x)
+#define F_DATA_WR_RD(x) (x)
+
+/* register SOURCE_PIF_DATA_RD */
+#define SOURCE_PIF_DATA_RD 5
+#define F_FIFO2_DATA_OUT(x) (x)
+#define F_FIFO2_DATA_OUT_RD(x) (x)
+
+/* register SOURCE_PIF_FIFO1_FLUSH */
+#define SOURCE_PIF_FIFO1_FLUSH 6
+#define F_FIFO1_FLUSH(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_FIFO1_FLUSH_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+/* register SOURCE_PIF_FIFO2_FLUSH */
+#define SOURCE_PIF_FIFO2_FLUSH 7
+#define F_FIFO2_FLUSH(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_FIFO2_FLUSH_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+/* register SOURCE_PIF_STATUS */
+#define SOURCE_PIF_STATUS 8
+#define F_SOURCE_PKT_MEM_CTRL_FSM_STATE(x) (((x) & ((1 << 2) - 1)) << 0)
+#define F_SOURCE_PKT_MEM_CTRL_FSM_STATE_RD(x) (((x) & (((1 << 2) - 1) << 0)) >> 0)
+#define F_FIFO1_FULL(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_FIFO1_FULL_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+#define F_FIFO2_EMPTY(x) (((x) & ((1 << 1) - 1)) << 3)
+#define F_FIFO2_EMPTY_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+
+/* register SOURCE_PIF_INTERRUPT_SOURCE */
+#define SOURCE_PIF_INTERRUPT_SOURCE 9
+#define F_HOST_WR_DONE_INT(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_HOST_WR_DONE_INT_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_HOST_RD_DONE_INT(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_HOST_RD_DONE_INT_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_NONVALID_TYPE_REQUESTED_INT(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_NONVALID_TYPE_REQUESTED_INT_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+#define F_PSLVERR(x) (((x) & ((1 << 1) - 1)) << 3)
+#define F_PSLVERR_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+#define F_ALLOC_WR_DONE(x) (((x) & ((1 << 1) - 1)) << 4)
+#define F_ALLOC_WR_DONE_RD(x) (((x) & (((1 << 1) - 1) << 4)) >> 4)
+#define F_ALLOC_WR_ERROR(x) (((x) & ((1 << 1) - 1)) << 5)
+#define F_ALLOC_WR_ERROR_RD(x) (((x) & (((1 << 1) - 1) << 5)) >> 5)
+#define F_FIFO1_OVERFLOW(x) (((x) & ((1 << 1) - 1)) << 6)
+#define F_FIFO1_OVERFLOW_RD(x) (((x) & (((1 << 1) - 1) << 6)) >> 6)
+#define F_FIFO1_UNDERFLOW(x) (((x) & ((1 << 1) - 1)) << 7)
+#define F_FIFO1_UNDERFLOW_RD(x) (((x) & (((1 << 1) - 1) << 7)) >> 7)
+#define F_FIFO2_OVERFLOW(x) (((x) & ((1 << 1) - 1)) << 8)
+#define F_FIFO2_OVERFLOW_RD(x) (((x) & (((1 << 1) - 1) << 8)) >> 8)
+#define F_FIFO2_UNDERFLOW(x) (((x) & ((1 << 1) - 1)) << 9)
+#define F_FIFO2_UNDERFLOW_RD(x) (((x) & (((1 << 1) - 1) << 9)) >> 9)
+
+/* register SOURCE_PIF_INTERRUPT_MASK */
+#define SOURCE_PIF_INTERRUPT_MASK 10
+#define F_HOST_WR_DONE_INT_MASK(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_HOST_WR_DONE_INT_MASK_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_HOST_RD_DONE_INT_MASK(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_HOST_RD_DONE_INT_MASK_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_NONVALID_TYPE_REQUESTED_INT_MASK(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_NONVALID_TYPE_REQUESTED_INT_MASK_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+#define F_PSLVERR_MASK(x) (((x) & ((1 << 1) - 1)) << 3)
+#define F_PSLVERR_MASK_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+#define F_ALLOC_WR_DONE_MASK(x) (((x) & ((1 << 1) - 1)) << 4)
+#define F_ALLOC_WR_DONE_MASK_RD(x) (((x) & (((1 << 1) - 1) << 4)) >> 4)
+#define F_ALLOC_WR_ERROR_MASK(x) (((x) & ((1 << 1) - 1)) << 5)
+#define F_ALLOC_WR_ERROR_MASK_RD(x) (((x) & (((1 << 1) - 1) << 5)) >> 5)
+#define F_FIFO1_OVERFLOW_MASK(x) (((x) & ((1 << 1) - 1)) << 6)
+#define F_FIFO1_OVERFLOW_MASK_RD(x) (((x) & (((1 << 1) - 1) << 6)) >> 6)
+#define F_FIFO1_UNDERFLOW_MASK(x) (((x) & ((1 << 1) - 1)) << 7)
+#define F_FIFO1_UNDERFLOW_MASK_RD(x) (((x) & (((1 << 1) - 1) << 7)) >> 7)
+#define F_FIFO2_OVERFLOW_MASK(x) (((x) & ((1 << 1) - 1)) << 8)
+#define F_FIFO2_OVERFLOW_MASK_RD(x) (((x) & (((1 << 1) - 1) << 8)) >> 8)
+#define F_FIFO2_UNDERFLOW_MASK(x) (((x) & ((1 << 1) - 1)) << 9)
+#define F_FIFO2_UNDERFLOW_MASK_RD(x) (((x) & (((1 << 1) - 1) << 9)) >> 9)
+
+/* register SOURCE_PIF_PKT_ALLOC_REG */
+#define SOURCE_PIF_PKT_ALLOC_REG 11
+#define F_PKT_ALLOC_ADDRESS(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_PKT_ALLOC_ADDRESS_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+#define F_PACKET_TYPE(x) (((x) & ((1 << 8) - 1)) << 8)
+#define F_PACKET_TYPE_RD(x) (((x) & (((1 << 8) - 1) << 8)) >> 8)
+#define F_TYPE_VALID(x) (((x) & ((1 << 1) - 1)) << 16)
+#define F_TYPE_VALID_RD(x) (((x) & (((1 << 1) - 1) << 16)) >> 16)
+#define F_ACTIVE_IDLE_TYPE(x) (((x) & ((1 << 1) - 1)) << 17)
+#define F_ACTIVE_IDLE_TYPE_RD(x) (((x) & (((1 << 1) - 1) << 17)) >> 17)
+
+/* register SOURCE_PIF_PKT_ALLOC_WR_EN */
+#define SOURCE_PIF_PKT_ALLOC_WR_EN 12
+#define F_PKT_ALLOC_WR_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_PKT_ALLOC_WR_EN_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+/* register SOURCE_PIF_SW_RESET */
+#define SOURCE_PIF_SW_RESET 13
+#define F_SW_RST(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_SW_RST_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+#endif //SOURCE_PIF
diff --git a/drivers/mxc/hdp/source_vif.h b/drivers/mxc/hdp/source_vif.h
new file mode 100644
index 000000000000..d968cf14af99
--- /dev/null
+++ b/drivers/mxc/hdp/source_vif.h
@@ -0,0 +1,63 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * This file was auto-generated. Do not edit it manually.
+ *
+ ******************************************************************************
+ *
+ * source_vif.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef SOURCE_VIF_H_
+#define SOURCE_VIF_H_
+
+/* register BND_HSYNC2VSYNC */
+#define BND_HSYNC2VSYNC 0
+#define F_IP_DTCT_WIN(x) (((x) & ((1 << 12) - 1)) << 0)
+#define F_IP_DTCT_WIN_RD(x) (((x) & (((1 << 12) - 1) << 0)) >> 0)
+#define F_IP_DET_EN(x) (((x) & ((1 << 1) - 1)) << 12)
+#define F_IP_DET_EN_RD(x) (((x) & (((1 << 1) - 1) << 12)) >> 12)
+#define F_IP_VIF_BYPASS(x) (((x) & ((1 << 1) - 1)) << 13)
+#define F_IP_VIF_BYPASS_RD(x) (((x) & (((1 << 1) - 1) << 13)) >> 13)
+
+/* register HSYNC2VSYNC_F1_L1 */
+#define HSYNC2VSYNC_F1_L1 1
+#define F_IP_DTCT_HSYNC2VSYNC_F1(x) (((x) & ((1 << 16) - 1)) << 0)
+#define F_IP_DTCT_HSYNC2VSYNC_F1_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+
+/* register HSYNC2VSYNC_F2_L1 */
+#define HSYNC2VSYNC_F2_L1 2
+#define F_IP_DTCT_HSYNC2VSYNC_F2(x) (((x) & ((1 << 16) - 1)) << 0)
+#define F_IP_DTCT_HSYNC2VSYNC_F2_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+
+/* register HSYNC2VSYNC_STATUS */
+#define HSYNC2VSYNC_STATUS 3
+#define F_IP_DTCT_ERR(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_IP_DTCT_ERR_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+#define F_IP_DCT_IP(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_IP_DCT_IP_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_IP_DTCT_VJITTER(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_IP_DTCT_VJITTER_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+#define F_IP_DTCT_HJITTER(x) (((x) & ((1 << 1) - 1)) << 3)
+#define F_IP_DTCT_HJITTER_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+
+/* register HSYNC2VSYNC_POL_CTRL */
+#define HSYNC2VSYNC_POL_CTRL 4
+#define F_VPOL(x) (((x) & ((1 << 1) - 1)) << 2)
+#define F_VPOL_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+#define F_HPOL(x) (((x) & ((1 << 1) - 1)) << 1)
+#define F_HPOL_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+#define F_VIF_AUTO_MODE(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_VIF_AUTO_MODE_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+#endif //SOURCE_VIF
diff --git a/drivers/mxc/hdp/util.c b/drivers/mxc/hdp/util.c
new file mode 100644
index 000000000000..c9977667201c
--- /dev/null
+++ b/drivers/mxc/hdp/util.c
@@ -0,0 +1,343 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * util.c
+ *
+ ******************************************************************************
+ */
+#include "util.h"
+#include "API_General.h"
+#include "apb_cfg.h"
+#include "opcodes.h"
+
+int cdn_apb_read(state_struct *state, u32 addr, u32 *value)
+{
+	struct hdp_mem *mem = state->mem;
+
+	state->rw->read_reg(mem, addr, value);
+	return 0;
+}
+
+int cdn_apb_write(state_struct *state, u32 addr, u32 value)
+{
+	struct hdp_mem *mem = state->mem;
+
+	state->rw->write_reg(mem, addr, value);
+	return 0;
+}
+
+int cdn_sapb_read(state_struct *state, u32 addr, u32 *value)
+{
+	struct hdp_mem *mem = state->mem;
+
+	state->rw->sread_reg(mem, addr, value);
+	return 0;
+}
+
+int cdn_sapb_write(state_struct *state, u32 addr, u32 value)
+{
+	struct hdp_mem *mem = state->mem;
+
+	state->rw->swrite_reg(mem, addr, value);
+	return 0;
+}
+
+void cdn_sleep(u32 ms)
+{
+	mdelay(ms);
+}
+
+void cdn_usleep(u32 us)
+{
+	udelay(us);
+}
+
+int cdn_bus_read(state_struct *state, u32 addr, u32 *value)
+{
+	return state->bus_type ?
+	    cdn_sapb_read(state, addr, value) : cdn_apb_read(state, addr,
+							     value);
+}
+
+int cdn_bus_write(state_struct *state, u32 addr, u32 value)
+{
+	return state->bus_type ?
+	    cdn_sapb_write(state, addr, value) : cdn_apb_write(state, addr,
+							       value);
+}
+
+void internal_itobe(int val, volatile u8 *dest, int bytes)
+{
+	int i;
+
+	for (i = bytes - 1; i >= 0; --i) {
+		dest[i] = (u8) val;
+		val >>= 8;
+	}
+}
+
+u32 internal_betoi(volatile u8 const *src, u8 bytes)
+{
+	u32 ret = 0;
+	int i;
+
+	if (bytes > sizeof(ret)) {
+		printk
+		    ("Warning. Read request for payload larger then supported.\n");
+		bytes = sizeof(ret);
+
+	}
+
+	for (i = 0; i < bytes; ++i) {
+		ret <<= 8;
+		ret |= (u32) src[i];
+	}
+
+	return ret;
+}
+
+u32 internal_mkmsg(volatile u8 *dest, int valNo, ...)
+{
+	va_list vl;
+	u32 len = 0;
+
+	va_start(vl, valNo);
+	len = internal_vmkmsg(dest, valNo, vl);
+	va_end(vl);
+	return len;
+}
+
+u32 internal_vmkmsg(volatile u8 *dest, int valNo, va_list vl)
+{
+	u32 len = 0;
+	int i;
+	for (i = 0; i < valNo; ++i) {
+		int size = va_arg(vl, int);
+
+		if (size > 0) {
+			internal_itobe(va_arg(vl, int), dest, size);
+			dest += size;
+			len += size;
+		} else {
+			memcpy((void *)dest, va_arg(vl, void *), -size);
+			dest -= size;
+			len -= size;
+		}
+	}
+	return len;
+}
+
+void internal_tx_mkfullmsg(state_struct *state, u8 module, u8 opcode,
+			   int valNo, ...)
+{
+	va_list vl;
+
+	va_start(vl, valNo);
+	internal_vtx_mkfullmsg(state, module, opcode, valNo, vl);
+	va_end(vl);
+}
+
+void internal_vtx_mkfullmsg(state_struct *state, u8 module, u8 opcode,
+			    int valNo, va_list vl)
+{
+	u32 len =
+	    internal_vmkmsg(state->txBuffer + INTERNAL_CMD_HEAD_SIZE, valNo,
+			    vl);
+	internal_mbox_tx_enable(state, module, opcode, len);
+	state->txEnable = 1;
+	state->running = 1;
+}
+
+void internal_readmsg(state_struct *state, int valNo, ...)
+{
+	va_list vl;
+
+	va_start(vl, valNo);
+	internal_vreadmsg(state, valNo, vl);
+	va_end(vl);
+}
+
+void internal_vreadmsg(state_struct *state, int valNo, va_list vl)
+{
+	u8 *src = state->rxBuffer + INTERNAL_CMD_HEAD_SIZE;
+	size_t i;
+
+	for (i = 0; i < (size_t) valNo; ++i) {
+		int size = va_arg(vl, int);
+		void *ptr = va_arg(vl, void *);
+
+		if (!ptr) {
+			src += size;
+		} else if (!size) {
+			*((u8 **) ptr) = src;
+		} else if (size > 0) {
+			switch ((size_t) size) {
+			case sizeof(u8):
+				*((u8 *) ptr) = internal_betoi(src, size);
+				break;
+			case sizeof(u16):
+				*((u16 *) ptr) = internal_betoi(src, size);
+				break;
+			case 3:	// 3-byte value (e.g. DPCD address) can be safely converted from BE
+			case sizeof(u32):
+				*((u32 *) ptr) = internal_betoi(src, size);
+				break;
+			default:
+				pr_warn("Warning. Unsupported variable size.\n");
+				memcpy(ptr, src, size);
+			};
+
+			src += size;
+		} else {
+			memcpy(ptr, src, -size);
+			src -= size;
+		}
+	}
+}
+
+INTERNAL_MBOX_STATUS mailbox_write(state_struct *state, u8 val)
+{
+	INTERNAL_MBOX_STATUS ret;
+	u32 full;
+
+	if (cdn_bus_read(state, MAILBOX_FULL_ADDR << 2, &full)) {
+		ret.tx_status = CDN_TX_APB_ERROR;
+		return ret;
+	}
+	if (full) {
+		ret.tx_status = CDN_TX_FULL;
+		return ret;
+	}
+	if (cdn_bus_write(state, MAILBOX0_WR_DATA << 2, val)) {
+		ret.tx_status = CDN_TX_APB_ERROR;
+		return ret;
+	}
+	ret.tx_status = CDN_TX_WRITE;
+	return ret;
+}
+
+INTERNAL_MBOX_STATUS mailbox_read(state_struct *state, volatile u8 *val)
+{
+	INTERNAL_MBOX_STATUS ret;
+	u32 empty;
+	u32 rd;
+
+	if (cdn_bus_read(state, MAILBOX_EMPTY_ADDR << 2, &empty)) {
+		ret.rx_status = CDN_RX_APB_ERROR;
+		return ret;
+	}
+	if (empty) {
+		ret.rx_status = CDN_RX_EMPTY;
+		return ret;
+	}
+	if (cdn_bus_read(state, MAILBOX0_RD_DATA << 2, &rd)) {
+		ret.rx_status = CDN_RX_APB_ERROR;
+		return ret;
+	}
+	*val = (u8) rd;
+	ret.rx_status = CDN_RX_READ;
+	return ret;
+}
+
+INTERNAL_MBOX_STATUS internal_mbox_tx_process(state_struct *state)
+{
+	u32 txCount = 0;
+	u32 length = (u32) state->txBuffer[2] << 8 | (u32) state->txBuffer[3];
+	INTERNAL_MBOX_STATUS ret = {.txend = 0 };
+	INTERNAL_MBOX_STATUS tx_ret;
+
+	ret.tx_status = CDN_TX_NOTHING;
+	if (!state->txEnable)
+		return ret;
+	while ((tx_ret.tx_status =
+		mailbox_write(state, state->txBuffer[state->txi]).tx_status) ==
+	       CDN_TX_WRITE) {
+		txCount++;
+		if (++state->txi >= length + 4) {
+			state->txEnable = 0;
+			state->txi = 0;
+			ret.txend = 1;
+			break;
+		}
+	}
+	if (txCount && tx_ret.tx_status == CDN_TX_FULL)
+		ret.tx_status = CDN_TX_WRITE;
+	else
+		ret.tx_status = tx_ret.tx_status;
+	return ret;
+}
+
+INTERNAL_MBOX_STATUS internal_mbox_rx_process(state_struct *state)
+{
+	u32 rxCount = 0;
+	INTERNAL_MBOX_STATUS ret = { 0, 0, 0, 0 };
+	INTERNAL_MBOX_STATUS rx_ret;
+
+	while ((rx_ret.rx_status =
+		mailbox_read(state, state->rxBuffer + state->rxi).rx_status) ==
+	       CDN_RX_READ) {
+		rxCount++;
+		if (++state->rxi >=
+		    4 +
+		    ((u32) state->rxBuffer[2] << 8 |
+		     (u32) state->rxBuffer[3])) {
+			state->rxi = 0;
+			ret.rxend = 1;
+			state->rxEnable = 0;
+			break;
+		}
+	}
+	ret.rx_status = rxCount ? CDN_RX_READ : CDN_RX_EMPTY;
+	return ret;
+}
+
+u32 internal_apb_available(state_struct *state)
+{
+	return !(state->rxEnable || state->txEnable);
+}
+
+void internal_mbox_tx_enable(state_struct *state, u8 module, u8 opcode,
+			     u16 length)
+{
+	state->txBuffer[0] = opcode;
+	state->txBuffer[1] = module;
+	state->txBuffer[2] = (u8) (length >> 8);
+	state->txBuffer[3] = (u8) length;
+	state->txEnable = 1;
+}
+
+CDN_API_STATUS internal_test_rx_head(state_struct *state, u8 module, u8 opcode)
+{
+	if (opcode != state->rxBuffer[0])
+		return CDN_BAD_OPCODE;
+	if (module != state->rxBuffer[1])
+		return CDN_BAD_MODULE;
+	return CDN_OK;
+}
+
+CDN_API_STATUS internal_test_rx_head_match(state_struct *state)
+{
+	return internal_test_rx_head(state, state->txBuffer[1],
+				     state->txBuffer[0]);
+}
+
+void print_fw_ver(state_struct *state)
+{
+	u16 ver, verlib;
+
+	CDN_API_General_getCurVersion(state, &ver, &verlib);
+	printk(KERN_INFO "FIRMWARE VERSION: %d, LIB VERSION: %d\n", ver, verlib);
+}
+
+u16 internal_get_msg_len(state_struct *state)
+{
+	return ((u16) state->rxBuffer[2] << 8) | (u16) state->rxBuffer[3];
+}
diff --git a/drivers/mxc/hdp/util.h b/drivers/mxc/hdp/util.h
new file mode 100644
index 000000000000..e48d5496964d
--- /dev/null
+++ b/drivers/mxc/hdp/util.h
@@ -0,0 +1,369 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Copyright 2017-2018 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ ******************************************************************************
+ *
+ * util.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef UTIL_H_
+#define UTIL_H_
+
+#include <linux/delay.h>
+#include <linux/mutex.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_edid.h>
+
+/**
+ * \addtogroup GENERAL_API
+ * \{
+ */
+/** status code returned by API calls */
+typedef enum {
+    /** operation succedded */
+	CDN_OK = 0,
+    /** CEC operation succedded */
+	CDN_CEC_ERR_NONE = 0,
+    /** mailbox is currently sending or receiving data */
+	CDN_BSY,
+    /** message set up and ready to be sent, no data sent yet */
+	CDN_STARTED,
+    /** error encountered while reading/writing APB */
+	CDN_ERR,
+    /** reply returned with bad opcode */
+	CDN_BAD_OPCODE,
+    /** reply returned with bad module */
+	CDN_BAD_MODULE,
+    /** reply not supported mode */
+	CDN_ERROR_NOT_SUPPORTED,
+    /** Invalid argument passed to CEC API function */
+	CDN_CEC_ERR_INVALID_ARG,
+    /**
+     * TX Buffer for CEC Messages is full. This is applicable only
+     * when TX Buffers for CEC Messages are implemented in the HW.
+     */
+	CDN_CEC_ERR_TX_BUFF_FULL,
+    /** No Messages in the RX Buffers are present. */
+	CDN_CEC_ERR_RX_BUFF_EMPTY,
+    /** Timeout during TX operation */
+	CDN_CEC_ERR_TX_TIMEOUT,
+    /** Timeout during RX operation */
+	CDN_CEC_ERR_RX_TIMEOUT,
+    /** Data transmision fail. */
+	CDN_CEC_ERR_TX_FAILED,
+    /** Data reception fail. */
+	CDN_CEC_ERR_RX_FAILED,
+    /** Operation aborted. */
+	CDN_CEC_ERR_ABORT,
+    /** All Logical Addresses are in use. */
+	CDN_CEC_ERR_ALL_LA_IN_USE,
+} CDN_API_STATUS;
+
+typedef enum {
+	CDN_DPTX,
+	CDN_HDMITX_TYPHOON,
+	CDN_HDMITX_KIRAN,
+} CDN_PROTOCOL_TYPE;
+
+typedef enum {
+	CDN_BUS_TYPE_APB = 0,
+	CDN_BUS_TYPE_SAPB = 1
+} CDN_BUS_TYPE;
+
+typedef enum {
+	NUM_OF_LANES_1 = 1,
+	NUM_OF_LANES_2 = 2,
+	NUM_OF_LANES_4 = 4,
+} VIC_NUM_OF_LANES;
+
+typedef enum {
+	RATE_1_6 = 162,
+	RATE_2_1 = 216,
+	RATE_2_4 = 243,
+	RATE_2_7 = 270,
+	RATE_3_2 = 324,
+	RATE_4_3 = 432,
+	RATE_5_4 = 540,
+	RATE_8_1 = 810,
+} VIC_SYMBOL_RATE;
+
+typedef enum {
+	PXL_RGB = 0x1,
+	YCBCR_4_4_4 = 0x2,
+	YCBCR_4_2_2 = 0x4,
+	YCBCR_4_2_0 = 0x8,
+	Y_ONLY = 0x10,
+} VIC_PXL_ENCODING_FORMAT;
+
+typedef enum {
+	BCS_6 = 0x1,
+	BCS_8 = 0x2,
+	BCS_10 = 0x4,
+	BCS_12 = 0x8,
+	BCS_16 = 0x10,
+} VIC_COLOR_DEPTH;
+
+typedef enum {
+	STEREO_VIDEO_LEFT = 0x0,
+	STEREO_VIDEO_RIGHT = 0x1,
+} STEREO_VIDEO_ATTR;
+
+typedef enum {
+	BT_601 = 0x0,
+	BT_709 = 0x1,
+} BT_TYPE;
+
+typedef struct {
+    /** apb write status */
+	enum tx_status_enum {
+	/** one or more bytes written */
+		CDN_TX_WRITE = 0,
+	/** nothing to write */
+		CDN_TX_NOTHING = 1,
+	/** mailbox full, 0 bytes written */
+		CDN_TX_FULL = 2,
+	/** APB error while writing */
+		CDN_TX_APB_ERROR = 3
+	} tx_status:3;
+    /** apb read status */
+	enum rx_status_enum {
+	/** 1 or more bytes read */
+		CDN_RX_READ = 0,
+	/** mailbox empty, 0 bytes read */
+		CDN_RX_EMPTY = 1,
+	/** apb error while reading */
+		CDN_RX_APB_ERROR = 2
+	} rx_status:2;
+    /** indicates end of currenly recived message */
+	u8 rxend:1;
+    /** end of tx message reached */
+	u8 txend:1;
+} INTERNAL_MBOX_STATUS;
+
+struct hdp_mem {
+	void __iomem *regs_base;
+	void __iomem *ss_base;
+	struct mutex mutex;
+};
+
+struct hdp_rw_func {
+	int (*read_reg)(struct hdp_mem *mem, u32 addr, u32 *value);
+	int (*write_reg)(struct hdp_mem *mem, u32 addr, u32 value);
+	int (*sread_reg)(struct hdp_mem *mem, u32 addr, u32 *value);
+	int (*swrite_reg)(struct hdp_mem *mem, u32 addr, u32 value);
+};
+
+typedef struct {
+	u8 txBuffer[1024];
+	u8 rxBuffer[1024];
+	u32 txi;		//iterators
+	u32 rxi;
+	u8 txEnable;		//data readt to send
+	u8 rxEnable;
+	u8 running;
+	CDN_BUS_TYPE bus_type;
+	u32 tmp;
+	u32 edp; /* use eDP */
+
+	struct mutex mutex;	//mutex may replace running
+	struct hdp_mem *mem;
+	struct hdp_rw_func *rw;
+} state_struct;
+/**
+ * \addtogroup UTILS
+ * \{
+ */
+#define INTERNAL_CMD_HEAD_SIZE 4
+
+/**
+ * \brief expands to blocking function body
+ * \param x - function call
+ */
+#ifdef CONFIG_EMU_PXP
+#define MAILBOX_FILL_TIMEOUT	5
+#else
+#define MAILBOX_FILL_TIMEOUT	15000
+#endif
+#define internal_block_function(y, x)					\
+do {									\
+	unsigned long end_jiffies = jiffies +				\
+			msecs_to_jiffies(MAILBOX_FILL_TIMEOUT);		\
+	CDN_API_STATUS ret;						\
+	mutex_lock(y);							\
+	do {								\
+		ret = x;						\
+		cpu_relax();						\
+	} while (time_after(end_jiffies, jiffies) &&			\
+			(ret == CDN_BSY || ret == CDN_STARTED));	\
+	mutex_unlock(y);						\
+	return ret;							\
+} while (0)
+
+/**
+ * \brief write message and write response (if any), non-blocking way. Also sets state.running = 0
+ */
+#define internal_process_messages(state)				\
+do {									\
+	if (state->txEnable && !internal_mbox_tx_process(state).txend)	\
+		return CDN_BSY;						\
+	if (state->rxEnable && !internal_mbox_rx_process(state).rxend)	\
+		return CDN_BSY;						\
+	state->running = 0;						\
+} while (0)
+
+#define internal_opcode_ok_or_return(state, module, opcode) do {	\
+	CDN_API_STATUS ret;						\
+	ret = internal_test_rx_head(state, module, opcode);		\
+	if (ret != CDN_OK)						\
+		return ret;						\
+} while (0)
+
+#define internal_opcode_match_or_return(state) do {			\
+	CDN_API_STATUS ret;						\
+	ret = internal_test_rx_head_match(state);			\
+	if (ret != CDN_OK)						\
+		return ret;						\
+} while (0)
+
+/* macro for simple tx only command, command format as in mkfullmsg (with count) */
+#define internal_macro_command_tx(state, module, opcode, bustype, command...)	\
+do {										\
+	if (!state->running) {							\
+		internal_tx_mkfullmsg(state, module, opcode, command);		\
+		state->bus_type = bustype;					\
+		return CDN_STARTED;						\
+	}									\
+	internal_process_messages(state);					\
+} while (0)
+
+/* macro for command with response with matching opcode, command format as in mkfullmsg (with count) */
+#define internal_macro_command_txrx(state, module, opcode, bustype, command...)	\
+do {										\
+	if (!state->running) {							\
+		internal_tx_mkfullmsg(state, module, opcode, command);		\
+		state->bus_type = bustype;					\
+		state->rxEnable = 1;						\
+		return CDN_STARTED;						\
+	}									\
+	internal_process_messages(state);					\
+	internal_opcode_match_or_return(state);					\
+} while (0)
+
+/**
+ * \brief put val into dest in big endian format
+ * \param val - value to put
+ * \param dest - place to put value
+ * \param bytes - true size of val in bytes. for example if bytes = 2 val is treated as short int
+ */
+void internal_itobe(int val, volatile u8 *dest, int bytes);
+
+/**
+ * \brief read big endian value from src and return it
+ * \param src - source to read from
+ * \param bytes - size of read value
+ * \return result
+ */
+u32 internal_betoi(volatile u8 const *src, u8 bytes);
+
+/**
+ * \brief create message from size and value pairs; also sets state.runnging and state.txEnable
+ * \param dest - pointer to write message to
+ * \param valNo - number of values to write
+ * \param ... - pairs of size and value, each value is written after another. if size is positive value, value is written with #internal_itobe, if size is negative, value is treated as src pointer for memcpy
+ *
+ * example:
+ *
+ *  u16 x = 0xAABB;
+ *
+ *  internal_mkmsg(dest, 3, 1, 1, 2, 3, -2, &x);
+ *
+ *  will write 01 00 03 AA BB to dest
+ */
+u32 internal_mkmsg(volatile u8 *dest, int valNo, ...);
+u32 internal_vmkmsg(volatile u8 *dest, int valNo, va_list vl);
+
+/**
+ * \brief setup message header in txBuffer, set txEnable = 1
+ */
+void internal_mbox_tx_enable(state_struct *state, u8 module, u8 opcode,
+			     u16 length);
+
+/**
+ * \brief write from txBuffer to mailbox until full or end of message.
+ *
+ * when txEnable == 0 writes nothing
+ * when write reaches end of message set txEnable = 0
+ */
+
+/**
+ * \brief combination of #internal_mkmsg and #internal_mbox_tx_enable
+ *
+ * #internal_mkmsg dest and #internal_mbox_tx_enable length are determined automatically
+ * this function also sets state.txEnable = 1 and state.running
+ */
+void internal_tx_mkfullmsg(state_struct *state, u8 module, u8 opcode,
+			   int valNo, ...);
+void internal_vtx_mkfullmsg(state_struct *state, u8 module, u8 opcode,
+			    int valNo, va_list vl);
+
+/**
+ * \brief read from state.txBuffer and store results in specified pointers
+ * \param valNo - numbero of values to read
+ * \param ... - pairs of size and ptr
+ *
+ * this function is similar to #internal_mkmsg -
+ *
+ * when size is positive read value using #internal_betoi
+ * when size is negative mempcy from txBuffer to ptr -size bytes
+ * when size is 0 write to ptr addres of current position in rxbuffer
+ * when ptr is NULL ignore size bytes (if size is negative this will rewind buffer)
+ */
+void internal_readmsg(state_struct *state, int valNo, ...);
+void internal_vreadmsg(state_struct *state, int valNo, va_list vl);
+
+INTERNAL_MBOX_STATUS internal_mbox_tx_process(state_struct *state);
+/**
+ * \brief read to rxBuffer from mailbox untill empty or end of message
+ *
+ * when rxEnable == 0 reads nothing
+ * when end of message reached sets rxEnable = 0
+ */
+INTERNAL_MBOX_STATUS internal_mbox_rx_process(state_struct *state);
+
+/**
+ * \brief check if apb is available
+ * \return !(rxEnable && txEable)
+ */
+u32 internal_apb_available(state_struct *state);
+
+/**
+ * \brief test if parameters match module and opcode in rxBuffer
+ * \return CDN_OK or CDN_BAD_OPCODE or CDN_BAD_MODULE
+ */
+CDN_API_STATUS internal_test_rx_head(state_struct *state, u8 module,
+				     u8 opcode);
+
+CDN_API_STATUS internal_test_rx_head_match(state_struct *state);
+
+/**
+ * \brief print current fw and lib version
+ */
+void print_fw_ver(state_struct *state);
+
+int cdn_apb_read(state_struct *state, u32 addr, u32 *value);
+int cdn_sapb_read(state_struct *state, u32 addr, u32 *value);
+int cdn_apb_write(state_struct *state, u32 addr, u32 value);
+int cdn_sapb_write(state_struct *state, u32 addr, u32 value);
+void cdn_sleep(u32 ms);
+void cdn_usleep(u32 us);
+u16 internal_get_msg_len(state_struct *state);
+
+#endif
-- 
2.17.1

