From acbf2596e4e0a91e95cb24517ed4e026cf30fcd6 Mon Sep 17 00:00:00 2001
From: Alex Marginean <alexandru.marginean@nxp.com>
Date: Thu, 12 Sep 2019 15:39:20 +0300
Subject: [PATCH 651/741] enetc: fix issue in MDIO WA leaving irqs disabled

commit 4238a2b5730a7006b38145b808e91901c52c8e9b from
http://source.codeaurora.org/external/qoriq/qoriq-components/linux

Use _irqsave only for local CPU, don't touch the flags for the other CPUS.
The original code is breaking irq flags as it is doing _restore of flags
in the wrong order.

Fixes: 6907d6d1d1cc ("enetc: WA for MDIO register access issue")

Signed-off-by: Alex Marginean <alexandru.marginean@nxp.com>
Signed-off-by: Claudiu Manoil <claudiu.manoil@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/net/ethernet/freescale/enetc/enetc_hw.h | 16 ++++++++++------
 1 file changed, 10 insertions(+), 6 deletions(-)

diff --git a/drivers/net/ethernet/freescale/enetc/enetc_hw.h b/drivers/net/ethernet/freescale/enetc/enetc_hw.h
index 0ea63c9f8427..fa8b2050ad58 100644
--- a/drivers/net/ethernet/freescale/enetc/enetc_hw.h
+++ b/drivers/net/ethernet/freescale/enetc/enetc_hw.h
@@ -401,19 +401,21 @@ static inline u32 enetc_rd_reg_wa_single(void *reg)
 	int cpu;
 	/* per-cpu ENETC lock array for register access issue WA */
 	spinlock_t *lock[ENETC_NR_CPU_LOCKS];
-	unsigned long flags[ENETC_NR_CPU_LOCKS];
+	unsigned long flags;
 
 	preempt_disable();
 
+	local_irq_save(flags);
 	for_each_online_cpu(cpu) {
 		lock[cpu] = per_cpu_ptr(&enetc_gregs, cpu);
-		spin_lock_irqsave(lock[cpu], flags[cpu]);
+		spin_lock(lock[cpu]);
 	}
 
 	val = ioread32(reg);
 
 	for_each_online_cpu(cpu)
-		spin_unlock_irqrestore(lock[cpu], flags[cpu]);
+		spin_unlock(lock[cpu]);
+	local_irq_restore(flags);
 
 	preempt_enable();
 
@@ -425,19 +427,21 @@ static inline void enetc_wr_reg_wa_single(void *reg, u32 val)
 	int cpu;
 	/* per-cpu ENETC lock array for register access issue WA */
 	spinlock_t *lock[ENETC_NR_CPU_LOCKS];
-	unsigned long flags[ENETC_NR_CPU_LOCKS];
+	unsigned long flags;
 
 	preempt_disable();
 
+	local_irq_save(flags);
 	for_each_online_cpu(cpu) {
 		lock[cpu] = per_cpu_ptr(&enetc_gregs, cpu);
-		spin_lock_irqsave(lock[cpu], flags[cpu]);
+		spin_lock(lock[cpu]);
 	}
 
 	iowrite32(val, reg);
 
 	for_each_online_cpu(cpu)
-		spin_unlock_irqrestore(lock[cpu], flags[cpu]);
+		spin_unlock(lock[cpu]);
+	local_irq_restore(flags);
 
 	preempt_enable();
 }
-- 
2.17.1

