From a148dc693d0f5c4e8e0dcb910aca4617ae877ea0 Mon Sep 17 00:00:00 2001
From: Florinel Iordache <florinel.iordache@nxp.com>
Date: Mon, 29 Oct 2018 12:32:15 +0200
Subject: [PATCH 277/741] net/phy: xgkr: Refactoring on serdes specific KR
 implementation

commit 56373539155cd34749f07735fbd8f92b1c76bd2b from
http://source.codeaurora.org/external/qoriq/qoriq-components/linux

This refactoring is required in preparation to add multiple lanes support on KR

Signed-off-by: Florinel Iordache <florinel.iordache@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/net/phy/fsl_backplane.c            | 35 ++++----
 drivers/net/phy/fsl_backplane.h            | 10 ++-
 drivers/net/phy/fsl_backplane_serdes_10g.c | 71 ++++++++++-------
 drivers/net/phy/fsl_backplane_serdes_28g.c | 92 ++++++++++++----------
 4 files changed, 119 insertions(+), 89 deletions(-)

diff --git a/drivers/net/phy/fsl_backplane.c b/drivers/net/phy/fsl_backplane.c
index ba0f7b093986..da0e8fb739db 100644
--- a/drivers/net/phy/fsl_backplane.c
+++ b/drivers/net/phy/fsl_backplane.c
@@ -226,7 +226,7 @@ static void tx_condition_init(struct tx_condition *tx_c)
 
 void tune_tecr0(struct fsl_xgkr_inst *inst)
 {
-	inst->bckpl_sd.tune_tecr0(inst->reg_base, inst->ratio_preq, inst->ratio_pst1q, inst->adpt_eq);
+	inst->bckpl_sd.tune_tecr(inst->reg_base, inst->ratio_preq, inst->ratio_pst1q, inst->adpt_eq, true);
 }
 
 static void start_lt(struct phy_device *phydev)
@@ -907,7 +907,7 @@ static void xgkr_start_train(struct phy_device *phydev)
 				/* LT failed already, reset lane to avoid
 				 * it run into hanging, then start LT again.
 				 */
-				inst->bckpl_sd.reset_gcr0(inst->reg_base);
+				inst->bckpl_sd.reset_lane(inst->reg_base);
 				start_lt(phydev);
 			} else if ((val & PMD_STATUS_SUP_STAT) &&
 				   (val & PMD_STATUS_FRAME_LOCK))
@@ -932,7 +932,7 @@ static void xgkr_start_train(struct phy_device *phydev)
 			lt_state = phy_read_mmd(phydev, lt_MDIO_MMD,
 						lt_KR_PMD_STATUS);
 			if (lt_state & TRAIN_FAIL) {
-				inst->bckpl_sd.reset_gcr0(inst->reg_base);
+				inst->bckpl_sd.reset_lane(inst->reg_base);
 				break;
 			}
 
@@ -1012,8 +1012,7 @@ static int fsl_backplane_probe(struct phy_device *phydev)
 	const char *bm;
 	int ret;
 	int bp_mode;
-	int serdes_type;
-	u32 lane[2];
+	u32 lane[2], lane_memmap_size;
 
 	phy_node = phydev->mdio.dev.of_node;
 	if (!phy_node) {
@@ -1043,12 +1042,12 @@ static int fsl_backplane_probe(struct phy_device *phydev)
 	ret = of_property_read_string(lane_node, "compatible", &st);
 	if (ret < 0) {
 		//assume SERDES-10G if compatible property is not specified
-		serdes_type = SERDES_10G;
+		bckpl_sd.serdes_type = SERDES_10G;
 	}
 	else if (!strcasecmp(st, "fsl,serdes-10g")) {
-		serdes_type = SERDES_10G;
+		bckpl_sd.serdes_type = SERDES_10G;
 	} else if (!strcasecmp(st, "fsl,serdes-28g")) {
-		serdes_type = SERDES_28G;
+		bckpl_sd.serdes_type = SERDES_28G;
 	} else {
 		dev_err(&phydev->mdio.dev, "Unknown serdes-type\n");
 		return -EINVAL;
@@ -1068,15 +1067,7 @@ static int fsl_backplane_probe(struct phy_device *phydev)
 		return -EINVAL;
 	}
 
-	phydev->priv = devm_ioremap_nocache(&phydev->mdio.dev,
-					    res_lane.start + lane[0],
-					    lane[1]);
-	if (!phydev->priv) {
-		dev_err(&phydev->mdio.dev, "ioremap_nocache failed\n");
-		return -ENOMEM;
-	}
-
-	switch (serdes_type)
+	switch (bckpl_sd.serdes_type)
 	{
 	case SERDES_10G:
 		setup_an_lt_ls();
@@ -1105,10 +1096,18 @@ static int fsl_backplane_probe(struct phy_device *phydev)
 	if (!xgkr_inst)
 		return -ENOMEM;
 
-	xgkr_inst->reg_base = phydev->priv;
 	xgkr_inst->phydev = phydev;
 	xgkr_inst->bckpl_sd = bckpl_sd;
 
+	lane_memmap_size = bckpl_sd.get_lane_memmap_size();
+	xgkr_inst->reg_base = devm_ioremap_nocache(&phydev->mdio.dev,
+					        res_lane.start + lane[0],
+					        lane_memmap_size);
+	if (!xgkr_inst->reg_base) {
+		dev_err(&phydev->mdio.dev, "ioremap_nocache failed\n");
+		return -ENOMEM;
+	}
+
 	phydev->priv = xgkr_inst;
 
 	if (bp_mode == PHY_BACKPLANE_10GBASE_KR) {
diff --git a/drivers/net/phy/fsl_backplane.h b/drivers/net/phy/fsl_backplane.h
index 3599a09c22d9..4d17ac1c53a5 100644
--- a/drivers/net/phy/fsl_backplane.h
+++ b/drivers/net/phy/fsl_backplane.h
@@ -12,9 +12,9 @@
 #define FSL_BACKPLANE_H
 
 /* C(-1) */
-#define BIN_M1					0
+#define BIN_M1						0
 /* C(1) */
-#define BIN_LONG				1
+#define BIN_LONG					1
 
 #define BIN_SNAPSHOT_NUM			5
 #define BIN_M1_THRESHOLD			3
@@ -22,8 +22,10 @@
 
 struct backplane_serdes {
 
-	void (*tune_tecr0)(void *reg, u32 ratio_preq, u32 ratio_pst1q, u32 adpt_eq);
-	void (*reset_gcr0)(void *reg);
+	int serdes_type;
+	u32 (*get_lane_memmap_size)(void);
+	void (*tune_tecr)(void *reg, u32 ratio_preq, u32 ratio_pst1q, u32 adpt_eq, bool reset);
+	void (*reset_lane)(void *reg);
 	void (*lane_set_1gkx)(void *reg);
 	int (*get_median_gaink2)(u32 *reg);
 	bool (*is_bin_early)(int bin_sel, void *reg);
diff --git a/drivers/net/phy/fsl_backplane_serdes_10g.c b/drivers/net/phy/fsl_backplane_serdes_10g.c
index 1db0b289cd2f..ff652a0a1ba5 100644
--- a/drivers/net/phy/fsl_backplane_serdes_10g.c
+++ b/drivers/net/phy/fsl_backplane_serdes_10g.c
@@ -21,25 +21,27 @@
 #define POST_COE_SHIFT				16
 #define ZERO_COE_SHIFT				8
 
-#define TECR0_INIT				0x24200000
+#define TECR0_INIT					0x24200000
+
+#define GCR0_RESET_MASK				0x00600000
 
-#define GCR0_RESET_MASK				0x600000
 #define GCR1_SNP_START_MASK			0x00000040
-#define GCR1_CTL_SNP_START_MASK			0x00002000
-#define GCR1_REIDL_TH_MASK			0x00700000
-#define GCR1_REIDL_EX_SEL_MASK			0x000c0000
-#define GCR1_REIDL_ET_MAS_MASK			0x00004000
-#define TECR0_AMP_RED_MASK			0x0000003f
+#define GCR1_CTL_SNP_START_MASK		0x00002000
 
-#define RECR1_CTL_SNP_DONE_MASK			0x00000002
+#define RECR1_CTL_SNP_DONE_MASK		0x00000002
 #define RECR1_SNP_DONE_MASK			0x00000004
 #define TCSR1_SNP_DATA_MASK			0x0000ffc0
-#define TCSR1_SNP_DATA_SHIFT			6
-#define TCSR1_EQ_SNPBIN_SIGN_MASK		0x100
+#define TCSR1_SNP_DATA_SHIFT		6
+#define TCSR1_EQ_SNPBIN_SIGN_MASK	0x100
 
 #define RECR1_GAINK2_MASK			0x0f000000
 #define RECR1_GAINK2_SHIFT			24
 
+/* Required only for 1000BASE KX */
+#define GCR1_REIDL_TH_MASK			0x00700000
+#define GCR1_REIDL_EX_SEL_MASK		0x000c0000
+#define GCR1_REIDL_ET_MAS_MASK		0x00004000
+#define TECR0_AMP_RED_MASK			0x0000003f
 
 struct per_lane_ctrl_status {
 	__be32 gcr0;	/* 0x.000 - General Control Register 0 */
@@ -60,38 +62,52 @@ struct per_lane_ctrl_status {
 	__be32 tcsr3;	/* 0x.03C - Test Control/Status Register 3 */
 };
 
-static void tune_tecr0(void *reg, u32 ratio_preq, u32 ratio_pst1q, u32 adpt_eq)
+static u32 get_lane_memmap_size(void)
 {
-	struct per_lane_ctrl_status *reg_base = reg;
-	u32 val;
+	return 0x40;
+}
 
-	val = TECR0_INIT |
-		adpt_eq << ZERO_COE_SHIFT |
-		ratio_preq << PRE_COE_SHIFT |
-		ratio_pst1q << POST_COE_SHIFT;
+static void reset_lane(void *reg)
+{
+	struct per_lane_ctrl_status *reg_base = reg;
 
 	/* reset the lane */
 	iowrite32(ioread32(&reg_base->gcr0) & ~GCR0_RESET_MASK,
 		    &reg_base->gcr0);
 	udelay(1);
-	iowrite32(val, &reg_base->tecr0);
-	udelay(1);
+	
 	/* unreset the lane */
 	iowrite32(ioread32(&reg_base->gcr0) | GCR0_RESET_MASK,
 		    &reg_base->gcr0);
 	udelay(1);
 }
 
-static void reset_gcr0(void *reg)
+static void tune_tecr(void *reg, u32 ratio_preq, u32 ratio_pst1q, u32 adpt_eq, bool reset)
 {
 	struct per_lane_ctrl_status *reg_base = reg;
+	u32 val;
 
-	iowrite32(ioread32(&reg_base->gcr0) & ~GCR0_RESET_MASK,
-		    &reg_base->gcr0);
-	udelay(1);
-	iowrite32(ioread32(&reg_base->gcr0) | GCR0_RESET_MASK,
-		    &reg_base->gcr0);
+	val = TECR0_INIT |
+		adpt_eq << ZERO_COE_SHIFT |
+		ratio_preq << PRE_COE_SHIFT |
+		ratio_pst1q << POST_COE_SHIFT;
+
+	if (reset) {
+		/* reset the lane */
+		iowrite32(ioread32(&reg_base->gcr0) & ~GCR0_RESET_MASK,
+				&reg_base->gcr0);
+		udelay(1);
+	}
+	
+	iowrite32(val, &reg_base->tecr0);
 	udelay(1);
+	
+	if (reset) {
+		/* unreset the lane */
+		iowrite32(ioread32(&reg_base->gcr0) | GCR0_RESET_MASK,
+				&reg_base->gcr0);
+		udelay(1);
+	}
 }
 
 static void lane_set_1gkx(void *reg)
@@ -251,8 +267,9 @@ static bool is_bin_early(int bin_sel, void *reg)
 
 void setup_backplane_serdes_10g(struct backplane_serdes *bckpl_serdes)
 {
-	bckpl_serdes->tune_tecr0 = tune_tecr0;
-	bckpl_serdes->reset_gcr0 = reset_gcr0;
+	bckpl_serdes->get_lane_memmap_size = get_lane_memmap_size;
+	bckpl_serdes->tune_tecr = tune_tecr;
+	bckpl_serdes->reset_lane = reset_lane;
 	bckpl_serdes->lane_set_1gkx = lane_set_1gkx;
 	bckpl_serdes->get_median_gaink2 = get_median_gaink2;
 	bckpl_serdes->is_bin_early = is_bin_early;
diff --git a/drivers/net/phy/fsl_backplane_serdes_28g.c b/drivers/net/phy/fsl_backplane_serdes_28g.c
index 483f74d5cdee..eec1263885ec 100644
--- a/drivers/net/phy/fsl_backplane_serdes_28g.c
+++ b/drivers/net/phy/fsl_backplane_serdes_28g.c
@@ -13,18 +13,17 @@
 
 #include "fsl_backplane.h"
 
+#define BIN_M1_SEL					0x0000c000
+#define BIN_Long_SEL				0x0000d000
+#define CDR_SEL_MASK				0x0000f000
+
 #define PRE_COE_SHIFT				16
 #define POST_COE_SHIFT				8
 #define ZERO_COE_SHIFT				24
 
 #define TECR0_INIT					0x20808000
 
-#define TECR0_AMP_RED_MASK			0x0000003f
-
-#define GCR0_RESET_MASK				0x020000
-#define BIN_M1_SEL					0x0000c000
-#define BIN_Long_SEL				0x0000d000
-#define CDR_SEL_MASK				0x0000f000
+#define RESET_REQ_MASK				0x80000000
 
 #define RECR3_SNP_START_MASK		0x80000000
 #define RECR3_SNP_DONE_MASK			0x40000000
@@ -36,7 +35,7 @@
 #define RECR3_GAINK2_MASK			0x1f000000
 #define RECR3_GAINK2_SHIFT			24
 
-//used only for 1GKX:
+/* Required only for 1000BASE KX */
 #define GCR1_REIDL_TH_MASK			0x00700000
 #define GCR1_REIDL_EX_SEL_MASK		0x000c0000
 #define GCR1_REIDL_ET_MAS_MASK		0x04000000
@@ -109,16 +108,52 @@ struct per_lane_ctrl_status {
 	__be32 resv25;	/* 0x.0FC - Reserved */
 };
 
-static void tune_tecr0(void *reg, u32 ratio_preq, u32 ratio_pst1q, u32 adpt_eq)
+static u32 get_lane_memmap_size(void)
+{
+	return 0x100;
+}
+
+static void reset_lane(void *reg)
 {
 	struct per_lane_ctrl_status *reg_base = reg;
 	u32 val;
+	int timeout;
 
-	/* reset the lane */
-	iowrite32(ioread32(&reg_base->gcr0) & ~GCR0_RESET_MASK,
-		    &reg_base->gcr0);
+	/* reset Tx lane: send reset request */
+	iowrite32(ioread32(&reg_base->trstctl) | RESET_REQ_MASK,
+		    &reg_base->trstctl);
 	udelay(1);
+	timeout = 10;
+	while (timeout--) {
+		val = ioread32(&reg_base->trstctl);
+		if (!(val & RESET_REQ_MASK))
+			break;
+		usleep_range(5, 20);
+	}
+	
+	/* reset Rx lane: send reset request */
+	iowrite32(ioread32(&reg_base->rrstctl) | RESET_REQ_MASK,
+		    &reg_base->rrstctl);
+	udelay(1);
+	timeout = 10;
+	while (timeout--) {
+		val = ioread32(&reg_base->rrstctl);
+		if (!(val & RESET_REQ_MASK))
+			break;
+		usleep_range(5, 20);
+	}
+}
 
+static void tune_tecr(void *reg, u32 ratio_preq, u32 ratio_pst1q, u32 adpt_eq, bool reset)
+{
+	struct per_lane_ctrl_status *reg_base = reg;
+	u32 val;
+
+	if (reset) {
+		/* reset lanes */
+		reset_lane(reg);
+	}
+	
 	val = TECR0_INIT |
 		ratio_preq << PRE_COE_SHIFT |
 		ratio_pst1q << POST_COE_SHIFT;
@@ -126,24 +161,7 @@ static void tune_tecr0(void *reg, u32 ratio_preq, u32 ratio_pst1q, u32 adpt_eq)
 
 	val = adpt_eq << ZERO_COE_SHIFT;
 	iowrite32(val, &reg_base->tecr1);
-
-	udelay(1);
-
-	/* unreset the lane */
-	iowrite32(ioread32(&reg_base->gcr0) | GCR0_RESET_MASK,
-		    &reg_base->gcr0);
-	udelay(1);
-}
-
-static void reset_gcr0(void *reg)
-{
-	struct per_lane_ctrl_status *reg_base = reg;
-
-	iowrite32(ioread32(&reg_base->gcr0) & ~GCR0_RESET_MASK,
-		    &reg_base->gcr0);
-	udelay(1);
-	iowrite32(ioread32(&reg_base->gcr0) | GCR0_RESET_MASK,
-		    &reg_base->gcr0);
+	
 	udelay(1);
 }
 
@@ -152,10 +170,8 @@ static void lane_set_1gkx(void *reg)
 	struct per_lane_ctrl_status *reg_base = reg;
 	u32 val;
 
-	/* reset the lane */
-	iowrite32(ioread32(&reg_base->gcr0) & ~GCR0_RESET_MASK,
-		    &reg_base->gcr0);
-	udelay(1);
+	/* reset lanes */
+	reset_lane(reg);
 
 	/* set gcr1 for 1GKX */
 	val = ioread32(&reg_base->rxgcr1);
@@ -169,11 +185,6 @@ static void lane_set_1gkx(void *reg)
 	val &= ~TECR0_AMP_RED_MASK;
 	iowrite32(val, &reg_base->tecr0);
 	udelay(1);
-
-	/* unreset the lane */
-	iowrite32(ioread32(&reg_base->gcr0) | GCR0_RESET_MASK,
-		    &reg_base->gcr0);
-	udelay(1);
 }
 
 static int get_median_gaink2(u32 *reg)
@@ -304,8 +315,9 @@ static bool is_bin_early(int bin_sel, void *reg)
 
 void setup_backplane_serdes_28g(struct backplane_serdes *bckpl_serdes)
 {
-	bckpl_serdes->tune_tecr0 = tune_tecr0;
-	bckpl_serdes->reset_gcr0 = reset_gcr0;
+	bckpl_serdes->get_lane_memmap_size = get_lane_memmap_size;
+	bckpl_serdes->tune_tecr = tune_tecr;
+	bckpl_serdes->reset_lane = reset_lane;
 	bckpl_serdes->lane_set_1gkx = lane_set_1gkx;
 	bckpl_serdes->get_median_gaink2 = get_median_gaink2;
 	bckpl_serdes->is_bin_early = is_bin_early;
-- 
2.17.1

