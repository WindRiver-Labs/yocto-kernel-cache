From 3d401febc9ccccdd5215a932de7b4891ca3e3c37 Mon Sep 17 00:00:00 2001
From: Xulin Sun <xulin.sun@windriver.com>
Date: Tue, 7 Jan 2020 16:36:31 +0800
Subject: [PATCH 11/22] irqchip: imx-irqsteer: add clock operations during
 probe

Some platforms like i.MX8QXP has clock control for this module
irqsteer, which as an interrupt controller cooperates with GIC,
gathers interrupts from the system and can be used to steer them
to one of the output bits (non A-series core).

Need to add clock operations and enable channel to IRQs during
initialization to make sure the driver is working properly.

This will fix the kdump hung issue when calling machine_kexec_mask_interrupts()
to mask the related interrupt but hung due to the irqsteer is in a
messy state.

Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/irqchip/irq-imx-irqsteer.c | 16 +++++++++++++++-
 1 file changed, 15 insertions(+), 1 deletion(-)
 mode change 100644 => 100755 drivers/irqchip/irq-imx-irqsteer.c

diff --git a/drivers/irqchip/irq-imx-irqsteer.c b/drivers/irqchip/irq-imx-irqsteer.c
old mode 100644
new mode 100755
index 29361048fd1f..0bc889f7a733
--- a/drivers/irqchip/irq-imx-irqsteer.c
+++ b/drivers/irqchip/irq-imx-irqsteer.c
@@ -216,6 +216,15 @@ static int imx_irqsteer_probe(struct platform_device *pdev)
 	irqsteer_data->inited = false;
 	spin_lock_init(&irqsteer_data->lock);
 
+	ret = clk_prepare_enable(irqsteer_data->ipg_clk);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to enable ipg clk: %d\n", ret);
+		return ret;
+	}
+
+	/* steer IRQs into configured channel */
+	writel_relaxed(BIT(irqsteer_data->channum), irqsteer_data->regs + CHANCTRL);
+
 	irqsteer_data->domain = irq_domain_add_linear(np,
 						 irqsteer_data->channum * 32,
 						 &imx_irqsteer_domain_ops,
@@ -223,7 +232,8 @@ static int imx_irqsteer_probe(struct platform_device *pdev)
 	if (!irqsteer_data->domain) {
 		dev_err(&irqsteer_data->pdev->dev,
 			"failed to create IRQ domain\n");
-		return -ENOMEM;
+		ret = -ENOMEM;
+		goto out;
 	}
 
 	irq_set_chained_handler_and_data(irqsteer_data->irq,
@@ -234,6 +244,10 @@ static int imx_irqsteer_probe(struct platform_device *pdev)
 
 	pm_runtime_enable(&pdev->dev);
 	return 0;
+
+out:
+	clk_disable_unprepare(irqsteer_data->ipg_clk);
+	return ret;
 }
 
 static int imx_irqsteer_remove(struct platform_device *pdev)
-- 
2.17.1

