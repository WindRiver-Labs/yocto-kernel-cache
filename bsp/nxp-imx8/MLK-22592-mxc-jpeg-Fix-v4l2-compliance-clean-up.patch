From c91a9a268e93615d6a25490cedd40f434d295be0 Mon Sep 17 00:00:00 2001
From: Mirela Rabulea <mirela.rabulea@nxp.com>
Date: Sun, 22 Sep 2019 11:28:11 +0300
Subject: [PATCH 08/37] MLK-22592: mxc-jpeg: Fix v4l2-compliance, clean-up

commit 9499d3fa0ac083d0004960c0785f9adb7a9dc6c3 from
https://source.codeaurora.org/external/imx/linux-imx.git

Isolate bytesperline/sizeimage calculations into a single place:
mxc_jpeg_bytesperline/mxc_jpeg_sizeimage new functions. Use the
new function during jpeg parse, TRY_FMT ioctl and default setup.

Signed-off-by: Mirela Rabulea <mirela.rabulea@nxp.com>
Reviewed-by: Robert Chiras <robert.chiras@nxp.com>
(cherry picked from commit 11638d431401b138ab686d5320b78a6f9073a498)
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/media/platform/imx8/mxc-jpeg.c | 110 +++++++++++--------------
 1 file changed, 46 insertions(+), 64 deletions(-)

diff --git a/drivers/media/platform/imx8/mxc-jpeg.c b/drivers/media/platform/imx8/mxc-jpeg.c
index d594e9d5d5da..2d3ad8362ff5 100644
--- a/drivers/media/platform/imx8/mxc-jpeg.c
+++ b/drivers/media/platform/imx8/mxc-jpeg.c
@@ -1199,45 +1199,45 @@ static enum mxc_jpeg_image_format mxc_jpeg_get_image_format(
 static void mxc_jpeg_bytesperline(struct mxc_jpeg_q_data *q,
 				  u32 precision)
 {
-	q->bytesperline[1] = 0;
-	switch (q->fmt->fourcc) {
-	case  V4L2_PIX_FMT_NV12:
-		q->bytesperline[0] = q->w * (precision / 8);
-		q->bytesperline[1] = q->w * (precision / 8) / 2;
-		break;
-	case  V4L2_PIX_FMT_YUYV:
-		q->bytesperline[0] = q->w * (precision / 8) * 2;
-		break;
-	case  V4L2_PIX_FMT_RGB24:
-		q->bytesperline[0] = q->w * (precision / 8) * 3;
-		break;
-	case  V4L2_PIX_FMT_ARGB32:
-		q->bytesperline[0] = q->w * (precision / 8) * 4;
-		break;
-	case  V4L2_PIX_FMT_YUV24:
-		q->bytesperline[0] = q->w * (precision / 8) * 3;
-		break;
-	case  V4L2_PIX_FMT_GREY:
-		q->bytesperline[0] = q->w * (precision / 8) * 1;
-		break;
-	case V4L2_PIX_FMT_JPEG:
+	/* Bytes distance between the leftmost pixels in two adjacent lines */
+	if (q->fmt->fourcc == V4L2_PIX_FMT_JPEG) {
+		/* bytesperline unused for compressed formats */
 		q->bytesperline[0] = 0;
-		break;
-	default:
-		q->bytesperline[0] = q->w * (precision / 8) * 3;
-		break;
+		q->bytesperline[1] = 0;
+	} else if (q->fmt->fourcc == V4L2_PIX_FMT_NV12) {
+		/* When the image format is planar the bytesperline value
+		 * applies to the first plane and is divided by the same factor
+		 * as the width field for the other planes
+		 */
+		q->bytesperline[0] = q->w * (precision / 8) *
+				     (q->fmt->depth / 8);
+		q->bytesperline[1] = q->bytesperline[0];
+	} else {
+		/* single plane formats */
+		q->bytesperline[0] = q->w * (precision / 8) *
+				     (q->fmt->depth / 8);
+		q->bytesperline[1] = 0;
 	}
 }
 
 static void mxc_jpeg_sizeimage(struct mxc_jpeg_q_data *q)
 {
 	if (q->fmt->fourcc == V4L2_PIX_FMT_JPEG) {
-		/* assuming worst jpeg compression */
-		q->sizeimage[0] = 6 * q->w * q->h;
+		/* if no sizeimage from user, assume worst jpeg compression */
+		if (!q->sizeimage[0])
+			q->sizeimage[0] = 6 * q->w * q->h;
 		q->sizeimage[1] = 0;
+
+		if (q->sizeimage[0] > MXC_JPEG_MAX_SIZEIMAGE)
+			q->sizeimage[0] = MXC_JPEG_MAX_SIZEIMAGE;
+
+		/* jpeg stream size must be multiple of 1K */
+		q->sizeimage[0] = ALIGN(q->sizeimage[0], 1024);
 	} else {
 		q->sizeimage[0] = q->bytesperline[0] * q->h;
-		q->sizeimage[1] = q->bytesperline[1] * q->h;
+		q->sizeimage[1] = 0;
+		if (q->fmt->fourcc == V4L2_PIX_FMT_NV12)
+			q->sizeimage[1] = q->sizeimage[0] / 2;
 	}
 }
 
@@ -1644,10 +1644,8 @@ static int mxc_jpeg_try_fmt(struct v4l2_format *f, struct mxc_jpeg_fmt *fmt,
 		 pix_mp->width : MXC_JPEG_MAX_WIDTH;
 	u32 h = (pix_mp->height < MXC_JPEG_MAX_HEIGHT) ?
 		 pix_mp->height : MXC_JPEG_MAX_HEIGHT;
-
-	unsigned int mode = ctx->mode;
 	int i;
-	bool is_nv12 = (fmt->fourcc == V4L2_PIX_FMT_NV12);
+	struct mxc_jpeg_q_data tmp_q;
 
 	memset(pix_mp->reserved, 0, sizeof(pix_mp->reserved));
 	pix_mp->field = V4L2_FIELD_NONE;
@@ -1671,42 +1669,26 @@ static int mxc_jpeg_try_fmt(struct v4l2_format *f, struct mxc_jpeg_fmt *fmt,
 	pix_mp->width = w; /* negotiate the width */
 	pix_mp->height = h; /* negotiate the height */
 
+	/* get user input into the tmp_q */
+	tmp_q.w = w;
+	tmp_q.h = h;
+	tmp_q.fmt = fmt;
+	for (i = 0; i < pix_mp->num_planes; i++) {
+		pfmt = &pix_mp->plane_fmt[i];
+		tmp_q.bytesperline[i] = pfmt->bytesperline;
+		tmp_q.sizeimage[i] = pfmt->sizeimage;
+	}
+
+	/* calculate bytesperline & sizeimage into the tmp_q */
+	mxc_jpeg_bytesperline(&tmp_q, 8);
+	mxc_jpeg_sizeimage(&tmp_q);
 
+	/* adjust user format according to our calculations */
 	for (i = 0; i < pix_mp->num_planes; i++) {
 		pfmt = &pix_mp->plane_fmt[i];
 		memset(pfmt->reserved, 0, sizeof(pfmt->reserved));
-
-		/* TODO try_fmt should not modify the state, move to s_fmt */
-		if (q_type == MXC_JPEG_FMT_TYPE_ENC &&
-		    mode == MXC_JPEG_DECODE) {
-			pfmt->bytesperline = 0;
-			if (pfmt->sizeimage == 0)
-				pfmt->sizeimage = MXC_JPEG_DEFAULT_SIZEIMAGE;
-			if (pfmt->sizeimage > MXC_JPEG_MAX_SIZEIMAGE)
-				pfmt->sizeimage = MXC_JPEG_MAX_SIZEIMAGE;
-			/* input jpeg stream must be aligned to 1024 */
-			pfmt->sizeimage = ALIGN(pfmt->sizeimage, 1024);
-		} else if (q_type == MXC_JPEG_FMT_TYPE_RAW &&
-		    mode == MXC_JPEG_DECODE) {
-			pfmt->bytesperline = w * (fmt->depth / 8);
-			pfmt->sizeimage = w * h * fmt->depth / 8;
-			if (is_nv12 && i == 0) /* luma plane */
-				pfmt->sizeimage = pfmt->sizeimage * 2 / 3;
-			else if (is_nv12 && i == 1) /* chroma plane */
-				pfmt->sizeimage = pfmt->sizeimage * 1 / 3;
-		} else if (q_type == MXC_JPEG_FMT_TYPE_ENC &&
-		    mode == MXC_JPEG_ENCODE) {
-			pfmt->bytesperline = 0;
-			/* assuming worst jpeg compression */
-			pfmt->sizeimage = w * h * 6;
-		} else { /* MXC_JPEG_FMT_TYPE_RAW && MXC_JPEG_ENCODE */
-			pfmt->bytesperline = w * (fmt->depth / 8);
-			pfmt->sizeimage = w * h * fmt->depth / 8;
-			if (is_nv12 && i == 0) /* luma plane */
-				pfmt->sizeimage = pfmt->sizeimage * 2 / 3;
-			else if (is_nv12 && i == 1) /* chroma plane */
-				pfmt->sizeimage = pfmt->sizeimage * 1 / 3;
-		}
+		pfmt->bytesperline = tmp_q.bytesperline[i];
+		pfmt->sizeimage = tmp_q.sizeimage[i];
 	}
 
 	return 0;
-- 
2.17.1

