From e11ace7c07a0d1d969a91130807341f3571d8376 Mon Sep 17 00:00:00 2001
From: Limeng <Meng.Li@windriver.com>
Date: Mon, 8 Jun 2020 19:16:16 +0800
Subject: [PATCH 8/9] driver: pinctrl: freescale: update pinctrl driver imx8
 platform
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

There is a SCU(system controller unit) in imx8 serise SoC. In fact,
it is a firmware running on CortexM Processor. The code running
on  CortexA processor communicate with the firmware by IPC.
For example, imx8 pin config is set by SCU, so it is need to send
command from CortexA to CortexM with IPC interface.
In kernel v5.2, there is a upstream commit edbee095fafb("firmware:
imx: add SCU firmware driver support "). So, when porting patch from
nxp-imx-sdk4.19, the mainline scu driver is used for pinctrl driver.
But the mainline scu driver doesnâ€™t have corresponding dts node to
enable it, and conflict with also is not compatible with ipc.c that
from nxp-imx-sdk4.19, commit cc2f301f1af8("MLK-22241-2 imx: ipc:
include back HVC SC ").
Therefore, modify pinctrl driver related code to unify them to
nxp-imx-sdk4.19.

Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/pinctrl/freescale/pinctrl-imx.c     |   8 +-
 drivers/pinctrl/freescale/pinctrl-imx.h     |  34 ++---
 drivers/pinctrl/freescale/pinctrl-imx8qm.c  |  19 ++-
 drivers/pinctrl/freescale/pinctrl-imx8qxp.c |  18 ++-
 drivers/pinctrl/freescale/pinctrl-scu.c     | 130 +++++++++-----------
 5 files changed, 111 insertions(+), 98 deletions(-)

diff --git a/drivers/pinctrl/freescale/pinctrl-imx.c b/drivers/pinctrl/freescale/pinctrl-imx.c
index 024c39ef0c46..0147e2c99a4f 100644
--- a/drivers/pinctrl/freescale/pinctrl-imx.c
+++ b/drivers/pinctrl/freescale/pinctrl-imx.c
@@ -373,7 +373,7 @@ static int imx_pinconf_get(struct pinctrl_dev *pctldev,
 	const struct imx_pinctrl_soc_info *info = ipctl->info;
 
 	if (info->flags & IMX_USE_SCU)
-		return imx_pinconf_get_scu(pctldev, pin_id, config);
+		return imx_pinconf_backend_get_scu(pctldev, pin_id, config);
 	else
 		return imx_pinconf_get_mmio(pctldev, pin_id, config);
 }
@@ -423,8 +423,8 @@ static int imx_pinconf_set(struct pinctrl_dev *pctldev,
 	const struct imx_pinctrl_soc_info *info = ipctl->info;
 
 	if (info->flags & IMX_USE_SCU)
-		return imx_pinconf_set_scu(pctldev, pin_id,
-					   configs, num_configs);
+		return imx_pinconf_backend_set_scu(pctldev, pin_id,
+						configs, num_configs);
 	else
 		return imx_pinconf_set_mmio(pctldev, pin_id,
 					    configs, num_configs);
@@ -440,7 +440,7 @@ static void imx_pinconf_dbg_show(struct pinctrl_dev *pctldev,
 	int ret;
 
 	if (info->flags & IMX_USE_SCU) {
-		ret = imx_pinconf_get_scu(pctldev, pin_id, &config);
+		ret = imx_pinconf_backend_get_scu(pctldev, pin_id, &config);
 		if (ret) {
 			dev_err(ipctl->dev, "failed to get %s pinconf\n",
 				pin_get_name(pctldev, pin_id));
diff --git a/drivers/pinctrl/freescale/pinctrl-imx.h b/drivers/pinctrl/freescale/pinctrl-imx.h
index f1aadb13372e..3234c8c7a1c9 100644
--- a/drivers/pinctrl/freescale/pinctrl-imx.h
+++ b/drivers/pinctrl/freescale/pinctrl-imx.h
@@ -129,6 +129,9 @@ struct imx_pinctrl {
 #define IMX8_ENABLE_MUX_CONFIG	(1 << 29)
 #define IMX8_ENABLE_PAD_CONFIG	(1 << 30)
 
+#define BM_IMX8_GP_ENABLE	(1 << 30)
+#define BM_IMX8_IFMUX_ENABLE	(1 << 31)
+
 #define NO_MUX		0x0
 #define NO_PAD		0x0
 
@@ -142,29 +145,28 @@ int imx_pinctrl_probe(struct platform_device *pdev,
 			const struct imx_pinctrl_soc_info *info);
 
 #ifdef CONFIG_PINCTRL_IMX_SCU
-#define BM_PAD_CTL_GP_ENABLE		BIT(30)
-#define BM_PAD_CTL_IFMUX_ENABLE		BIT(31)
-#define BP_PAD_CTL_IFMUX		27
-
-int imx_pinctrl_sc_ipc_init(struct platform_device *pdev);
-int imx_pinconf_get_scu(struct pinctrl_dev *pctldev, unsigned pin_id,
-			unsigned long *config);
-int imx_pinconf_set_scu(struct pinctrl_dev *pctldev, unsigned pin_id,
-			unsigned long *configs, unsigned num_configs);
+int imx_pmx_set_one_pin_scu(struct imx_pinctrl *ipctl, struct imx_pin *pin);
+int imx_pinconf_backend_get_scu(struct pinctrl_dev *pctldev, unsigned pin_id,
+		unsigned long *config);
+int imx_pinconf_backend_set_scu(struct pinctrl_dev *pctldev, unsigned pin_id,
+		unsigned long *configs, unsigned num_configs);
 void imx_pinctrl_parse_pin_scu(struct imx_pinctrl *ipctl,
 			       unsigned int *pin_id, struct imx_pin *pin,
 			       const __be32 **list_p);
 #else
-static inline int imx_pinconf_get_scu(struct pinctrl_dev *pctldev,
-				      unsigned pin_id, unsigned long *config)
+static inline int imx_pmx_set_one_pin_scu(struct imx_pinctrl *ipctl, struct imx_pin *pin)
+{
+	return 0;
+}
+static inline int imx_pinconf_backend_get_scu(struct pinctrl_dev *pctldev, unsigned pin_id,
+		unsigned long *config)
 {
-	return -EINVAL;
+	return 0;
 }
-static inline int imx_pinconf_set_scu(struct pinctrl_dev *pctldev,
-				      unsigned pin_id, unsigned long *configs,
-				      unsigned num_configs)
+static inline int imx_pinconf_backend_set_scu(struct pinctrl_dev *pctldev, unsigned pin_id,
+		unsigned long *configs, unsigned num_configs)
 {
-	return -EINVAL;
+	return 0;
 }
 static inline void imx_pinctrl_parse_pin_scu(struct imx_pinctrl *ipctl,
 					    unsigned int *pin_id,
diff --git a/drivers/pinctrl/freescale/pinctrl-imx8qm.c b/drivers/pinctrl/freescale/pinctrl-imx8qm.c
index 82df6c610b32..33929ba969c6 100644
--- a/drivers/pinctrl/freescale/pinctrl-imx8qm.c
+++ b/drivers/pinctrl/freescale/pinctrl-imx8qm.c
@@ -25,6 +25,8 @@
 
 #include "pinctrl-imx.h"
 
+extern sc_ipc_t pinctrl_ipcHandle;
+
 static const struct pinctrl_pin_desc imx8qm_pinctrl_pads[] = {
 	IMX_PINCTRL_PIN(SC_P_SIM0_CLK),
 	IMX_PINCTRL_PIN(SC_P_SIM0_RST),
@@ -311,12 +313,21 @@ static struct of_device_id imx8qm_pinctrl_of_match[] = {
 
 static int imx8qm_pinctrl_probe(struct platform_device *pdev)
 {
-	int ret;
+	uint32_t mu_id;
+	sc_err_t sciErr = SC_ERR_NONE;
+
+	sciErr = sc_ipc_getMuID(&mu_id);
+	if (sciErr != SC_ERR_NONE) {
+		pr_info("pinctrl: Cannot obtain MU ID\n");
+		return sciErr;
+	}
 
-	ret = imx_pinctrl_sc_ipc_init(pdev);
-	if (ret)
-			return ret;
+	sciErr = sc_ipc_open(&pinctrl_ipcHandle, mu_id);
 
+	if (sciErr != SC_ERR_NONE) {
+		pr_info("pinctrl: Cannot open MU channel to SCU\n");
+		return sciErr;
+	};
 
 	return imx_pinctrl_probe(pdev, &imx8qm_pinctrl_info);
 }
diff --git a/drivers/pinctrl/freescale/pinctrl-imx8qxp.c b/drivers/pinctrl/freescale/pinctrl-imx8qxp.c
index 49a54973a98c..06220d302d1f 100644
--- a/drivers/pinctrl/freescale/pinctrl-imx8qxp.c
+++ b/drivers/pinctrl/freescale/pinctrl-imx8qxp.c
@@ -218,11 +218,21 @@ static struct of_device_id imx8qxp_pinctrl_of_match[] = {
 
 static int imx8qxp_pinctrl_probe(struct platform_device *pdev)
 {
-	int ret;
+	uint32_t mu_id;
+	sc_err_t sciErr = SC_ERR_NONE;
 
-	ret = imx_pinctrl_sc_ipc_init(pdev);
-	if (ret)
-		return ret;
+	sciErr = sc_ipc_getMuID(&mu_id);
+	if (sciErr != SC_ERR_NONE) {
+		pr_info("pinctrl: Cannot obtain MU ID\n");
+		return sciErr;
+	}
+
+	sciErr = sc_ipc_open(&pinctrl_ipcHandle, mu_id);
+
+	if (sciErr != SC_ERR_NONE) {
+		pr_info("pinctrl: Cannot open MU channel to SCU\n");
+		return sciErr;
+	};
 
 	return imx_pinctrl_probe(pdev, &imx8qxp_pinctrl_info);
 }
diff --git a/drivers/pinctrl/freescale/pinctrl-scu.c b/drivers/pinctrl/freescale/pinctrl-scu.c
index 23cf04bdfc55..7162940f3aef 100644
--- a/drivers/pinctrl/freescale/pinctrl-scu.c
+++ b/drivers/pinctrl/freescale/pinctrl-scu.c
@@ -1,105 +1,94 @@
-// SPDX-License-Identifier: GPL-2.0+
 /*
  * Copyright (C) 2016 Freescale Semiconductor, Inc.
- * Copyright 2017-2018 NXP
- *	Dong Aisheng <aisheng.dong@nxp.com>
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
  */
 
 #include <linux/err.h>
-#include <linux/firmware/imx/sci.h>
-#include <linux/of_address.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/pinctrl/machine.h>
+#include <linux/pinctrl/pinconf.h>
 #include <linux/pinctrl/pinctrl.h>
-#include <linux/platform_device.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/slab.h>
+#include <soc/imx8/sc/sci.h>
 
 #include "../core.h"
 #include "pinctrl-imx.h"
 
-enum pad_func_e {
-	IMX_SC_PAD_FUNC_SET = 15,
-	IMX_SC_PAD_FUNC_GET = 16,
-};
+sc_ipc_t pinctrl_ipcHandle;
 
-struct imx_sc_msg_req_pad_set {
-	struct imx_sc_rpc_msg hdr;
-	u32 val;
-	u16 pad;
-} __packed __aligned(4);
-
-struct imx_sc_msg_req_pad_get {
-	struct imx_sc_rpc_msg hdr;
-	u16 pad;
-} __packed __aligned(4);
-
-struct imx_sc_msg_resp_pad_get {
-	struct imx_sc_rpc_msg hdr;
-	u32 val;
-} __packed;
-
-static struct imx_sc_ipc *pinctrl_ipc_handle;
-
-int imx_pinctrl_sc_ipc_init(struct platform_device *pdev)
+int imx_pmx_set_one_pin_scu(struct imx_pinctrl *ipctl, struct imx_pin *pin)
 {
-	return imx_scu_get_handle(&pinctrl_ipc_handle);
+	return 0;
 }
 
-int imx_pinconf_get_scu(struct pinctrl_dev *pctldev, unsigned pin_id,
-			unsigned long *config)
+int imx_pinconf_backend_get_scu(struct pinctrl_dev *pctldev, unsigned pin_id,
+			    unsigned long *config)
 {
-	struct imx_sc_msg_req_pad_get msg;
-	struct imx_sc_msg_resp_pad_get *resp;
-	struct imx_sc_rpc_msg *hdr = &msg.hdr;
-	int ret;
-
-	hdr->ver = IMX_SC_RPC_VERSION;
-	hdr->svc = IMX_SC_RPC_SVC_PAD;
-	hdr->func = IMX_SC_PAD_FUNC_GET;
-	hdr->size = 2;
+	sc_err_t err = SC_ERR_NONE;
+	sc_ipc_t ipc = pinctrl_ipcHandle;
 
-	msg.pad = pin_id;
+	if (ipc == -1) {
+		printk("IPC handle not initialized!\n");
+		return -EIO;
+	}
 
-	ret = imx_scu_call_rpc(pinctrl_ipc_handle, &msg, true);
-	if (ret)
-		return ret;
+	err = sc_pad_get(ipc, pin_id, (unsigned int *)config);
 
-	resp = (struct imx_sc_msg_resp_pad_get *)&msg;
-	*config = resp->val;
+	if (err != SC_ERR_NONE)
+		return -EIO;
 
 	return 0;
 }
 
-int imx_pinconf_set_scu(struct pinctrl_dev *pctldev, unsigned pin_id,
-			unsigned long *configs, unsigned num_configs)
+int imx_pinconf_backend_set_scu(struct pinctrl_dev *pctldev, unsigned pin_id,
+			    unsigned long *configs, unsigned num_configs)
 {
+	sc_err_t err = SC_ERR_NONE;
+	sc_ipc_t ipc = pinctrl_ipcHandle;
 	struct imx_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);
-	struct imx_sc_msg_req_pad_set msg;
-	struct imx_sc_rpc_msg *hdr = &msg.hdr;
-	unsigned int mux = configs[0];
-	unsigned int conf = configs[1];
-	unsigned int val;
-	int ret;
-
+	const struct imx_pinctrl_soc_info *info = ipctl->info;
 	/*
-	 * Set mux and conf together in one IPC call
+	 * Mux should be done in pmx set, but we do not have a good api
+	 * to handle that in scfw, so config it in pad conf func
 	 */
-	WARN_ON(num_configs != 2);
+	unsigned int mux = configs[0];
+	unsigned int val = configs[1];
 
-	val = conf | BM_PAD_CTL_IFMUX_ENABLE | BM_PAD_CTL_GP_ENABLE;
-	val |= mux << BP_PAD_CTL_IFMUX;
+	if (ipc == -1) {
+		printk("IPC handle not initialized!\n");
+		return -EIO;
+	}
 
-	hdr->ver = IMX_SC_RPC_VERSION;
-	hdr->svc = IMX_SC_RPC_SVC_PAD;
-	hdr->func = IMX_SC_PAD_FUNC_SET;
-	hdr->size = 3;
+	if (info->flags & IMX8_ENABLE_MUX_CONFIG)
+		val |= BM_IMX8_IFMUX_ENABLE;
 
-	msg.pad = pin_id;
-	msg.val = val;
+	if (info->flags & IMX8_ENABLE_PAD_CONFIG)
+		val |= BM_IMX8_GP_ENABLE;
 
-	ret = imx_scu_call_rpc(pinctrl_ipc_handle, &msg, true);
+	if (info->flags & SHARE_MUX_CONF_REG) {
+		val |= (mux << 27) & (0x7 << 27);
+		err = sc_pad_set(ipc, pin_id, val);
+	}
 
-	dev_dbg(ipctl->dev, "write: pin_id %u config 0x%x val 0x%x\n",
-		pin_id, conf, val);
+	if (err != SC_ERR_NONE)
+		return -EIO;
 
-	return ret;
+	return 0;
 }
 
 void imx_pinctrl_parse_pin_scu(struct imx_pinctrl *ipctl,
@@ -119,3 +108,4 @@ void imx_pinctrl_parse_pin_scu(struct imx_pinctrl *ipctl,
 	dev_dbg(ipctl->dev, "%s: 0x%x 0x%08lx", info->pins[pin->pin].name,
 		pin_scu->mux_mode, pin_scu->config);
 }
+
-- 
2.17.1

