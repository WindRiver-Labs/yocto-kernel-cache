From 2a533ca9d5c7a6723533e3441b1031fee77fb9b1 Mon Sep 17 00:00:00 2001
From: ming_qian <ming.qian@nxp.com>
Date: Wed, 13 Nov 2019 17:57:40 +0800
Subject: [PATCH 13/37] MLK-22963: VPU encoder: fix call vzalloc during
 spinlock

commit a9e7b669ca5fae0bdd0db618fc9a049e4eb7c855 from
https://source.codeaurora.org/external/imx/linux-imx.git

platform vzalloc may call wait_completion to sleep,
but sleep is forbidden during spinlock,
so use mutex instead

Signed-off-by: ming_qian <ming.qian@nxp.com>
Reviewed-by: Shijie Qin <shijie.qin@nxp.com>
(cherry picked from commit 5c96bd4a36f8b5dd4dc067a5dfd349a26b2eaf84)
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/mxc/vpu_windsor/vpu_encoder_b0.h  |  2 +-
 drivers/mxc/vpu_windsor/vpu_encoder_mem.c | 15 ++++++++-------
 2 files changed, 9 insertions(+), 8 deletions(-)

diff --git a/drivers/mxc/vpu_windsor/vpu_encoder_b0.h b/drivers/mxc/vpu_windsor/vpu_encoder_b0.h
index a9ad783461b1..5b315acac321 100644
--- a/drivers/mxc/vpu_windsor/vpu_encoder_b0.h
+++ b/drivers/mxc/vpu_windsor/vpu_encoder_b0.h
@@ -328,7 +328,7 @@ struct vpu_enc_mem_info {
 	unsigned long size;
 	unsigned long bytesused;
 	struct list_head memorys;
-	spinlock_t lock;
+	struct mutex lock;
 };
 
 struct vpu_dev {
diff --git a/drivers/mxc/vpu_windsor/vpu_encoder_mem.c b/drivers/mxc/vpu_windsor/vpu_encoder_mem.c
index ac9dddd4915c..278adcea9b3d 100644
--- a/drivers/mxc/vpu_windsor/vpu_encoder_mem.c
+++ b/drivers/mxc/vpu_windsor/vpu_encoder_mem.c
@@ -29,7 +29,7 @@ int vpu_enc_init_reserved_memory(struct vpu_enc_mem_info *info)
 	memset_io(info->virt_addr, 0, info->size);
 	info->bytesused = 0;
 	INIT_LIST_HEAD(&info->memorys);
-	spin_lock_init(&info->lock);
+	mutex_init(&info->lock);
 
 	return 0;
 }
@@ -42,15 +42,16 @@ void vpu_enc_release_reserved_memory(struct vpu_enc_mem_info *info)
 	if (!info)
 		return;
 
-	spin_lock(&info->lock);
+	mutex_lock(&info->lock);
 	list_for_each_entry_safe(item, tmp, &info->memorys, list) {
 		list_del_init(&item->list);
 		info->bytesused -= item->size;
 		vpu_dbg(LVL_MEM, "free reserved memory %ld\n", item->size);
 		VPU_SAFE_RELEASE(item, vfree);
 	}
-	spin_unlock(&info->lock);
+	mutex_unlock(&info->lock);
 
+	mutex_destroy(&info->lock);
 	if (info->virt_addr) {
 		iounmap(info->virt_addr);
 		info->virt_addr = NULL;
@@ -68,7 +69,7 @@ int vpu_enc_alloc_reserved_mem(struct vpu_enc_mem_info *info,
 	if (!info || !buffer)
 		return -EINVAL;
 
-	spin_lock(&info->lock);
+	mutex_lock(&info->lock);
 	if (buffer->size + info->bytesused > info->size) {
 		ret = -ENOMEM;
 		goto exit;
@@ -104,7 +105,7 @@ int vpu_enc_alloc_reserved_mem(struct vpu_enc_mem_info *info,
 	buffer->phy_addr = item->phy_addr;
 	ret = 0;
 exit:
-	spin_unlock(&info->lock);
+	mutex_unlock(&info->lock);
 	return ret;
 }
 
@@ -134,7 +135,7 @@ int vpu_enc_free_reserved_mem(struct vpu_enc_mem_info *info,
 		return -EINVAL;
 	}
 
-	spin_lock(&info->lock);
+	mutex_lock(&info->lock);
 	list_for_each_entry_safe(item, tmp, &info->memorys, list) {
 		if (offset < item->offset)
 			continue;
@@ -148,7 +149,7 @@ int vpu_enc_free_reserved_mem(struct vpu_enc_mem_info *info,
 		ret = 0;
 		break;
 	}
-	spin_unlock(&info->lock);
+	mutex_unlock(&info->lock);
 
 	return ret;
 }
-- 
2.17.1

