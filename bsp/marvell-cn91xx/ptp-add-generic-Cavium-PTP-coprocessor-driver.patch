From bad631845714486ac1a62f297ac027e600ff73ac Mon Sep 17 00:00:00 2001
From: Radoslaw Biernacki <rad@semihalf.com>
Date: Tue, 9 Oct 2018 00:42:20 +0300
Subject: [PATCH 0258/1051] ptp: add generic Cavium PTP coprocessor driver

The Cavium PTP coprocessor can be found in LiquidIO and ThunderX products.
This patch modify the existing LiquidIO driver in scope of PTP and adds a new
PTP driver for ThunderX MIO_PTP in a way that both drivers share the common
code base. The registers and associated structures definition is now placed in
drivers/ptp/cavium_ptp_regs.h
The implementation of generic Cavium PTP driver is now in
drivers/ptp_cavium.[ch]

By introducing common Cavium PTP coprocessor adjtime() and adjfreq() functions,
this patch also fixes bug in LiquidIO for PTP compensation register handling.
The hardware adds the clock compensation value to the PTP clock value on every
coprocessor cycle. Typical convention is that it represent number of nanosecond
between each cycle. From the other hand ptp_adjfreq() API function gets the ppb
parameter, which means a deviation from base PTP clock frequency in Parts Per
Billion. As a result, the compensation value should be modified according to
following formula:
comp = tbase + tbase*ppb/1G where tbase is the initial compensation value.
Previously in LiquidIO compensation value was incremented or decremented by
ppb << 32 / clock_rate at each call of ptp_adjfreq(). This was invalid and made
PTP adjustments unstable. Adding the mentioned value to previous adjustment value
didn't reflect the desire change, which in turn requires even more adjustment.
In the end PTP clock adjustment did a masive overshot and reach its upper or
lower limit in just few adj. calls.

Signed-off-by: Radoslaw Biernacki <rad@semihalf.com>
Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
[Kevin: The original patch got from Marvell sdk10.0_19.06.
Just some minor context mods in order to port to wrlinux]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/net/ethernet/cavium/Kconfig           |   1 +
 .../ethernet/cavium/liquidio/cn66xx_regs.h    |  16 +-
 .../ethernet/cavium/liquidio/lio_ethtool.c    |   5 +-
 .../net/ethernet/cavium/liquidio/lio_main.c   | 215 ++-------
 .../ethernet/cavium/liquidio/octeon_network.h |  13 +-
 drivers/ptp/Kconfig                           |  28 ++
 drivers/ptp/Makefile                          |   2 +
 drivers/ptp/cavium_ptp.c                      | 293 ++++++++++++
 drivers/ptp/cavium_ptp.h                      |  53 +++
 drivers/ptp/cavium_ptp_regs.h                 | 425 ++++++++++++++++++
 drivers/ptp/cavium_thunderx_ptp.c             | 184 ++++++++
 11 files changed, 1040 insertions(+), 195 deletions(-)
 create mode 100644 drivers/ptp/cavium_ptp.c
 create mode 100644 drivers/ptp/cavium_ptp.h
 create mode 100644 drivers/ptp/cavium_ptp_regs.h
 create mode 100644 drivers/ptp/cavium_thunderx_ptp.c

diff --git a/drivers/net/ethernet/cavium/Kconfig b/drivers/net/ethernet/cavium/Kconfig
index c984ae2e4396..7df63b6303ef 100644
--- a/drivers/net/ethernet/cavium/Kconfig
+++ b/drivers/net/ethernet/cavium/Kconfig
@@ -68,6 +68,7 @@ config LIQUIDIO
 	depends on 64BIT && PCI
 	depends on MAY_USE_DEVLINK
 	imply PTP_1588_CLOCK
+	select PTP_1588_CLOCK_CAVIUM_PTP
 	select FW_LOADER
 	select LIBCRC32C
 	---help---
diff --git a/drivers/net/ethernet/cavium/liquidio/cn66xx_regs.h b/drivers/net/ethernet/cavium/liquidio/cn66xx_regs.h
index b248966837b4..95e0959a1f27 100644
--- a/drivers/net/ethernet/cavium/liquidio/cn66xx_regs.h
+++ b/drivers/net/ethernet/cavium/liquidio/cn66xx_regs.h
@@ -502,20 +502,8 @@
 #define    CN6XXX_CIU_SOFT_RST            0x0001070000000740ULL
 
 /*############################ MIO #########################*/
-#define    CN6XXX_MIO_PTP_CLOCK_CFG       0x0001070000000f00ULL
-#define    CN6XXX_MIO_PTP_CLOCK_LO        0x0001070000000f08ULL
-#define    CN6XXX_MIO_PTP_CLOCK_HI        0x0001070000000f10ULL
-#define    CN6XXX_MIO_PTP_CLOCK_COMP      0x0001070000000f18ULL
-#define    CN6XXX_MIO_PTP_TIMESTAMP       0x0001070000000f20ULL
-#define    CN6XXX_MIO_PTP_EVT_CNT         0x0001070000000f28ULL
-#define    CN6XXX_MIO_PTP_CKOUT_THRESH_LO 0x0001070000000f30ULL
-#define    CN6XXX_MIO_PTP_CKOUT_THRESH_HI 0x0001070000000f38ULL
-#define    CN6XXX_MIO_PTP_CKOUT_HI_INCR   0x0001070000000f40ULL
-#define    CN6XXX_MIO_PTP_CKOUT_LO_INCR   0x0001070000000f48ULL
-#define    CN6XXX_MIO_PTP_PPS_THRESH_LO   0x0001070000000f50ULL
-#define    CN6XXX_MIO_PTP_PPS_THRESH_HI   0x0001070000000f58ULL
-#define    CN6XXX_MIO_PTP_PPS_HI_INCR     0x0001070000000f60ULL
-#define    CN6XXX_MIO_PTP_PPS_LO_INCR     0x0001070000000f68ULL
+
+#define    CN6XXX_MIO_PTP_BASE            0x0001070000000000ULL
 
 #define    CN6XXX_MIO_QLM4_CFG            0x00011800000015B0ULL
 #define    CN6XXX_MIO_RST_BOOT            0x0001180000001600ULL
diff --git a/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c b/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c
index 06f7449c569d..837b9cc5d38f 100644
--- a/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c
+++ b/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c
@@ -2561,8 +2561,9 @@ static int lio_get_ts_info(struct net_device *netdev,
 		SOF_TIMESTAMPING_RX_SOFTWARE |
 		SOF_TIMESTAMPING_SOFTWARE;
 
-	if (lio->ptp_clock)
-		info->phc_index = ptp_clock_index(lio->ptp_clock);
+	if (lio->cavium_ptp_clock)
+		info->phc_index = ptp_clock_index(
+				lio->cavium_ptp_clock->ptp_clock);
 	else
 		info->phc_index = -1;
 
diff --git a/drivers/net/ethernet/cavium/liquidio/lio_main.c b/drivers/net/ethernet/cavium/liquidio/lio_main.c
index 7e8454d3b1ad..16308d564421 100644
--- a/drivers/net/ethernet/cavium/liquidio/lio_main.c
+++ b/drivers/net/ethernet/cavium/liquidio/lio_main.c
@@ -19,6 +19,7 @@
 #include <linux/interrupt.h>
 #include <linux/pci.h>
 #include <linux/firmware.h>
+#include "../drivers/ptp/cavium_ptp.h"
 #include <net/vxlan.h>
 #include <linux/kthread.h>
 #include <net/switchdev.h>
@@ -1535,6 +1536,32 @@ static void free_netsgbuf(void *buf)
 	tx_buffer_free(skb);
 }
 
+u64 lio_cavium_ptp_reg_read(struct cavium_ptp_clock_info *info, u64 offset)
+{
+	struct lio *lio = container_of(info, struct lio, cavium_ptp_info);
+	struct octeon_device *oct = (struct octeon_device *)lio->oct_dev;
+
+	return lio_pci_readq(oct, CN6XXX_MIO_PTP_BASE + offset);
+}
+
+void lio_cavium_ptp_reg_write(struct cavium_ptp_clock_info *info,
+			      u64 offset, u64 val)
+{
+	struct lio *lio = container_of(info, struct lio, cavium_ptp_info);
+	struct octeon_device *oct = (struct octeon_device *)lio->oct_dev;
+
+	lio_pci_writeq(oct, val, CN6XXX_MIO_PTP_BASE + offset);
+}
+
+static void lio_cavium_ptp_adjtime(struct cavium_ptp_clock_info *info,
+				   s64 delta)
+{
+	struct lio *lio = container_of(info, struct lio, cavium_ptp_info);
+
+	/* ptp_adjust is read without spin_lock */
+	lio->ptp_adjust = delta;
+}
+
 /**
  * \brief Unmap and free gather buffer with response
  * @param buf buffer
@@ -1579,170 +1606,6 @@ static void free_netsgbuf_with_resp(void *buf)
 	/* Don't free the skb yet */
 }
 
-/**
- * \brief Adjust ptp frequency
- * @param ptp PTP clock info
- * @param ppb how much to adjust by, in parts-per-billion
- */
-static int liquidio_ptp_adjfreq(struct ptp_clock_info *ptp, s32 ppb)
-{
-	struct lio *lio = container_of(ptp, struct lio, ptp_info);
-	struct octeon_device *oct = (struct octeon_device *)lio->oct_dev;
-	u64 comp, delta;
-	unsigned long flags;
-	bool neg_adj = false;
-
-	if (ppb < 0) {
-		neg_adj = true;
-		ppb = -ppb;
-	}
-
-	/* The hardware adds the clock compensation value to the
-	 * PTP clock on every coprocessor clock cycle, so we
-	 * compute the delta in terms of coprocessor clocks.
-	 */
-	delta = (u64)ppb << 32;
-	do_div(delta, oct->coproc_clock_rate);
-
-	spin_lock_irqsave(&lio->ptp_lock, flags);
-	comp = lio_pci_readq(oct, CN6XXX_MIO_PTP_CLOCK_COMP);
-	if (neg_adj)
-		comp -= delta;
-	else
-		comp += delta;
-	lio_pci_writeq(oct, comp, CN6XXX_MIO_PTP_CLOCK_COMP);
-	spin_unlock_irqrestore(&lio->ptp_lock, flags);
-
-	return 0;
-}
-
-/**
- * \brief Adjust ptp time
- * @param ptp PTP clock info
- * @param delta how much to adjust by, in nanosecs
- */
-static int liquidio_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)
-{
-	unsigned long flags;
-	struct lio *lio = container_of(ptp, struct lio, ptp_info);
-
-	spin_lock_irqsave(&lio->ptp_lock, flags);
-	lio->ptp_adjust += delta;
-	spin_unlock_irqrestore(&lio->ptp_lock, flags);
-
-	return 0;
-}
-
-/**
- * \brief Get hardware clock time, including any adjustment
- * @param ptp PTP clock info
- * @param ts timespec
- */
-static int liquidio_ptp_gettime(struct ptp_clock_info *ptp,
-				struct timespec64 *ts)
-{
-	u64 ns;
-	unsigned long flags;
-	struct lio *lio = container_of(ptp, struct lio, ptp_info);
-	struct octeon_device *oct = (struct octeon_device *)lio->oct_dev;
-
-	spin_lock_irqsave(&lio->ptp_lock, flags);
-	ns = lio_pci_readq(oct, CN6XXX_MIO_PTP_CLOCK_HI);
-	ns += lio->ptp_adjust;
-	spin_unlock_irqrestore(&lio->ptp_lock, flags);
-
-	*ts = ns_to_timespec64(ns);
-
-	return 0;
-}
-
-/**
- * \brief Set hardware clock time. Reset adjustment
- * @param ptp PTP clock info
- * @param ts timespec
- */
-static int liquidio_ptp_settime(struct ptp_clock_info *ptp,
-				const struct timespec64 *ts)
-{
-	u64 ns;
-	unsigned long flags;
-	struct lio *lio = container_of(ptp, struct lio, ptp_info);
-	struct octeon_device *oct = (struct octeon_device *)lio->oct_dev;
-
-	ns = timespec64_to_ns(ts);
-
-	spin_lock_irqsave(&lio->ptp_lock, flags);
-	lio_pci_writeq(oct, ns, CN6XXX_MIO_PTP_CLOCK_HI);
-	lio->ptp_adjust = 0;
-	spin_unlock_irqrestore(&lio->ptp_lock, flags);
-
-	return 0;
-}
-
-/**
- * \brief Check if PTP is enabled
- * @param ptp PTP clock info
- * @param rq request
- * @param on is it on
- */
-static int
-liquidio_ptp_enable(struct ptp_clock_info *ptp __attribute__((unused)),
-		    struct ptp_clock_request *rq __attribute__((unused)),
-		    int on __attribute__((unused)))
-{
-	return -EOPNOTSUPP;
-}
-
-/**
- * \brief Open PTP clock source
- * @param netdev network device
- */
-static void oct_ptp_open(struct net_device *netdev)
-{
-	struct lio *lio = GET_LIO(netdev);
-	struct octeon_device *oct = (struct octeon_device *)lio->oct_dev;
-
-	spin_lock_init(&lio->ptp_lock);
-
-	snprintf(lio->ptp_info.name, 16, "%s", netdev->name);
-	lio->ptp_info.owner = THIS_MODULE;
-	lio->ptp_info.max_adj = 250000000;
-	lio->ptp_info.n_alarm = 0;
-	lio->ptp_info.n_ext_ts = 0;
-	lio->ptp_info.n_per_out = 0;
-	lio->ptp_info.pps = 0;
-	lio->ptp_info.adjfreq = liquidio_ptp_adjfreq;
-	lio->ptp_info.adjtime = liquidio_ptp_adjtime;
-	lio->ptp_info.gettime64 = liquidio_ptp_gettime;
-	lio->ptp_info.settime64 = liquidio_ptp_settime;
-	lio->ptp_info.enable = liquidio_ptp_enable;
-
-	lio->ptp_adjust = 0;
-
-	lio->ptp_clock = ptp_clock_register(&lio->ptp_info,
-					     &oct->pci_dev->dev);
-
-	if (IS_ERR(lio->ptp_clock))
-		lio->ptp_clock = NULL;
-}
-
-/**
- * \brief Init PTP clock
- * @param oct octeon device
- */
-static void liquidio_ptp_init(struct octeon_device *oct)
-{
-	u64 clock_comp, cfg;
-
-	clock_comp = (u64)NSEC_PER_SEC << 32;
-	do_div(clock_comp, oct->coproc_clock_rate);
-	lio_pci_writeq(oct, clock_comp, CN6XXX_MIO_PTP_CLOCK_COMP);
-
-	/* Enable */
-	cfg = lio_pci_readq(oct, CN6XXX_MIO_PTP_CLOCK_CFG);
-	lio_pci_writeq(oct, cfg | 0x01, CN6XXX_MIO_PTP_CLOCK_CFG);
-}
-
 /**
  * \brief Load firmware to device
  * @param oct octeon device
@@ -1852,9 +1715,21 @@ static int liquidio_open(struct net_device *netdev)
 			oct->droq[0]->ops.poll_mode = 1;
 	}
 
-	if (oct->ptp_enable)
-		oct_ptp_open(netdev);
+	/* On 4.9 there's check
+	 *	if (oct->ptp_enable)
+	 *		oct_ptp_open(netdev);
+	 */
 
+	lio->ptp_adjust = 0;
+	lio->cavium_ptp_info = (struct cavium_ptp_clock_info) {
+		.clock_rate = oct->coproc_clock_rate,
+		.name = netdev->name,
+		.reg_read = lio_cavium_ptp_reg_read,
+		.reg_write = lio_cavium_ptp_reg_write,
+		.adjtime_clbck = lio_cavium_ptp_adjtime,
+	};
+	lio->cavium_ptp_clock = cavium_ptp_register(&lio->cavium_ptp_info,
+						    &oct->pci_dev->dev);
 	ifstate_set(lio, LIO_IFSTATE_RUNNING);
 
 	if (OCTEON_CN23XX_PF(oct)) {
@@ -1916,9 +1791,9 @@ static int liquidio_stop(struct net_device *netdev)
 		cleanup_tx_poll_fn(netdev);
 	}
 
-	if (lio->ptp_clock) {
-		ptp_clock_unregister(lio->ptp_clock);
-		lio->ptp_clock = NULL;
+	if (lio->cavium_ptp_clock) {
+		cavium_ptp_remove(lio->cavium_ptp_clock);
+		lio->cavium_ptp_clock = NULL;
 	}
 
 	/* Wait for any pending Rx descriptors */
@@ -3868,8 +3743,6 @@ static int liquidio_init_nic_module(struct octeon_device *oct)
 		}
 	}
 
-	liquidio_ptp_init(oct);
-
 	dev_dbg(&oct->pci_dev->dev, "Network interfaces ready\n");
 
 	return retval;
diff --git a/drivers/net/ethernet/cavium/liquidio/octeon_network.h b/drivers/net/ethernet/cavium/liquidio/octeon_network.h
index d7a3916fe877..cfde3d55868e 100644
--- a/drivers/net/ethernet/cavium/liquidio/octeon_network.h
+++ b/drivers/net/ethernet/cavium/liquidio/octeon_network.h
@@ -23,7 +23,7 @@
 
 #ifndef __OCTEON_NETWORK_H__
 #define __OCTEON_NETWORK_H__
-#include <linux/ptp_clock_kernel.h>
+#include "../drivers/ptp/cavium_ptp.h"
 
 #define LIO_MAX_MTU_SIZE (OCTNET_MAX_FRM_SIZE - OCTNET_FRM_HEADER_SIZE)
 #define LIO_MIN_MTU_SIZE ETH_MIN_MTU
@@ -163,13 +163,10 @@ struct lio {
 	/** Copy of ctrl reg in phy */
 	u32 led_ctrl_val;
 
-	/* PTP clock information */
-	struct ptp_clock_info ptp_info;
-	struct ptp_clock *ptp_clock;
-	s64 ptp_adjust;
-
-	/* for atomic access to Octeon PTP reg and data struct */
-	spinlock_t ptp_lock;
+	/* Cavium PTP clock information */
+	struct cavium_ptp_clock_info cavium_ptp_info;
+	struct cavium_ptp_clock *cavium_ptp_clock;
+	s64 ptp_adjust; /* shadow copy of adjust for fast operations */
 
 	/* Interface info */
 	u32	intf_open;
diff --git a/drivers/ptp/Kconfig b/drivers/ptp/Kconfig
index 474c988d2e95..73c41d7799d9 100644
--- a/drivers/ptp/Kconfig
+++ b/drivers/ptp/Kconfig
@@ -69,6 +69,34 @@ config PTP_1588_CLOCK_IXP46X
 	  To compile this driver as a module, choose M here: the module
 	  will be called ptp_ixp46x.
 
+config PTP_1588_CLOCK_CAVIUM_PTP
+	tristate "Cavium PTP coprocessor as PTP clock"
+	select PTP_1588_CLOCK
+	default y
+	help
+          This driver adds support for using the Cavium PTP coprocessor as a
+          PTP clock. This clock is only useful if your PTP programs are getting
+          hardware time stamps on the PTP Ethernet packets using the
+          SO_TIMESTAMPING API.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called ptp_ixp46x.
+
+config PTP_1588_CLOCK_CAVIUM_THUNDERX_PTP
+	tristate "Cavium Thunder PTP coprocessor as PTP clock"
+	depends on 64BIT
+	default ARCH_THUNDER
+	select PTP_1588_CLOCK_CAVIUM_PTP
+	default y
+	help
+          This driver adds support for using the Cavium PTP coprocessor present
+          in ThunderX SoC as a PTP clock. This clock is only useful if your PTP
+          programs are getting hardware time stamps on the PTP Ethernet packets
+          using the SO_TIMESTAMPING API.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called ptp_ixp46x.
+
 comment "Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks."
 	depends on PHYLIB=n || NETWORK_PHY_TIMESTAMPING=n
 
diff --git a/drivers/ptp/Makefile b/drivers/ptp/Makefile
index 19efa9cfa950..e618fa4e6237 100644
--- a/drivers/ptp/Makefile
+++ b/drivers/ptp/Makefile
@@ -10,3 +10,5 @@ obj-$(CONFIG_PTP_1588_CLOCK_IXP46X)	+= ptp_ixp46x.o
 obj-$(CONFIG_PTP_1588_CLOCK_PCH)	+= ptp_pch.o
 obj-$(CONFIG_PTP_1588_CLOCK_KVM)	+= ptp_kvm.o
 obj-$(CONFIG_PTP_1588_CLOCK_QORIQ)	+= ptp_qoriq.o
+obj-$(CONFIG_PTP_1588_CLOCK_CAVIUM_PTP)	+= cavium_ptp.o
+obj-$(CONFIG_PTP_1588_CLOCK_CAVIUM_THUNDERX_PTP)	+= cavium_thunderx_ptp.o
diff --git a/drivers/ptp/cavium_ptp.c b/drivers/ptp/cavium_ptp.c
new file mode 100644
index 000000000000..fce7507754de
--- /dev/null
+++ b/drivers/ptp/cavium_ptp.c
@@ -0,0 +1,293 @@
+/**********************************************************************
+* Author: Cavium, Inc.
+*
+* Contact: support@cavium.com
+*          Please include "LiquidIO" in the subject.
+*
+* Copyright (c) 2003-2015 Cavium, Inc.
+*
+* This file is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License, Version 2, as
+* published by the Free Software Foundation.
+*
+* This file is distributed in the hope that it will be useful, but
+* AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
+* of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+* NONINFRINGEMENT.  See the GNU General Public License for more
+* details.
+*
+* This file may also be available under a different license from Cavium.
+* Contact Cavium, Inc. for more information
+**********************************************************************/
+
+#include <linux/device.h>
+#include <linux/module.h>
+
+#include "cavium_ptp_regs.h"
+#include "cavium_ptp.h"
+
+#define DRV_NAME         "Cavium generic PTP Driver"
+#define DRV_VERSION      "1.0"
+
+/*
+ * Interrupt service routine
+ */
+
+/* static irqreturn_t isr(int irq, void *priv) */
+
+/*
+ * PTP clock operations
+ */
+
+/**
+ * \brief Adjust ptp frequency
+ * @param ptp PTP clock info
+ * @param ppb how much to adjust by, in parts-per-billion
+ */
+static int cavium_ptp_adjfreq(struct ptp_clock_info *ptp_info, s32 ppb)
+{
+	struct cavium_ptp_clock *cavium_ptp_clock =
+		container_of(ptp_info, struct cavium_ptp_clock, ptp_info);
+	struct cavium_ptp_clock_info *cavium_ptp_info =
+		cavium_ptp_clock->cavium_ptp_info;
+	union ptp_clock_comp clock_comp;
+	u64 comp;
+	u64 adj;
+	unsigned long flags;
+	int neg_adj = 0;
+
+	if (ppb < 0) {
+		neg_adj = 1;
+		ppb = -ppb;
+	}
+
+	/* The hardware adds the clock compensation value to the PTP clock on
+	 * every coprocessor clock cycle. Typical convention is that it
+	 * represent number of nanosecond betwen each cycle. In this convention
+	 * Compensation value is in 64 bit fixed-point representation where
+	 * upper 32 bits are number of nanoseconds and lower is fractions of
+	 * nanosecond.
+	 * The ppb represent the ratio in "parts per bilion" by which the
+	 * compensation value should be corrected.
+	 * To calculate new compenstation value we use 64bit fixed point
+	 * arithmetic on following formula comp = tbase + tbase*ppb/1G where
+	 * tbase is the basic compensation value calculated initialy in
+	 * cavium_ptp_init() -> tbase = 1/Hz. Then we use endian independent
+	 * structure definition to write data to PTP register */
+	comp = ((u64)1000000000ull << 32) / cavium_ptp_clock->clock_rate;
+	adj = comp * ppb;
+	adj = div_u64(adj, 1000000000ull);
+	comp = neg_adj ? comp - adj : comp + adj;
+	clock_comp.s.nanosec = comp >> 32;
+	clock_comp.s.frnanosec = comp & 0xFFFFFFFF;
+
+	spin_lock_irqsave(&cavium_ptp_clock->spin_lock, flags);
+	cavium_ptp_info->reg_write(cavium_ptp_info,
+				   PTP_CLOCK_COMP, clock_comp.u64);
+	spin_unlock_irqrestore(&cavium_ptp_clock->spin_lock, flags);
+
+	return 0;
+}
+
+/**
+ * \brief Adjust ptp time
+ * @param ptp PTP clock info
+ * @param delta how much to adjust by, in nanosecs
+ */
+static int cavium_ptp_adjtime(struct ptp_clock_info *ptp_info, s64 delta)
+{
+	struct cavium_ptp_clock *cavium_ptp_clock =
+		container_of(ptp_info, struct cavium_ptp_clock, ptp_info);
+	struct cavium_ptp_clock_info *cavium_ptp_info =
+		cavium_ptp_clock->cavium_ptp_info;
+	unsigned long flags;
+
+	spin_lock_irqsave(&cavium_ptp_clock->spin_lock, flags);
+	cavium_ptp_clock->ptp_adjust += delta;
+	spin_unlock_irqrestore(&cavium_ptp_clock->spin_lock, flags);
+
+	/* notify child module about the time adjust */
+	if (cavium_ptp_info->adjtime_clbck)
+		cavium_ptp_info->adjtime_clbck(cavium_ptp_info, delta);
+
+	return 0;
+}
+
+/**
+ * \brief Get hardware clock time, including any adjustment
+ * @param ptp PTP clock info
+ * @param ts timespec
+ */
+static int cavium_ptp_gettime(struct ptp_clock_info *ptp_info,
+				  struct timespec64 *ts)
+{
+	struct cavium_ptp_clock *cavium_ptp_clock =
+		container_of(ptp_info, struct cavium_ptp_clock, ptp_info);
+	struct cavium_ptp_clock_info *cavium_ptp_info =
+		cavium_ptp_clock->cavium_ptp_info;
+	union ptp_clock_hi clock;
+	unsigned long flags;
+	u32 remainder;
+
+	spin_lock_irqsave(&cavium_ptp_clock->spin_lock, flags);
+	clock.u64 = cavium_ptp_info->reg_read(cavium_ptp_info, PTP_CLOCK_HI);
+	/* adjust also need spinlock */
+	clock.u64 += cavium_ptp_clock->ptp_adjust;
+	spin_unlock_irqrestore(&cavium_ptp_clock->spin_lock, flags);
+
+	ts->tv_sec = div_u64_rem(clock.s.nanosec, 1000000000ULL, &remainder);
+	ts->tv_nsec = remainder;
+
+	return 0;
+}
+
+/**
+ * \brief Set hardware clock time. Reset adjustment
+ * @param ptp PTP clock info
+ * @param ts timespec
+ */
+static int cavium_ptp_settime(struct ptp_clock_info *ptp_info,
+				  const struct timespec64 *ts)
+{
+	struct cavium_ptp_clock *cavium_ptp_clock =
+		container_of(ptp_info, struct cavium_ptp_clock, ptp_info);
+	struct cavium_ptp_clock_info *cavium_ptp_info =
+		cavium_ptp_clock->cavium_ptp_info;
+	union ptp_clock_hi clock;
+	unsigned long flags;
+
+	clock.s.nanosec = timespec64_to_ns(ts);
+
+	spin_lock_irqsave(&cavium_ptp_clock->spin_lock, flags);
+	cavium_ptp_info->reg_write(cavium_ptp_info, PTP_CLOCK_HI, clock.u64);
+	cavium_ptp_clock->ptp_adjust = 0; /* adjust also need spinlock */
+	spin_unlock_irqrestore(&cavium_ptp_clock->spin_lock, flags);
+
+	return 0;
+}
+
+/**
+ * \brief Check if PTP is enabled
+ * @param ptp PTP clock info
+ * @param rq request
+ * @param on is it on
+ */
+static int cavium_ptp_enable(struct ptp_clock_info *ptp_info,
+				 struct ptp_clock_request *rq, int on)
+{
+	return -EOPNOTSUPP;
+}
+
+
+
+struct cavium_ptp_clock*
+cavium_ptp_register(struct cavium_ptp_clock_info *cavium_ptp_info,
+			struct device *dev)
+{
+	struct cavium_ptp_clock *cavium_ptp_clock = NULL;
+	union ptp_clock_cfg clock_cfg;
+	union ptp_clock_comp clock_comp;
+	u64 val;
+
+	cavium_ptp_clock = devm_kzalloc(dev, sizeof(*cavium_ptp_clock),
+					GFP_KERNEL);
+	if (!cavium_ptp_clock)
+		return NULL;
+
+	/* initialize genetic Cavium PTP structure */
+	cavium_ptp_clock->cavium_ptp_info = cavium_ptp_info;
+	spin_lock_init(&cavium_ptp_clock->spin_lock);
+	cavium_ptp_clock->ptp_adjust = 0;
+	cavium_ptp_clock->clock_rate = cavium_ptp_info->clock_rate;
+	cavium_ptp_clock->ptp_info = (struct ptp_clock_info) {
+		.owner		= THIS_MODULE,
+		.max_adj	= 1000000000ull,
+		.n_ext_ts	= 0,
+		.n_pins		= 0,
+		.pps		= 0,
+		.adjfreq	= cavium_ptp_adjfreq,
+		.adjtime	= cavium_ptp_adjtime,
+		.gettime64	= cavium_ptp_gettime,
+		.settime64	= cavium_ptp_settime,
+		.enable		= cavium_ptp_enable,
+	};
+	snprintf(cavium_ptp_clock->ptp_info.name, 16, "%s",
+		 cavium_ptp_info->name);
+
+	/* enable PTP HW module */
+	clock_cfg.u64 = cavium_ptp_info->reg_read(
+		cavium_ptp_info, PTP_CLOCK_CFG);
+	clock_cfg.s.ptp_en = 1;
+	cavium_ptp_info->reg_write(cavium_ptp_info, PTP_CLOCK_CFG,
+				   clock_cfg.u64);
+
+	/* The hardware adds the clock compensation value to the PTP clock on
+	 * every coprocessor clock cycle. Typical convention is tha it represent
+	 * number of nanosecond betwen each cycle. In this convention
+	 * Compensation value is in 64 bit fixed-point representation where
+	 * upper 32 bits are number of nanoseconds and lower is fractions of
+	 * nanosecond. To calculate it we use 64bit fixed point arithmetic on
+	 * following formula comp = t = 1/Hz. Then we use endian independent
+	 * structire definition to write data to PTP register */
+	val = ((u64)1000000000ull << 32) / cavium_ptp_clock->clock_rate;
+	clock_comp.s.nanosec = val >> 32;
+	clock_comp.s.frnanosec = val & 0xFFFFFFFF;
+	cavium_ptp_info->reg_write(cavium_ptp_info, PTP_CLOCK_COMP,
+				   clock_comp.u64);
+
+	/* register PTP clock in kernel */
+	cavium_ptp_clock->ptp_clock =
+		ptp_clock_register(&cavium_ptp_clock->ptp_info, dev);
+	if (IS_ERR(cavium_ptp_clock->ptp_clock))
+		goto err_stop_cavium_ptp;
+
+	return cavium_ptp_clock;
+
+err_stop_cavium_ptp:
+	/* stop PTP HW module */
+	clock_cfg.u64 = cavium_ptp_info->reg_read(
+		cavium_ptp_info, PTP_CLOCK_CFG);
+	clock_cfg.s.ptp_en = 0;
+	cavium_ptp_info->reg_write(cavium_ptp_info, PTP_CLOCK_CFG,
+				   clock_cfg.u64);
+
+	devm_kfree(dev, cavium_ptp_clock);
+	return NULL;
+}
+EXPORT_SYMBOL(cavium_ptp_register);
+
+void cavium_ptp_remove(struct cavium_ptp_clock *cavium_ptp_clock)
+{
+	union ptp_clock_cfg clock_cfg;
+	struct cavium_ptp_clock_info *cavium_ptp_info =
+		cavium_ptp_clock->cavium_ptp_info;
+
+	/* stop PTP HW module */
+	clock_cfg.u64 = cavium_ptp_info->reg_read(
+		cavium_ptp_info, PTP_CLOCK_CFG);
+	clock_cfg.s.ptp_en = 0;
+	cavium_ptp_info->reg_write(cavium_ptp_info, PTP_CLOCK_CFG,
+				   clock_cfg.u64);
+
+	ptp_clock_unregister(cavium_ptp_clock->ptp_clock);
+}
+EXPORT_SYMBOL(cavium_ptp_remove);
+
+static int __init cavium_ptp_init_module(void)
+{
+	pr_info("%s, ver %s\n", DRV_NAME, DRV_VERSION);
+
+	return 0;
+}
+
+static void __exit cavium_ptp_cleanup_module(void)
+{
+}
+
+module_init(cavium_ptp_init_module);
+module_exit(cavium_ptp_cleanup_module);
+
+MODULE_AUTHOR("Cavium Networks, <support@cavium.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION(DRV_NAME);
+MODULE_VERSION(DRV_VERSION);
diff --git a/drivers/ptp/cavium_ptp.h b/drivers/ptp/cavium_ptp.h
new file mode 100644
index 000000000000..97889e4e65e7
--- /dev/null
+++ b/drivers/ptp/cavium_ptp.h
@@ -0,0 +1,53 @@
+/**********************************************************************
+* Author: Cavium, Inc.
+*
+* Contact: support@cavium.com
+*          Please include "LiquidIO" in the subject.
+*
+* Copyright (c) 2003-2015 Cavium, Inc.
+*
+* This file is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License, Version 2, as
+* published by the Free Software Foundation.
+*
+* This file is distributed in the hope that it will be useful, but
+* AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
+* of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+* NONINFRINGEMENT.  See the GNU General Public License for more
+* details.
+*
+* This file may also be available under a different license from Cavium.
+* Contact Cavium, Inc. for more information
+**********************************************************************/
+
+#ifndef __CAVIUM_PTP_H__
+#define __CAVIUM_PTP_H__
+
+#include <linux/ptp_clock_kernel.h>
+
+struct cavium_ptp_clock_info {
+	u32 clock_rate;
+	const char *name;
+	u64 (*reg_read)(struct cavium_ptp_clock_info *info, u64 offset);
+	void (*reg_write)(struct cavium_ptp_clock_info *info, u64 offset,
+			  u64 val);
+	void (*adjtime_clbck)(struct cavium_ptp_clock_info *info, s64 delta);
+};
+
+struct cavium_ptp_clock {
+	/* PTP clock information */
+	spinlock_t spin_lock;
+	struct ptp_clock *ptp_clock;
+	struct ptp_clock_info ptp_info;
+	s64 ptp_adjust;
+	u32 clock_rate;
+
+	/* descendant data */
+	struct cavium_ptp_clock_info *cavium_ptp_info;
+};
+
+extern struct cavium_ptp_clock *cavium_ptp_register(
+	struct cavium_ptp_clock_info *info, struct device *dev);
+extern void cavium_ptp_remove(struct cavium_ptp_clock *cavium_ptp_clock);
+
+#endif /* __CAVIUM_PTP_H__ */
diff --git a/drivers/ptp/cavium_ptp_regs.h b/drivers/ptp/cavium_ptp_regs.h
new file mode 100644
index 000000000000..56c5bf960e4e
--- /dev/null
+++ b/drivers/ptp/cavium_ptp_regs.h
@@ -0,0 +1,425 @@
+/**********************************************************************
+* Author: Cavium, Inc.
+*
+* Contact: support@cavium.com
+*		Please include "LiquidIO" in the subject.
+*
+* Copyright (c) 2003-2015 Cavium, Inc.
+*
+* This file is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License, Version 2, as
+* published by the Free Software Foundation.
+*
+* This file is distributed in the hope that it will be useful, but
+* AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
+* of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+* NONINFRINGEMENT.	See the GNU General Public License for more
+* details.
+*
+* This file may also be available under a different license from Cavium.
+* Contact Cavium, Inc. for more information
+**********************************************************************/
+
+#ifndef __CAVIUM_PTP_REGS_H__
+#define __CAVIUM_PTP_REGS_H__
+
+#define PTP_CLOCK_CFG			(0xF00ULL)
+#define PTP_CLOCK_LO			(0xF08ULL)
+#define PTP_CLOCK_HI			(0xF10ULL)
+#define PTP_CLOCK_COMP			(0xF18ULL)
+#define PTP_TIMESTAMP			(0xF20ULL)
+#define PTP_EVT_CNT			(0xF28ULL)
+#define PTP_CKOUT_THRESH_LO		(0xF30ULL)
+#define PTP_CKOUT_THRESH_HI		(0xF38ULL)
+#define PTP_CKOUT_HI_INCR		(0xF40ULL)
+#define PTP_CKOUT_LO_INCR		(0xF48ULL)
+#define PTP_PPS_THRESH_LO		(0xF50ULL)
+#define PTP_PPS_THRESH_HI		(0xF58ULL)
+#define PTP_PPS_HI_INCR			(0xF60ULL)
+#define PTP_PPS_LO_INCR			(0xF68ULL)
+#define PTP_INT				(0xF70ULL)
+#define PTP_INT_W1S			(0xF78ULL)
+#define PTP_DPLL_INCR			(0xF80ULL)
+#define PTP_DPLL_ERR_THRESH		(0xF88ULL)
+#define PTP_DPLL_ERR_INT		(0xF90ULL)
+#define PTP_INT_ENA_W1C			(0xFA0ULL)
+#define PTP_INT_ENA_W1S			(0xFA8ULL)
+
+/* ***********************************************************************
+ * REGISTERS */
+
+union ptp_clock_cfg {
+	uint64_t u64;
+	uint32_t u32[2];
+	struct {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+		uint64_t	ptp_en		: 1;
+		uint64_t	ext_clk_en	: 1;
+		uint64_t	ext_clk_in	: 6;
+		uint64_t	tstmp_en	: 1;
+		uint64_t	tstmp_edge	: 1;
+		uint64_t	tstmp_in	: 6;
+		uint64_t	evcnt_en	: 1;
+		uint64_t	evcnt_edge	: 1;
+		uint64_t	evcnt_in	: 6;
+		uint64_t	ckout_en	: 1;
+		uint64_t	ckout_inv	: 1;
+		uint64_t	rsvd2		: 4;
+		uint64_t	pps_en		: 1;
+		uint64_t	pps_inv		: 1;
+		uint64_t	rsvd1		: 6;
+		uint64_t	ext_clk_edge	: 2;
+		uint64_t	ckout		: 1;
+		uint64_t	pps		: 1;
+		uint64_t	rsvd0		: 22;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+		uint64_t	rsvd0		: 22;
+		uint64_t	pps		: 1;
+		uint64_t	ckout		: 1;
+		uint64_t	ext_clk_edge	: 2;
+		uint64_t	rsvd1		: 6;
+		uint64_t	pps_inv		: 1;
+		uint64_t	pps_en		: 1;
+		uint64_t	rsvd2		: 4;
+		uint64_t	ckout_inv	: 1;
+		uint64_t	ckout_en	: 1;
+		uint64_t	evcnt_in	: 6;
+		uint64_t	evcnt_edge	: 1;
+		uint64_t	evcnt_en	: 1;
+		uint64_t	tstmp_in	: 6;
+		uint64_t	tstmp_edge	: 1;
+		uint64_t	tstmp_en	: 1;
+		uint64_t	ext_clk_in	: 6;
+		uint64_t	ext_clk_en	: 1;
+		uint64_t	ptp_en		: 1;
+#endif
+	} __packed s;
+};
+
+union ptp_clock_lo {
+	uint64_t u64;
+	uint32_t u32[2];
+	struct {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+		uint64_t	frnanosec	: 32;
+		uint64_t	rsvd0		: 32;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+		uint64_t	rsvd0		: 32;
+		uint64_t	frnanosec	: 32;
+#endif
+	} __packed s;
+};
+
+union ptp_clock_hi {
+	uint64_t u64;
+	uint32_t u32[2];
+	struct {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+		uint64_t	nanosec		: 64;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+		uint64_t	nanosec		: 64;
+#endif
+	} __packed s;
+};
+
+union ptp_clock_comp {
+	uint64_t u64;
+	uint32_t u32[2];
+	struct {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+		uint64_t	frnanosec	: 32;
+		uint64_t	nanosec		: 32;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+		uint64_t	nanosec		: 32;
+		uint64_t	frnanosec	: 32;
+#endif
+	} __packed s;
+};
+
+union ptp_timestamp {
+	uint64_t u64;
+	uint32_t u32[2];
+	struct {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+		uint64_t	nanosec		: 64;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+		uint64_t	nanosec		: 64;
+#endif
+	} __packed s;
+};
+
+union ptp_evt_cnt {
+	uint64_t u64;
+	uint32_t u32[2];
+	struct {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+		uint64_t	cntr		: 64;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+		uint64_t	cntr		: 64;
+#endif
+	} __packed s;
+};
+
+union ptp_ckout_thresh_lo {
+	uint64_t u64;
+	uint32_t u32[2];
+	struct {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+		uint64_t	frnanosec	: 32;
+		uint64_t	rsvd0		: 32;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+		uint64_t	rsvd0		: 32;
+		uint64_t	frnanosec	: 32;
+#endif
+	} __packed s;
+};
+
+union ptp_ckout_thresh_hi {
+	uint64_t u64;
+	uint32_t u32[2];
+	struct {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+		uint64_t	nanosec		: 64;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+		uint64_t	nanosec		: 64;
+#endif
+	} __packed s;
+};
+
+union ptp_ckout_hi_incr {
+	uint64_t u64;
+	uint32_t u32[2];
+	struct {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+		uint64_t	frnanosec	: 32;
+		uint64_t	nanosec		: 32;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+		uint64_t	nanosec		: 32;
+		uint64_t	frnanosec	: 32;
+#endif
+	} __packed s;
+};
+
+union ptp_ckout_lo_incr {
+	uint64_t u64;
+	uint32_t u32[2];
+	struct {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+		uint64_t	frnanosec	: 32;
+		uint64_t	nanosec		: 32;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+		uint64_t	nanosec		: 32;
+		uint64_t	frnanosec	: 32;
+#endif
+	} __packed s;
+};
+
+union ptp_pps_thresh_lo {
+	uint64_t u64;
+	uint32_t u32[2];
+	struct {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+		uint64_t	frnanosec	: 32;
+		uint64_t	rsvd0		: 32;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+		uint64_t	rsvd0		: 32;
+		uint64_t	frnanosec	: 32;
+#endif
+	} __packed s;
+};
+
+union ptp_pps_thresh_hi {
+	uint64_t u64;
+	uint32_t u32[2];
+	struct {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+		uint64_t	nanosec		: 64;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+		uint64_t	nanosec		: 64;
+#endif
+	} __packed s;
+};
+
+union ptp_pps_hi_incr {
+	uint64_t u64;
+	uint32_t u32[2];
+	struct {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+		uint64_t	frnanosec	: 32;
+		uint64_t	nanosec		: 32;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+		uint64_t	nanosec		: 32;
+		uint64_t	frnanosec	: 32;
+#endif
+	} __packed s;
+};
+
+union ptp_pps_lo_incr {
+	uint64_t u64;
+	uint32_t u32[2];
+	struct {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+		uint64_t	frnanosec	: 32;
+		uint64_t	nanosec		: 32;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+		uint64_t	nanosec		: 32;
+		uint64_t	frnanosec	: 32;
+#endif
+	} __packed s;
+};
+
+union ptp_int {
+	uint64_t u64;
+	uint32_t u32[2];
+	struct {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+		uint64_t	evt_int		: 1;
+		uint64_t	dpll_int	: 1;
+		uint64_t	rsvd0		: 62;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+		uint64_t	rsvd0		: 62;
+		uint64_t	dpll_int	: 1;
+		uint64_t	evt_int		: 1;
+#endif
+	} __packed s;
+};
+
+union ptp_int_w1s {
+	uint64_t u64;
+	uint32_t u32[2];
+	struct {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+		uint64_t	evt_int		: 1;
+		uint64_t	dpll_int	: 1;
+		uint64_t	rsvd0		: 62;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+		uint64_t	rsvd0		: 62;
+		uint64_t	dpll_int	: 1;
+		uint64_t	evt_int		: 1;
+#endif
+	} __packed s;
+};
+
+union ptp_dpll_incr {
+	uint64_t u64;
+	uint32_t u32[2];
+	struct {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+		uint64_t	frnanosec	: 32;
+		uint64_t	nanosec		: 32;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+		uint64_t	nanosec		: 32;
+		uint64_t	frnanosec	: 32;
+#endif
+	} __packed s;
+};
+
+union ptp_dpll_err_thresh {
+	uint64_t u64;
+	uint32_t u32[2];
+	struct {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+		uint64_t	min		: 32;
+		uint64_t	max		: 32;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+		uint64_t	max		: 32;
+		uint64_t	min		: 32;
+#endif
+	} __packed s;
+};
+
+union ptp_dpll_err_int {
+	uint64_t u64;
+	uint32_t u32[2];
+	struct {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+		uint64_t	rsvd0		: 32;
+		uint64_t	n_sclk		: 32;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+		uint64_t	n_sclk		: 32;
+		uint64_t	rsvd0		: 32;
+#endif
+	} __packed s;
+};
+
+union ptp_int_ena_w1c {
+	uint64_t u64;
+	uint32_t u32[2];
+	struct {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+		uint64_t	evt_int		: 1;
+		uint64_t	dpll_int	: 1;
+		uint64_t	rsvd0		: 62;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+		uint64_t	rsvd0		: 62;
+		uint64_t	dpll_int	: 1;
+		uint64_t	evt_int		: 1;
+#endif
+	} __packed s;
+};
+
+union ptp_int_ena_w1s {
+	uint64_t u64;
+	uint32_t u32[2];
+	struct {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+		uint64_t	evt_int		: 1;
+		uint64_t	dpll_int	: 1;
+		uint64_t	rsvd0		: 62;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+		uint64_t	rsvd0		: 62;
+		uint64_t	dpll_int	: 1;
+		uint64_t	evt_int		: 1;
+#endif
+	} __packed s;
+};
+
+union ptp_msix_vecx_addr {
+	uint64_t u64;
+	uint32_t u32[2];
+	struct {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+		uint64_t	secvec		: 1;
+		uint64_t	rsvd1		: 1;
+		uint64_t	addr		: 47;
+		uint64_t	rsvd0		: 15;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+		uint64_t	rsvd0		: 15;
+		uint64_t	addr		: 47;
+		uint64_t	rsvd1		: 1;
+		uint64_t	secvec		: 1;
+#endif
+	} __packed s;
+};
+
+union ptp_msix_vecx_ctl {
+	uint64_t u64;
+	uint32_t u32[2];
+	struct {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+		uint64_t	data		: 20;
+		uint64_t	rsvd1		: 12;
+		uint64_t	mask		: 1;
+		uint64_t	rsvd0		: 31;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+		uint64_t	rsvd0		: 31;
+		uint64_t	mask		: 1;
+		uint64_t	rsvd1		: 12;
+		uint64_t	data		: 20;
+#endif
+	} __packed s;
+};
+
+union ptp_msix_pbax {
+	uint64_t u64;
+	uint32_t u32[2];
+	struct {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+		uint64_t	pend		: 64;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+		uint64_t	pend		: 64;
+#endif
+	} __packed s;
+};
+
+#endif /* __CAVIUM_PTP_REGS_H__ */
diff --git a/drivers/ptp/cavium_thunderx_ptp.c b/drivers/ptp/cavium_thunderx_ptp.c
new file mode 100644
index 000000000000..81076c63e2f1
--- /dev/null
+++ b/drivers/ptp/cavium_thunderx_ptp.c
@@ -0,0 +1,184 @@
+/**********************************************************************
+* Author: Cavium, Inc.
+*
+* Contact: support@cavium.com
+*          Please include "LiquidIO" in the subject.
+*
+* Copyright (c) 2003-2015 Cavium, Inc.
+*
+* This file is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License, Version 2, as
+* published by the Free Software Foundation.
+*
+* This file is distributed in the hope that it will be useful, but
+* AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
+* of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+* NONINFRINGEMENT.  See the GNU General Public License for more
+* details.
+*
+* This file may also be available under a different license from Cavium.
+* Contact Cavium, Inc. for more information
+**********************************************************************/
+
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+
+#include "cavium_ptp.h"
+
+#define NSEC_PER_SEC     1000000000L
+#define DRV_NAME         "Cavium Thunder PTP Driver"
+#define DRV_VERSION      "1.0"
+
+/* PCI device IDs */
+#define PCI_DEVICE_ID_THUNDER_PTP	0xA00C
+
+struct thunder_ptp_clock {
+	void __iomem *reg_base;
+	struct pci_dev *pdev;
+	struct cavium_ptp_clock *cavium_ptp_clock;
+	struct cavium_ptp_clock_info cavium_ptp_info;
+};
+
+/*
+ * Register access functions
+ */
+
+/* The Cavium PTP can *only* be found in SoCs containing the ThunderX ARM64 CPU
+ * implementation.  All accesses to the device registers on this platform are
+ * implicitly strongly ordered with respect to memory accesses. So
+ * writeq_relaxed() and readq_relaxed() are safe to use with no memory barriers
+ * in this driver.  The readq()/writeq() functions add explicit ordering
+ * operation which in this case are redundant, and only add overhead.
+ */
+
+static u64 thunder_ptp_reg_read(struct cavium_ptp_clock_info *info,
+				    u64 offset)
+{
+	struct thunder_ptp_clock *thunder_ptp_clock =
+		container_of(info, struct thunder_ptp_clock, cavium_ptp_info);
+	void __iomem *addr = thunder_ptp_clock->reg_base + offset;
+
+	return readq_relaxed(addr);
+}
+
+static void thunder_ptp_reg_write(struct cavium_ptp_clock_info *info,
+				      u64 offset, u64 val)
+{
+	struct thunder_ptp_clock *thunder_ptp_clock =
+		container_of(info, struct thunder_ptp_clock, cavium_ptp_info);
+	void __iomem *addr = thunder_ptp_clock->reg_base + offset;
+
+	writeq_relaxed(val, addr);
+}
+
+/* module operations */
+
+static int thunder_ptp_probe(struct pci_dev *pdev,
+				 const struct pci_device_id *ent)
+{
+	int err;
+	struct thunder_ptp_clock *thunder_ptp_clock = NULL;
+	struct device *dev = &pdev->dev;
+
+	thunder_ptp_clock = devm_kzalloc(dev, sizeof(*thunder_ptp_clock),
+					 GFP_KERNEL);
+	if (!thunder_ptp_clock)
+		return -ENOMEM;
+	thunder_ptp_clock->pdev = pdev;
+	pci_set_drvdata(pdev, thunder_ptp_clock);
+
+	err = pci_enable_device(pdev);
+	if (err) {
+		dev_err(dev, "Failed to enable PCI device\n");
+		pci_set_drvdata(pdev, NULL);
+		return err;
+	}
+
+	err = pci_request_regions(pdev, DRV_NAME);
+	if (err) {
+		dev_err(dev, "PCI request regions failed 0x%x\n", err);
+		goto err_disable_device;
+	}
+
+	/* MAP configuration registers */
+	thunder_ptp_clock->reg_base = ioremap(pci_resource_start(pdev, 0),
+					    pci_resource_len(pdev, 0));
+	if (!thunder_ptp_clock->reg_base) {
+		dev_err(dev, "BGX: Cannot map CSR memory space, aborting\n");
+		err = -ENOMEM;
+		goto err_release_regions;
+	}
+
+	/* register the cavium_ptp_clock */
+	thunder_ptp_clock->cavium_ptp_info = (struct cavium_ptp_clock_info) {
+		/* \TODO Below we need to give the SCLK which is:
+		 * PLL_REF_CLK (= 50 MHz) Ã— [PNR_MUL]
+		 * PNR_MUL can be obtained from RST_BOOT[PNR_MUL] */
+		.clock_rate = 16ull * 50000000ull,
+		.name = "ThunderX PTP",
+		.reg_read = thunder_ptp_reg_read,
+		.reg_write = thunder_ptp_reg_write,
+		.adjtime_clbck = NULL,
+	};
+	thunder_ptp_clock->cavium_ptp_clock = cavium_ptp_register(
+		&thunder_ptp_clock->cavium_ptp_info, dev);
+	if (IS_ERR(thunder_ptp_clock->cavium_ptp_clock))
+		goto err_release_regions;
+
+	return 0;
+
+err_release_regions:
+	pci_release_regions(pdev);
+err_disable_device:
+	pci_disable_device(pdev);
+	pci_set_drvdata(pdev, NULL);
+
+	devm_kfree(dev, thunder_ptp_clock);
+	return err;
+}
+
+static void thunder_ptp_remove(struct pci_dev *pdev)
+{
+	struct thunder_ptp_clock *thunder_ptp_clock = pci_get_drvdata(pdev);
+
+	cavium_ptp_remove(thunder_ptp_clock->cavium_ptp_clock);
+	iounmap(thunder_ptp_clock->reg_base);
+	pci_release_regions(pdev);
+	pci_disable_device(pdev);
+	pci_set_drvdata(pdev, NULL);
+}
+
+/* Supported devices */
+static const struct pci_device_id thunder_ptp_id_table[] = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, PCI_DEVICE_ID_THUNDER_PTP) },
+	{ 0, }  /* end of table */
+};
+
+static struct pci_driver thunder_ptp_driver = {
+	.name = DRV_NAME,
+	.id_table = thunder_ptp_id_table,
+	.probe = thunder_ptp_probe,
+	.remove = thunder_ptp_remove,
+};
+
+static int __init thunder_ptp_init_module(void)
+{
+	pr_info("%s, ver %s\n", DRV_NAME, DRV_VERSION);
+
+	return pci_register_driver(&thunder_ptp_driver);
+}
+
+static void __exit thunder_ptp_cleanup_module(void)
+{
+	pci_unregister_driver(&thunder_ptp_driver);
+}
+
+module_init(thunder_ptp_init_module);
+module_exit(thunder_ptp_cleanup_module);
+
+MODULE_AUTHOR("Cavium Networks, <support@cavium.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION(DRV_NAME);
+MODULE_VERSION(DRV_VERSION);
+MODULE_DEVICE_TABLE(pci, thunder_ptp_id_table);
-- 
2.17.1

