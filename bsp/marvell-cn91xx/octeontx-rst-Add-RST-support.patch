From 2719531a1a9fbc4c2e8cd3716814d69b8ef4718b Mon Sep 17 00:00:00 2001
From: Tirumalesh Chalamarla <tchalamarla@caviumnetworks.com>
Date: Tue, 9 Oct 2018 00:39:29 +0300
Subject: [PATCH 0243/1051] octeontx-rst: Add RST support

Introducing RST driver needed for sso timeout.
To enable driver set: CONFIG_OCTEONTX_RST=y

Signed-off-by: Santosh Shukla <santosh.shukla@caviumnetworks.com>
Signed-off-by: Tirumalesh Chalamarla <tchalamarla@caviumnetworks.com>
Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
[Kevin: The original patch got from Marvell sdk10.0_19.06]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/net/ethernet/cavium/Kconfig           |   6 +
 .../ethernet/cavium/octeontx-83xx/Makefile    |   2 +
 .../net/ethernet/cavium/octeontx-83xx/rst.h   |  28 +++
 .../ethernet/cavium/octeontx-83xx/rst_main.c  | 192 ++++++++++++++++++
 4 files changed, 228 insertions(+)
 create mode 100644 drivers/net/ethernet/cavium/octeontx-83xx/rst.h
 create mode 100644 drivers/net/ethernet/cavium/octeontx-83xx/rst_main.c

diff --git a/drivers/net/ethernet/cavium/Kconfig b/drivers/net/ethernet/cavium/Kconfig
index 054c5a23a8cd..b0a0e441563b 100644
--- a/drivers/net/ethernet/cavium/Kconfig
+++ b/drivers/net/ethernet/cavium/Kconfig
@@ -118,4 +118,10 @@ config OCTEONTX_FPA_VF
           FPA provides hardware assisted memory management for
 	  OcteonTX coprocessors. Each VF owns single FPA pool.
 
+config OCTEONTX_RST
+	tristate "OcteonTX Reset driver(RST)"
+	depends on 64BIT
+	help
+	  Select this option to enable RST.
+
 endif # NET_VENDOR_CAVIUM
diff --git a/drivers/net/ethernet/cavium/octeontx-83xx/Makefile b/drivers/net/ethernet/cavium/octeontx-83xx/Makefile
index 28744c31246f..06da4f766f57 100644
--- a/drivers/net/ethernet/cavium/octeontx-83xx/Makefile
+++ b/drivers/net/ethernet/cavium/octeontx-83xx/Makefile
@@ -4,6 +4,8 @@
 
 obj-$(CONFIG_OCTEONTX_FPA_PF) += fpapf.o
 obj-$(CONFIG_OCTEONTX_FPA_VF) += fpavf.o
+obj-$(CONFIG_OCTEONTX_RST) += rst.o
 
 fpapf-objs := fpapf_main.o
 fpavf-objs := fpavf_main.o
+rst-objs := rst_main.o
diff --git a/drivers/net/ethernet/cavium/octeontx-83xx/rst.h b/drivers/net/ethernet/cavium/octeontx-83xx/rst.h
new file mode 100644
index 000000000000..b1bbe36bf336
--- /dev/null
+++ b/drivers/net/ethernet/cavium/octeontx-83xx/rst.h
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2017 Cavium, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License
+ * as published by the Free Software Foundation.
+ */
+
+#ifndef RST_H
+#define RST_H
+
+#define PCI_DEVICE_ID_OCTEONTX_RST_PF	0xA00E
+
+#define PCI_RST_PF_CFG_BAR	0
+
+/* reg offset */
+#define RST_BOOT	0x1600
+
+#define PLL_REF_CLK	(50 * 1000 * 1000)
+
+struct rst_com_s {
+	u64 (*get_sclk_freq)(int id);
+	/* Will add rest function based on use-case */
+};
+
+extern struct rst_com_s rst_com;
+
+#endif
diff --git a/drivers/net/ethernet/cavium/octeontx-83xx/rst_main.c b/drivers/net/ethernet/cavium/octeontx-83xx/rst_main.c
new file mode 100644
index 000000000000..95717c83f510
--- /dev/null
+++ b/drivers/net/ethernet/cavium/octeontx-83xx/rst_main.c
@@ -0,0 +1,192 @@
+/*
+ * Copyright (C) 2017 Cavium, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License
+ * as published by the Free Software Foundation.
+ */
+
+#include <linux/types.h>
+#include <linux/stat.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+
+#include "rst.h"
+
+#define DRV_NAME "octeontx-rst"
+#define DRV_VERSION "0.1"
+
+static atomic_t rst_count = ATOMIC_INIT(0);
+static DEFINE_SPINLOCK(octeontx_rst_devices_lock);
+static LIST_HEAD(octeontx_rst_devices);
+
+struct rstpf {
+	struct pci_dev		*pdev;
+	void __iomem		*reg_base;
+	int			id;
+	struct list_head	list;
+};
+
+/* In Cavium OcteonTX SoCs, all accesses to the device registers are
+ * implicitly strongly ordered.
+ * So writeq_relaxed() and readq_relaxed() are safe to use
+ * with out any memory barriers.
+ */
+
+/* Register read/write APIs */
+static inline void rst_reg_write(struct rstpf *rst, u64 offset, u64 val)
+{
+	writeq_relaxed(val, rst->reg_base + offset);
+}
+
+static inline u64 rst_reg_read(struct rstpf *rst, u64 offset)
+{
+	return readq_relaxed(rst->reg_base + offset);
+}
+
+static struct rstpf *rst_get(u32 id)
+{
+	struct rstpf *rst = NULL;
+	struct rstpf *curr;
+
+	spin_lock(&octeontx_rst_devices_lock);
+	list_for_each_entry(curr, &octeontx_rst_devices, list) {
+		if (curr->id == id) {
+			rst = curr;
+			break;
+		}
+	}
+
+	if (!rst) {
+		spin_unlock(&octeontx_rst_devices_lock);
+		return NULL;
+	}
+
+	spin_unlock(&octeontx_rst_devices_lock);
+	return rst;
+}
+
+static u64 rst_get_sclk_freq(int node)
+{
+	u64 sclk_freq;
+	struct rstpf *rst = NULL;
+
+	rst = rst_get(node);
+	if (!rst)
+		return 0;
+
+	/* Bit 38:33 is PNR_MULL */
+	sclk_freq = (rst_reg_read(rst, RST_BOOT) >> 33) & 0x3f;
+	sclk_freq *= PLL_REF_CLK;
+
+	return sclk_freq;
+}
+
+struct rst_com_s rst_com = {
+	.get_sclk_freq = rst_get_sclk_freq
+/* add future RST function here !!!: TODO  */
+};
+EXPORT_SYMBOL(rst_com);
+
+static int rst_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	struct device *dev = &pdev->dev;
+	struct rstpf *rst;
+	int err = -ENOMEM;
+
+	rst = devm_kzalloc(dev, sizeof(*rst), GFP_KERNEL);
+	if (!rst)
+		return err;
+
+	pci_set_drvdata(pdev, rst);
+	rst->pdev = pdev;
+
+	err = pcim_enable_device(pdev);
+	if (err) {
+		dev_err(dev, "Failed to enable PCI device\n");
+		return err;
+	}
+
+	err = pci_request_regions(pdev, DRV_NAME);
+	if (err) {
+		dev_err(dev, "PCI request regions failed\n");
+		return err;
+	}
+
+	/* Map CFG registers */
+	rst->reg_base = pcim_iomap(pdev, PCI_RST_PF_CFG_BAR, 0);
+	if (!rst->reg_base) {
+		dev_err(dev, "Can't map CFG space\n");
+		err = -ENOMEM;
+		return err;
+	}
+
+	/* set RST ID */
+	rst->id = atomic_add_return(1, &rst_count);
+	rst->id -= 1;
+
+	INIT_LIST_HEAD(&rst->list);
+
+	/* use sso_device_lock; as rst use-case scope limited till sso */
+	spin_lock(&octeontx_rst_devices_lock);
+	list_add(&rst->list, &octeontx_rst_devices);
+	spin_unlock(&octeontx_rst_devices_lock);
+
+	return 0;
+}
+
+static void rst_remove(struct pci_dev *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct rstpf *rst = pci_get_drvdata(pdev);
+
+	if (!rst)
+		return;
+
+	/* use sso_device_lock; as rst use-case scope limited till sso */
+	spin_lock(&octeontx_rst_devices_lock);
+	list_del(&rst->list);
+	spin_unlock(&octeontx_rst_devices_lock);
+	pci_release_regions(pdev);
+	pci_disable_device(pdev);
+	pci_set_drvdata(pdev, NULL);
+	devm_kfree(dev, rst);
+}
+
+/* devices supported */
+static const struct pci_device_id rst_id_table[] = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, PCI_DEVICE_ID_OCTEONTX_RST_PF) },
+	{ 0, } /* end of table */
+};
+
+static struct pci_driver rst_driver = {
+	.name = DRV_NAME,
+	.id_table = rst_id_table,
+	.probe = rst_probe,
+	.remove = rst_remove,
+	.sriov_configure = NULL,
+};
+
+MODULE_AUTHOR("Santosh Shukla");
+MODULE_DESCRIPTION("Cavium OCTEONTX RST Physical Function Driver");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION(DRV_VERSION);
+MODULE_DEVICE_TABLE(pci, rst_id_table);
+
+static int __init rst_init_module(void)
+{
+	pr_info("%s, ver %s\n", DRV_NAME, DRV_VERSION);
+
+	return pci_register_driver(&rst_driver);
+}
+
+static void __exit rst_cleanup_module(void)
+{
+	pci_unregister_driver(&rst_driver);
+}
+
+module_init(rst_init_module);
+module_exit(rst_cleanup_module);
+
-- 
2.17.1

