From 3248eb4dca52ac65a2bccfaa46f2c234e04ec2c8 Mon Sep 17 00:00:00 2001
From: Valentin Catalin Neacsu <valentin-catalin.neacsu@nxp.com>
Date: Fri, 19 Oct 2018 11:06:20 +0300
Subject: [PATCH 2/4] net: phy: aquantia: add support for autoneg

commit 68cd59f195f1e5671b68a6bed246410d81de41e9 from
http://source.codeaurora.org/external/qoriq/qoriq-components/linux

USXGMII interface between external PHY and internal PCS support
autonegotiation. In order to take advantage of this feature autoneg
should be enable on the phy line side also.
Added function on Aquantia for configuring autoneg advertisements and if
the autoneg is off, force a specific speed in the phy.

Signed-off-by: Valentin Catalin Neacsu <valentin-catalin.neacsu@nxp.com>
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/net/phy/aquantia_main.c | 154 +++++++++++++++++++++++++-------
 1 file changed, 123 insertions(+), 31 deletions(-)

diff --git a/drivers/net/phy/aquantia_main.c b/drivers/net/phy/aquantia_main.c
index 777a61bc3e70..dded4e8c39db 100644
--- a/drivers/net/phy/aquantia_main.c
+++ b/drivers/net/phy/aquantia_main.c
@@ -154,6 +154,12 @@
 #define AQUANTIA_VND1_GSYSCFG_5G		3
 #define AQUANTIA_VND1_GSYSCFG_10G		4
 
+#define MDIO_PMA_CTRL2_AQ_2500BT       0x30
+#define MDIO_PMA_CTRL2_AQ_5000BT       0x31
+#define MDIO_PMA_CTRL2_AQ_TYPE_MASK    0x3F
+
+#define MDIO_AN_VENDOR_PROV_CTRL       0xc400
+
 struct aqr107_hw_stat {
 	const char *name;
 	int reg;
@@ -256,6 +262,63 @@ static int aquantia_read_reg(struct phy_device *phydev, int devad, u32 regnum)
 
 	return mdiobus_read(phydev->mdio.bus, phydev->mdio.addr, addr);
 }
+
+static int aquantia_pma_setup_forced(struct phy_device *phydev)
+{
+	int ctrl1, ctrl2, ret;
+
+	/* Half duplex is not supported */
+	if (phydev->duplex != DUPLEX_FULL)
+		return -EINVAL;
+
+	ctrl1 = phy_read_mmd(phydev, MDIO_MMD_PMAPMD, MDIO_CTRL1);
+	if (ctrl1 < 0)
+		return ctrl1;
+
+	ctrl2 = phy_read_mmd(phydev, MDIO_MMD_PMAPMD, MDIO_CTRL2);
+	if (ctrl2 < 0)
+		return ctrl2;
+
+	ctrl1 &= ~MDIO_CTRL1_SPEEDSEL;
+	ctrl2 &= ~(MDIO_PMA_CTRL2_AQ_TYPE_MASK);
+
+	switch (phydev->speed) {
+	case SPEED_10:
+		ctrl2 |= MDIO_PMA_CTRL2_10BT;
+		break;
+	case SPEED_100:
+		ctrl1 |= MDIO_PMA_CTRL1_SPEED100;
+		ctrl2 |= MDIO_PMA_CTRL2_100BTX;
+		break;
+	case SPEED_1000:
+		ctrl1 |= MDIO_PMA_CTRL1_SPEED1000;
+		/* Assume 1000base-T */
+		ctrl2 |= MDIO_PMA_CTRL2_1000BT;
+		break;
+	case SPEED_10000:
+		ctrl1 |= MDIO_CTRL1_SPEED10G;
+		/* Assume 10Gbase-T */
+		ctrl2 |= MDIO_PMA_CTRL2_10GBT;
+		break;
+	case SPEED_2500:
+		ctrl1 |= MDIO_PMA_CTRL1_AQ_SPEED2500;
+		ctrl2 |= MDIO_PMA_CTRL2_AQ_2500BT;
+		break;
+	case SPEED_5000:
+		ctrl1 |= MDIO_PMA_CTRL1_AQ_SPEED5000;
+		ctrl2 |= MDIO_PMA_CTRL2_AQ_5000BT;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ret = phy_write_mmd(phydev, MDIO_MMD_PMAPMD, MDIO_CTRL1, ctrl1);
+	if (ret < 0)
+		return ret;
+
+	return phy_write_mmd(phydev, MDIO_MMD_PMAPMD, MDIO_CTRL2, ctrl2);
+}
+
 static int aquantia_aneg(struct phy_device *phydev, bool control)
 {       
 	int reg = aquantia_read_reg(phydev, MDIO_MMD_AN, MDIO_CTRL1);
@@ -271,46 +334,75 @@ static int aquantia_aneg(struct phy_device *phydev, bool control)
         return aquantia_write_reg(phydev, MDIO_MMD_AN, MDIO_CTRL1, reg);
 }
 
+static int aquantia_config_advert(struct phy_device *phydev)
+{
+	u32 advertise;
+	int oldadv, adv, oldadv1, adv1;
+	int err, changed = 0;
+
+	/* Only allow advertising what this PHY supports */
+	supported = SUPPORTED_10000baseT_Full | SUPPORTED_1000baseT_Full |
+		    SUPPORTED_2500baseX_Full | SUPPORTED_100baseT_Full |
+		    PHY_DEFAULT_FEATURES;
+
+	linkmode_mod_bit(supported, advertise, phydev->advertising & supported);
+	/* Setup standard advertisement */
+	oldadv = phy_read_mmd(phydev, MDIO_MMD_AN,
+			      MDIO_AN_10GBT_CTRL);
+	if (oldadv < 0)
+		return oldadv;
+
+	/* Aquantia vendor specific advertisments */
+	oldadv1 = phy_read_mmd(phydev, MDIO_MMD_AN,
+			       MDIO_AN_VENDOR_PROV_CTRL);
+	if (oldadv1 < 0)
+		return oldadv1;
+
+	adv  = 0;
+	adv1 = 0;
+
+	/*100BaseT_full is supported by default*/
+
+	if (linkmode_test_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT, advertise))
+		adv1 |= 0x8000;
+	if (linkmode_test_bit(ADVERTISED_10000baseT_Full, advertise))
+		adv |= 0x1000;
+	if (linkmode_test_bit(ADVERTISED_2500baseX_Full, advertise))
+		adv1 |= 0x400;
+
+	if (adv != oldadv) {
+		err = phy_write_mmd(phydev, MDIO_MMD_AN,
+				    MDIO_AN_10GBT_CTRL, adv);
+		if (err < 0)
+			return err;
+		changed = 1;
+	}
+	if (adv1 != oldadv1) {
+		err = phy_write_mmd(phydev, MDIO_MMD_AN,
+				    MDIO_AN_VENDOR_PROV_CTRL, adv1);
+		if (err < 0)
+			return err;
+		changed = 1;
+	}
+
+	return changed;
+}
+
 static int aqr_config_aneg(struct phy_device *phydev)
 {
-	bool changed = false;
-	u16 reg;
-	int ret;
+	int ret = 0;
 
 	if (phydev->autoneg == AUTONEG_DISABLE) {
-		genphy_c45_pma_setup_forced(phydev);
+		aquantia_pma_setup_forced(phydev);
 		return aquantia_aneg(phydev, false);
 	}
 
-	ret = genphy_c45_an_config_aneg(phydev);
-	if (ret < 0)
-		return ret;
+	ret = aquantia_config_advert(phydev);
 	if (ret > 0)
-		changed = true;
+		/* restart autoneg */
+		return aquantia_aneg(phydev, true);
 
-	/* Clause 45 has no standardized support for 1000BaseT, therefore
-	 * use vendor registers for this mode.
-	 */
-	reg = 0;
-	if (linkmode_test_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT,
-			      phydev->advertising))
-		reg |= MDIO_AN_VEND_PROV_1000BASET_FULL;
-
-	if (linkmode_test_bit(ETHTOOL_LINK_MODE_1000baseT_Half_BIT,
-			      phydev->advertising))
-		reg |= MDIO_AN_VEND_PROV_1000BASET_HALF;
-
-	ret = phy_modify_mmd_changed(phydev, MDIO_MMD_AN, MDIO_AN_VEND_PROV,
-				     MDIO_AN_VEND_PROV_1000BASET_HALF |
-				     MDIO_AN_VEND_PROV_1000BASET_FULL, reg);
-	if (ret < 0)
-		return ret;
-	if (ret > 0)
-		changed = true;
-
-	genphy_c45_check_and_restart_aneg(phydev, changed);
-
-	return aquantia_aneg(phydev, true);
+	return ret;
 }
 
 static struct {
-- 
2.17.1

