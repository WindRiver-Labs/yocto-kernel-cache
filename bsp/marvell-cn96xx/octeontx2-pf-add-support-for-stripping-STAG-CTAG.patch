From ecb069f82b686a8166a0f16253a6d8f3f64f7394 Mon Sep 17 00:00:00 2001
From: Subbaraya Sundeep <sbhatta@marvell.com>
Date: Fri, 12 Apr 2019 15:22:35 +0530
Subject: [PATCH 203/255] octeontx2-pf: add support for stripping STAG/CTAG

commit bd2892394658f238be94d85c2f519819459f08ea from
git@git.assembla.com:cavium/WindRiver.linux.git

Add support for stripping VLAN tag. In case double tagged packet
is received only the outer VLAN gets stripped off.
And  VLAN offload can be done installed with VTAG action.

Change-Id: Id5a35348ec325eb79d15f5632822e310cc9d8287
Signed-off-by: Subbaraya Sundeep <sbhatta@marvell.com>
Signed-off-by: Tomasz Duszynski <tduszynski@marvell.com>
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../marvell/octeontx2/nic/otx2_common.c       |  53 +++++++
 .../marvell/octeontx2/nic/otx2_common.h       |   6 +-
 .../ethernet/marvell/octeontx2/nic/otx2_pf.c  | 135 +++++++++++++++++-
 .../marvell/octeontx2/nic/otx2_txrx.c         |  12 ++
 4 files changed, 203 insertions(+), 3 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.c
index f20125429b8a..216d92e46ec3 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.c
@@ -22,6 +22,59 @@ static inline void otx2_nix_rq_op_stats(struct queue_stats *stats,
 static inline void otx2_nix_sq_op_stats(struct queue_stats *stats,
 					struct otx2_nic *pfvf, int qidx);
 
+int otx2_install_rxvlan_offload_flow(struct otx2_nic *pfvf)
+{
+	struct npc_install_flow_req *req;
+	int err;
+
+	if (!pfvf->rxvlan_alloc)
+		return -EINVAL;
+
+	otx2_mbox_lock(&pfvf->mbox);
+	req = otx2_mbox_alloc_msg_npc_install_flow(&pfvf->mbox);
+	if (!req) {
+		otx2_mbox_unlock(&pfvf->mbox);
+		return -ENOMEM;
+	}
+
+	req->entry = pfvf->rxvlan_entry;
+	req->intf = NIX_INTF_RX;
+	req->channel = pfvf->rx_chan_base;
+	req->op = NIX_RX_ACTIONOP_UCAST;
+	req->features = BIT_ULL(NPC_OUTER_VID);
+	req->vtag0_valid = 1;
+	req->vtag0_type = 0;
+
+	/* Send message to AF */
+	err = otx2_sync_mbox_msg(&pfvf->mbox);
+	otx2_mbox_unlock(&pfvf->mbox);
+	return err;
+}
+EXPORT_SYMBOL(otx2_install_rxvlan_offload_flow);
+
+int otx2_delete_rxvlan_offload_flow(struct otx2_nic *pfvf)
+{
+	struct npc_delete_flow_req *req;
+	int err;
+
+	if (!pfvf->rxvlan_alloc)
+		return -EINVAL;
+
+	otx2_mbox_lock(&pfvf->mbox);
+	req = otx2_mbox_alloc_msg_npc_delete_flow(&pfvf->mbox);
+	if (!req) {
+		otx2_mbox_unlock(&pfvf->mbox);
+		return -ENOMEM;
+	}
+
+	req->entry = pfvf->rxvlan_entry;
+	/* Send message to AF */
+	err = otx2_sync_mbox_msg(&pfvf->mbox);
+	otx2_mbox_unlock(&pfvf->mbox);
+	return err;
+}
+EXPORT_SYMBOL(otx2_delete_rxvlan_offload_flow);
+
 void otx2_update_lmac_stats(struct otx2_nic *pfvf)
 {
 	struct msg_req *req;
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h
index aa7d7199a1ed..5780d6a9a6fe 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h
@@ -99,7 +99,7 @@ struct  mbox {
 	struct otx2_mbox	mbox_up;
 	struct work_struct	mbox_up_wrk;
 	struct otx2_nic		*pfvf;
-	void *bbuf_base; /* Bounce buffer for mbox memory */
+	void			*bbuf_base; /* Bounce buffer for mbox memory */
 	atomic_t		lock; /* serialize mailbox access */
 };
 
@@ -157,6 +157,8 @@ struct otx2_nic {
 	u8			cq_time_wait;
 	u32			cq_ecount_wait;
 	struct work_struct	reset_task;
+	u16			rxvlan_entry;
+	bool			rxvlan_alloc;
 };
 
 static inline bool is_9xxx_pass1_silicon(struct pci_dev *pdev)
@@ -448,6 +450,8 @@ void otx2_update_lmac_stats(struct otx2_nic *pfvf);
 int otx2_update_rq_stats(struct otx2_nic *pfvf, int qidx);
 int otx2_update_sq_stats(struct otx2_nic *pfvf, int qidx);
 void otx2_set_ethtool_ops(struct net_device *netdev);
+int otx2_install_rxvlan_offload_flow(struct otx2_nic *pfvf);
+int otx2_delete_rxvlan_offload_flow(struct otx2_nic *pfvf);
 
 int otx2_open(struct net_device *netdev);
 int otx2_stop(struct net_device *netdev);
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c
index 560e73873d33..afcef769927e 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c
@@ -400,6 +400,52 @@ static int otx2_cgx_config_loopback(struct otx2_nic *pf, bool enable)
 	return err;
 }
 
+static int otx2_enable_rxvlan(struct otx2_nic *pf, bool enable)
+{
+	struct nix_vtag_config *req;
+	struct mbox_msghdr *rsp_hdr;
+	int err;
+
+	if (enable) {
+		err = otx2_install_rxvlan_offload_flow(pf);
+		if (err)
+			return err;
+	} else {
+		err = otx2_delete_rxvlan_offload_flow(pf);
+		if (err)
+			return err;
+	}
+
+	otx2_mbox_lock(&pf->mbox);
+	req = otx2_mbox_alloc_msg_nix_vtag_cfg(&pf->mbox);
+	if (!req) {
+		otx2_mbox_unlock(&pf->mbox);
+		return -ENOMEM;
+	}
+
+	req->vtag_size = 0;
+	req->cfg_type = 1;
+	/* must be set to zero */
+	req->rx.vtag_type = 0;
+	req->rx.strip_vtag = enable;
+	req->rx.capture_vtag = enable;
+
+	err = otx2_sync_mbox_msg(&pf->mbox);
+	if (err) {
+		otx2_mbox_unlock(&pf->mbox);
+		return err;
+	}
+
+	rsp_hdr = otx2_mbox_get_rsp(&pf->mbox.mbox, 0, &req->hdr);
+	if (IS_ERR(rsp_hdr)) {
+		otx2_mbox_unlock(&pf->mbox);
+		return PTR_ERR(rsp_hdr);
+	}
+
+	otx2_mbox_unlock(&pf->mbox);
+	return rsp_hdr->rc;
+}
+
 int otx2_set_real_num_queues(struct net_device *netdev,
 			     int tx_queues, int rx_queues)
 {
@@ -419,6 +465,68 @@ int otx2_set_real_num_queues(struct net_device *netdev,
 	return err;
 }
 
+static void otx2_alloc_rxvlan(struct otx2_nic *pf)
+{
+	netdev_features_t old, wanted = NETIF_F_HW_VLAN_STAG_RX |
+					NETIF_F_HW_VLAN_CTAG_RX;
+	struct npc_mcam_alloc_entry_req *req;
+	struct npc_mcam_alloc_entry_rsp *rsp;
+	int err;
+
+	otx2_mbox_lock(&pf->mbox);
+	req = otx2_mbox_alloc_msg_npc_mcam_alloc_entry(&pf->mbox);
+	if (!req) {
+		otx2_mbox_unlock(&pf->mbox);
+		return;
+	}
+
+	req->contig = false;
+	req->count = 1;
+	/* Send message to AF */
+	err = otx2_sync_mbox_msg(&pf->mbox);
+	if (err) {
+		otx2_mbox_unlock(&pf->mbox);
+		return;
+	}
+	rsp = (struct npc_mcam_alloc_entry_rsp *)otx2_mbox_get_rsp
+						 (&pf->mbox.mbox, 0, &req->hdr);
+	if (IS_ERR(rsp)) {
+		otx2_mbox_unlock(&pf->mbox);
+		return;
+	}
+
+	otx2_mbox_unlock(&pf->mbox);
+	pf->rxvlan_entry = rsp->entry_list[0];
+	pf->rxvlan_alloc = true;
+
+	old = pf->netdev->hw_features;
+	if (rsp->hdr.rc) {
+		/* in case of failure during rxvlan allocation
+		 * features must be updated accordingly
+		 */
+		dev_info(pf->dev,
+			 "Disabling RX VLAN offload due to non-availability of MCAM space\n");
+		pf->netdev->hw_features &= ~wanted;
+		pf->netdev->features &= ~wanted;
+	} else if (!(pf->netdev->hw_features & wanted)) {
+		/* we are recovering from the previous failure */
+		pf->netdev->hw_features |= wanted;
+		err = otx2_enable_rxvlan(pf, true);
+		if (!err)
+			pf->netdev->features |= wanted;
+	} else if (pf->netdev->features & wanted) {
+		/* interface is going up */
+		err = otx2_enable_rxvlan(pf, true);
+		if (err) {
+			pf->netdev->features &= ~wanted;
+			netdev_features_change(pf->netdev);
+		}
+	}
+
+	if (old != pf->netdev->hw_features)
+		netdev_features_change(pf->netdev);
+}
+
 static irqreturn_t otx2_q_intr_handler(int irq, void *data)
 {
 	struct otx2_nic *pf = data;
@@ -818,6 +926,11 @@ int otx2_open(struct net_device *netdev)
 
 	/* Enable link notifications */
 	otx2_cgx_config_linkevents(pf, true);
+
+	/* Alloc rxvlan entry in MCAM for PFs only */
+	if (!(pf->pcifunc & RVU_PFVF_FUNC_MASK))
+		otx2_alloc_rxvlan(pf);
+
 	return 0;
 
 err_free_cints:
@@ -893,6 +1006,17 @@ int otx2_stop(struct net_device *netdev)
 	return 0;
 }
 
+static netdev_features_t otx2_fix_features(struct net_device *dev,
+					   netdev_features_t features)
+{
+	if (features & NETIF_F_HW_VLAN_CTAG_RX)
+		features |= NETIF_F_HW_VLAN_STAG_RX;
+	else
+		features &= ~NETIF_F_HW_VLAN_STAG_RX;
+
+	return features;
+}
+
 static void otx2_set_rx_mode(struct net_device *netdev)
 {
 	struct otx2_nic *pf = netdev_priv(netdev);
@@ -941,6 +1065,11 @@ static int otx2_set_features(struct net_device *netdev,
 	if ((changed & NETIF_F_LOOPBACK) && netif_running(netdev))
 		return otx2_cgx_config_loopback(pf,
 						features & NETIF_F_LOOPBACK);
+
+	if ((changed & NETIF_F_HW_VLAN_CTAG_RX) && netif_running(netdev))
+		return otx2_enable_rxvlan(pf,
+					  features & NETIF_F_HW_VLAN_CTAG_RX);
+
 	return 0;
 }
 
@@ -948,6 +1077,7 @@ static const struct net_device_ops otx2_netdev_ops = {
 	.ndo_open		= otx2_open,
 	.ndo_stop		= otx2_stop,
 	.ndo_start_xmit		= otx2_xmit,
+	.ndo_fix_features	= otx2_fix_features,
 	.ndo_set_mac_address    = otx2_set_mac_address,
 	.ndo_change_mtu		= otx2_change_mtu,
 	.ndo_set_rx_mode	= otx2_set_rx_mode,
@@ -1081,9 +1211,10 @@ static int otx2_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	netdev->hw_features = (NETIF_F_RXCSUM | NETIF_F_IP_CSUM |
 			       NETIF_F_IPV6_CSUM | NETIF_F_RXHASH |
 			       NETIF_F_SG | NETIF_F_TSO | NETIF_F_TSO6);
-
 	netdev->features |= netdev->hw_features;
-	netdev->hw_features |= NETIF_F_LOOPBACK;
+	netdev->hw_features |= NETIF_F_LOOPBACK |
+			       NETIF_F_HW_VLAN_STAG_RX |
+			       NETIF_F_HW_VLAN_CTAG_RX;
 
 	netdev->gso_max_segs = OTX2_MAX_GSO_SEGS;
 
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_txrx.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_txrx.c
index 7c56c9116763..14c13a72b6cd 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_txrx.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_txrx.c
@@ -259,6 +259,18 @@ static void otx2_rcv_pkt_handler(struct otx2_nic *pfvf,
 	if (pfvf->netdev->features & NETIF_F_RXCSUM)
 		skb->ip_summed = CHECKSUM_UNNECESSARY;
 
+	/* This holds true on condition RX VLAN offloads are enabled and
+	 * 802.1AD or 802.1Q VLANs were found in frame.
+	 */
+	if (parse->vtag0_gone) {
+		if (skb->protocol == htons(ETH_P_8021Q))
+			__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021AD),
+					       parse->vtag0_tci);
+		else
+			__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),
+					       parse->vtag0_tci);
+	}
+
 	napi_gro_receive(&qset->napi[cq->cint_idx].napi, skb);
 }
 
-- 
2.17.1

