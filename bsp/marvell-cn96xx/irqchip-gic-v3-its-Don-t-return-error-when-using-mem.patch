From 6d0f709fffe83deacc9bd1d4d243cd4c4cfde040 Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Tue, 22 Sep 2020 14:34:56 +0800
Subject: [PATCH] irqchip/gic-v3-its: Don't return error when using mem region
 from atf

With the commit cefeae7aaa6a ("drivers: gicv3: fetches atf mem region
for LPI prop and pend tables"), we have added a 'prop_page' in
struct rdists to distinguish if the allocated pages are from kernel or
atf, but we forgot to assign value to it when the pages is allocated
from kernel. So add the code to fix this. After the change in commit
cefeae7aaa6a, its_allocate_prop_table()/its_allocate_pending_table()
will return NULL when the mem region is got from atf, so we can't
consider the return of NULL as an error, actually we should check both
the return value of its_allocate_prop_table()/its_allocate_pending_table()
and the value of gic_rdists->prop_table_va/gic_data_rdist()->pend_vaddr.

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/irqchip/irq-gic-v3-fixes.c |  1 +
 drivers/irqchip/irq-gic-v3-its.c   | 20 +++++++++-----------
 2 files changed, 10 insertions(+), 11 deletions(-)

diff --git a/drivers/irqchip/irq-gic-v3-fixes.c b/drivers/irqchip/irq-gic-v3-fixes.c
index e9f7548ba7fe..01a2f36ef87f 100644
--- a/drivers/irqchip/irq-gic-v3-fixes.c
+++ b/drivers/irqchip/irq-gic-v3-fixes.c
@@ -187,6 +187,7 @@ struct page *its_prop_alloc_pages(struct rdists *gic_rdists,
 
 		gic_rdists->prop_table_pa = page_to_phys(prop_page);
 		gic_rdists->prop_table_va = page_address(prop_page);
+		gic_rdists->prop_page = prop_page;
 	}
 
 	return prop_page;
diff --git a/drivers/irqchip/irq-gic-v3-its.c b/drivers/irqchip/irq-gic-v3-its.c
index e2003100639a..f8a17d81a357 100644
--- a/drivers/irqchip/irq-gic-v3-its.c
+++ b/drivers/irqchip/irq-gic-v3-its.c
@@ -1710,13 +1710,11 @@ static int __init its_setup_lpi_prop_table(void)
 				    GICD_TYPER_ID_BITS(gic_rdists->gicd_typer),
 				    ITS_MAX_LPI_NRBITS);
 		page = its_allocate_prop_table(GFP_NOWAIT);
-		if (!page) {
+		if (!page && !gic_rdists->prop_table_va) {
 			pr_err("Failed to allocate PROPBASE\n");
 			return -ENOMEM;
 		}
 
-		gic_rdists->prop_table_pa = page_to_phys(page);
-		gic_rdists->prop_table_va = page_address(page);
 		WARN_ON(gic_reserve_range(gic_rdists->prop_table_pa,
 					  LPI_PROPBASE_SZ));
 	}
@@ -2077,7 +2075,7 @@ static int __init allocate_lpi_tables(void)
 		struct page *pend_page;
 
 		pend_page = its_allocate_pending_table(GFP_NOWAIT);
-		if (!pend_page) {
+		if (!pend_page && !gic_data_rdist()->pend_vaddr) {
 			pr_err("Failed to allocate PENDBASE for CPU%d\n", cpu);
 			return -ENOMEM;
 		}
@@ -2114,7 +2112,6 @@ static u64 its_clear_vpend_valid(void __iomem *vlpi_base)
 static void its_cpu_init_lpis(void)
 {
 	void __iomem *rbase = gic_data_rdist_rd_base();
-	struct page *pend_page;
 	phys_addr_t paddr;
 	u64 val, tmp;
 
@@ -2137,14 +2134,15 @@ static void its_cpu_init_lpis(void)
 		paddr &= GENMASK_ULL(51, 16);
 
 		WARN_ON(!gic_check_reserved_range(paddr, LPI_PENDBASE_SZ));
-		its_free_pending_table(gic_data_rdist()->pend_page);
-		gic_data_rdist()->pend_page = NULL;
+		if (gic_data_rdist()->pend_page) {
+			its_free_pending_table(gic_data_rdist()->pend_page);
+			gic_data_rdist()->pend_page = NULL;
+		}
 
 		goto out;
 	}
 
-	pend_page = gic_data_rdist()->pend_page;
-	paddr = page_to_phys(pend_page);
+	paddr = gic_data_rdist()->pend_paddr;
 	WARN_ON(gic_reserve_range(paddr, LPI_PENDBASE_SZ));
 
 	/* set PROPBASE */
@@ -3029,7 +3027,7 @@ static int its_vpe_init(struct its_vpe *vpe)
 
 	/* Allocate VPT */
 	vpt_page = its_allocate_pending_table(GFP_KERNEL);
-	if (!vpt_page) {
+	if (!vpt_page && !gic_data_rdist()->pend_vaddr) {
 		its_vpe_id_free(vpe_id);
 		return -ENOMEM;
 	}
@@ -3101,7 +3099,7 @@ static int its_vpe_irq_domain_alloc(struct irq_domain *domain, unsigned int virq
 	}
 
 	vprop_page = its_allocate_prop_table(GFP_KERNEL);
-	if (!vprop_page) {
+	if (!vprop_page && !gic_rdists->prop_table_va) {
 		its_lpi_free(bitmap, base, nr_ids);
 		return -ENOMEM;
 	}
-- 
2.17.1

