From f16af5eb204a69ba434941ae6e395869f9fa9c0f Mon Sep 17 00:00:00 2001
From: Subbaraya Sundeep <sbhatta@marvell.com>
Date: Tue, 16 Apr 2019 15:57:53 +0530
Subject: [PATCH 016/138] octeontx2-pf: Synchronize mailbox for PF and VF
 messages

commit fc921636169072ba8ce6a515513e420c5d9d4f3b from
git@git.assembla.com:cavium/WindRiver.linux.git

Same mailbox region is used by PF for PF messages and
its VF messages. Hence forward VF messages in critical
section thereby providing mutual exclusion between
PF and its VFs. Simplified logic such that sending VF
messages, receiving responses and raising VF interrupt
are done at one place.

Change-Id: I5cd660e3d6fe5a5ae20a60629fdf7e8155946a9a
Signed-off-by: Subbaraya Sundeep <sbhatta@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/8055
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../ethernet/marvell/octeontx2/nic/otx2_pf.c  | 25 ++++++++-----------
 1 file changed, 10 insertions(+), 15 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c
index 66f586d6cb43..c0dbb4d8098c 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c
@@ -379,20 +379,21 @@ static int otx2_forward_vf_mbox_msgs(struct otx2_nic *pf,
 		if (err) {
 			dev_warn(pf->dev,
 				 "AF not responding to VF%d messages\n", vf);
+			/* restore PF mbase and exit */
+			dst_mdev->mbase = pf->mbox.bbuf_base;
 			otx2_mbox_unlock(&pf->mbox);
 			return err;
 		}
-		otx2_mbox_unlock(&pf->mbox);
-	} else if (dir == MBOX_DIR_PFVF) {
-		otx2_mbox_lock(&pf->mbox);
-		req_hdr = (struct mbox_hdr *)(src_mbox->dev[0].mbase +
-					      src_mbox->rx_start);
+		/* At this point, all the VF messages sent to AF are acked
+		 * with proper responses and responses are copied to VF
+		 * mailbox hence raise interrupt to VF.
+		 */
+		req_hdr = (struct mbox_hdr *)(dst_mdev->mbase +
+					      dst_mbox->mbox.rx_start);
 		req_hdr->num_msgs = num_msgs;
 
-		otx2_forward_msg_pfvf(&src_mbox->dev[0],
-				      &pf->mbox_pfvf[0].mbox,
-				      pf->mbox.bbuf_base,
-				      vf);
+		otx2_forward_msg_pfvf(dst_mdev, &pf->mbox_pfvf[0].mbox,
+				      pf->mbox.bbuf_base, vf);
 		otx2_mbox_unlock(&pf->mbox);
 	} else if (dir == MBOX_DIR_PFVF_UP) {
 		src_mdev = &src_mbox->dev[0];
@@ -808,7 +809,6 @@ static void otx2_pfaf_mbox_handler(struct work_struct *work)
 	struct mbox *af_mbox;
 	struct otx2_nic *pf;
 	int offset, id;
-	int devid = 0;
 
 	af_mbox = container_of(work, struct mbox, mbox_wrk);
 	mbox = &af_mbox->mbox;
@@ -821,7 +821,6 @@ static void otx2_pfaf_mbox_handler(struct work_struct *work)
 
 	for (id = 0; id < af_mbox->num_msgs; id++) {
 		msg = (struct mbox_msghdr *)(mdev->mbase + offset);
-		devid = msg->pcifunc & RVU_PFVF_FUNC_MASK;
 		otx2_process_pfaf_mbox_msg(pf, msg);
 		offset = mbox->rx_start + msg->next_msgoff;
 		mdev->msgs_acked++;
@@ -829,10 +828,6 @@ static void otx2_pfaf_mbox_handler(struct work_struct *work)
 
 	otx2_mbox_reset(mbox, 0);
 
-	if (devid)
-		otx2_forward_vf_mbox_msgs(pf, &pf->mbox.mbox,
-					  MBOX_DIR_PFVF, devid - 1,
-					  af_mbox->num_msgs);
 	/* mbox messages in the same direction to be handled by same
 	 * mailbox occurs serially. So write to af_mbox->num_msgs
 	 * happens only after the previous context is done with it.
-- 
2.17.1

