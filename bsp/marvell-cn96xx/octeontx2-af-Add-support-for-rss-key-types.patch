From 77a3be068edfcf5583d567cfca72d371dd68d12c Mon Sep 17 00:00:00 2001
From: Kiran Kumar K <kirankumark@marvell.com>
Date: Tue, 12 Mar 2019 15:48:45 +0530
Subject: [PATCH 183/255] octeontx2-af: Add support for rss key types

commit f16f7b4612ac7418ef1af869b90cf39e8827d546 from
git@git.assembla.com:cavium/WindRiver.linux.git

This patch will add support for few more RSS key types for flow
key algo to compute rss hash index. Following flow key types have
been added.
Tunnel types like NVGRE, VXLAN, GENEVE.
L2 offload type ETH_DMAC, Here we will consider only DMAC 6 bytes.
And extension header IPV6_EXT (1 byte followed by IPV6 header)

Change-Id: Ice84920b4f5264d5ceac8c9428f320194d4d762a
Signed-off-by: Kiran Kumar K <kirankumark@marvell.com>
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../net/ethernet/marvell/octeontx2/af/mbox.h  |  5 ++
 .../ethernet/marvell/octeontx2/af/rvu_nix.c   | 46 +++++++++++++++++++
 2 files changed, 51 insertions(+)

diff --git a/drivers/net/ethernet/marvell/octeontx2/af/mbox.h b/drivers/net/ethernet/marvell/octeontx2/af/mbox.h
index a64dd6177346..0ef31497773a 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/mbox.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/mbox.h
@@ -646,6 +646,11 @@ struct nix_rss_flowkey_cfg {
 #define NIX_FLOW_KEY_TYPE_TCP	BIT(3)
 #define NIX_FLOW_KEY_TYPE_UDP	BIT(4)
 #define NIX_FLOW_KEY_TYPE_SCTP	BIT(5)
+#define NIX_FLOW_KEY_TYPE_NVGRE    BIT(6)
+#define NIX_FLOW_KEY_TYPE_VXLAN    BIT(7)
+#define NIX_FLOW_KEY_TYPE_GENEVE   BIT(8)
+#define NIX_FLOW_KEY_TYPE_ETH_DMAC BIT(9)
+#define NIX_FLOW_KEY_TYPE_IPV6_EXT BIT(10)
 	u32	flowkey_cfg; /* Flowkey types selected */
 	u8	group;       /* RSS context or group */
 };
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c
index 60cf421138db..c92163005d07 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c
@@ -2249,6 +2249,52 @@ static int set_flowkey_fields(struct nix_rx_flowkey_alg *alg, u32 flow_cfg)
 				keyoff_marker = false;
 			}
 			break;
+		case NIX_FLOW_KEY_TYPE_NVGRE:
+		case NIX_FLOW_KEY_TYPE_VXLAN:
+		case NIX_FLOW_KEY_TYPE_GENEVE:
+			field->lid = NPC_LID_LD;
+			field->bytesm1 = 2;
+			field->ltype_mask = 0xF;
+			field_marker = true;
+			keyoff_marker = false;
+			if (key_type == NIX_FLOW_KEY_TYPE_NVGRE && valid_key) {
+				field->hdr_offset = 4; /* VSID offset */
+				field->ltype_match = NPC_LT_LD_GRE;
+			}
+
+			if (key_type == NIX_FLOW_KEY_TYPE_VXLAN && valid_key) {
+				/* VNI at UDP header + 4B */
+				field->hdr_offset = 12;
+				field->ltype_match = NPC_LT_LD_UDP_VXLAN;
+			}
+
+			if (key_type == NIX_FLOW_KEY_TYPE_GENEVE && valid_key) {
+				/* VNI at UDP header + 4B */
+				field->hdr_offset = 12;
+				field->ltype_match = NPC_LT_LD_UDP_GENEVE;
+			}
+
+			if (key_type == NIX_FLOW_KEY_TYPE_GENEVE)
+				keyoff_marker = true;
+			break;
+		case NIX_FLOW_KEY_TYPE_ETH_DMAC:
+			field->lid = NPC_LID_LA;
+			field->hdr_offset = 0;
+			field->bytesm1 = 5; /* DMAC 6 Byte */
+			field->ltype_match = NPC_LT_LA_ETHER;
+			field->ltype_mask = 0xF;
+			field_marker = true;
+			keyoff_marker = true;
+			break;
+		case NIX_FLOW_KEY_TYPE_IPV6_EXT:
+			field->lid = NPC_LID_LC;
+			field->hdr_offset = 40; /* IPV6 hdr */
+			field->bytesm1 = 0; /* 1 Byte ext hdr*/
+			field->ltype_match = NPC_LT_LC_IP6_EXT;
+			field->ltype_mask = 0xF;
+			field_marker = true;
+			keyoff_marker = true;
+			break;
 		}
 		field->ena = 1;
 
-- 
2.17.1

