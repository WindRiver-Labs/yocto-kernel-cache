From 8b5a9b7b2b5b203cf6eac4aaaa005c27acdaacf6 Mon Sep 17 00:00:00 2001
From: Sunil Goutham <sgoutham@marvell.com>
Date: Sat, 27 Jul 2019 13:34:47 +0530
Subject: [PATCH 115/138] octeontx2-af: Apply relevant HW issue workarounds for
 96xx B0 silicon

commit e88fa2dbb1efe907bc78802ed3870d3ef665a4d9 from
git@git.assembla.com:cavium/WindRiver.linux.git

Made changes to apply relevant workarounds for HW issues which
are present in 96xx B0 silicon. Also moved some silicon checks to
a common place to reduce clutter.

Change-Id: I09b7d3812c9a14c0a574ed4bb4bbbdf133323e2a
Signed-off-by: Sunil Goutham <sgoutham@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/13140
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Tested-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../net/ethernet/marvell/octeontx2/af/rvu.c   |  6 +-
 .../net/ethernet/marvell/octeontx2/af/rvu.h   | 17 ++++-
 .../ethernet/marvell/octeontx2/af/rvu_fixes.c | 73 ++++++++++++++++++-
 .../ethernet/marvell/octeontx2/af/rvu_npc.c   | 19 ++---
 .../ethernet/marvell/octeontx2/af/rvu_sso.c   |  2 +-
 .../ethernet/marvell/octeontx2/af/rvu_tim.c   | 21 ------
 6 files changed, 93 insertions(+), 45 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu.c
index 98df35195f50..fbb1d06fa3cd 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu.c
@@ -67,7 +67,7 @@ static void rvu_setup_hw_capabilities(struct rvu *rvu)
 	hw->cap.nix_shaping = true;
 	hw->cap.nix_tx_link_bp = true;
 
-	if (is_rvu_96xx_A0(rvu) || is_rvu_95xx_A0(rvu)) {
+	if (is_rvu_96xx_B0(rvu) || is_rvu_95xx_A0(rvu)) {
 		hw->cap.nix_fixed_txschq_mapping = true;
 		hw->cap.nix_txsch_per_cgx_lmac = 4;
 		hw->cap.nix_txsch_per_lbk_lmac = 132;
@@ -1049,8 +1049,8 @@ static int rvu_lookup_rsrc(struct rvu *rvu, struct rvu_block *block,
 {
 	u64 val;
 
-	if (block->type == BLKTYPE_TIM && is_rvu_96xx_A0(rvu))
-		return rvu_lf_lookup_tim_errata(rvu, block, pcifunc, slot);
+	if (block->type == BLKTYPE_TIM)
+		return rvu_tim_lookup_rsrc(rvu, block, pcifunc, slot);
 
 	val = ((u64)pcifunc << 24) | (slot << 16) | (1ULL << 13);
 	rvu_write64(rvu, block->addr, block->lookup_reg, val);
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu.h b/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
index e15f8bb311f9..ad0093e0a90f 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
@@ -474,6 +474,7 @@ static inline u64 rvupf_read64(struct rvu *rvu, u64 offset)
 	return readq(rvu->pfreg_base + offset);
 }
 
+/* Silicon revisions */
 static inline bool is_rvu_96xx_A0(struct rvu *rvu)
 {
 	struct pci_dev *pdev = rvu->pdev;
@@ -482,6 +483,14 @@ static inline bool is_rvu_96xx_A0(struct rvu *rvu)
 		(pdev->subsystem_device == PCI_SUBSYS_DEVID_96XX);
 }
 
+static inline bool is_rvu_96xx_B0(struct rvu *rvu)
+{
+	struct pci_dev *pdev = rvu->pdev;
+
+	return ((pdev->revision == 0x00) || (pdev->revision == 0x01)) &&
+		(pdev->subsystem_device == PCI_SUBSYS_DEVID_96XX);
+}
+
 static inline bool is_rvu_95xx_A0(struct rvu *rvu)
 {
 	struct pci_dev *pdev = rvu->pdev;
@@ -636,8 +645,6 @@ void rvu_cpt_unregister_interrupts(struct rvu *rvu);
 /* TIM APIs */
 int rvu_tim_init(struct rvu *rvu);
 int rvu_tim_lf_teardown(struct rvu *rvu, u16 pcifunc, int lf, int slot);
-int rvu_lf_lookup_tim_errata(struct rvu *rvu, struct rvu_block *block,
-		u16 pcifunc, int slot);
 
 /* CONFIG_DEBUG_FS*/
 #ifdef CONFIG_DEBUG_FS
@@ -649,6 +656,7 @@ static inline void rvu_dbg_exit(struct rvu *rvu) {}
 #endif /* CONFIG_DEBUG_FS*/
 
 /* HW workarounds/fixes */
+#include "npc.h"
 void rvu_nix_txsch_lock(struct nix_hw *nix_hw);
 void rvu_nix_txsch_unlock(struct nix_hw *nix_hw);
 void rvu_nix_update_link_credits(struct rvu *rvu, int blkaddr,
@@ -661,4 +669,9 @@ ssize_t rvu_nix_get_tx_stall_counters(struct rvu *rvu,
 				      char __user *buffer, loff_t *ppos);
 int rvu_nix_fixes_init(struct rvu *rvu, struct nix_hw *nix_hw, int blkaddr);
 void rvu_nix_fixes_exit(struct rvu *rvu, struct nix_hw *nix_hw);
+int rvu_tim_lookup_rsrc(struct rvu *rvu, struct rvu_block *block,
+			u16 pcifunc, int slot);
+int rvu_npc_get_tx_nibble_cfg(struct rvu *rvu, u64 nibble_ena);
+bool is_parse_nibble_config_valid(struct rvu *rvu,
+				  struct npc_mcam_kex *mcam_kex);
 #endif /* RVU_H */
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_fixes.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_fixes.c
index 36c747a45682..a27d7e5de5a0 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_fixes.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_fixes.c
@@ -898,19 +898,19 @@ int rvu_nix_fixes_init(struct rvu *rvu, struct nix_hw *nix_hw, int blkaddr)
 	int err;
 	u64 cfg;
 
-	if (!is_rvu_96xx_A0(rvu) && !is_rvu_95xx_A0(rvu))
+	if (!is_rvu_96xx_B0(rvu) && !is_rvu_95xx_A0(rvu))
 		return 0;
 
 	/* As per a HW errata in 96xx A0 silicon, NIX may corrupt
 	 * internal state when conditional clocks are turned off.
 	 * Hence enable them.
 	 */
-	if (is_rvu_95xx_A0(rvu))
+	if (is_rvu_96xx_A0(rvu))
 		rvu_write64(rvu, blkaddr, NIX_AF_CFG,
-			    rvu_read64(rvu, blkaddr, NIX_AF_CFG) | 0x40ULL);
+			    rvu_read64(rvu, blkaddr, NIX_AF_CFG) | 0x5EULL);
 	else
 		rvu_write64(rvu, blkaddr, NIX_AF_CFG,
-			    rvu_read64(rvu, blkaddr, NIX_AF_CFG) | 0x5EULL);
+			    rvu_read64(rvu, blkaddr, NIX_AF_CFG) | 0x40ULL);
 
 	/* Set chan/link to backpressure TL3 instead of TL2 */
 	rvu_write64(rvu, blkaddr, NIX_AF_PSE_CHANNEL_LEVEL, 0x01);
@@ -942,3 +942,68 @@ void rvu_nix_fixes_exit(struct rvu *rvu, struct nix_hw *nix_hw)
 
 	rvu_nix_tx_stall_workaround_exit(rvu, nix_hw);
 }
+
+int rvu_tim_lookup_rsrc(struct rvu *rvu, struct rvu_block *block,
+			u16 pcifunc, int slot)
+{
+	int lf, blkaddr;
+	u64 val;
+
+	/* Due to a HW issue LF_CFG_DEBUG register cannot be used to
+	 * find PF_FUNC <=> LF mapping, hence scan through LFX_CFG
+	 * registers to find mapped LF for a given PF_FUNC.
+	 */
+	if (is_rvu_96xx_B0(rvu)) {
+		blkaddr = rvu_get_blkaddr(rvu, BLKTYPE_TIM, pcifunc);
+		if (blkaddr < 0)
+			return TIM_AF_LF_INVALID;
+
+		for (lf = 0; lf < block->lf.max; lf++) {
+			val = rvu_read64(rvu, block->addr, block->lfcfg_reg |
+					 (lf << block->lfshift));
+			if ((((val >> 8) & 0xffff) == pcifunc) &&
+			    (val & 0xff) == slot)
+				return lf;
+		}
+		return -1;
+	}
+
+	val = ((u64)pcifunc << 24) | (slot << 16) | (1ULL << 13);
+	rvu_write64(rvu, block->addr, block->lookup_reg, val);
+
+	/* Wait for the lookup to finish */
+	while (rvu_read64(rvu, block->addr, block->lookup_reg) & (1ULL << 13))
+		;
+
+	val = rvu_read64(rvu, block->addr, block->lookup_reg);
+
+	/* Check LF valid bit */
+	if (!(val & (1ULL << 12)))
+		return -1;
+
+	return (val & 0xFFF);
+}
+
+int rvu_npc_get_tx_nibble_cfg(struct rvu *rvu, u64 nibble_ena)
+{
+	/* Due to a HW issue in these silicon versions, parse nibble enable
+	 * configuration has to be identical for both Rx and Tx interfaces.
+	 */
+	if (is_rvu_96xx_B0(rvu))
+		return nibble_ena;
+	return 0;
+}
+
+bool is_parse_nibble_config_valid(struct rvu *rvu,
+				  struct npc_mcam_kex *mcam_kex)
+{
+	if (!is_rvu_96xx_B0(rvu))
+		return true;
+
+	/* Due to a HW issue in above silicon versions, parse nibble enable
+	 * configuration has to be identical for both Rx and Tx interfaces.
+	 */
+	if (mcam_kex->keyx_cfg[NIX_INTF_RX] != mcam_kex->keyx_cfg[NIX_INTF_TX])
+		return false;
+	return true;
+}
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc.c
index adbb64286d41..2230f4a716fa 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc.c
@@ -1113,13 +1113,7 @@ static void npc_load_mkex_profile(struct rvu *rvu, int blkaddr)
 		/* Compare with mkex mod_param name string */
 		if (mcam_kex->mkex_sign == MKEX_SIGN &&
 		    !strncmp(mcam_kex->name, mkex_profile, MKEX_NAME_LEN)) {
-			/* Due to an errata (35786) in A0 pass silicon,
-			 * parse nibble enable configuration has to be
-			 * identical for both Rx and Tx interfaces.
-			 */
-			if (is_rvu_96xx_A0(rvu) &&
-			    mcam_kex->keyx_cfg[NIX_INTF_RX] !=
-			    mcam_kex->keyx_cfg[NIX_INTF_TX])
+			if (!is_parse_nibble_config_valid(rvu, mcam_kex))
 				goto load_default;
 
 			/* Program selected mkex profile */
@@ -1478,13 +1472,10 @@ int rvu_npc_init(struct rvu *rvu)
 	nibble_ena = 0x249207;
 	rvu_write64(rvu, blkaddr, NPC_AF_INTFX_KEX_CFG(NIX_INTF_RX),
 			((keyz & 0x3) << 32) | nibble_ena);
-	/* Due to an errata (35786) in A0 pass silicon, parse nibble enable
-	 * configuration has to be identical for both Rx and Tx interfaces.
-	 */
-	/* For A1 silicon onwards, no need to match the channel number for
-	 * Tx side, so match only Ltypes from LA...LE
-	 */
-	if (!is_rvu_96xx_A0(rvu))
+
+	/* Extract Ltypes LID_LA to LID_LE */
+	nibble_ena = rvu_npc_get_tx_nibble_cfg(rvu, nibble_ena);
+	if (!nibble_ena)
 		nibble_ena = 0x249200;
 	rvu_write64(rvu, blkaddr, NPC_AF_INTFX_KEX_CFG(NIX_INTF_TX),
 			((keyz & 0x3) << 32) | nibble_ena);
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_sso.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_sso.c
index b68137f015b2..663fb2ce2865 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_sso.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_sso.c
@@ -377,7 +377,7 @@ int rvu_sso_lf_teardown(struct rvu *rvu, u16 pcifunc, int lf, int slot)
 	 * TAQ buffer used by HWGRP when HWGRP is reset. Use SW routine to
 	 * drain it manually.
 	 */
-	if (is_rvu_96xx_A0(rvu))
+	if (is_rvu_96xx_B0(rvu))
 		rvu_sso_ggrp_taq_flush(rvu, pcifunc, lf, slot, ssow_lf, blkaddr,
 				       ssow_blkaddr);
 
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_tim.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_tim.c
index 3f07334c49b2..5c7e219c6656 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_tim.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_tim.c
@@ -58,27 +58,6 @@ static int rvu_tim_disable_lf(struct rvu *rvu, int lf, int blkaddr)
 	return 0;
 }
 
-int rvu_lf_lookup_tim_errata(struct rvu *rvu, struct rvu_block *block,
-		u16 pcifunc, int slot)
-{
-	int i, blkaddr;
-	u64 val;
-
-	blkaddr = rvu_get_blkaddr(rvu, BLKTYPE_TIM, pcifunc);
-	if (blkaddr < 0)
-		return TIM_AF_LF_INVALID;
-
-	for (i = 0; i < block->lf.max; i++) {
-		val = rvu_read64(rvu, block->addr, block->lfcfg_reg |
-				 (i << block->lfshift));
-		if ((((val >> 8) & 0xffff) == pcifunc) &&
-				(val & 0xff) == slot)
-			return i;
-	}
-
-	return -1;
-}
-
 int rvu_mbox_handler_tim_lf_alloc(struct rvu *rvu,
 				  struct tim_lf_alloc_req *req,
 				  struct tim_lf_alloc_rsp *rsp)
-- 
2.17.1

