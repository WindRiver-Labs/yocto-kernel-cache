From 573b33b75773a58058c1404a3063b0e60ea4fad2 Mon Sep 17 00:00:00 2001
From: Peter Swain <pswain@marvell.com>
Date: Tue, 7 May 2019 12:06:35 -0700
Subject: [PATCH 065/138] mmc: cavium: track & apply CMD6 bus changes ASAP

commit 1ce65aea41b1927324e2e0c717b2d9d0aa685da3 from
git@git.assembla.com:cavium/WindRiver.linux.git

When mmc/core issued CMD6 to change bus width, timing
and encoding style, we must apply the change to our
hardware immediately.
Previous code applied it eventually, but meanwhile
mmc/core code had been polling status with CMD13
under the old protocol, which may have been causing
HS400 transitions to fail.

To apply the change immediately, at IRQ-time, the host
pointer is set on every outgoing request, so IRQ handler
can find context (the associated cvm_mmc_slot) for a
successfully executed CMD6, and the MIO_EMM_SWITCH value
it should apply, to bring the host hardware & target card
into alignment.

CMD6 can potentially set/clear individual bits of ext_csd,
which would require caching the ext_csd entries for the 3
bytes we track, to reconstruct the meaning.
But fortunately mmc/core only issues a full-byte assignment
(action=3) for the power/width/timing properties we mirror.
Should this change, more work may be needed here.

Change-Id: I13df44e96d61a071b73f1d3f014ff0276ba51135
Signed-off-by: Peter Swain <pswain@marvell.com>
Signed-off-by: Sujeet Baranwal <sbaranwal@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/8546
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Tested-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/mmc/host/cavium.c | 82 ++++++++++++++++++++++++++++++++++-----
 drivers/mmc/host/cavium.h |  9 ++++-
 2 files changed, 80 insertions(+), 11 deletions(-)

diff --git a/drivers/mmc/host/cavium.c b/drivers/mmc/host/cavium.c
index 37a26230be5a..9c1dfce78609 100644
--- a/drivers/mmc/host/cavium.c
+++ b/drivers/mmc/host/cavium.c
@@ -299,7 +299,8 @@ static void do_switch(struct cvm_mmc_host *host, u64 emm_switch)
 {
 	int retries = 100;
 	u64 rsp_sts;
-	int bus_id;
+	int bus_id = get_bus_id(emm_switch);
+	struct cvm_mmc_slot *slot = host->slot[bus_id];
 
 	/*
 	 * Modes setting only taken from slot 0. Work around that hardware
@@ -321,6 +322,11 @@ static void do_switch(struct cvm_mmc_host *host, u64 emm_switch)
 	} while (--retries);
 
 	check_switch_errors(host);
+
+	if (slot) {
+		slot->cmd6_pending = false;
+		slot->cached_switch = emm_switch;
+	}
 }
 
 /* need to change hardware state to match software requirements? */
@@ -374,14 +380,11 @@ static void cvm_mmc_reset_bus(struct cvm_mmc_slot *slot)
 	u64 emm_switch, wdog;
 
 	emm_switch = readq(host->base + MIO_EMM_SWITCH(host));
-	emm_switch &= ~(MIO_EMM_SWITCH_EXE | MIO_EMM_SWITCH_ERR0 |
-			MIO_EMM_SWITCH_ERR1 | MIO_EMM_SWITCH_ERR2);
+	emm_switch &= ~(MIO_EMM_SWITCH_EXE | MIO_EMM_SWITCH_ERRS);
 	set_bus_id(&emm_switch, slot->bus_id);
 
 	wdog = readq(host->base + MIO_EMM_WDOG(host));
 	do_switch(host, emm_switch);
-
-	slot->cached_switch = emm_switch;
 	host->powered = true;
 
 	msleep(20);
@@ -561,15 +564,23 @@ irqreturn_t cvm_mmc_interrupt(int irq, void *dev_id)
 {
 	struct cvm_mmc_host *host = dev_id;
 	struct mmc_request *req;
+	struct cvm_mmc_slot *slot;
 	unsigned long flags = 0;
 	u64 emm_int, rsp_sts;
 	bool host_done;
+	int bus_id;
 
 	if (host->need_irq_handler_lock)
 		spin_lock_irqsave(&host->irq_handler_lock, flags);
 	else
 		__acquire(&host->irq_handler_lock);
 
+	rsp_sts = readq(host->base + MIO_EMM_RSP_STS(host));
+	bus_id = get_bus_id(rsp_sts);
+	slot = host->slot[bus_id];
+	if (slot)
+		req = slot->current_req;
+
 	/* Clear interrupt bits (write 1 clears ). */
 	emm_int = readq(host->base + MIO_EMM_INT(host));
 	writeq(emm_int, host->base + MIO_EMM_INT(host));
@@ -581,8 +592,6 @@ irqreturn_t cvm_mmc_interrupt(int irq, void *dev_id)
 	if (!req)
 		goto out;
 
-	rsp_sts = readq(host->base + MIO_EMM_RSP_STS(host));
-
 	/*
 	 * dma_pend means DMA has stalled with CRC errs.
 	 * start teardown, get irq on completion, mmc stack retries.
@@ -633,6 +642,14 @@ irqreturn_t cvm_mmc_interrupt(int irq, void *dev_id)
 	    (rsp_sts & MIO_EMM_RSP_STS_DMA_PEND))
 		cleanup_dma(host, rsp_sts);
 
+	/* follow CMD6 timing/width with IMMEDIATE switch */
+	if (slot && slot->cmd6_pending) {
+		if (host_done && !req->cmd->error)
+			do_switch(host, slot->want_switch);
+		else if (slot)
+			slot->cmd6_pending = false;
+	}
+
 	host->current_req = NULL;
 	req->done(req);
 
@@ -909,6 +926,51 @@ static void do_write_request(struct cvm_mmc_host *host, struct mmc_request *mrq)
 	sg_miter_stop(smi);
 }
 
+static void cvm_mmc_track_switch(struct cvm_mmc_slot *slot, u32 cmd_arg)
+{
+	u8 how = (cmd_arg >> 24) & 3;
+	u8 where = (u8)(cmd_arg >> 16);
+	u8 val = (u8)(cmd_arg >> 8);
+
+	slot->want_switch = slot->cached_switch;
+
+	/*
+	 * track ext_csd assignments (how==3) for critical entries
+	 * to make sure we follow up with MIO_EMM_SWITCH adjustment
+	 * before ANY mmc/core interaction at old settings.
+	 * Current mmc/core logic (linux 4.14) does not set/clear
+	 * bits (how = 1 or 2), which would require more complex
+	 * logic to track the intent of a change
+	 */
+
+	if (how != 3)
+		return;
+
+	switch (where) {
+	case EXT_CSD_BUS_WIDTH:
+		slot->want_switch &= ~MIO_EMM_SWITCH_BUS_WIDTH;
+		slot->want_switch |=
+			FIELD_PREP(MIO_EMM_SWITCH_BUS_WIDTH, val);
+		break;
+	case EXT_CSD_POWER_CLASS:
+		slot->want_switch &= ~MIO_EMM_SWITCH_POWER_CLASS;
+		slot->want_switch |=
+			FIELD_PREP(MIO_EMM_SWITCH_POWER_CLASS, val);
+		break;
+	case EXT_CSD_HS_TIMING:
+		slot->want_switch &= ~MIO_EMM_SWITCH_TIMING;
+		if (val)
+			slot->want_switch |=
+				FIELD_PREP(MIO_EMM_SWITCH_TIMING,
+					(1 << (val - 1)));
+		break;
+	default:
+		return;
+	}
+
+	slot->cmd6_pending = true;
+}
+
 static void cvm_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq)
 {
 	struct cvm_mmc_slot *slot = mmc_priv(mmc);
@@ -939,6 +1001,7 @@ static void cvm_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq)
 
 	WARN_ON(host->current_req);
 	host->current_req = mrq;
+	mrq->host = mmc;
 
 	if (cmd->data) {
 		if (cmd->data->flags & MMC_DATA_READ)
@@ -954,6 +1017,9 @@ static void cvm_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq)
 	host->dma_active = false;
 	host->int_enable(host, MIO_EMM_INT_CMD_DONE | MIO_EMM_INT_CMD_ERR);
 
+	if (cmd->opcode == MMC_SWITCH)
+		cvm_mmc_track_switch(slot, cmd->arg);
+
 	emm_cmd = FIELD_PREP(MIO_EMM_CMD_VAL, 1) |
 		  FIELD_PREP(MIO_EMM_CMD_CTYPE_XOR, mods.ctype_xor) |
 		  FIELD_PREP(MIO_EMM_CMD_RTYPE_XOR, mods.rtype_xor) |
@@ -1159,8 +1225,6 @@ static int cvm_mmc_init_lowlevel(struct cvm_mmc_slot *slot)
 	/* Make the changes take effect on this bus slot. */
 	set_bus_id(&emm_switch, slot->bus_id);
 	do_switch(host, emm_switch);
-
-	slot->cached_switch = emm_switch;
 	host->powered = true;
 
 	/*
diff --git a/drivers/mmc/host/cavium.h b/drivers/mmc/host/cavium.h
index 707234eb4935..b20b9fca1595 100644
--- a/drivers/mmc/host/cavium.h
+++ b/drivers/mmc/host/cavium.h
@@ -139,6 +139,7 @@ struct cvm_mmc_host {
 struct cvm_mmc_slot {
 	struct mmc_host *mmc;		/* slot-level mmc_core object */
 	struct cvm_mmc_host *host;	/* common hw for all slots */
+	struct mmc_request *current_req;
 
 	u64 clock;
 
@@ -153,6 +154,8 @@ struct cvm_mmc_slot {
 	int slew;			/* clock skew */
 
 	int bus_id;
+	bool cmd6_pending;
+	u64 want_switch;
 };
 
 struct cvm_mmc_cr_type {
@@ -264,9 +267,11 @@ struct cvm_mmc_cr_mods {
 #define MIO_EMM_SWITCH_ERR0		BIT_ULL(58)
 #define MIO_EMM_SWITCH_ERR1		BIT_ULL(57)
 #define MIO_EMM_SWITCH_ERR2		BIT_ULL(56)
-#define MIO_EMM_SWITCH_HS_TIMING	BIT_ULL(48)
-#define MIO_EMM_SWITCH_HS200_TIMING	BIT_ULL(49)
+#define MIO_EMM_SWITCH_ERRS		GENMASK_ULL(58, 56)
 #define MIO_EMM_SWITCH_HS400_TIMING	BIT_ULL(50)
+#define MIO_EMM_SWITCH_HS200_TIMING	BIT_ULL(49)
+#define MIO_EMM_SWITCH_HS_TIMING	BIT_ULL(48)
+#define MIO_EMM_SWITCH_TIMING		GENMASK_ULL(50, 48)
 #define MIO_EMM_SWITCH_BUS_WIDTH	GENMASK_ULL(42, 40)
 #define MIO_EMM_SWITCH_POWER_CLASS	GENMASK_ULL(35, 32)
 #define MIO_EMM_SWITCH_CLK_HI		GENMASK_ULL(31, 16)
-- 
2.17.1

