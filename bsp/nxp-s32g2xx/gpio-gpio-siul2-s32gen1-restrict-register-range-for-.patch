From e703a353529e8392f75d1ac20ee70b8d6229313e Mon Sep 17 00:00:00 2001
From: Xulin Sun <xulin.sun@windriver.com>
Date: Tue, 7 Apr 2020 15:03:44 +0800
Subject: [PATCH 1/3] gpio: gpio-siul2-s32gen1: restrict register range for
 regmap access

SIUL registers are NOT continuous, some registers are
reserved and accessing them from userspace will trigger
external abort, usually we should add regmap register access table to
avoid below abort, however the SIUL module shares the syscon_regmap_config
of the mfd/syscon with other IPAD regmaps. So to avoid below call trace
and not destroy current software framework, register a call function
for readable_reg and reinit regmap_config.

CPU: 2 PID: 18231 Comm: read_all Not tainted 5.2.33-yocto-standard #1
Hardware name: Freescale S32G275 (DT)
pstate: 20000085 (nzCv daIf -PAN -UAO)
pc : regmap_mmio_read32le+0x24/0x48
lr : regmap_mmio_read+0x48/0x70
sp : ffffff801123bb70
x29: ffffff801123bb70 x28: ffffffc873b5c000
x27: ffffff8010b408f0 x26: 0000000000000001
x25: 000000000000013c x24: ffffff801123be40
x23: 00000000000003ff x22: ffffff801123bcfc
x21: ffffff801123bcfc x20: ffffffc873a9e500
x19: 0000000000000024 x18: 0000000000000020
x17: 0000000000000000 x16: 0000000000000000
x15: ffffffc876189160 x14: 0000000000000003
x13: ffffffc873bf73ff x12: ffffffc873bf707e
x11: 0000000000000000 x10: 0000000000000000
x9 : 0000000000000000 x8 : ffffffc83fca4e00
x7 : 000000000000000f x6 : ffffffc873bf7083
x5 : 00000000fffffff9 x4 : 0000000000000002
x3 : ffffff801061f058 x2 : ffffff801061ee18
x1 : 0000000000000024 x0 : ffffff8011490024
Call trace:
regmap_mmio_read32le+0x24/0x48
regmap_mmio_read+0x48/0x70
_regmap_bus_reg_read+0x38/0x48
_regmap_read+0x68/0x1b0
regmap_read+0x50/0x78
regmap_read_debugfs+0x120/0x338
regmap_map_read_file+0x44/0x58
full_proxy_read+0x68/0x98
__vfs_read+0x48/0x90
vfs_read+0xb0/0x130
ksys_read+0x7c/0x108
__arm64_sys_read+0x24/0x30
el0_svc_common.constprop.0+0x74/0x168
el0_svc_handler+0x70/0x90
el0_svc+0x8/0xc

Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/gpio/gpio-siul2-s32gen1.c | 42 +++++++++++++++++++++++++++++++
 1 file changed, 42 insertions(+)

diff --git a/drivers/gpio/gpio-siul2-s32gen1.c b/drivers/gpio/gpio-siul2-s32gen1.c
index eeea536e62e5..265a71ae3d4e 100644
--- a/drivers/gpio/gpio-siul2-s32gen1.c
+++ b/drivers/gpio/gpio-siul2-s32gen1.c
@@ -33,6 +33,10 @@
 #include <linux/regmap.h>
 #include <linux/mfd/syscon.h>
 
+/* SIUL2 MCU ID Register 1 */
+#define SIUL2_MIDR1			0x4
+/* SIUL2 MCU ID Register 2 */
+#define SIUL2_MIDR2			0x8
 /* DMA/Interrupt Status Flag Register */
 #define SIUL2_DISR0			0x10
 /* DMA/Interrupt Request Enable Register */
@@ -43,6 +47,8 @@
 #define SIUL2_IREER0			0x28
 /* Interrupt Falling-Edge Event Enable Register */
 #define SIUL2_IFEER0			0x30
+/* Interrupt Filter Enable Register 0 */
+#define SIUL2_IFER0			0x38
 
 /* Device tree ranges */
 #define SIUL2_GPIO_OUTPUT_RANGE		0
@@ -331,6 +337,28 @@ static struct irq_chip siul2_gpio_irq_chip = {
 	.irq_set_type		= siul2_gpio_irq_set_type,
 };
 
+static bool siul2_readable_register(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case SIUL2_MIDR1:
+	case SIUL2_MIDR2:
+	case SIUL2_DISR0:
+	case SIUL2_DIRER0:
+	case SIUL2_DIRSR0:
+	case SIUL2_IREER0:
+	case SIUL2_IFEER0:
+	case SIUL2_IFER0:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static struct regmap_config siul2_regmap_config = {
+	.readable_reg = siul2_readable_register,
+	.max_register = SIUL2_IFER0,
+};
+
 static int siul2_irq_setup(struct platform_device *pdev,
 			  struct siul2_gpio_dev *gpio_dev)
 {
@@ -340,6 +368,8 @@ static int siul2_irq_setup(struct platform_device *pdev,
 	struct of_phandle_args pinspec;
 	int irq;
 	unsigned long flags;
+	struct device_node *irq_np;
+
 	/*
 	 * Allow multiple instances of the gpio driver to only
 	 * initialize the irq control registers only once.
@@ -358,6 +388,18 @@ static int siul2_irq_setup(struct platform_device *pdev,
 	if (IS_ERR(gpio_dev->irqmap))
 		return PTR_ERR(gpio_dev->irqmap);
 
+	irq_np = of_parse_phandle(pdev->dev.of_node, "regmap2", 0);
+	if (!irq_np)
+		return 0;
+	siul2_regmap_config.name = of_node_full_name(irq_np);
+
+	err = regmap_reinit_cache(gpio_dev->irqmap, &siul2_regmap_config);
+	if (err) {
+		dev_err(&pdev->dev, "failed to regmap reinit cache.\n");
+		ret = err;
+		goto irq_setup_err;
+	}
+
 	/* EIRQ pins */
 	err = siul2_get_gpio_pinspec(pdev, &pinspec, 1);
 	if (err) {
-- 
2.17.1

