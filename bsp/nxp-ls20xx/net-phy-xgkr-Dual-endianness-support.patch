From 970b72352790094661cbfa636c252a4ce6a05afb Mon Sep 17 00:00:00 2001
From: Florinel Iordache <florinel.iordache@nxp.com>
Date: Mon, 29 Oct 2018 13:16:01 +0200
Subject: [PATCH 747/767] net/phy: xgkr: Dual endianness support

Added support for Serdes dual endianness. Serdes endianness is defined in DTS serdes node

Signed-off-by: Florinel Iordache <florinel.iordache@nxp.com>
[Xulin: Original patch taken from NXP LSDK-18.12.]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/net/phy/fsl_backplane.c            |  75 +++++---
 drivers/net/phy/fsl_backplane.h            |   9 +-
 drivers/net/phy/fsl_backplane_serdes_10g.c |  96 ++++++-----
 drivers/net/phy/fsl_backplane_serdes_28g.c | 190 +++++++++++----------
 4 files changed, 209 insertions(+), 161 deletions(-)

diff --git a/drivers/net/phy/fsl_backplane.c b/drivers/net/phy/fsl_backplane.c
index 3ad4ea0676a9..46da9084a008 100644
--- a/drivers/net/phy/fsl_backplane.c
+++ b/drivers/net/phy/fsl_backplane.c
@@ -205,7 +205,7 @@ struct xgkr_params {
 	void *reg_base;		/* lane memory map: registers base address */
 	int idx;			/* lane relative index inside a multi-lane PHY */
 	struct phy_device *phydev;
-	struct backplane_serdes bckpl_sd;
+	struct serdes_access *srds;
 	struct tx_condition tx_c;
 	struct delayed_work xgkr_wk;
 	enum train_state state;
@@ -258,6 +258,26 @@ static void setup_an_lt_lx(void)
 	g_an_BP_STAT = 0x0F;
 }
 
+static u32 le_ioread32(u32 *reg)
+{
+	return ioread32(reg);
+}
+
+static void le_iowrite32(u32 value, u32 *reg)
+{
+	iowrite32(value, reg);
+}
+
+static u32 be_ioread32(u32 *reg)
+{
+	return ioread32be(reg);
+}
+
+static void be_iowrite32(u32 value, u32 *reg)
+{
+	iowrite32be(value, reg);
+}
+
 /**
  * xgkr_phy_write_mmd - Wrapper function for phy_write_mmd
  * for writing a register on an MMD on a given PHY.
@@ -353,7 +373,7 @@ void tune_tecr(struct xgkr_params *xgkr)
 		reset = true;
 	}
 	
-	xgkr->bckpl_sd.tune_tecr(xgkr->reg_base, xgkr->ratio_preq, xgkr->ratio_pst1q, xgkr->adpt_eq, reset);
+	xgkr->srds->tune_tecr(xgkr->reg_base, xgkr->ratio_preq, xgkr->ratio_pst1q, xgkr->adpt_eq, reset);
 }
 
 static void start_lt(struct xgkr_params *xgkr)
@@ -674,7 +694,7 @@ static void train_tx(struct xgkr_params *xgkr)
 		}
 
 		if (status_cop1 != COE_MAX) {
-			median_gaink2 = xgkr->bckpl_sd.get_median_gaink2(xgkr->reg_base);
+			median_gaink2 = xgkr->srds->get_median_gaink2(xgkr->reg_base);
 			if (median_gaink2 == 0xf) {
 				tx_c->post_inc = 1;
 			} else {
@@ -699,8 +719,8 @@ static void train_tx(struct xgkr_params *xgkr)
 #endif
 
 	/* snapshot and select bin */
-	bin_m1_early = xgkr->bckpl_sd.is_bin_early(BIN_M1, xgkr->reg_base);
-	bin_long_early = xgkr->bckpl_sd.is_bin_early(BIN_LONG, xgkr->reg_base);
+	bin_m1_early = xgkr->srds->is_bin_early(BIN_M1, xgkr->reg_base);
+	bin_long_early = xgkr->srds->is_bin_early(BIN_LONG, xgkr->reg_base);
 
 	if (!tx_c->bin_m1_stop && !tx_c->bin_m1_late_early && bin_m1_early) {
 		tx_c->bin_m1_stop = true;
@@ -1104,9 +1124,9 @@ static void xgkr_start_train(struct xgkr_params *xgkr)
 				if (xgkr_inst->bp_mode == PHY_BACKPLANE_40GBASE_KR) {
 					/* Reset only the Master Lane */
 					if (xgkr->idx == MASTER_LANE)
-						xgkr->bckpl_sd.reset_lane(xgkr->reg_base);
+						xgkr->srds->reset_lane(xgkr->reg_base);
 				} else {
-					xgkr->bckpl_sd.reset_lane(xgkr->reg_base);
+					xgkr->srds->reset_lane(xgkr->reg_base);
 				}
 				
 				start_lt(xgkr);
@@ -1139,9 +1159,9 @@ static void xgkr_start_train(struct xgkr_params *xgkr)
 				if (xgkr_inst->bp_mode == PHY_BACKPLANE_40GBASE_KR) {
 					/* Reset only the Master Lane */
 					if (xgkr->idx == MASTER_LANE)
-						xgkr->bckpl_sd.reset_lane(xgkr->reg_base);
+						xgkr->srds->reset_lane(xgkr->reg_base);
 				} else {
-					xgkr->bckpl_sd.reset_lane(xgkr->reg_base);
+					xgkr->srds->reset_lane(xgkr->reg_base);
 				}
 				
 				break;
@@ -1371,7 +1391,8 @@ static int fsl_backplane_probe(struct phy_device *phydev)
 	struct xgkr_phy_data *xgkr_inst;
 	struct device_node *phy_node, *lane_node;
 	struct resource res_lane;
-	struct backplane_serdes bckpl_sd;
+	struct serdes_access *srds = NULL;
+	int serdes_type;
 	const char *st;
 	const char *bm;
 	int ret, i, phy_lanes;
@@ -1410,12 +1431,12 @@ static int fsl_backplane_probe(struct phy_device *phydev)
 	ret = of_property_read_string(lane_node, "compatible", &st);
 	if (ret < 0) {
 		//assume SERDES-10G if compatible property is not specified
-		bckpl_sd.serdes_type = SERDES_10G;
+		serdes_type = SERDES_10G;
 	}
 	else if (!strcasecmp(st, "fsl,serdes-10g")) {
-		bckpl_sd.serdes_type = SERDES_10G;
+		serdes_type = SERDES_10G;
 	} else if (!strcasecmp(st, "fsl,serdes-28g")) {
-		bckpl_sd.serdes_type = SERDES_28G;
+		serdes_type = SERDES_28G;
 	} else {
 		dev_err(&phydev->mdio.dev, "Unknown serdes-type\n");
 		return -EINVAL;
@@ -1435,16 +1456,16 @@ static int fsl_backplane_probe(struct phy_device *phydev)
 		return -EINVAL;
 	}
 
-	switch (bckpl_sd.serdes_type)
+	switch (serdes_type)
 	{
 	case SERDES_10G:
 		setup_an_lt_ls();
-		setup_backplane_serdes_10g(&bckpl_sd);
+		srds = setup_serdes_access_10g();
 		break;
 
 	case SERDES_28G:
 		setup_an_lt_lx();
-		setup_backplane_serdes_28g(&bckpl_sd);
+		srds = setup_serdes_access_28g();
 		break;
 
 	default:
@@ -1452,6 +1473,22 @@ static int fsl_backplane_probe(struct phy_device *phydev)
 		return -EINVAL;
 	}
 
+	if (!srds) {
+		dev_err(&phydev->mdio.dev, "Unsupported serdes-type\n");
+		return -EINVAL;
+	}
+
+	srds->serdes_type = serdes_type;
+	srds->is_little_endian = of_property_read_bool(lane_node, "little-endian");
+
+	if (srds->is_little_endian) {
+		srds->ioread32 = le_ioread32;
+		srds->iowrite32 = le_iowrite32;
+	} else {
+		srds->ioread32 = be_ioread32;
+		srds->iowrite32 = be_iowrite32;
+	}
+
 	xgkr_inst = devm_kzalloc(&phydev->mdio.dev,
 				 sizeof(*xgkr_inst), GFP_KERNEL);
 	if (!xgkr_inst)
@@ -1461,12 +1498,12 @@ static int fsl_backplane_probe(struct phy_device *phydev)
 	xgkr_inst->bp_mode = bp_mode;
 	mutex_init(&xgkr_inst->phy_lock);
 
-	lane_memmap_size = bckpl_sd.get_lane_memmap_size();
+	lane_memmap_size = srds->get_lane_memmap_size();
 	
 	for (i = 0; i < phy_lanes; i++) {
 		xgkr_inst->xgkr[i].idx = i;
 		xgkr_inst->xgkr[i].phydev = phydev;
-		xgkr_inst->xgkr[i].bckpl_sd = bckpl_sd;
+		xgkr_inst->xgkr[i].srds = srds;
 		xgkr_inst->xgkr[i].reg_base = devm_ioremap_nocache(&phydev->mdio.dev,
 						    res_lane.start + lane_base_addr[i],
 						    lane_memmap_size);
@@ -1484,7 +1521,7 @@ static int fsl_backplane_probe(struct phy_device *phydev)
 	case PHY_BACKPLANE_1000BASE_KX:
 		phydev->speed = SPEED_1000;
 		/* configure the lane for 1000BASE-KX */
-		bckpl_sd.lane_set_1gkx(xgkr_inst->xgkr[SINGLE_LANE].reg_base);
+		srds->lane_set_1gkx(xgkr_inst->xgkr[SINGLE_LANE].reg_base);
 		break;
 
 	case PHY_BACKPLANE_10GBASE_KR:
diff --git a/drivers/net/phy/fsl_backplane.h b/drivers/net/phy/fsl_backplane.h
index 4d17ac1c53a5..8c50586f3959 100644
--- a/drivers/net/phy/fsl_backplane.h
+++ b/drivers/net/phy/fsl_backplane.h
@@ -20,9 +20,12 @@
 #define BIN_M1_THRESHOLD			3
 #define BIN_LONG_THRESHOLD			2
 
-struct backplane_serdes {
+struct serdes_access {
 
 	int serdes_type;
+	bool is_little_endian;
+	u32 (*ioread32)(u32 *reg);
+	void (*iowrite32)(u32 value, u32 *reg);
 	u32 (*get_lane_memmap_size)(void);
 	void (*tune_tecr)(void *reg, u32 ratio_preq, u32 ratio_pst1q, u32 adpt_eq, bool reset);
 	void (*reset_lane)(void *reg);
@@ -31,8 +34,8 @@ struct backplane_serdes {
 	bool (*is_bin_early)(int bin_sel, void *reg);
 };
 
-void setup_backplane_serdes_10g(struct backplane_serdes *bckpl_serdes);
-void setup_backplane_serdes_28g(struct backplane_serdes *bckpl_serdes);
+struct serdes_access* setup_serdes_access_10g(void);
+struct serdes_access* setup_serdes_access_28g(void);
 
 
 #endif //FSL_BACKPLANE_H
diff --git a/drivers/net/phy/fsl_backplane_serdes_10g.c b/drivers/net/phy/fsl_backplane_serdes_10g.c
index ff652a0a1ba5..2d19d881faf0 100644
--- a/drivers/net/phy/fsl_backplane_serdes_10g.c
+++ b/drivers/net/phy/fsl_backplane_serdes_10g.c
@@ -44,24 +44,26 @@
 #define TECR0_AMP_RED_MASK			0x0000003f
 
 struct per_lane_ctrl_status {
-	__be32 gcr0;	/* 0x.000 - General Control Register 0 */
-	__be32 gcr1;	/* 0x.004 - General Control Register 1 */
-	__be32 gcr2;	/* 0x.008 - General Control Register 2 */
-	__be32 resv1;	/* 0x.00C - Reserved */
-	__be32 recr0;	/* 0x.010 - Receive Equalization Control Register 0 */
-	__be32 recr1;	/* 0x.014 - Receive Equalization Control Register 1 */
-	__be32 tecr0;	/* 0x.018 - Transmit Equalization Control Register 0 */
-	__be32 resv2;	/* 0x.01C - Reserved */
-	__be32 tlcr0;	/* 0x.020 - TTL Control Register 0 */
-	__be32 tlcr1;	/* 0x.024 - TTL Control Register 1 */
-	__be32 tlcr2;	/* 0x.028 - TTL Control Register 2 */
-	__be32 tlcr3;	/* 0x.02C - TTL Control Register 3 */
-	__be32 tcsr0;	/* 0x.030 - Test Control/Status Register 0 */
-	__be32 tcsr1;	/* 0x.034 - Test Control/Status Register 1 */
-	__be32 tcsr2;	/* 0x.038 - Test Control/Status Register 2 */
-	__be32 tcsr3;	/* 0x.03C - Test Control/Status Register 3 */
+	u32 gcr0;	/* 0x.000 - General Control Register 0 */
+	u32 gcr1;	/* 0x.004 - General Control Register 1 */
+	u32 gcr2;	/* 0x.008 - General Control Register 2 */
+	u32 resv1;	/* 0x.00C - Reserved */
+	u32 recr0;	/* 0x.010 - Receive Equalization Control Register 0 */
+	u32 recr1;	/* 0x.014 - Receive Equalization Control Register 1 */
+	u32 tecr0;	/* 0x.018 - Transmit Equalization Control Register 0 */
+	u32 resv2;	/* 0x.01C - Reserved */
+	u32 tlcr0;	/* 0x.020 - TTL Control Register 0 */
+	u32 tlcr1;	/* 0x.024 - TTL Control Register 1 */
+	u32 tlcr2;	/* 0x.028 - TTL Control Register 2 */
+	u32 tlcr3;	/* 0x.02C - TTL Control Register 3 */
+	u32 tcsr0;	/* 0x.030 - Test Control/Status Register 0 */
+	u32 tcsr1;	/* 0x.034 - Test Control/Status Register 1 */
+	u32 tcsr2;	/* 0x.038 - Test Control/Status Register 2 */
+	u32 tcsr3;	/* 0x.03C - Test Control/Status Register 3 */
 };
 
+static struct serdes_access srds;
+
 static u32 get_lane_memmap_size(void)
 {
 	return 0x40;
@@ -72,12 +74,12 @@ static void reset_lane(void *reg)
 	struct per_lane_ctrl_status *reg_base = reg;
 
 	/* reset the lane */
-	iowrite32(ioread32(&reg_base->gcr0) & ~GCR0_RESET_MASK,
+	srds.iowrite32(srds.ioread32(&reg_base->gcr0) & ~GCR0_RESET_MASK,
 		    &reg_base->gcr0);
 	udelay(1);
 	
 	/* unreset the lane */
-	iowrite32(ioread32(&reg_base->gcr0) | GCR0_RESET_MASK,
+	srds.iowrite32(srds.ioread32(&reg_base->gcr0) | GCR0_RESET_MASK,
 		    &reg_base->gcr0);
 	udelay(1);
 }
@@ -94,17 +96,17 @@ static void tune_tecr(void *reg, u32 ratio_preq, u32 ratio_pst1q, u32 adpt_eq, b
 
 	if (reset) {
 		/* reset the lane */
-		iowrite32(ioread32(&reg_base->gcr0) & ~GCR0_RESET_MASK,
+		srds.iowrite32(srds.ioread32(&reg_base->gcr0) & ~GCR0_RESET_MASK,
 				&reg_base->gcr0);
 		udelay(1);
 	}
 	
-	iowrite32(val, &reg_base->tecr0);
+	srds.iowrite32(val, &reg_base->tecr0);
 	udelay(1);
 	
 	if (reset) {
 		/* unreset the lane */
-		iowrite32(ioread32(&reg_base->gcr0) | GCR0_RESET_MASK,
+		srds.iowrite32(srds.ioread32(&reg_base->gcr0) | GCR0_RESET_MASK,
 				&reg_base->gcr0);
 		udelay(1);
 	}
@@ -116,25 +118,25 @@ static void lane_set_1gkx(void *reg)
 	u32 val;
 
 	/* reset the lane */
-	iowrite32(ioread32(&reg_base->gcr0) & ~GCR0_RESET_MASK,
+	srds.iowrite32(srds.ioread32(&reg_base->gcr0) & ~GCR0_RESET_MASK,
 		    &reg_base->gcr0);
 	udelay(1);
 
 	/* set gcr1 for 1GKX */
-	val = ioread32(&reg_base->gcr1);
+	val = srds.ioread32(&reg_base->gcr1);
 	val &= ~(GCR1_REIDL_TH_MASK | GCR1_REIDL_EX_SEL_MASK |
 		 GCR1_REIDL_ET_MAS_MASK);
-	iowrite32(val, &reg_base->gcr1);
+	srds.iowrite32(val, &reg_base->gcr1);
 	udelay(1);
 
 	/* set tecr0 for 1GKX */
-	val = ioread32(&reg_base->tecr0);
+	val = srds.ioread32(&reg_base->tecr0);
 	val &= ~TECR0_AMP_RED_MASK;
-	iowrite32(val, &reg_base->tecr0);
+	srds.iowrite32(val, &reg_base->tecr0);
 	udelay(1);
 
 	/* unreset the lane */
-	iowrite32(ioread32(&reg_base->gcr0) | GCR0_RESET_MASK,
+	srds.iowrite32(srds.ioread32(&reg_base->gcr0) | GCR0_RESET_MASK,
 		    &reg_base->gcr0);
 	udelay(1);
 }
@@ -152,7 +154,7 @@ static int get_median_gaink2(u32 *reg)
 	for (i = 0; i < BIN_SNAPSHOT_NUM; i++) {
 		/* wait RECR1_CTL_SNP_DONE_MASK has cleared */
 		timeout = 100;
-		while (ioread32(&reg_base->recr1) &
+		while (srds.ioread32(&reg_base->recr1) &
 		       RECR1_CTL_SNP_DONE_MASK) {
 			udelay(1);
 			timeout--;
@@ -161,13 +163,13 @@ static int get_median_gaink2(u32 *reg)
 		}
 
 		/* start snap shot */
-		iowrite32((ioread32(&reg_base->gcr1) |
+		srds.iowrite32((srds.ioread32(&reg_base->gcr1) |
 			    GCR1_CTL_SNP_START_MASK),
 			    &reg_base->gcr1);
 
 		/* wait for SNP done */
 		timeout = 100;
-		while (!(ioread32(&reg_base->recr1) &
+		while (!(srds.ioread32(&reg_base->recr1) &
 		       RECR1_CTL_SNP_DONE_MASK)) {
 			udelay(1);
 			timeout--;
@@ -176,12 +178,12 @@ static int get_median_gaink2(u32 *reg)
 		}
 
 		/* read and save the snap shot */
-		rx_eq_snp = ioread32(&reg_base->recr1);
+		rx_eq_snp = srds.ioread32(&reg_base->recr1);
 		gaink2_snap_shot[i] = (rx_eq_snp & RECR1_GAINK2_MASK) >>
 					RECR1_GAINK2_SHIFT;
 
 		/* terminate the snap shot by setting GCR1[REQ_CTL_SNP] */
-		iowrite32((ioread32(&reg_base->gcr1) &
+		srds.iowrite32((srds.ioread32(&reg_base->gcr1) &
 			    ~GCR1_CTL_SNP_START_MASK),
 			    &reg_base->gcr1);
 	}
@@ -215,7 +217,7 @@ static bool is_bin_early(int bin_sel, void *reg)
 	for (i = 0; i < BIN_SNAPSHOT_NUM; i++) {
 		/* wait RECR1_SNP_DONE_MASK has cleared */
 		timeout = 100;
-		while ((ioread32(&reg_base->recr1) & RECR1_SNP_DONE_MASK)) {
+		while ((srds.ioread32(&reg_base->recr1) & RECR1_SNP_DONE_MASK)) {
 			udelay(1);
 			timeout--;
 			if (timeout == 0)
@@ -224,22 +226,22 @@ static bool is_bin_early(int bin_sel, void *reg)
 
 		/* set TCSR1[CDR_SEL] to BinM1/BinLong */
 		if (bin_sel == BIN_M1) {
-			iowrite32((ioread32(&reg_base->tcsr1) &
+			srds.iowrite32((srds.ioread32(&reg_base->tcsr1) &
 				    ~CDR_SEL_MASK) | BIN_M1_SEL,
 				    &reg_base->tcsr1);
 		} else {
-			iowrite32((ioread32(&reg_base->tcsr1) &
+			srds.iowrite32((srds.ioread32(&reg_base->tcsr1) &
 				    ~CDR_SEL_MASK) | BIN_Long_SEL,
 				    &reg_base->tcsr1);
 		}
 
 		/* start snap shot */
-		iowrite32(ioread32(&reg_base->gcr1) | GCR1_SNP_START_MASK,
+		srds.iowrite32(srds.ioread32(&reg_base->gcr1) | GCR1_SNP_START_MASK,
 			    &reg_base->gcr1);
 
 		/* wait for SNP done */
 		timeout = 100;
-		while (!(ioread32(&reg_base->recr1) & RECR1_SNP_DONE_MASK)) {
+		while (!(srds.ioread32(&reg_base->recr1) & RECR1_SNP_DONE_MASK)) {
 			udelay(1);
 			timeout--;
 			if (timeout == 0)
@@ -247,13 +249,13 @@ static bool is_bin_early(int bin_sel, void *reg)
 		}
 
 		/* read and save the snap shot */
-		bin_snap_shot[i] = (ioread32(&reg_base->tcsr1) &
+		bin_snap_shot[i] = (srds.ioread32(&reg_base->tcsr1) &
 				TCSR1_SNP_DATA_MASK) >> TCSR1_SNP_DATA_SHIFT;
 		if (bin_snap_shot[i] & TCSR1_EQ_SNPBIN_SIGN_MASK)
 			negative_count++;
 
 		/* terminate the snap shot by setting GCR1[REQ_CTL_SNP] */
-		iowrite32(ioread32(&reg_base->gcr1) & ~GCR1_SNP_START_MASK,
+		srds.iowrite32(srds.ioread32(&reg_base->gcr1) & ~GCR1_SNP_START_MASK,
 			    &reg_base->gcr1);
 	}
 
@@ -265,13 +267,15 @@ static bool is_bin_early(int bin_sel, void *reg)
 	return early;
 }
 
-void setup_backplane_serdes_10g(struct backplane_serdes *bckpl_serdes)
+struct serdes_access* setup_serdes_access_10g(void)
 {
-	bckpl_serdes->get_lane_memmap_size = get_lane_memmap_size;
-	bckpl_serdes->tune_tecr = tune_tecr;
-	bckpl_serdes->reset_lane = reset_lane;
-	bckpl_serdes->lane_set_1gkx = lane_set_1gkx;
-	bckpl_serdes->get_median_gaink2 = get_median_gaink2;
-	bckpl_serdes->is_bin_early = is_bin_early;
+	srds.get_lane_memmap_size = get_lane_memmap_size;
+	srds.tune_tecr = tune_tecr;
+	srds.reset_lane = reset_lane;
+	srds.lane_set_1gkx = lane_set_1gkx;
+	srds.get_median_gaink2 = get_median_gaink2;
+	srds.is_bin_early = is_bin_early;
+
+	return &srds;
 }
 
diff --git a/drivers/net/phy/fsl_backplane_serdes_28g.c b/drivers/net/phy/fsl_backplane_serdes_28g.c
index d3f23740b1e5..4e188ad92224 100644
--- a/drivers/net/phy/fsl_backplane_serdes_28g.c
+++ b/drivers/net/phy/fsl_backplane_serdes_28g.c
@@ -43,72 +43,74 @@
 #define TECR0_AMP_RED_MASK			0x0000003f
 
 struct per_lane_ctrl_status {
-	__be32 gcr0;	/* 0x.000 - General Control Register 0 */
-	__be32 resv1;	/* 0x.004 - Reserved */
-	__be32 resv2;	/* 0x.008 - Reserved */
-	__be32 resv3;	/* 0x.00C - Reserved */
-	__be32 resv4;	/* 0x.010 - Reserved */
-	__be32 resv5;	/* 0x.014 - Reserved */
-	__be32 resv6;	/* 0x.018 - Reserved */
-	__be32 resv7;	/* 0x.01C - Reserved */
-	__be32 trstctl;	/* 0x.020 - TX Reset Control Register */
-	__be32 tgcr0;	/* 0x.024 - TX General Control Register 0 */
-	__be32 tgcr1;	/* 0x.028 - TX General Control Register 1 */
-	__be32 tgcr2;	/* 0x.02C - TX General Control Register 2 */
-	__be32 tecr0;	/* 0x.030 - Transmit Equalization Control Register 0 */
-	__be32 tecr1;	/* 0x.034 - Transmit Equalization Control Register 1 */
-	__be32 resv8;	/* 0x.038 - Reserved */
-	__be32 resv9;	/* 0x.03C - Reserved */
-	__be32 rrstctl;	/* 0x.040 - RX Reset Control Register */
-	__be32 rgcr0;	/* 0x.044 - RX General Control Register 0 */
-	__be32 rxgcr1; 	/* 0x.048 - RX General Control Register 1 */
-	__be32 resv10;	/* 0x.04C - Reserved */
-	__be32 recr0;	/* 0x.050 - RX Equalization Register 0 */
-	__be32 recr1;	/* 0x.054 - RX Equalization Register 1 */
-	__be32 recr2;	/* 0x.058 - RX Equalization Register 2 */
-	__be32 recr3;	/* 0x.05C - RX Equalization Register 3 */
-	__be32 recr4;	/* 0x.060 - RX Equalization Register 4 */
-	__be32 resv11;	/* 0x.064 - Reserved */
-	__be32 rccr0;	/* 0x.068 - RX Calibration Register 0 */
-	__be32 rccr1;	/* 0x.06C - RX Calibration Register 1 */
-	__be32 rcpcr0;	/* 0x.070 - RX Clock Path Register 0 */
-	__be32 rsccr0;	/* 0x.074 - RX Sampler Calibration Control Register 0 */
-	__be32 rsccr1;	/* 0x.078 - RX Sampler Calibration Control Register 1 */
-	__be32 resv12;	/* 0x.07C - Reserved */
-	__be32 ttlcr0;	/* 0x.080 - Transition Tracking Loop Register 0 */
-	__be32 ttlcr1;	/* 0x.084 - Transition Tracking Loop Register 1 */
-	__be32 ttlcr2;	/* 0x.088 - Transition Tracking Loop Register 2 */
-	__be32 ttlcr3;	/* 0x.08C - Transition Tracking Loop Register 3 */
-	__be32 resv13;	/* 0x.090 - Reserved */
-	__be32 resv14;	/* 0x.094 - Reserved */
-	__be32 resv15;	/* 0x.098 - Reserved */
-	__be32 resv16;	/* 0x.09C - Reserved */
-	__be32 tcsr0;	/* 0x.0A0 - Test Control/Status Register 0 */
-	__be32 tcsr1;	/* 0x.0A4 - Test Control/Status Register 1 */
-	__be32 tcsr2;	/* 0x.0A8 - Test Control/Status Register 2 */
-	__be32 tcsr3;	/* 0x.0AC - Test Control/Status Register 3 */
-	__be32 tcsr4;	/* 0x.0B0 - Test Control/Status Register 4 */
-	__be32 resv17;	/* 0x.0B4 - Reserved */
-	__be32 resv18;	/* 0x.0B8 - Reserved */
-	__be32 resv19;	/* 0x.0BC - Reserved */
-	__be32 rxcb0;	/* 0x.0C0 - RX Control Block Register 0 */
-	__be32 rxcb1;	/* 0x.0C4 - RX Control Block Register 1 */
-	__be32 resv20;	/* 0x.0C8 - Reserved */
-	__be32 resv21;	/* 0x.0CC - Reserved */
-	__be32 rxss0;	/* 0x.0D0 - RX Speed Switch Register 0 */
-	__be32 rxss1;	/* 0x.0D4 - RX Speed Switch Register 1 */
-	__be32 rxss2;	/* 0x.0D8 - RX Speed Switch Register 2 */
-	__be32 resv22;	/* 0x.0DC - Reserved */
-	__be32 txcb0;	/* 0x.0E0 - TX Control Block Register 0 */
-	__be32 txcb1;	/* 0x.0E4 - TX Control Block Register 1 */
-	__be32 resv23;	/* 0x.0E8 - Reserved */
-	__be32 resv24;	/* 0x.0EC - Reserved */
-	__be32 txss0;	/* 0x.0F0 - TX Speed Switch Register 0 */
-	__be32 txss1;	/* 0x.0F4 - TX Speed Switch Register 1 */
-	__be32 txss2;	/* 0x.0F8 - TX Speed Switch Register 2 */
-	__be32 resv25;	/* 0x.0FC - Reserved */
+	u32 gcr0;	/* 0x.000 - General Control Register 0 */
+	u32 resv1;	/* 0x.004 - Reserved */
+	u32 resv2;	/* 0x.008 - Reserved */
+	u32 resv3;	/* 0x.00C - Reserved */
+	u32 resv4;	/* 0x.010 - Reserved */
+	u32 resv5;	/* 0x.014 - Reserved */
+	u32 resv6;	/* 0x.018 - Reserved */
+	u32 resv7;	/* 0x.01C - Reserved */
+	u32 trstctl;	/* 0x.020 - TX Reset Control Register */
+	u32 tgcr0;	/* 0x.024 - TX General Control Register 0 */
+	u32 tgcr1;	/* 0x.028 - TX General Control Register 1 */
+	u32 tgcr2;	/* 0x.02C - TX General Control Register 2 */
+	u32 tecr0;	/* 0x.030 - Transmit Equalization Control Register 0 */
+	u32 tecr1;	/* 0x.034 - Transmit Equalization Control Register 1 */
+	u32 resv8;	/* 0x.038 - Reserved */
+	u32 resv9;	/* 0x.03C - Reserved */
+	u32 rrstctl;	/* 0x.040 - RX Reset Control Register */
+	u32 rgcr0;	/* 0x.044 - RX General Control Register 0 */
+	u32 rxgcr1; 	/* 0x.048 - RX General Control Register 1 */
+	u32 resv10;	/* 0x.04C - Reserved */
+	u32 recr0;	/* 0x.050 - RX Equalization Register 0 */
+	u32 recr1;	/* 0x.054 - RX Equalization Register 1 */
+	u32 recr2;	/* 0x.058 - RX Equalization Register 2 */
+	u32 recr3;	/* 0x.05C - RX Equalization Register 3 */
+	u32 recr4;	/* 0x.060 - RX Equalization Register 4 */
+	u32 resv11;	/* 0x.064 - Reserved */
+	u32 rccr0;	/* 0x.068 - RX Calibration Register 0 */
+	u32 rccr1;	/* 0x.06C - RX Calibration Register 1 */
+	u32 rcpcr0;	/* 0x.070 - RX Clock Path Register 0 */
+	u32 rsccr0;	/* 0x.074 - RX Sampler Calibration Control Register 0 */
+	u32 rsccr1;	/* 0x.078 - RX Sampler Calibration Control Register 1 */
+	u32 resv12;	/* 0x.07C - Reserved */
+	u32 ttlcr0;	/* 0x.080 - Transition Tracking Loop Register 0 */
+	u32 ttlcr1;	/* 0x.084 - Transition Tracking Loop Register 1 */
+	u32 ttlcr2;	/* 0x.088 - Transition Tracking Loop Register 2 */
+	u32 ttlcr3;	/* 0x.08C - Transition Tracking Loop Register 3 */
+	u32 resv13;	/* 0x.090 - Reserved */
+	u32 resv14;	/* 0x.094 - Reserved */
+	u32 resv15;	/* 0x.098 - Reserved */
+	u32 resv16;	/* 0x.09C - Reserved */
+	u32 tcsr0;	/* 0x.0A0 - Test Control/Status Register 0 */
+	u32 tcsr1;	/* 0x.0A4 - Test Control/Status Register 1 */
+	u32 tcsr2;	/* 0x.0A8 - Test Control/Status Register 2 */
+	u32 tcsr3;	/* 0x.0AC - Test Control/Status Register 3 */
+	u32 tcsr4;	/* 0x.0B0 - Test Control/Status Register 4 */
+	u32 resv17;	/* 0x.0B4 - Reserved */
+	u32 resv18;	/* 0x.0B8 - Reserved */
+	u32 resv19;	/* 0x.0BC - Reserved */
+	u32 rxcb0;	/* 0x.0C0 - RX Control Block Register 0 */
+	u32 rxcb1;	/* 0x.0C4 - RX Control Block Register 1 */
+	u32 resv20;	/* 0x.0C8 - Reserved */
+	u32 resv21;	/* 0x.0CC - Reserved */
+	u32 rxss0;	/* 0x.0D0 - RX Speed Switch Register 0 */
+	u32 rxss1;	/* 0x.0D4 - RX Speed Switch Register 1 */
+	u32 rxss2;	/* 0x.0D8 - RX Speed Switch Register 2 */
+	u32 resv22;	/* 0x.0DC - Reserved */
+	u32 txcb0;	/* 0x.0E0 - TX Control Block Register 0 */
+	u32 txcb1;	/* 0x.0E4 - TX Control Block Register 1 */
+	u32 resv23;	/* 0x.0E8 - Reserved */
+	u32 resv24;	/* 0x.0EC - Reserved */
+	u32 txss0;	/* 0x.0F0 - TX Speed Switch Register 0 */
+	u32 txss1;	/* 0x.0F4 - TX Speed Switch Register 1 */
+	u32 txss2;	/* 0x.0F8 - TX Speed Switch Register 2 */
+	u32 resv25;	/* 0x.0FC - Reserved */
 };
 
+static struct serdes_access srds;
+
 static u32 get_lane_memmap_size(void)
 {
 	return 0x100;
@@ -121,24 +123,24 @@ static void reset_lane(void *reg)
 	unsigned long timeout;
 
 	/* reset Tx lane: send reset request */
-	iowrite32(ioread32(&reg_base->trstctl) | RESET_REQ_MASK,
+	srds.iowrite32(srds.ioread32(&reg_base->trstctl) | RESET_REQ_MASK,
 		    &reg_base->trstctl);
 	udelay(1);
 	timeout = 10;
 	while (timeout--) {
-		val = ioread32(&reg_base->trstctl);
+		val = srds.ioread32(&reg_base->trstctl);
 		if (!(val & RESET_REQ_MASK))
 			break;
 		usleep_range(5, 20);
 	}
 	
 	/* reset Rx lane: send reset request */
-	iowrite32(ioread32(&reg_base->rrstctl) | RESET_REQ_MASK,
+	srds.iowrite32(srds.ioread32(&reg_base->rrstctl) | RESET_REQ_MASK,
 		    &reg_base->rrstctl);
 	udelay(1);
 	timeout = 10;
 	while (timeout--) {
-		val = ioread32(&reg_base->rrstctl);
+		val = srds.ioread32(&reg_base->rrstctl);
 		if (!(val & RESET_REQ_MASK))
 			break;
 		usleep_range(5, 20);
@@ -165,10 +167,10 @@ static void tune_tecr(void *reg, u32 ratio_preq, u32 ratio_pst1q, u32 adpt_eq, b
 	val = TECR0_INIT |
 		ratio_preq << PRE_COE_SHIFT |
 		ratio_pst1q << POST_COE_SHIFT;
-	iowrite32(val, &reg_base->tecr0);
+	srds.iowrite32(val, &reg_base->tecr0);
 
 	val = adpt_eq << ZERO_COE_SHIFT;
-	iowrite32(val, &reg_base->tecr1);
+	srds.iowrite32(val, &reg_base->tecr1);
 	
 	udelay(1);
 }
@@ -182,16 +184,16 @@ static void lane_set_1gkx(void *reg)
 	reset_lane(reg);
 
 	/* set gcr1 for 1GKX */
-	val = ioread32(&reg_base->rxgcr1);
+	val = srds.ioread32(&reg_base->rxgcr1);
 	val &= ~(GCR1_REIDL_TH_MASK | GCR1_REIDL_EX_SEL_MASK |
 		 GCR1_REIDL_ET_MAS_MASK);
-	iowrite32(val, &reg_base->rxgcr1);
+	srds.iowrite32(val, &reg_base->rxgcr1);
 	udelay(1);
 
 	/* set tecr0 for 1GKX */
-	val = ioread32(&reg_base->tecr0);
+	val = srds.ioread32(&reg_base->tecr0);
 	val &= ~TECR0_AMP_RED_MASK;
-	iowrite32(val, &reg_base->tecr0);
+	srds.iowrite32(val, &reg_base->tecr0);
 	udelay(1);
 }
 
@@ -208,7 +210,7 @@ static int get_median_gaink2(u32 *reg)
 	for (i = 0; i < BIN_SNAPSHOT_NUM; i++) {
 		/* wait RECR3_SNP_DONE_MASK has cleared */
 		timeout = 100;
-		while (ioread32(&reg_base->recr3) &
+		while (srds.ioread32(&reg_base->recr3) &
 				RECR3_SNP_DONE_MASK) {
 			udelay(1);
 			timeout--;
@@ -217,13 +219,13 @@ static int get_median_gaink2(u32 *reg)
 		}
 
 		/* start snap shot */
-		iowrite32((ioread32(&reg_base->recr3) |
+		srds.iowrite32((srds.ioread32(&reg_base->recr3) |
 			    RECR3_SNP_START_MASK),
 			    &reg_base->recr3);
 
 		/* wait for SNP done */
 		timeout = 100;
-		while (!(ioread32(&reg_base->recr3) &
+		while (!(srds.ioread32(&reg_base->recr3) &
 				RECR3_SNP_DONE_MASK)) {
 			udelay(1);
 			timeout--;
@@ -232,12 +234,12 @@ static int get_median_gaink2(u32 *reg)
 		}
 
 		/* read and save the snap shot */
-		rx_eq_snp = ioread32(&reg_base->recr3);
+		rx_eq_snp = srds.ioread32(&reg_base->recr3);
 		gaink2_snap_shot[i] = (rx_eq_snp & RECR3_GAINK2_MASK) >>
 					RECR3_GAINK2_SHIFT;
 
 		/* terminate the snap shot by setting GCR1[REQ_CTL_SNP] */
-		iowrite32((ioread32(&reg_base->recr3) &
+		srds.iowrite32((srds.ioread32(&reg_base->recr3) &
 			    ~RECR3_SNP_START_MASK),
 			    &reg_base->recr3);
 	}
@@ -271,7 +273,7 @@ static bool is_bin_early(int bin_sel, void *reg)
 	for (i = 0; i < BIN_SNAPSHOT_NUM; i++) {
 		/* wait RECR3_SNP_DONE_MASK has cleared */
 		timeout = 100;
-		while ((ioread32(&reg_base->recr3) & RECR3_SNP_DONE_MASK)) {
+		while ((srds.ioread32(&reg_base->recr3) & RECR3_SNP_DONE_MASK)) {
 			udelay(1);
 			timeout--;
 			if (timeout == 0)
@@ -280,22 +282,22 @@ static bool is_bin_early(int bin_sel, void *reg)
 
 		/* set TCSR1[CDR_SEL] to BinM1/BinLong */
 		if (bin_sel == BIN_M1) {
-			iowrite32((ioread32(&reg_base->recr4) &
+			srds.iowrite32((srds.ioread32(&reg_base->recr4) &
 				    ~CDR_SEL_MASK) | BIN_M1_SEL,
 				    &reg_base->recr4);
 		} else {
-			iowrite32((ioread32(&reg_base->recr4) &
+			srds.iowrite32((srds.ioread32(&reg_base->recr4) &
 				    ~CDR_SEL_MASK) | BIN_Long_SEL,
 				    &reg_base->recr4);
 		}
 
 		/* start snap shot */
-		iowrite32(ioread32(&reg_base->recr3) | RECR3_SNP_START_MASK,
+		srds.iowrite32(srds.ioread32(&reg_base->recr3) | RECR3_SNP_START_MASK,
 			    &reg_base->recr3);
 
 		/* wait for SNP done */
 		timeout = 100;
-		while (!(ioread32(&reg_base->recr3) & RECR3_SNP_DONE_MASK)) {
+		while (!(srds.ioread32(&reg_base->recr3) & RECR3_SNP_DONE_MASK)) {
 			udelay(1);
 			timeout--;
 			if (timeout == 0)
@@ -303,13 +305,13 @@ static bool is_bin_early(int bin_sel, void *reg)
 		}
 
 		/* read and save the snap shot */
-		bin_snap_shot[i] = (ioread32(&reg_base->recr4) &
+		bin_snap_shot[i] = (srds.ioread32(&reg_base->recr4) &
 				RECR4_SNP_DATA_MASK) >> RECR4_SNP_DATA_SHIFT;
 		if (bin_snap_shot[i] & RECR4_EQ_SNPBIN_SIGN_MASK)
 			negative_count++;
 
 		/* terminate the snap shot by setting GCR1[REQ_CTL_SNP] */
-		iowrite32(ioread32(&reg_base->recr3) & ~RECR3_SNP_START_MASK,
+		srds.iowrite32(srds.ioread32(&reg_base->recr3) & ~RECR3_SNP_START_MASK,
 			    &reg_base->recr3);
 	}
 
@@ -321,12 +323,14 @@ static bool is_bin_early(int bin_sel, void *reg)
 	return early;
 }
 
-void setup_backplane_serdes_28g(struct backplane_serdes *bckpl_serdes)
+struct serdes_access* setup_serdes_access_28g(void)
 {
-	bckpl_serdes->get_lane_memmap_size = get_lane_memmap_size;
-	bckpl_serdes->tune_tecr = tune_tecr;
-	bckpl_serdes->reset_lane = reset_lane;
-	bckpl_serdes->lane_set_1gkx = lane_set_1gkx;
-	bckpl_serdes->get_median_gaink2 = get_median_gaink2;
-	bckpl_serdes->is_bin_early = is_bin_early;
+	srds.get_lane_memmap_size = get_lane_memmap_size;
+	srds.tune_tecr = tune_tecr;
+	srds.reset_lane = reset_lane;
+	srds.lane_set_1gkx = lane_set_1gkx;
+	srds.get_median_gaink2 = get_median_gaink2;
+	srds.is_bin_early = is_bin_early;
+
+	return &srds;
 }
-- 
2.17.0

