From af1b39c7b6d7c45f3a12518684e011f997eadc71 Mon Sep 17 00:00:00 2001
From: Tomasz Duszynski <tduszynski@cavium.com>
Date: Thu, 18 Apr 2019 12:53:00 +0200
Subject: [PATCH 172/386] octeontx2-pf: assign default mac address during probe

As soon as netdev becomes registered one expects to see
a valid mac address. Mac address can either come from
hardware or be randomly generated if the former is invalid.

Change-Id: I316f5c0e7ffaaa58f4f7512de4ee7f84a9a0452a
Signed-off-by: Tomasz Duszynski <tduszynski@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/7967
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[RH: Original patch taken from marvell 88F3720 board support SDK 10.0-PR2003]
Signed-off-by: Ruiqiang Hao <Ruiqiang.Hao@windriver.com>
---
 .../marvell/octeontx2/nic/otx2_common.c       | 52 ++++++++++++++++++-
 .../marvell/octeontx2/nic/otx2_common.h       |  1 +
 .../ethernet/marvell/octeontx2/nic/otx2_pf.c  | 14 ++---
 3 files changed, 59 insertions(+), 8 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.c
index 27ddb8c6f071..9acbff551f59 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.c
@@ -182,6 +182,39 @@ int otx2_hw_set_mac_addr(struct otx2_nic *pfvf, struct net_device *netdev)
 	return err;
 }
 
+static int otx2_hw_get_mac_addr(struct otx2_nic *pfvf,
+				struct net_device *netdev)
+{
+	struct nix_get_mac_addr_rsp *rsp;
+	struct mbox_msghdr *msghdr;
+	struct msg_req *req;
+	int err;
+
+	otx2_mbox_lock(&pfvf->mbox);
+	req = otx2_mbox_alloc_msg_nix_get_mac_addr(&pfvf->mbox);
+	if (!req) {
+		otx2_mbox_unlock(&pfvf->mbox);
+		return -ENOMEM;
+	}
+
+	err = otx2_sync_mbox_msg(&pfvf->mbox);
+	if (err) {
+		otx2_mbox_unlock(&pfvf->mbox);
+		return err;
+	}
+
+	msghdr = otx2_mbox_get_rsp(&pfvf->mbox.mbox, 0, &req->hdr);
+	if (!msghdr) {
+		otx2_mbox_unlock(&pfvf->mbox);
+		return -ENOMEM;
+	}
+	rsp = (struct nix_get_mac_addr_rsp *)msghdr;
+	ether_addr_copy(netdev->dev_addr, rsp->mac_addr);
+	otx2_mbox_unlock(&pfvf->mbox);
+
+	return 0;
+}
+
 int otx2_set_mac_address(struct net_device *netdev, void *p)
 {
 	struct otx2_nic *pfvf = netdev_priv(netdev);
@@ -389,6 +422,24 @@ void otx2_tx_timeout(struct net_device *netdev)
 }
 EXPORT_SYMBOL(otx2_tx_timeout);
 
+void otx2_get_mac_from_af(struct net_device *netdev)
+{
+	struct otx2_nic *pfvf = netdev_priv(netdev);
+	int err;
+
+	err = otx2_hw_get_mac_addr(pfvf, netdev);
+	if (err)
+		dev_warn(pfvf->dev, "Failed to read mac from hardware\n");
+
+	/* Normally AF should provide mac addresses for both PFs and CGX mapped
+	 * VFs which means random mac gets generated either in case of error
+	 * or LBK netdev.
+	 */
+	if (!is_valid_ether_addr(netdev->dev_addr))
+		eth_hw_addr_random(netdev);
+}
+EXPORT_SYMBOL(otx2_get_mac_from_af);
+
 static int otx2_get_link(struct otx2_nic *pfvf)
 {
 	int link = 0;
@@ -1288,7 +1339,6 @@ void mbox_handler_nix_lf_alloc(struct otx2_nic *pfvf,
 	pfvf->hw.sqb_size = rsp->sqb_size;
 	pfvf->rx_chan_base = rsp->rx_chan_base;
 	pfvf->tx_chan_base = rsp->tx_chan_base;
-	ether_addr_copy(pfvf->netdev->dev_addr, rsp->mac_addr);
 	pfvf->hw.lso_tsov4_idx = rsp->lso_tsov4_idx;
 	pfvf->hw.lso_tsov6_idx = rsp->lso_tsov6_idx;
 }
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h
index b12655449f41..9b181a901fb8 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h
@@ -461,6 +461,7 @@ int otx2_set_mac_address(struct net_device *netdev, void *p);
 int otx2_change_mtu(struct net_device *netdev, int new_mtu);
 int otx2_hw_set_mtu(struct otx2_nic *pfvf, int mtu);
 void otx2_tx_timeout(struct net_device *netdev);
+void otx2_get_mac_from_af(struct net_device *netdev);
 
 /* RVU block related APIs */
 int otx2_attach_npa_nix(struct otx2_nic *pfvf);
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c
index 68a7e65ccb1e..5f8a8a638aa7 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c
@@ -1593,13 +1593,10 @@ int otx2_open(struct net_device *netdev)
 		napi_enable(&cq_poll->napi);
 	}
 
-	/* Check if MAC address from AF is valid or else set a random MAC */
-	if (is_zero_ether_addr(netdev->dev_addr)) {
-		eth_hw_addr_random(netdev);
-		err = otx2_hw_set_mac_addr(pf, netdev);
-		if (err)
-			goto err_disable_napi;
-	}
+	/* Set default mac address */
+	err = otx2_hw_set_mac_addr(pf, netdev);
+	if (err)
+		goto err_disable_napi;
 
 	/* Set default MTU in HW */
 	err = otx2_hw_set_mtu(pf, netdev->mtu);
@@ -2226,6 +2223,9 @@ static int otx2_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	/* Don't check for error.  Proceed without ptp */
 	otx2_ptp_init(pf);
 
+	/* Assign default mac address */
+	otx2_get_mac_from_af(netdev);
+
 	/* NPA's pool is a stack to which SW frees buffer pointers via Aura.
 	 * HW allocates buffer pointer from stack and uses it for DMA'ing
 	 * ingress packet. In some scenarios HW can free back allocated buffer
-- 
2.17.1

