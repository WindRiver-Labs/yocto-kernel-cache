From fd31bb5b0c7c102a19cfc7ebb5cb87cfe8bc7a08 Mon Sep 17 00:00:00 2001
From: Alan Tull <atull@kernel.org>
Date: Tue, 13 Nov 2018 12:14:04 -0600
Subject: [PATCH 09/18] fpga: add intel stratix10 soc fpga manager driver

commit  02f3f8cdbda0c4d4f632e70e12951b328aac23cf from
https://github.com/altera-opensource/linux-socfpga.git

'Commit e7eef1d7633a ("fpga: add intel stratix10 soc fpga manager driver")'

Add driver for reconfiguring Intel Stratix10 SoC FPGA devices.
This driver communicates through the Intel service layer driver
which does communication with privileged hardware (that does the
FPGA programming) through a secure mailbox.

Signed-off-by: Alan Tull <atull@kernel.org>
Signed-off-by: Richard Gong <richard.gong@intel.com>
Acked-by: Moritz Fischer <mdf@kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/fpga/Kconfig         |   2 +-
 drivers/fpga/stratix10-soc.c | 200 +++++++++++++++++------------------
 2 files changed, 101 insertions(+), 101 deletions(-)

diff --git a/drivers/fpga/Kconfig b/drivers/fpga/Kconfig
index e53070b95d87..6f04d4cef7bc 100644
--- a/drivers/fpga/Kconfig
+++ b/drivers/fpga/Kconfig
@@ -48,7 +48,7 @@ config FPGA_MGR_SOCFPGA_A10
 
 config FPGA_MGR_STRATIX10_SOC
 	tristate "Intel Stratix10 SoC FPGA Manager"
-	depends on (ARCH_STRATIX10 && INTEL_SERVICE)
+	depends on (ARCH_STRATIX10 && INTEL_STRATIX10_SERVICE)
 	help
 	  FPGA manager driver support for the Intel Stratix10 SoC.
 
diff --git a/drivers/fpga/stratix10-soc.c b/drivers/fpga/stratix10-soc.c
index 9112d0cd96d8..215d33789c74 100644
--- a/drivers/fpga/stratix10-soc.c
+++ b/drivers/fpga/stratix10-soc.c
@@ -1,25 +1,15 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * FPGA Manager Driver for Intel Stratix10 SoC
  *
  *  Copyright (C) 2018 Intel Corporation
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 #include <linux/completion.h>
 #include <linux/fpga/fpga-mgr.h>
-#include <linux/intel-service-client.h>
+#include <linux/firmware/intel/stratix10-svc-client.h>
 #include <linux/module.h>
 #include <linux/of.h>
+#include <linux/of_platform.h>
 
 /*
  * FPGA programming requires a higher level of privilege (EL3), per the SoC
@@ -34,10 +24,10 @@
 #define S10_BUFFER_TIMEOUT (msecs_to_jiffies(SVC_RECONFIG_BUFFER_TIMEOUT_MS))
 #define S10_RECONFIG_TIMEOUT (msecs_to_jiffies(SVC_RECONFIG_REQUEST_TIMEOUT_MS))
 
-/**
+/*
  * struct s10_svc_buf
- * @buf: virtual address of buf provided by service layer
- * @lock: locked if buffer is in use
+ * buf:  virtual address of buf provided by service layer
+ * lock: locked if buffer is in use
  */
 struct s10_svc_buf {
 	char *buf;
@@ -45,39 +35,37 @@ struct s10_svc_buf {
 };
 
 struct s10_priv {
-	struct intel_svc_chan *chan;
-	struct intel_svc_client client;
+	struct stratix10_svc_chan *chan;
+	struct stratix10_svc_client client;
 	struct completion status_return_completion;
 	struct s10_svc_buf svc_bufs[NUM_SVC_BUFS];
 	unsigned long status;
 };
 
 static int s10_svc_send_msg(struct s10_priv *priv,
-			    enum intel_svc_command_code command,
+			    enum stratix10_svc_command_code command,
 			    void *payload, u32 payload_length)
 {
-	struct intel_svc_chan *chan = priv->chan;
-	struct intel_svc_client_msg msg;
+	struct stratix10_svc_chan *chan = priv->chan;
+	struct device *dev = priv->client.dev;
+	struct stratix10_svc_client_msg msg;
 	int ret;
 
-	pr_debug("%s cmd=%d payload=%p legnth=%d\n",
-		 __func__, command, payload, payload_length);
+	dev_dbg(dev, "%s cmd=%d payload=%p length=%d\n",
+		__func__, command, payload, payload_length);
 
 	msg.command = command;
 	msg.payload = payload;
 	msg.payload_length = payload_length;
 
-	ret = intel_svc_send(chan, &msg);
-	pr_debug("intel_svc_send returned status %d\n", ret);
+	ret = stratix10_svc_send(chan, &msg);
+	dev_dbg(dev, "stratix10_svc_send returned status %d\n", ret);
 
 	return ret;
 }
 
-/**
- * s10_free_buffers
+/*
  * Free buffers allocated from the service layer's pool that are not in use.
- * @mgr: fpga manager struct
- * Free all buffers that are not in use.
  * Return true when all buffers are freed.
  */
 static bool s10_free_buffers(struct fpga_manager *mgr)
@@ -94,8 +82,8 @@ static bool s10_free_buffers(struct fpga_manager *mgr)
 
 		if (!test_and_set_bit_lock(SVC_BUF_LOCK,
 					   &priv->svc_bufs[i].lock)) {
-			intel_svc_free_memory(priv->chan,
-					      priv->svc_bufs[i].buf);
+			stratix10_svc_free_memory(priv->chan,
+						  priv->svc_bufs[i].buf);
 			priv->svc_bufs[i].buf = NULL;
 			num_free++;
 		}
@@ -104,11 +92,8 @@ static bool s10_free_buffers(struct fpga_manager *mgr)
 	return num_free == NUM_SVC_BUFS;
 }
 
-/**
- * s10_free_buffer_count
- * Count how many buffers are not in use.
- * @mgr: fpga manager struct
- * Return # of buffers that are not in use.
+/*
+ * Returns count of how many buffers are not in use.
  */
 static uint s10_free_buffer_count(struct fpga_manager *mgr)
 {
@@ -123,13 +108,13 @@ static uint s10_free_buffer_count(struct fpga_manager *mgr)
 	return num_free;
 }
 
-/**
+/*
  * s10_unlock_bufs
  * Given the returned buffer address, match that address to our buffer struct
  * and unlock that buffer.  This marks it as available to be refilled and sent
  * (or freed).
- * @priv: private data
- * @kaddr: kernel address of buffer that was returned from service layer
+ * priv: private data
+ * kaddr: kernel address of buffer that was returned from service layer
  */
 static void s10_unlock_bufs(struct s10_priv *priv, void *kaddr)
 {
@@ -148,21 +133,20 @@ static void s10_unlock_bufs(struct s10_priv *priv, void *kaddr)
 	WARN(1, "Unknown buffer returned from service layer %p\n", kaddr);
 }
 
-/**
- * s10_receive_callback
- * Callback for service layer to use to provide client (this driver) messages
- * received through the mailbox.
- * @client: service layer client struct
- * @data: message
+/*
+ * s10_receive_callback - callback for service layer to use to provide client
+ * (this driver) messages received through the mailbox.
+ * client: service layer client struct
+ * data: message from service layer
  */
-static void s10_receive_callback(struct intel_svc_client *client,
-				 struct intel_svc_c_data *data)
+static void s10_receive_callback(struct stratix10_svc_client *client,
+				 struct stratix10_svc_cb_data *data)
 {
 	struct s10_priv *priv = client->priv;
 	u32 status;
 	int i;
 
-	WARN_ONCE(!data, "%s: intel_svc_rc_data = NULL", __func__);
+	WARN_ONCE(!data, "%s: stratix10_svc_rc_data = NULL", __func__);
 
 	status = data->status;
 
@@ -183,14 +167,9 @@ static void s10_receive_callback(struct intel_svc_client *client,
 	complete(&priv->status_return_completion);
 }
 
-/**
- * s10_ops_write_init
- * Prepare for FPGA reconfiguration by requesting partial reconfig and
- * allocating buffers from the service layer.
- * @mgr: fpga manager
- * @info: fpga image info
- * @buf: fpga image buffer
- * @count: size of buf in bytes
+/*
+ * s10_ops_write_init - prepare for FPGA reconfiguration by requesting
+ * partial reconfig and allocating buffers from the service layer.
  */
 static int s10_ops_write_init(struct fpga_manager *mgr,
 			      struct fpga_image_info *info,
@@ -198,22 +177,22 @@ static int s10_ops_write_init(struct fpga_manager *mgr,
 {
 	struct s10_priv *priv = mgr->priv;
 	struct device *dev = priv->client.dev;
-	struct intel_command_reconfig_payload payload;
+	struct stratix10_svc_command_config_type ctype;
 	char *kbuf;
 	uint i;
 	int ret;
 
-	payload.flags = 0;
+	ctype.flags = 0;
 	if (info->flags & FPGA_MGR_PARTIAL_RECONFIG) {
-		dev_info(dev, "Requesting partial reconfiguration.\n");
-		payload.flags |= BIT(COMMAND_RECONFIG_FLAG_PARTIAL);
+		dev_dbg(dev, "Requesting partial reconfiguration.\n");
+		ctype.flags |= BIT(COMMAND_RECONFIG_FLAG_PARTIAL);
 	} else {
-		dev_info(dev, "Requesting full reconfiguration.\n");
+		dev_dbg(dev, "Requesting full reconfiguration.\n");
 	}
 
 	reinit_completion(&priv->status_return_completion);
 	ret = s10_svc_send_msg(priv, COMMAND_RECONFIG,
-			       &payload, sizeof(payload));
+			       &ctype, sizeof(ctype));
 	if (ret < 0)
 		goto init_done;
 
@@ -238,7 +217,7 @@ static int s10_ops_write_init(struct fpga_manager *mgr,
 
 	/* Allocate buffers from the service layer's pool. */
 	for (i = 0; i < NUM_SVC_BUFS; i++) {
-		kbuf = intel_svc_allocate_memory(priv->chan, SVC_BUF_SIZE);
+		kbuf = stratix10_svc_allocate_memory(priv->chan, SVC_BUF_SIZE);
 		if (!kbuf) {
 			s10_free_buffers(mgr);
 			ret = -ENOMEM;
@@ -250,21 +229,19 @@ static int s10_ops_write_init(struct fpga_manager *mgr,
 	}
 
 init_done:
-	intel_svc_done(priv->chan);
+	stratix10_svc_done(priv->chan);
 	return ret;
 }
 
-/**
- * s10_send_buf
- * Send a buffer to the service layer queue.
- * @mgr: fpga manager struct
- * @buf: fpga image buffer
- * @count: size of buf in bytes
+/*
+ * s10_send_buf - send a buffer to the service layer queue
+ * mgr: fpga manager struct
+ * buf: fpga image buffer
+ * count: size of buf in bytes
  * Returns # of bytes transferred or -ENOBUFS if the all the buffers are in use
- * or if the service queue is full.  Never returns 0.
+ * or if the service queue is full. Never returns 0.
  */
 static int s10_send_buf(struct fpga_manager *mgr, const char *buf, size_t count)
-
 {
 	struct s10_priv *priv = mgr->priv;
 	struct device *dev = priv->client.dev;
@@ -286,28 +263,21 @@ static int s10_send_buf(struct fpga_manager *mgr, const char *buf, size_t count)
 
 	svc_buf = priv->svc_bufs[i].buf;
 	memcpy(svc_buf, buf, xfer_sz);
-	/* Returns -ENOBUFS If service queue is full. */
 	ret = s10_svc_send_msg(priv, COMMAND_RECONFIG_DATA_SUBMIT,
 			       svc_buf, xfer_sz);
 	if (ret < 0) {
 		dev_err(dev,
 			"Error while sending data to service layer (%d)", ret);
+		clear_bit_unlock(SVC_BUF_LOCK, &priv->svc_bufs[i].lock);
 		return ret;
 	}
 
 	return xfer_sz;
 }
 
-/**
- * s10_ops_write
- *
+/*
  * Send a FPGA image to privileged layers to write to the FPGA.  When done
  * sending, free all service layer buffers we allocated in write_init.
- *
- * @mgr: fpga manager
- * @buf: fpga image buffer
- * @count: size of buf in bytes
- * Returns 0 for success or negative errno.
  */
 static int s10_ops_write(struct fpga_manager *mgr, const char *buf,
 			 size_t count)
@@ -388,13 +358,6 @@ static int s10_ops_write(struct fpga_manager *mgr, const char *buf,
 	return ret;
 }
 
-/**
- * s10_ops_write_complete
- * Wait for FPGA configuration to be done
- * @mgr: fpga manager
- * @info: fpga image info
- * Returns 0 for success negative errno.
- */
 static int s10_ops_write_complete(struct fpga_manager *mgr,
 				  struct fpga_image_info *info)
 {
@@ -431,7 +394,7 @@ static int s10_ops_write_complete(struct fpga_manager *mgr,
 		ret = 0;
 
 		if (test_and_clear_bit(SVC_STATUS_RECONFIG_COMPLETED,
-					&priv->status))
+				       &priv->status))
 			break;
 
 		if (test_and_clear_bit(SVC_STATUS_RECONFIG_ERROR,
@@ -442,7 +405,7 @@ static int s10_ops_write_complete(struct fpga_manager *mgr,
 		}
 	} while (1);
 
-	intel_svc_done(priv->chan);
+	stratix10_svc_done(priv->chan);
 
 	return ret;
 }
@@ -462,8 +425,8 @@ static const struct fpga_manager_ops s10_ops = {
 static int s10_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
-	struct fpga_manager *mgr;
 	struct s10_priv *priv;
+	struct fpga_manager *mgr;
 	int ret;
 
 	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
@@ -474,8 +437,8 @@ static int s10_probe(struct platform_device *pdev)
 	priv->client.receive_cb = s10_receive_callback;
 	priv->client.priv = priv;
 
-	priv->chan = request_svc_channel_byname(&priv->client,
-						SVC_CLIENT_FPGA);
+	priv->chan = stratix10_svc_request_channel_byname(&priv->client,
+							  SVC_CLIENT_FPGA);
 	if (IS_ERR(priv->chan)) {
 		dev_err(dev, "couldn't get service channel (%s)\n",
 			SVC_CLIENT_FPGA);
@@ -487,18 +450,23 @@ static int s10_probe(struct platform_device *pdev)
 	mgr = fpga_mgr_create(dev, "Stratix10 SOC FPGA Manager",
 			      &s10_ops, priv);
 	if (!mgr) {
-		free_svc_channel(priv->chan);
-		return -ENOMEM;
+		dev_err(dev, "unable to create FPGA manager\n");
+		ret = -ENOMEM;
+		goto probe_err;
 	}
 
-	platform_set_drvdata(pdev, mgr);
-
 	ret = fpga_mgr_register(mgr);
 	if (ret) {
+		dev_err(dev, "unable to register FPGA manager\n");
 		fpga_mgr_free(mgr);
-		free_svc_channel(priv->chan);
+		goto probe_err;
 	}
 
+	platform_set_drvdata(pdev, mgr);
+	return ret;
+
+probe_err:
+	stratix10_svc_free_channel(priv->chan);
 	return ret;
 }
 
@@ -508,7 +476,7 @@ static int s10_remove(struct platform_device *pdev)
 	struct s10_priv *priv = mgr->priv;
 
 	fpga_mgr_unregister(mgr);
-	free_svc_channel(priv->chan);
+	stratix10_svc_free_channel(priv->chan);
 
 	return 0;
 }
@@ -529,7 +497,39 @@ static struct platform_driver s10_driver = {
 	},
 };
 
-module_platform_driver(s10_driver);
+static int __init s10_init(void)
+{
+	struct device_node *fw_np;
+	struct device_node *np;
+	int ret;
+
+	fw_np = of_find_node_by_name(NULL, "svc");
+	if (!fw_np)
+		return -ENODEV;
+
+	of_node_get(fw_np);
+	np = of_find_matching_node(fw_np, s10_of_match);
+	if (!np) {
+		of_node_put(fw_np);
+		return -ENODEV;
+	}
+
+	of_node_put(np);
+	ret = of_platform_populate(fw_np, s10_of_match, NULL, NULL);
+	of_node_put(fw_np);
+	if (ret)
+		return ret;
+
+	return platform_driver_register(&s10_driver);
+}
+
+static void __exit s10_exit(void)
+{
+	return platform_driver_unregister(&s10_driver);
+}
+
+module_init(s10_init);
+module_exit(s10_exit);
 
 MODULE_AUTHOR("Alan Tull <atull@kernel.org>");
 MODULE_DESCRIPTION("Intel Stratix 10 SOC FPGA Manager");
-- 
2.17.1

