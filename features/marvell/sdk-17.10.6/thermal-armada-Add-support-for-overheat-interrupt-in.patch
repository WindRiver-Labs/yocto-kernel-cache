From e8dcbbf84a2b498949b4988eb77c88dbc26bc90e Mon Sep 17 00:00:00 2001
From: Ofer Heifetz <oferh@marvell.com>
Date: Thu, 12 Nov 2015 10:09:53 +0200
Subject: [PATCH 0095/1345] thermal: armada: Add support for overheat
 interrupt indication

commit  344a2911e5c265e20fdc93e34e7452c5861f011a from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

The Armada 38x thermal sensor unit supports detection of overheat scenario
when the junction temperature reaches configured threshold +/- calculated
hysteresis value.
When the temperature reaches both high or low thresholds, interrupt
is asserted. This patch add support for the thermal sensor interrupt.
Threshold and hysteresis value can be configured in DT, if none given
default low/high thresholds are 97..107 Celsius degrees.

Signed-off-by: Ofer Heifetz <oferh@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/24793
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Lior Amsalem <alior@marvell.com>

Conflicts:
	arch/arm/boot/dts/armada-38x.dtsi

Change-Id: Ibb0fb4a835646c1f4b637548ab712667c791e46d
Signed-off-by: Grzegorz Jaszczyk <jaz@semihalf.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/27813
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Ofer Heifetz <oferh@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 .../devicetree/bindings/thermal/armada-thermal.txt |   25 +++-
 arch/arm/boot/dts/armada-38x.dtsi                  |    6 +-
 drivers/thermal/armada_thermal.c                   |  138 +++++++++++++++++++-
 3 files changed, 162 insertions(+), 7 deletions(-)

diff --git a/Documentation/devicetree/bindings/thermal/armada-thermal.txt b/Documentation/devicetree/bindings/thermal/armada-thermal.txt
index b0048d5..9f5efef 100644
--- a/Documentation/devicetree/bindings/thermal/armada-thermal.txt
+++ b/Documentation/devicetree/bindings/thermal/armada-thermal.txt
@@ -10,16 +10,31 @@ Required properties:
 		marvell,armada-ap806-thermal
 
 - reg:		Device's register space.
-		Two entries are expected, see the examples below.
+		Two or three entries are expected, see the examples below.
 		The first one is required for the sensor register;
 		the second one is required for the control register
 		to be used for sensor initialization (a.k.a. calibration).
+		The third entry is dedicated to the DFX interrupt for
+		Armada 38x.
+
+- interrupts:	Should contain interrupt for thermal system
+
+- threshold:	Temperature threshold in Celsius, the threshold +/- calculated
+		hysteresis (formula below) define the upper and lower watermark
+		which when crossing, an interrupt will be asserted.
+
+- hysteresis:	Valid values are 0..3, following is upper/lower watermark calculation:
+		high/low watermark = threshold +/- 0.4761 * 2^(hysteresis + 2).
+		Following are the corresponding degrees corresponding to
+		hysteresis value: 0=>1.9, 1=>3.8,  2=>7.6, 3=>15.2
 
 Example:
 
-	thermal@d0018300 {
-		compatible = "marvell,armada370-thermal";
-                reg = <0xd0018300 0x4
-		       0xd0018304 0x4>;
+	thermal@e4078 {
+		compatible = "marvell,armada380-thermal";
+		reg = <0xe4078 0x4>, <0xe4074 0x4>, <0xe4100 0x20>;
+		interrupts = <GIC_SPI 78 IRQ_TYPE_LEVEL_HIGH>;
+		threshold = <100>;
+		hysteresis = <2>;
 		status = "okay";
 	};
diff --git a/arch/arm/boot/dts/armada-38x.dtsi b/arch/arm/boot/dts/armada-38x.dtsi
index 40f4efe..2f5925c 100644
--- a/arch/arm/boot/dts/armada-38x.dtsi
+++ b/arch/arm/boot/dts/armada-38x.dtsi
@@ -585,7 +585,11 @@
 
 			thermal: thermal@e8078 {
 				compatible = "marvell,armada380-thermal";
-				reg = <0xe4078 0x4>, <0xe4070 0x8>;
+				reg = <0xe4078 0x4>, <0xe4070 0x8>,
+				      <0xe4100 0x20>;
+				interrupts = <GIC_SPI 78 IRQ_TYPE_LEVEL_HIGH>;
+				threshold = <100>;
+				hysteresis = <2>;
 				status = "okay";
 			};
 
diff --git a/drivers/thermal/armada_thermal.c b/drivers/thermal/armada_thermal.c
index 1d5c57b..5ee6dc4 100644
--- a/drivers/thermal/armada_thermal.c
+++ b/drivers/thermal/armada_thermal.c
@@ -23,8 +23,11 @@
 #include <linux/platform_device.h>
 #include <linux/of_device.h>
 #include <linux/thermal.h>
+#include <linux/interrupt.h>
 
 #define THERMAL_VALID_MASK		0x1
+#define MCELSIUS(temp)			((temp) * 1000)
+#define CELSIUS(temp)			((temp) / 1000)
 
 /* Thermal Manager Control and Status Register */
 #define PMU_TDC0_SW_RST_MASK		(0x1 << 1)
@@ -52,13 +55,22 @@
 #define AP806_TSEN_OUTPUT_MSB		512
 #define AP806_TSEN_OUTPUT_COMP		1024
 
+/* Statically defined overheat threshold Celsius */
+#define A380_THRESH_DEFAULT_TEMP	100
+#define A380_THRESH_DEFAULT_HYST	2
+#define A380_THRESH_OFFSET		16
+#define A380_THRESH_HYST_MASK		0x3
+#define A380_THRESH_HYST_OFFSET		26
+
 struct armada_thermal_data;
 
 /* Marvell EBU Thermal Sensor Dev Structure */
 struct armada_thermal_priv {
 	void __iomem *sensor;
 	void __iomem *control;
+	void __iomem *dfx;
 	struct armada_thermal_data *data;
+	struct platform_device *pdev;
 };
 
 struct armada_thermal_data {
@@ -83,6 +95,69 @@ struct armada_thermal_data {
 	struct thermal_zone_device_ops *ops;
 };
 
+inline unsigned int armada380_thresh_val_calc(unsigned int celsius_temp,
+					      struct armada_thermal_data *data)
+{
+	int thresh_val;
+
+	thresh_val = ((MCELSIUS(celsius_temp) * data->coef_div) +
+		      data->coef_b) / data->coef_m;
+
+	return thresh_val & data->temp_mask;
+}
+
+inline unsigned int armada380_thresh_celsius_calc(int thresh_val,
+				     int hyst, struct armada_thermal_data *data)
+{
+	unsigned int mcelsius_temp;
+
+	mcelsius_temp = (((data->coef_m * (thresh_val + hyst)) -
+			  data->coef_b) / data->coef_div);
+
+	return CELSIUS(mcelsius_temp);
+}
+
+static void armada380_temp_set_threshold(struct platform_device *pdev,
+					 struct armada_thermal_priv *priv)
+{
+	int temp, reg, hyst;
+	unsigned int thresh;
+	struct armada_thermal_data *data = priv->data;
+	struct device_node *np = pdev->dev.of_node;
+
+	/* get threshold value from DT */
+	if (of_property_read_u32(np, "threshold", &thresh)) {
+		thresh = A380_THRESH_DEFAULT_TEMP;
+		dev_warn(&pdev->dev, "no threshold in DT, using default\n");
+	}
+
+	/* get hysteresis value from DT */
+	if (of_property_read_u32(np, "hysteresis", &hyst)) {
+		hyst = A380_THRESH_DEFAULT_HYST;
+		dev_warn(&pdev->dev, "no hysteresis in DT, using default\n");
+	}
+
+	temp = armada380_thresh_val_calc(thresh, data);
+	reg = readl_relaxed(priv->control + A380_CONTROL_MSB_OFFSET);
+
+	/* Set Threshold */
+	reg &= ~(data->temp_mask << A380_THRESH_OFFSET);
+	reg |= (temp << A380_THRESH_OFFSET);
+
+	/* Set Hysteresis */
+	reg &= ~(A380_THRESH_HYST_MASK << A380_THRESH_HYST_OFFSET);
+	reg |= (hyst << A380_THRESH_HYST_OFFSET);
+
+	writel(reg, priv->control + A380_CONTROL_MSB_OFFSET);
+
+	/* hysteresis calculation is 2^(2+n) */
+	hyst = 1 << (hyst + 2);
+
+	dev_info(&pdev->dev, "Overheat threshold between %d..%d\n",
+		armada380_thresh_celsius_calc(temp, -hyst, data),
+		armada380_thresh_celsius_calc(temp, hyst, data));
+}
+
 static void armadaxp_init_sensor(struct platform_device *pdev,
 				 struct armada_thermal_priv *priv)
 {
@@ -165,6 +240,22 @@ static void armada380_init_sensor(struct platform_device *pdev,
 	reg &= ~A380_TSEN_TC_TRIM_MASK;
 	reg |= 0x3;
 	writel(reg, priv->control);
+
+	/* Set thresholds */
+	armada380_temp_set_threshold(pdev, priv);
+
+	/* Clear on Read DFX temperature irqs cause */
+	reg = readl_relaxed(priv->dfx + 0x10);
+
+	/* Unmask DFX Temperature overheat and cooldown irqs */
+	reg = readl_relaxed(priv->dfx + 0x14);
+	reg |= (0x3 << 1);
+	writel(reg, priv->dfx + 0x14);
+
+	/* Unmask DFX Server irq */
+	reg = readl_relaxed(priv->dfx + 0x4);
+	reg |= (0x3 << 1);
+	writel(reg, priv->dfx + 0x4);
 }
 
 static void armada_ap806_init_sensor(struct platform_device *pdev,
@@ -255,6 +346,31 @@ static int armada_ap806_get_temp(struct thermal_zone_device *thermal, int *temp)
 	.get_temp = armada_ap806_get_temp,
 };
 
+static irqreturn_t a38x_temp_irq_handler(int irq, void *data)
+{
+	struct armada_thermal_priv *priv = (struct armada_thermal_priv *)data;
+	struct device *dev = &priv->pdev->dev;
+	u32 reg;
+
+	/* Mask Temp irq */
+	reg = readl_relaxed(priv->dfx + 0x14);
+	reg &= ~(0x3 << 1);
+	writel(reg, priv->dfx + 0x14);
+
+	/* Clear Temp irq cause */
+	reg = readl_relaxed(priv->dfx + 0x10);
+
+	if (reg & (0x3 << 1))
+		dev_warn(dev, "Overheat critical %s threshold temperature reached\n",
+			 (reg & (1 << 1)) ? "high" : "low");
+
+	/* UnMask Temp irq */
+	reg = readl_relaxed(priv->dfx + 0x14);
+	reg |= (0x3 << 1);
+	writel(reg, priv->dfx + 0x14);
+
+	return IRQ_HANDLED;
+}
 
 static const struct armada_thermal_data armadaxp_data = {
 	.init_sensor = armadaxp_init_sensor,
@@ -350,6 +466,7 @@ static int armada_thermal_probe(struct platform_device *pdev)
 	const struct of_device_id *match;
 	struct armada_thermal_priv *priv;
 	struct resource *res;
+	int irq;
 
 	match = of_match_device(armada_thermal_id_table, &pdev->dev);
 	if (!match)
@@ -369,6 +486,11 @@ static int armada_thermal_probe(struct platform_device *pdev)
 	if (IS_ERR(priv->control))
 		return PTR_ERR(priv->control);
 
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 2);
+	priv->dfx = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(priv->dfx))
+		return PTR_ERR(priv->dfx);
+
 	priv->data = (struct armada_thermal_data *)match->data;
 	priv->data->init_sensor(pdev, priv);
 
@@ -380,6 +502,20 @@ static int armada_thermal_probe(struct platform_device *pdev)
 		return PTR_ERR(thermal);
 	}
 
+	priv->pdev = pdev;
+
+	/* Register overheat interrupt */
+	irq = platform_get_irq(pdev, 0);
+
+	if (irq < 0) {
+		dev_warn(&pdev->dev, "no irq\n");
+		return irq;
+	}
+	if (devm_request_irq(&pdev->dev, irq, a38x_temp_irq_handler,
+				0, pdev->name, priv) < 0) {
+		dev_warn(&pdev->dev, "Interrupt not available.\n");
+	}
+
 	platform_set_drvdata(pdev, thermal);
 
 	return 0;
@@ -407,5 +543,5 @@ static int armada_thermal_exit(struct platform_device *pdev)
 module_platform_driver(armada_thermal_driver);
 
 MODULE_AUTHOR("Ezequiel Garcia <ezequiel.garcia@free-electrons.com>");
-MODULE_DESCRIPTION("Armada 370/XP thermal driver");
+MODULE_DESCRIPTION("Armada 370/380/XP thermal driver");
 MODULE_LICENSE("GPL v2");
-- 
1.7.9.5

