From 1a162ed035245dd2a971c1b3ba111b64a5b0b26d Mon Sep 17 00:00:00 2001
From: Ernest Villion <ernestv@marvell.com>
Date: Sun, 27 Mar 2016 15:57:29 +0300
Subject: [PATCH 0222/1345] pp3: adding to net/core gnss definitions

commit  7e62653a6f060524c0f7e7019c234f1d48237ab5 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

Change-Id: I733c0b61d4fa6f88adf24769ae754f58b82d2b0f
Signed-off-by: Ernest Villion <ernestv@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/29595
Reviewed-by: Lior Amsalem <alior@marvell.com>
Tested-by: Lior Amsalem <alior@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 include/net/gnss/mv_nss_defs.h     |  107 +++++++++++++++
 include/net/gnss/mv_nss_metadata.h |  180 +++++++++++++++++++++++++
 include/net/gnss/mv_nss_ops.h      |  123 +++++++++++++++++
 net/core/Makefile                  |    1 +
 net/core/gnss/Makefile             |    4 +
 net/core/gnss/mv_nss_ops.c         |  257 ++++++++++++++++++++++++++++++++++++
 6 files changed, 672 insertions(+)
 create mode 100644 include/net/gnss/mv_nss_defs.h
 create mode 100644 include/net/gnss/mv_nss_metadata.h
 create mode 100644 include/net/gnss/mv_nss_ops.h
 create mode 100644 net/core/gnss/Makefile
 create mode 100644 net/core/gnss/mv_nss_ops.c

diff --git a/include/net/gnss/mv_nss_defs.h b/include/net/gnss/mv_nss_defs.h
new file mode 100644
index 0000000..69001d6
--- /dev/null
+++ b/include/net/gnss/mv_nss_defs.h
@@ -0,0 +1,107 @@
+/*
+* ***************************************************************************
+* Copyright (C) 2015 Marvell International Ltd.
+* ***************************************************************************
+* This program is free software: you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the Free
+* Software Foundation, either version 2 of the License, or any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program.  If not, see <http://www.gnu.org/licenses/>.
+* ***************************************************************************
+*/
+/*  mv_nss.h */
+
+#ifndef __MV_NSS_DEFS_H__
+#define __MV_NSS_DEFS_H__
+
+/* Minimal Ethernet virtual port ID */
+#define MV_NSS_ETH_PORT_MIN		(0)
+/* Maximum number of Ethernet virtual ports */
+#define MV_NSS_ETH_PORT_NUM		(8)
+#define MV_NSS_ETH_PORT_MAX		(MV_NSS_ETH_PORT_MIN + MV_NSS_ETH_PORT_NUM - 1)
+
+/* CPU virtual ports - one per CPU */
+#define MV_NSS_CPU_PORT_MIN		(10)
+#define MV_NSS_CPU_PORT_NUM		(4)
+#define MV_NSS_CPU_PORT_MAX		(MV_NSS_CPU_PORT_MIN + MV_NSS_CPU_PORT_NUM - 1)
+
+/* Virtual port IDs - external virtual port (WLAN) */
+#define MV_NSS_EXT_PORT_MIN		(16)
+#define MV_NSS_EXT_PORT_NUM		(16)
+#define MV_NSS_EXT_PORT_MAX		(MV_NSS_EXT_PORT_MIN + MV_NSS_EXT_PORT_NUM - 1)
+
+/* Minimal application defined virtual port ID */
+#define MV_NSS_PORT_APP_MIN		(32)
+/* Maximum number of application virtual ports */
+#define MV_NSS_PORT_APP_NUM		(256 - MV_NSS_PORT_APP_MIN)
+#define MV_NSS_PORT_APP_MAX		(MV_NSS_PORT_APP_MIN + MV_NSS_PORT_APP_NUM - 1)
+
+/* Drop virtual port. Packet will be dropped */
+#define MV_NSS_PORT_DROP		(0xFFFE)
+
+/* Invalid or no virtual port indication */
+#define MV_NSS_PORT_NONE		(0xFFFF)
+
+enum mv_nss_l2_option {
+	MV_NSS_L2_UCAST_PROMISC = 0,
+	MV_NSS_L2_MCAST_PROMISC = 1,
+	MV_NSS_L2_BCAST_ADM = 2,
+	MV_NSS_L2_MCAST_ADM = 3,
+	MV_NSS_L2_IP_MCAST_LOCAL_ADM = 4,
+	MV_NSS_L2_IP_MCAST_NON_LOCAL_ADM = 5,
+	MV_NSS_L2_VLAN_UNKNOWN_ADM = 6,
+	MV_NSS_L2_OPTION_LAST = 8
+};
+
+#define MV_NSS_NON_PROMISC_MODE (1 << MV_NSS_L2_BCAST_ADM)
+#define MV_NSS_ALL_MCAST_MODE   (MV_NSS_NON_PROMISC_MODE | (1 << MV_NSS_L2_MCAST_PROMISC))
+#define MV_NSS_PROMISC_MODE     (MV_NSS_ALL_MCAST_MODE | (1 << MV_NSS_L2_UCAST_PROMISC))
+
+
+struct mv_nss_meter {
+	bool         enable;
+	unsigned int cir;
+	unsigned int eir;
+	unsigned int cbs;
+	unsigned int ebs;
+};
+
+struct mv_nss_drop {
+	bool           enable;
+	unsigned short td;             /* tail drop threshold */
+	unsigned short red;            /* random early drop threshold */
+};
+
+struct mv_nss_sched {
+	unsigned short priority;       /* priority */
+	unsigned short weight;         /* weight */
+	bool           wrr_enable;
+};
+
+
+struct mv_nss_vq_stats {
+	uint64_t pkts;    /* Number of processed packets */
+	uint64_t octets;  /* Number of processed octets */
+	uint64_t errors;  /* Number of processing errors */
+	uint64_t drops;   /* Number of dropped packets */
+};
+
+struct mv_nss_vq_advance_stats {
+	unsigned int	pkts_fill_lvl;     /* Current queue fill level, packets */
+	unsigned int	pkts_fill_lvl_max; /* Maximum queue fill level, packets */
+	unsigned int	pkts_fill_lvl_avg; /* Average queue fill level, packets */
+	unsigned int	pkts_rate;         /* Average packet arrival rate, pkts/sec */
+	unsigned int	bytes_fill_lvl;	   /* Current queue fill level, octets */
+	unsigned int	bytes_fill_lvl_max;  /* Maximum queue fill level, octets */
+	unsigned int	bytes_fill_lvl_avg;  /* Average queue fill level, octets */
+	unsigned int	bytes_rate;          /* Average octets arrival rate, octets/sec */
+	unsigned int	time_elapsed;	   /* Time elapsed from the last query, msec */
+};
+
+#endif /* __MV_NSS_H__ */
diff --git a/include/net/gnss/mv_nss_metadata.h b/include/net/gnss/mv_nss_metadata.h
new file mode 100644
index 0000000..9949fa3
--- /dev/null
+++ b/include/net/gnss/mv_nss_metadata.h
@@ -0,0 +1,180 @@
+/*
+* ***************************************************************************
+* Copyright (C) 2015 Marvell International Ltd.
+* ***************************************************************************
+* This program is free software: you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the Free
+* Software Foundation, either version 2 of the License, or any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program.  If not, see <http://www.gnu.org/licenses/>.
+* ***************************************************************************
+*/
+/*  mv_nss_metadata.h */
+
+#ifndef __MV_NSS_METADATA_H__
+#define __MV_NSS_METADATA_H__
+
+/*
+* struct mv_nss_metadata
+*
+* Description:
+*       Basic packet annotation.
+*
+* Fields:
+*       port_src    - Source virtual port.
+*       port_dst    - Destination virtual port.
+*       type        - Packet information.
+*                       bit [0] - Validity condition.
+*                         0 - bits [4-31] are valid
+*                         1 - bits [4-31] are invalid
+*                       bits [1]: Frame type:
+*                         0 - Standard Ethernet II frame
+*                         1 - Proprietary A-MSDU frame
+*                       bits [8-14] - L3 offset: IPv4 or IPv6 offset in the packet.
+*                          This field indicates the beginning of Layer3 (in octets).
+*                       bit [15] - MAC to me: MAC DA lookup results
+*                         0 - MAC DA is unknown (not MAC to me)
+*                         1 - MAC DA is known unicast or multicast MAC address
+*                             (MAC to me)
+*                       bits [16-20] - IP Header length: IP Header Length in
+*                            4-octet words.
+*                            IPv4: IPv4 header length including options
+*                            if exist
+*                            IPv6: IPv6 header length including extension
+*                            header if exists
+*                       bits [21-23] - L4 info: L4 parsing results
+*                         0 - Unknown
+*                         1 - TCP
+*                         2 - TCP + checksum error
+*                         3 - UDP
+*                         4 - UDP lite
+*                         5 - UDP + checksum error
+*                         6 - IGMP
+*                         7 - Other
+*                       bits [24-25]: VLAN info - Number of VLANs in the packet
+*                         0 - Untagged
+*                         1 - Single Tag
+*                         2 - Double tag
+*                         3 - Reserved
+*                       bit [26] - Management or non-management packet type
+*                         0 - Non-management packet
+*                         1 - Management packet
+*                       bits [27-28] - L2 info: indicates type of L2 packet
+*                         0 - Unicast
+*                         1 - Multicast
+*                         2 - IP Multicast
+*                         3 - Broadcast
+*                       bits [29-31] - L3 info: L3 parsing results
+*                         0 - Unknown
+*                         1 - IPv4
+*                         2 - IPv4 fragment
+*                         3 - IPv4 with options
+*                         4 = IPv4 with errors (checksum, TTL, etc)
+*                         5 = IPv6
+*                         6 = IPv6 with extension(s) header
+*                         7 = ARP
+*       cos         - Class of service.
+*       reason      - Packet origination context.
+*       opaque      - Application opaque handle.
+*       reserved    - Reserved fields.
+*/
+struct mv_nss_metadata {
+	uint16_t port_src;
+	uint16_t port_dst;
+	uint32_t type;
+	uint32_t opaque;
+	uint8_t  cos;
+	uint8_t  reason;
+	uint8_t reserved[18];
+};
+
+
+/*
+* typedef: struct mv_nss_metadata_wlan_t
+*
+* Description:
+*       Packet annotation for packets toward WLAN.
+*
+* Fields:
+*       port_src    - Source virtual port.
+*       port_dst    - Destination virtual port.
+*       type        - Packet information.
+*                       bits [0-2]: Frame type:
+*                         0 - Standard Ethernet II frame
+*                         1 - Proprietary A-MSDU short frame
+*                         2 - Proprietary A-MSDU basic frame
+*                       bit [3] - Validity condition:
+*                         0 - bits [4-31] are invalid
+*                         1 - bits [4-31] are valid
+*                       bits [8-14] - L3 offset: IPv4 or IPv6 offset in the packet.
+*                          This field indicates the beginning of Layer3 (in octets).
+*                       bit [15] - MAC to me: MAC DA lookup results
+*                         0 - MAC DA is unknown (not MAC to me)
+*                         1 - MAC DA is known unicast or multicast MAC address
+*                             (MAC to me)
+*                       bits [16-20] - IP Header length: IP Header Length in
+*                            4-octet words.
+*                            IPv4: IPv4 header length including options
+*                            if exist
+*                            IPv6: IPv6 header length including extension
+*                            header if exists
+*                       bits [21-23] - L4 info: L4 parsing results
+*                         0 - Unknown
+*                         1 - TCP
+*                         2 - TCP + checksum error
+*                         3 - UDP
+*                         4 - UDP lite
+*                         5 - UDP + checksum error
+*                         6 - IGMP
+*                         7 - Other
+*                       bits [24-25]: VLAN info - Number of VLANs in the packet
+*                         0 - Untagged
+*                         1 - Single Tag
+*                         2 - Double tag
+*                         3 - Reserved
+*                       bit [26] - Management or non-management packet type
+*                         0 - Non-management packet
+*                         1 - Management packet
+*                       bits [27-28] - L2 info: indicates type of L2 packet
+*                         0 - Unicast
+*                         1 - Multicast
+*                         2 - IP Multicast
+*                         3 - Broadcast
+*                       bits [29-31] - L3 info: L3 parsing results
+*                         0 - Unknown
+*                         1 - IPv4
+*                         2 - IPv4 fragment
+*                         3 - IPv4 with options
+*                         4 = IPv4 with errors (checksum, TTL, etc)
+*                         5 = IPv6
+*                         6 = IPv6 with extension(s) header
+*                         7 = ARP
+*       opaque      - A-MSDU opaque application handle from A-MSDU context.
+*       cos         - Class of service.
+*       reason      - Packet origination context.
+*       reserved1   - Reserved fields.
+*       lifetime    - Total A-MSDU aggregation time, nanoseconds.
+*       reserved2   - Reserved fields.
+*/
+struct mv_nss_metadata_wlan {
+	uint16_t port_src;
+	uint16_t port_dst;
+	uint32_t type;
+	uint32_t opaque;
+	uint8_t  cos;
+	uint8_t  reason;
+	uint16_t reserved1;
+	uint32_t lifetime;
+	uint8_t  reserved2[12];
+};
+
+
+
+
+#endif /* __MV_NSS_METADATA_H__ */
diff --git a/include/net/gnss/mv_nss_ops.h b/include/net/gnss/mv_nss_ops.h
new file mode 100644
index 0000000..d8b193d
--- /dev/null
+++ b/include/net/gnss/mv_nss_ops.h
@@ -0,0 +1,123 @@
+/*
+* ***************************************************************************
+* Copyright (C) 2015 Marvell International Ltd.
+* ***************************************************************************
+* This program is free software: you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the Free
+* Software Foundation, either version 2 of the License, or any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program.  If not, see <http://www.gnu.org/licenses/>.
+* ***************************************************************************
+*/
+/*  mv_nss_ops.h */
+
+#ifndef __MV_NSS_OPS_H__
+#define __MV_NSS_OPS_H__
+
+#include <linux/types.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+
+
+
+/*
+ * struct mv_nss_if_ops
+ *
+ * Description:
+ *       NSS compatible network device operations.
+ *
+ * Fields:
+ *       recv_pause  - Stop traffic receive.
+ *       recv_resume - Resume traffic receive.
+ *       shutdown    - NSS shutdown notification.
+ */
+struct mv_nss_if_ops {
+	void (*recv_pause)(struct net_device *iface, int cos);
+	void (*recv_resume)(struct net_device *iface, int cos);
+	void (*shutdown)(void);
+};
+
+/*
+ * struct mv_gnss_ops
+ *
+ * Description:
+ *       NSS common operations.
+ *
+ * Fields:
+ *       alloc_skb        - Allocate new skb.
+ *       free_skb         - Release skb.
+ *       receive_skb      - Send skb for processing.
+ *       get_metadata_skb - Retrieve pointer to packet metadata.
+ *                          Metadata is valid if and only if
+ *                          the returned pointer is non NULL.
+ *       init_metadata    - Mark metadata associated with skb
+ *                          as valid or invalid. If metadata
+ *                          is marked as invalid, get_metadata_skb
+ *                          would return NULL.
+ *       xmit_pause       - Stop sending traffic to network device.
+ *       xmit_resume      - Resume sending traffic to network device.
+ *       register         - Register a compatible NSS network device
+ *                          with fast path application.
+ *       unregister -       Unregister a compatible NSS network device
+ *                          from fast path application.
+ */
+struct mv_nss_ops {
+	struct sk_buff* (*alloc_skb)(unsigned int size, gfp_t priority);
+	void (*free_skb)(struct sk_buff *skb);
+	int (*receive_skb)(struct sk_buff *skb);
+	void* (*get_metadata_skb)(struct sk_buff *skb);
+	void* (*init_metadata_skb)(struct sk_buff *skb); /*returns a pointer to on success*/
+	void (*remove_metadata_skb)(struct sk_buff *skb);
+	int (*xmit_pause)(struct net_device *iface, int cos);
+	int (*xmit_resume)(struct net_device *iface, int cos);
+	int (*register_iface)(struct net_device *iface, struct mv_nss_if_ops *if_ops);
+	int (*unregister_iface)(struct net_device *iface);
+};
+
+/*
+ * mv_nss_ops_set
+ *
+ * Description:
+ *       Set common NSS operations by software fast path application.
+ *
+ * Parameters:
+ *       ops - Pointer to common NSS operations.
+ *
+ * Returns:
+ *    None.
+ */
+
+void mv_nss_ops_set(struct mv_nss_ops *ops);
+
+/*
+ * mv_nss_ops_get
+ *
+ * Description:
+ *       Set common NSS operations by software fast path application.
+ *
+ * Parameters:
+ *       None.
+ *
+ * Returns:
+ *    Pointer to common NSS operations.
+ */
+struct mv_nss_ops *mv_nss_ops_get(const struct net_device *iface);
+
+
+int mv_nss_ops_prefix_add(const char *name);
+int mv_nss_ops_prefix_del(const char *name);
+void mv_nss_ops_show(void);
+void mv_nss_ops_prefix_list_show(void);
+void mv_nss_ops_prefix_list_clear(void);
+void mv_nss_ops_filter_on(bool filter);
+
+
+
+
+#endif /* __MV_NSS_OPS_H__ */
diff --git a/net/core/Makefile b/net/core/Makefile
index 79f9479..16b429e 100644
--- a/net/core/Makefile
+++ b/net/core/Makefile
@@ -24,6 +24,7 @@ obj-$(CONFIG_NET_PTP_CLASSIFY) += ptp_classifier.o
 obj-$(CONFIG_CGROUP_NET_PRIO) += netprio_cgroup.o
 obj-$(CONFIG_CGROUP_NET_CLASSID) += netclassid_cgroup.o
 obj-$(CONFIG_LWTUNNEL) += lwtunnel.o
+obj-$(CONFIG_MV_GNSS_SUPPORT) += gnss/
 obj-$(CONFIG_LWTUNNEL_BPF) += lwt_bpf.o
 obj-$(CONFIG_DST_CACHE) += dst_cache.o
 obj-$(CONFIG_HWBM) += hwbm.o
diff --git a/net/core/gnss/Makefile b/net/core/gnss/Makefile
new file mode 100644
index 0000000..1885ee2
--- /dev/null
+++ b/net/core/gnss/Makefile
@@ -0,0 +1,4 @@
+#
+# Makefile for Marvell GNSS.
+#
+obj-$(CONFIG_MV_GNSS_SUPPORT) := mv_nss_ops.o
diff --git a/net/core/gnss/mv_nss_ops.c b/net/core/gnss/mv_nss_ops.c
new file mode 100644
index 0000000..59be26f
--- /dev/null
+++ b/net/core/gnss/mv_nss_ops.c
@@ -0,0 +1,257 @@
+/****************************************************************************
+* Copyright (C) 2015 Marvell International Ltd.
+* ***************************************************************************
+* This program is free software: you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the Free
+* Software Foundation, either version 2 of the License, or any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program.  If not, see <http://www.gnu.org/licenses/>.
+* ***************************************************************************
+*/
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/ioport.h>
+#include <linux/device.h>
+#include <linux/string.h>
+
+#include <net/gnss/mv_nss_ops.h>
+
+#define MV_NSS_OPS_PREFIX_MAX		(32)
+#define MV_NSS_OPS_PREFIX_NUM_OK(v)	((v) >= 0 && (v) < MV_NSS_OPS_PREFIX_MAX)
+#define MV_NSS_OPS_PREFIX_SIZE_OK(v)	((v) > 0 && (v) < IFNAMSIZ)
+
+#define MV_NSS_OPS_LOCK_SMP(nss_ops_lock, flags)					\
+do {								\
+	if (in_interrupt())					\
+		spin_lock((nss_ops_lock));				\
+	else							\
+		spin_lock_irqsave((nss_ops_lock), (flags));		\
+} while (0)
+
+#define MV_NSS_OPS_UNLOCK_SMP(nss_ops_lock, flags)				\
+do {								\
+	if (in_interrupt())					\
+		spin_unlock((nss_ops_lock));				\
+	else							\
+		spin_unlock_irqrestore((nss_ops_lock), (flags));	\
+} while (0)
+
+struct mv_nss_ops_prefix {
+	char			prefix[IFNAMSIZ];
+	struct list_head	list_elem;
+};
+
+static struct mv_nss_ops	*nss_ops;
+static struct list_head		nss_ops_prefix_list = LIST_HEAD_INIT(nss_ops_prefix_list);
+static int			nss_ops_list_size;
+static bool			nss_ops_if_filter;
+static spinlock_t		nss_ops_lock;
+
+static struct mv_nss_ops_prefix *mv_nss_prefix_find(const char *name)
+{
+	struct list_head *curr;
+	struct list_head *q;
+	struct mv_nss_ops_prefix *tmp;
+
+	list_for_each_safe(curr, q, &nss_ops_prefix_list) {
+		tmp = list_entry(curr, struct mv_nss_ops_prefix, list_elem);
+		pr_info("prefix:%s(%d) name:%s(%d)\n", tmp->prefix, strlen(tmp->prefix), name, strlen(name));
+		if (!memcmp(tmp->prefix, name, strlen(tmp->prefix)))
+			return tmp;
+	}
+
+	pr_info("not found name:%s(%d)\n", name, strlen(name));
+	return NULL;
+}
+
+static struct mv_nss_ops_prefix *mv_nss_prefix_find_exact(const char *name)
+{
+	struct list_head *curr;
+	struct list_head *q;
+	struct mv_nss_ops_prefix *tmp;
+
+	list_for_each_safe(curr, q, &nss_ops_prefix_list) {
+		tmp = list_entry(curr, struct mv_nss_ops_prefix, list_elem);
+		if (!strncmp(tmp->prefix, name, IFNAMSIZ))
+			return tmp;
+	}
+
+	return NULL;
+}
+
+void mv_nss_ops_prefix_list_clear(void)
+{
+	struct list_head		*curr, *q;
+	struct mv_nss_ops_prefix	*tmp;
+	unsigned long iflags		= 0;
+
+	MV_NSS_OPS_LOCK_SMP(&nss_ops_lock, iflags);
+	list_for_each_safe(curr, q, &nss_ops_prefix_list) {
+		tmp = list_entry(curr, struct mv_nss_ops_prefix, list_elem);
+		list_del(&tmp->list_elem);
+		kfree(tmp);
+		nss_ops_list_size--;
+	}
+	MV_NSS_OPS_UNLOCK_SMP(&nss_ops_lock, iflags);
+}
+EXPORT_SYMBOL(mv_nss_ops_prefix_list_clear);
+
+void mv_nss_ops_prefix_list_show(void)
+{
+	struct list_head		*curr;
+	struct mv_nss_ops_prefix	*tmp;
+
+	pr_info("NSS PREFIX LIST SIZE=%d\n", nss_ops_list_size);
+	list_for_each(curr, &nss_ops_prefix_list) {
+		tmp = list_entry(curr, struct mv_nss_ops_prefix, list_elem);
+		pr_info("%s\n", tmp->prefix);
+	}
+}
+EXPORT_SYMBOL(mv_nss_ops_prefix_list_show);
+
+void mv_nss_ops_show(void)
+{
+	pr_cont("NSS prefix filter:      %s\n", nss_ops_if_filter ? "ON" : "OFF");
+	if (!nss_ops) {
+		pr_info("\nEmpty OPS\n");
+		return;
+	}
+
+	pr_info("\nNSS OPS:              %p\n", nss_ops);
+	pr_cont("ops->alloc_skb:          %p\n", nss_ops->alloc_skb);
+	pr_cont("ops->free_skb:           %p\n", nss_ops->free_skb);
+	pr_cont("ops->receive_skb:        %p\n", nss_ops->receive_skb);
+	pr_cont("ops->get_metadata_skb:   %p\n", nss_ops->get_metadata_skb);
+	pr_cont("ops->init_metadata_skb:  %p\n", nss_ops->init_metadata_skb);
+	pr_cont("ops->remove_metadata_skb:%p\n", nss_ops->remove_metadata_skb);
+	pr_cont("ops->xmit_pause:         %p\n", nss_ops->xmit_pause);
+	pr_cont("ops->xmit_resume:        %p\n", nss_ops->xmit_resume);
+	pr_cont("ops->register_iface:     %p\n", nss_ops->register_iface);
+	pr_cont("ops->unregister_iface:   %p\n", nss_ops->unregister_iface);
+}
+EXPORT_SYMBOL(mv_nss_ops_show);
+
+int mv_nss_ops_prefix_add(const char *name)
+{
+	struct mv_nss_ops_prefix	*tmp;
+	size_t				len;
+	unsigned long iflags		= 0;
+
+	if (!name) {
+		pr_err("nss ops null prefix name\n");
+		return -ENXIO;
+	}
+
+	len = strlen(name);
+	if (!MV_NSS_OPS_PREFIX_SIZE_OK(len)) {
+		pr_err("nss ops illegal prefix size: %d\n", len);
+		return -ENXIO;
+	}
+
+	if (!MV_NSS_OPS_PREFIX_NUM_OK(nss_ops_list_size)) {
+		pr_err("nss ops to many preficies: %d\n", nss_ops_list_size);
+		return -EINVAL;
+	}
+
+	tmp = kzalloc(sizeof(*tmp), GFP_KERNEL);
+	if (!tmp)
+		return -ENOMEM;
+
+	strncpy(tmp->prefix, name, IFNAMSIZ);
+
+	MV_NSS_OPS_LOCK_SMP(&nss_ops_lock, iflags);
+	/*find already added*/
+	if (unlikely(mv_nss_prefix_find_exact(name))) {
+		pr_err("%s already added\n", name);
+		goto err;
+	}
+	list_add_tail(&tmp->list_elem, &nss_ops_prefix_list);
+	nss_ops_list_size++;
+	MV_NSS_OPS_UNLOCK_SMP(&nss_ops_lock, iflags);
+
+	return 0;
+
+err:
+	MV_NSS_OPS_UNLOCK_SMP(&nss_ops_lock, iflags);
+	kfree(tmp);
+	return -EINVAL;
+}
+EXPORT_SYMBOL(mv_nss_ops_prefix_add);
+
+int mv_nss_ops_prefix_del(const char *name)
+{
+	struct mv_nss_ops_prefix	*tmp;
+	unsigned long iflags		= 0;
+
+	if (!name) {
+		pr_err("nss ops null prefix name\n");
+		return -ENXIO;
+	}
+
+	MV_NSS_OPS_LOCK_SMP(&nss_ops_lock, iflags);
+	tmp = mv_nss_prefix_find_exact(name);
+	if (unlikely(!tmp)) {
+		pr_err("%s not found\n", name);
+		goto err;
+	}
+
+	list_del(&tmp->list_elem);
+	nss_ops_list_size--;
+	MV_NSS_OPS_UNLOCK_SMP(&nss_ops_lock, iflags);
+
+	kfree(tmp);
+
+	return 0;
+
+err:
+	MV_NSS_OPS_UNLOCK_SMP(&nss_ops_lock, iflags);
+	return -EINVAL;
+}
+EXPORT_SYMBOL(mv_nss_ops_prefix_del);
+
+struct mv_nss_ops *mv_nss_ops_get(const struct net_device *iface)
+{
+	if (!nss_ops_if_filter) {
+		pr_info("nss_ops_get:%p interface:%s\n", nss_ops, iface ? iface->name : "NULL");
+		return nss_ops;
+	}
+
+	if (!iface)
+		goto not_found;
+
+	if (!mv_nss_prefix_find(iface->name))
+		goto not_found;
+
+	pr_info("nss_ops_get:%p interface:%s\n", nss_ops, iface->name);
+	return nss_ops;
+
+not_found:
+	pr_devel("debug: nss_ops_get: interface:%s not supported\n", iface ? iface->name : "NULL");
+	return NULL;
+}
+EXPORT_SYMBOL(mv_nss_ops_get);
+
+void mv_nss_ops_set(struct mv_nss_ops *ops)
+{
+	nss_ops = ops;
+	pr_info("nss ops_set ops:%p\n", nss_ops);
+}
+EXPORT_SYMBOL(mv_nss_ops_set);
+
+void mv_nss_ops_filter_on(bool filter)
+{
+	unsigned long iflags		= 0;
+
+	MV_NSS_OPS_LOCK_SMP(&nss_ops_lock, iflags);
+	nss_ops_if_filter = filter;
+	MV_NSS_OPS_UNLOCK_SMP(&nss_ops_lock, iflags);
+}
+EXPORT_SYMBOL(mv_nss_ops_filter_on);
+
-- 
1.7.9.5

