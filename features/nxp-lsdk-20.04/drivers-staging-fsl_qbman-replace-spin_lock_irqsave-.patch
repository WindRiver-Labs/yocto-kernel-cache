From eef94e9e729dc39e6110703f48e46d05750c56d7 Mon Sep 17 00:00:00 2001
From: Xulin Sun <xulin.sun@windriver.com>
Date: Sat, 27 Jun 2020 18:34:10 +0800
Subject: [PATCH 2/2] drivers/staging/fsl_qbman: replace spin_lock_irqsave with
 raw_spin_lock_irqsave

Replace spin_lock_irqsave with raw_spin_lock_irqsave to fix
below call trace for preempt rt kernel type.

BUG: sleeping function called from invalid context at kernel/locking/rtmutex.c:975
 in_atomic(): 1, irqs_disabled(): 0, pid: 1, name: swapper/0
 Preemption disabled at:
 [<ffff0000109433e4>] qman_create_cgr+0x54/0x2f0
 CPU: 3 PID: 1 Comm: swapper/0 Not tainted 5.2.45-rt15-yocto-preempt-rt #1
 Hardware name: LS1043A RDB Board (DT)
 Call trace:
  dump_backtrace+0x0/0x138
  show_stack+0x24/0x30
  dump_stack+0x9c/0xc4
  ___might_sleep+0x13c/0x168
  rt_spin_lock+0x44/0x80
  qman_create_cgr+0xf4/0x2f0
  dpaa_eth_cgr_init+0xcc/0x138
  dpaa_eth_priv_probe+0x320/0x7b0
  platform_drv_probe+0x58/0xa8
  really_probe+0xcc/0x290
  driver_probe_device+0x5c/0xf0
  device_driver_attach+0x74/0x80
  __driver_attach+0x64/0xe0
  bus_for_each_dev+0x80/0xd0
  driver_attach+0x30/0x40
  bus_add_driver+0x14c/0x1f0
  driver_register+0x64/0x110
  __platform_driver_register+0x54/0x60
  dpa_load+0x64/0xa4
  do_one_initcall+0x64/0x2c8
  kernel_init_freeable+0x338/0x3d8
  kernel_init+0x18/0x104
  ret_from_fork+0x10/0x1c

Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/staging/fsl_qbman/qman_high.c | 16 ++++++++--------
 1 file changed, 8 insertions(+), 8 deletions(-)

diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index 43ea7d1ebf9d..ee6cdef9e6d0 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -115,7 +115,7 @@ struct qman_portal {
 	/* linked-list of CSCN handlers. */
 	struct list_head cgr_cbs;
 	/* list lock */
-	spinlock_t cgr_lock;
+	raw_spinlock_t cgr_lock;
 	/* 2-element array. ccgrs[0] is mask, ccgrs[1] is snapshot. */
 	struct qman_ccgrs *ccgrs[QMAN_CEETM_MAX];
 	/* 256-element array, each is a linked-list of CCSCN handlers. */
@@ -650,7 +650,7 @@ struct qman_portal *qman_create_portal(
 		/* if the given mask is NULL, assume all CGRs can be seen */
 		qman_cgrs_fill(&portal->cgrs[0]);
 	INIT_LIST_HEAD(&portal->cgr_cbs);
-	spin_lock_init(&portal->cgr_lock);
+	raw_spin_lock_init(&portal->cgr_lock);
 	if (num_ceetms) {
 		for (ret = 0; ret < num_ceetms; ret++) {
 			portal->ccgrs[ret] = kmalloc(2 *
@@ -950,7 +950,7 @@ static u32 __poll_portal_slow(struct qman_portal *p, u32 is)
 		struct qman_cgr *cgr;
 		unsigned long irqflags __maybe_unused;
 
-		spin_lock_irqsave(&p->cgr_lock, irqflags);
+		raw_spin_lock_irqsave(&p->cgr_lock, irqflags);
 		/*
 		 * The CSCI bit must be cleared _before_ issuing the
 		 * Query Congestion State command, to ensure that a long
@@ -976,7 +976,7 @@ static u32 __poll_portal_slow(struct qman_portal *p, u32 is)
 		list_for_each_entry(cgr, &p->cgr_cbs, node)
 			if (cgr->cb && qman_cgrs_get(&c, cgr->cgrid))
 				cgr->cb(p, cgr, qman_cgrs_get(&rr, cgr->cgrid));
-		spin_unlock_irqrestore(&p->cgr_lock, irqflags);
+		raw_spin_unlock_irqrestore(&p->cgr_lock, irqflags);
 	}
 	if (is & QM_PIRQ_CCSCI) {
 		struct qman_ccgrs rr, c, congestion_result;
@@ -2950,7 +2950,7 @@ int qman_create_cgr(struct qman_cgr *cgr, u32 flags,
 
 	memset(&local_opts, 0, sizeof(struct qm_mcc_initcgr));
 	cgr->chan = p->config->public_cfg.channel;
-	spin_lock_irqsave(&p->cgr_lock, irqflags);
+	raw_spin_lock_irqsave(&p->cgr_lock, irqflags);
 
 	/* if no opts specified, just add it to the list */
 	if (!opts)
@@ -2993,7 +2993,7 @@ int qman_create_cgr(struct qman_cgr *cgr, u32 flags,
 							cgr->cgrid))
 		cgr->cb(p, cgr, 1);
 release_lock:
-	spin_unlock_irqrestore(&p->cgr_lock, irqflags);
+	raw_spin_unlock_irqrestore(&p->cgr_lock, irqflags);
 	put_affine_portal();
 	return ret;
 }
@@ -3064,7 +3064,7 @@ int qman_delete_cgr(struct qman_cgr *cgr)
 		goto put_portal;
 	}
 	memset(&local_opts, 0, sizeof(struct qm_mcc_initcgr));
-	spin_lock_irqsave(&p->cgr_lock, irqflags);
+	raw_spin_lock_irqsave(&p->cgr_lock, irqflags);
 	list_del(&cgr->node);
 	/*
 	 * If there are no other CGR objects for this CGRID in the list, update
@@ -3091,7 +3091,7 @@ int qman_delete_cgr(struct qman_cgr *cgr)
 		/* add back to the list */
 		list_add(&cgr->node, &p->cgr_cbs);
 release_lock:
-	spin_unlock_irqrestore(&p->cgr_lock, irqflags);
+	raw_spin_unlock_irqrestore(&p->cgr_lock, irqflags);
 put_portal:
 	put_affine_portal();
 	return ret;
-- 
2.17.1

